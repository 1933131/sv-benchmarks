extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 32 "include/uapi/linux/types.h"
typedef __u16 __le16;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 152 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 420 "include/linux/printk.h"
struct file_operations;
#line 432
struct completion;
#line 687 "include/linux/list.h"
struct lockdep_map;
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_15 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 328 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_25 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_24 {
   struct __anonstruct____missing_field_name_25 __annonCompField11 ;
   struct __anonstruct____missing_field_name_26 __annonCompField12 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_24 __annonCompField13 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_27 __annonCompField14 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_31 __annonCompField16 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_30 __annonCompField17 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
struct usb_device;
#line 216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
struct timespec;
#line 217
struct compat_timespec;
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
struct __anonstruct_futex_34 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
struct __anonstruct_nanosleep_35 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 218
struct pollfd;
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
struct __anonstruct_poll_36 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
union __anonunion____missing_field_name_33 {
   struct __anonstruct_futex_34 futex ;
   struct __anonstruct_nanosleep_35 nanosleep ;
   struct __anonstruct_poll_36 poll ;
};
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_33 __annonCompField18 ;
};
#line 426 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 598 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 106 "include/linux/debugobjects.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 238 "include/linux/timer.h"
struct hrtimer;
#line 239
enum hrtimer_restart;
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 1170 "include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 296 "include/linux/rcupdate.h"
struct notifier_block;
#line 1120 "include/linux/rcupdate.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 837 "include/uapi/linux/sysctl.h"
struct ctl_table;
#line 838
struct nsproxy;
#line 839
struct ctl_table_root;
#line 840
struct ctl_table_header;
#line 841
struct ctl_dir;
#line 37 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 57 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 96 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 117 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 122 "include/linux/sysctl.h"
struct __anonstruct____missing_field_name_47 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 122 "include/linux/sysctl.h"
union __anonunion____missing_field_name_46 {
   struct __anonstruct____missing_field_name_47 __annonCompField19 ;
   struct callback_head rcu ;
};
#line 122
struct ctl_table_set;
#line 122 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion____missing_field_name_46 __annonCompField20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 143 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 149 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 154 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 616
struct vm_area_struct;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
#line 796 "include/linux/mmzone.h"
struct rw_semaphore;
#line 797 "include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_113 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_113 mm_context_t;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 60 "include/linux/kmemleak.h"
struct kmem_cache;
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 33
struct inode;
#line 34
struct dentry;
#line 35
struct user_namespace;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_146 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_147 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_145 {
   struct __anonstruct____missing_field_name_146 __annonCompField33 ;
   struct __anonstruct____missing_field_name_147 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_145 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_148 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_154 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_152 {
   union __anonunion____missing_field_name_153 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_151 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_152 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_149 {
   union __anonunion____missing_field_name_150 __annonCompField37 ;
   union __anonunion____missing_field_name_151 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_157 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_156 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_157 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_158 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_148 __annonCompField36 ;
   struct __anonstruct____missing_field_name_149 __annonCompField42 ;
   union __anonunion____missing_field_name_155 __annonCompField45 ;
   union __anonunion____missing_field_name_158 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_159 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_159 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_161 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_161 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_162 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_162 kgid_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_163 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_163 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_165 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_166 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_167 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_168 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_170 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_169 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_170 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_171 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_172 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_164 {
   int _pad[28U] ;
   struct __anonstruct__kill_165 _kill ;
   struct __anonstruct__timer_166 _timer ;
   struct __anonstruct__rt_167 _rt ;
   struct __anonstruct__sigchld_168 _sigchld ;
   struct __anonstruct__sigfault_169 _sigfault ;
   struct __anonstruct__sigpoll_171 _sigpoll ;
   struct __anonstruct__sigsys_172 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_164 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 20 "include/linux/rtmutex.h"
struct rt_mutex {
   raw_spinlock_t wait_lock ;
   struct rb_root waiters ;
   struct rb_node *waiters_leftmost ;
   struct task_struct *owner ;
   int save_state ;
   char const   *name ;
   char const   *file ;
   int line ;
   void *magic ;
};
#line 40
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct cred;
#line 38
struct key_type;
#line 42 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_179 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_180 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_182 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_181 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_182 __annonCompField49 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_183 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_185 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_184 {
   union __anonunion_payload_185 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_179 __annonCompField47 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_180 __annonCompField48 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_181 __annonCompField50 ;
   union __anonunion_type_data_183 type_data ;
   union __anonunion____missing_field_name_184 __annonCompField51 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369 "include/linux/cred.h"
union __anonunion____missing_field_name_186 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 369 "include/linux/cred.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_186 __annonCompField52 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 31
struct kernfs_node;
#line 32
struct kernfs_ops;
#line 33
struct kernfs_open_file;
#line 75 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270
struct kernfs_root;
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1161
struct uts_namespace;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
struct v4l2_control;
#line 218
struct pvr2_dvb_adapter;
#line 242
struct usb_interface;
#line 255
struct v4l2_ext_controls;
#line 273
struct i2c_adapter;
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 261 "include/linux/mod_devicetable.h"
struct input_device_id {
   kernel_ulong_t flags ;
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
   kernel_ulong_t evbit[1U] ;
   kernel_ulong_t keybit[12U] ;
   kernel_ulong_t relbit[1U] ;
   kernel_ulong_t absbit[1U] ;
   kernel_ulong_t mscbit[1U] ;
   kernel_ulong_t ledbit[1U] ;
   kernel_ulong_t sndbit[1U] ;
   kernel_ulong_t ffbit[2U] ;
   kernel_ulong_t swbit[1U] ;
   kernel_ulong_t driver_info ;
};
#line 650
struct iattr;
#line 651
struct super_block;
#line 652
struct file_system_type;
#line 653
struct kernfs_open_node;
#line 654
struct kernfs_iattrs;
#line 677 "include/linux/mod_devicetable.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_208 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_208 __annonCompField56 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
struct kobject;
#line 479
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 485 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 135 "./arch/x86/include/uapi/asm/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "include/linux/stat.h"
struct bin_attribute;
#line 37 "include/linux/stat.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct path;
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct fwnode_handle;
#line 22
struct iommu_ops;
#line 23
struct iommu_group;
#line 61 "include/linux/device.h"
struct device_attribute;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 139
struct device_type;
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 1273
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
} ;
#line 1280 "include/linux/device.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};
#line 32 "include/linux/of.h"
typedef u32 phandle;
#line 34 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
#line 44 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 1084 "include/linux/of.h"
struct i2c_msg {
   __u16 addr ;
   __u16 flags ;
   __u16 len ;
   __u8 *buf ;
};
#line 82 "include/uapi/linux/i2c.h"
union i2c_smbus_data {
   __u8 byte ;
   __u16 word ;
   __u8 block[34U] ;
};
#line 39 "include/linux/i2c.h"
struct i2c_algorithm;
#line 40
struct i2c_client;
#line 42
struct i2c_board_info;
#line 43
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 196 "include/linux/i2c.h"
struct i2c_client {
   unsigned short flags ;
   unsigned short addr ;
   char name[20U] ;
   struct i2c_adapter *adapter ;
   struct device dev ;
   int irq ;
   struct list_head detected ;
   int (*slave_cb)(struct i2c_client * , enum i2c_slave_event  , u8 * ) ;
};
#line 251
enum i2c_slave_event {
    I2C_SLAVE_READ_REQUESTED = 0,
    I2C_SLAVE_WRITE_REQUESTED = 1,
    I2C_SLAVE_READ_PROCESSED = 2,
    I2C_SLAVE_WRITE_RECEIVED = 3,
    I2C_SLAVE_STOP = 4
} ;
#line 271 "include/linux/i2c.h"
struct i2c_board_info {
   char type[20U] ;
   unsigned short flags ;
   unsigned short addr ;
   void *platform_data ;
   struct dev_archdata *archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   int irq ;
};
#line 359 "include/linux/i2c.h"
struct i2c_algorithm {
   int (*master_xfer)(struct i2c_adapter * , struct i2c_msg * , int  ) ;
   int (*smbus_xfer)(struct i2c_adapter * , u16  , unsigned short  , char  , u8  ,
                     int  , union i2c_smbus_data * ) ;
   u32 (*functionality)(struct i2c_adapter * ) ;
   int (*reg_slave)(struct i2c_client * ) ;
   int (*unreg_slave)(struct i2c_client * ) ;
};
#line 411 "include/linux/i2c.h"
struct i2c_bus_recovery_info {
   int (*recover_bus)(struct i2c_adapter * ) ;
   int (*get_scl)(struct i2c_adapter * ) ;
   void (*set_scl)(struct i2c_adapter * , int  ) ;
   int (*get_sda)(struct i2c_adapter * ) ;
   void (*prepare_recovery)(struct i2c_adapter * ) ;
   void (*unprepare_recovery)(struct i2c_adapter * ) ;
   int scl_gpio ;
   int sda_gpio ;
};
#line 451 "include/linux/i2c.h"
struct i2c_adapter_quirks {
   u64 flags ;
   int max_num_msgs ;
   u16 max_write_len ;
   u16 max_read_len ;
   u16 max_comb_1st_msg_len ;
   u16 max_comb_2nd_msg_len ;
};
#line 481 "include/linux/i2c.h"
struct i2c_adapter {
   struct module *owner ;
   unsigned int class ;
   struct i2c_algorithm  const  *algo ;
   void *algo_data ;
   struct rt_mutex bus_lock ;
   int timeout ;
   int retries ;
   struct device dev ;
   int nr ;
   char name[48U] ;
   struct completion dev_released ;
   struct mutex userspace_clients_lock ;
   struct list_head userspace_clients ;
   struct i2c_bus_recovery_info *bus_recovery_info ;
   struct i2c_adapter_quirks  const  *quirks ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
struct kernel_param;
#line 58 "include/linux/elf.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_214 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_214 __annonCompField57 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 64 "include/linux/page_ext.h"
struct file_ra_state;
#line 65
struct writeback_control;
#line 66
struct bdi_writeback;
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 1200
struct kvec;
#line 2242 "include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 21 "include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 30 "include/uapi/linux/input.h"
struct input_id {
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
};
#line 47 "include/uapi/linux/input.h"
struct input_absinfo {
   __s32 value ;
   __s32 minimum ;
   __s32 maximum ;
   __s32 fuzz ;
   __s32 flat ;
   __s32 resolution ;
};
#line 75 "include/uapi/linux/input.h"
struct input_keymap_entry {
   __u8 flags ;
   __u8 len ;
   __u16 index ;
   __u32 keycode ;
   __u8 scancode[32U] ;
};
#line 99 "include/uapi/linux/input.h"
struct ff_replay {
   __u16 length ;
   __u16 delay ;
};
#line 1010 "include/uapi/linux/input.h"
struct ff_trigger {
   __u16 button ;
   __u16 interval ;
};
#line 1020 "include/uapi/linux/input.h"
struct ff_envelope {
   __u16 attack_length ;
   __u16 attack_level ;
   __u16 fade_length ;
   __u16 fade_level ;
};
#line 1039 "include/uapi/linux/input.h"
struct ff_constant_effect {
   __s16 level ;
   struct ff_envelope envelope ;
};
#line 1049 "include/uapi/linux/input.h"
struct ff_ramp_effect {
   __s16 start_level ;
   __s16 end_level ;
   struct ff_envelope envelope ;
};
#line 1061 "include/uapi/linux/input.h"
struct ff_condition_effect {
   __u16 right_saturation ;
   __u16 left_saturation ;
   __s16 right_coeff ;
   __s16 left_coeff ;
   __u16 deadband ;
   __s16 center ;
};
#line 1082 "include/uapi/linux/input.h"
struct ff_periodic_effect {
   __u16 waveform ;
   __u16 period ;
   __s16 magnitude ;
   __s16 offset ;
   __u16 phase ;
   struct ff_envelope envelope ;
   __u32 custom_len ;
   __s16 *custom_data ;
};
#line 1113 "include/uapi/linux/input.h"
struct ff_rumble_effect {
   __u16 strong_magnitude ;
   __u16 weak_magnitude ;
};
#line 1126 "include/uapi/linux/input.h"
union __anonunion_u_224 {
   struct ff_constant_effect constant ;
   struct ff_ramp_effect ramp ;
   struct ff_periodic_effect periodic ;
   struct ff_condition_effect condition[2U] ;
   struct ff_rumble_effect rumble ;
};
#line 1126 "include/uapi/linux/input.h"
struct ff_effect {
   __u16 type ;
   __s16 id ;
   __u16 direction ;
   struct ff_trigger trigger ;
   struct ff_replay replay ;
   union __anonunion_u_224 u ;
};
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_node;
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_228 {
   spinlock_t lock ;
   int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion____missing_field_name_227 {
   struct __anonstruct____missing_field_name_228 __annonCompField61 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_227 __annonCompField62 ;
};
#line 50 "include/linux/lockref.h"
struct vfsmount;
#line 51 "include/linux/lockref.h"
struct __anonstruct____missing_field_name_230 {
   u32 hash ;
   u32 len ;
};
#line 51 "include/linux/lockref.h"
union __anonunion____missing_field_name_229 {
   struct __anonstruct____missing_field_name_230 __annonCompField63 ;
   u64 hash_len ;
};
#line 51 "include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_229 __annonCompField64 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_231 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_231 d_u ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
#line 585 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_235 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion____missing_field_name_234 {
   struct __anonstruct____missing_field_name_235 __annonCompField65 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_234 __annonCompField66 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 47
struct block_device;
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 60 "include/uapi/linux/fs.h"
struct export_operations;
#line 62
struct iovec;
#line 63
struct kiocb;
#line 64
struct poll_table_struct;
#line 65
struct kstatfs;
#line 66
struct swap_info_struct;
#line 67
struct iov_iter;
#line 74 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 212 "./include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_239 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_239 kprojid_t;
#line 166 "include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 66 "include/linux/quota.h"
typedef long long qsize_t;
#line 67 "include/linux/quota.h"
union __anonunion____missing_field_name_240 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 67 "include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_240 __annonCompField68 ;
   enum quota_type type ;
};
#line 184 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 206
struct quota_format_type;
#line 207 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 272 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
#line 325 "include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 348 "include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 394 "include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 405 "include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 418 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 432 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 496 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
#line 526 "include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
#line 365 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 422 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 442
struct request_queue;
#line 443
struct hd_struct;
#line 443
struct gendisk;
#line 443 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 559
struct posix_acl;
#line 560
struct inode_operations;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_243 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_244 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 560
struct file_lock_context;
#line 560
struct cdev;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_245 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
#line 560 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_243 __annonCompField69 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_244 __annonCompField70 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_245 __annonCompField71 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 806 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 814 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 837 "include/linux/fs.h"
union __anonunion_f_u_246 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 837 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_246 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 922 "include/linux/fs.h"
typedef void *fl_owner_t;
#line 923
struct file_lock;
#line 924 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 930 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 946
struct net;
#line 951
struct nlm_lockowner;
#line 952 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_248 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_247 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_248 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_247 fl_u ;
};
#line 1004 "include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1062 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1240 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1271
struct super_operations;
#line 1271
struct xattr_handler;
#line 1271
struct mtd_info;
#line 1271 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1510 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1524
struct dir_context;
#line 1549 "include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1556 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1617 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1910 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 3032 "include/linux/fs.h"
struct input_value {
   __u16 type ;
   __u16 code ;
   __s32 value ;
};
#line 38 "include/linux/input.h"
struct ff_device;
#line 38
struct input_mt;
#line 38
struct input_handle;
#line 38 "include/linux/input.h"
struct input_dev {
   char const   *name ;
   char const   *phys ;
   char const   *uniq ;
   struct input_id id ;
   unsigned long propbit[1U] ;
   unsigned long evbit[1U] ;
   unsigned long keybit[12U] ;
   unsigned long relbit[1U] ;
   unsigned long absbit[1U] ;
   unsigned long mscbit[1U] ;
   unsigned long ledbit[1U] ;
   unsigned long sndbit[1U] ;
   unsigned long ffbit[2U] ;
   unsigned long swbit[1U] ;
   unsigned int hint_events_per_packet ;
   unsigned int keycodemax ;
   unsigned int keycodesize ;
   void *keycode ;
   int (*setkeycode)(struct input_dev * , struct input_keymap_entry  const  * , unsigned int * ) ;
   int (*getkeycode)(struct input_dev * , struct input_keymap_entry * ) ;
   struct ff_device *ff ;
   unsigned int repeat_key ;
   struct timer_list timer ;
   int rep[2U] ;
   struct input_mt *mt ;
   struct input_absinfo *absinfo ;
   unsigned long key[12U] ;
   unsigned long led[1U] ;
   unsigned long snd[1U] ;
   unsigned long sw[1U] ;
   int (*open)(struct input_dev * ) ;
   void (*close)(struct input_dev * ) ;
   int (*flush)(struct input_dev * , struct file * ) ;
   int (*event)(struct input_dev * , unsigned int  , unsigned int  , int  ) ;
   struct input_handle *grab ;
   spinlock_t event_lock ;
   struct mutex mutex ;
   unsigned int users ;
   bool going_away ;
   struct device dev ;
   struct list_head h_list ;
   struct list_head node ;
   unsigned int num_vals ;
   unsigned int max_vals ;
   struct input_value *vals ;
   bool devres_managed ;
};
#line 191 "include/linux/input.h"
struct input_handler {
   void *private ;
   void (*event)(struct input_handle * , unsigned int  , unsigned int  , int  ) ;
   void (*events)(struct input_handle * , struct input_value  const  * , unsigned int  ) ;
   bool (*filter)(struct input_handle * , unsigned int  , unsigned int  , int  ) ;
   bool (*match)(struct input_handler * , struct input_dev * ) ;
   int (*connect)(struct input_handler * , struct input_dev * , struct input_device_id  const  * ) ;
   void (*disconnect)(struct input_handle * ) ;
   void (*start)(struct input_handle * ) ;
   bool legacy_minors ;
   int minor ;
   char const   *name ;
   struct input_device_id  const  *id_table ;
   struct list_head h_list ;
   struct list_head node ;
};
#line 306 "include/linux/input.h"
struct input_handle {
   void *private ;
   int open ;
   char const   *name ;
   struct input_dev *dev ;
   struct input_handler *handler ;
   struct list_head d_node ;
   struct list_head h_node ;
};
#line 473 "include/linux/input.h"
struct ff_device {
   int (*upload)(struct input_dev * , struct ff_effect * , struct ff_effect * ) ;
   int (*erase)(struct input_dev * , int  ) ;
   int (*playback)(struct input_dev * , int  , int  ) ;
   void (*set_gain)(struct input_dev * , u16  ) ;
   void (*set_autocenter)(struct input_dev * , u16  ) ;
   void (*destroy)(struct ff_device * ) ;
   void *private ;
   unsigned long ffbit[2U] ;
   struct mutex mutex ;
   int max_effects ;
   struct ff_effect *effects ;
   struct file *effect_owners[] ;
};
#line 532
enum rc_type {
    RC_TYPE_UNKNOWN = 0,
    RC_TYPE_OTHER = 1,
    RC_TYPE_LIRC = 2,
    RC_TYPE_RC5 = 3,
    RC_TYPE_RC5X = 4,
    RC_TYPE_RC5_SZ = 5,
    RC_TYPE_JVC = 6,
    RC_TYPE_SONY12 = 7,
    RC_TYPE_SONY15 = 8,
    RC_TYPE_SONY20 = 9,
    RC_TYPE_NEC = 10,
    RC_TYPE_SANYO = 11,
    RC_TYPE_MCE_KBD = 12,
    RC_TYPE_RC6_0 = 13,
    RC_TYPE_RC6_6A_20 = 14,
    RC_TYPE_RC6_6A_24 = 15,
    RC_TYPE_RC6_6A_32 = 16,
    RC_TYPE_RC6_MCE = 17,
    RC_TYPE_SHARP = 18,
    RC_TYPE_XMP = 19
} ;
#line 555 "include/linux/input.h"
struct rc_map_table {
   u32 scancode ;
   u32 keycode ;
};
#line 83 "include/media/rc-map.h"
struct rc_map {
   struct rc_map_table *scan ;
   unsigned int size ;
   unsigned int len ;
   unsigned int alloc ;
   enum rc_type rc_type ;
   char const   *name ;
   spinlock_t lock ;
};
#line 26 "include/media/rc-core.h"
enum rc_driver_type {
    RC_DRIVER_SCANCODE = 0,
    RC_DRIVER_IR_RAW = 1
} ;
#line 31 "include/media/rc-core.h"
struct rc_scancode_filter {
   u32 data ;
   u32 mask ;
};
#line 52
struct ir_raw_event_ctrl;
#line 52 "include/media/rc-core.h"
struct rc_dev {
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[5U] ;
   char const   *input_name ;
   char const   *input_phys ;
   struct input_id input_id ;
   char *driver_name ;
   char const   *map_name ;
   struct rc_map rc_map ;
   struct mutex lock ;
   unsigned long devno ;
   struct ir_raw_event_ctrl *raw ;
   struct input_dev *input_dev ;
   enum rc_driver_type driver_type ;
   bool idle ;
   bool encode_wakeup ;
   u64 allowed_protocols ;
   u64 enabled_protocols ;
   u64 allowed_wakeup_protocols ;
   u64 enabled_wakeup_protocols ;
   struct rc_scancode_filter scancode_filter ;
   struct rc_scancode_filter scancode_wakeup_filter ;
   u32 scancode_mask ;
   u32 users ;
   void *priv ;
   spinlock_t keylock ;
   bool keypressed ;
   unsigned long keyup_jiffies ;
   struct timer_list timer_keyup ;
   u32 last_keycode ;
   enum rc_type last_protocol ;
   u32 last_scancode ;
   u8 last_toggle ;
   u32 timeout ;
   u32 min_timeout ;
   u32 max_timeout ;
   u32 rx_resolution ;
   u32 tx_resolution ;
   int (*change_protocol)(struct rc_dev * , u64 * ) ;
   int (*change_wakeup_protocol)(struct rc_dev * , u64 * ) ;
   int (*open)(struct rc_dev * ) ;
   void (*close)(struct rc_dev * ) ;
   int (*s_tx_mask)(struct rc_dev * , u32  ) ;
   int (*s_tx_carrier)(struct rc_dev * , u32  ) ;
   int (*s_tx_duty_cycle)(struct rc_dev * , u32  ) ;
   int (*s_rx_carrier_range)(struct rc_dev * , u32  , u32  ) ;
   int (*tx_ir)(struct rc_dev * , unsigned int * , unsigned int  ) ;
   void (*s_idle)(struct rc_dev * , bool  ) ;
   int (*s_learning_mode)(struct rc_dev * , int  ) ;
   int (*s_carrier_report)(struct rc_dev * , int  ) ;
   int (*s_filter)(struct rc_dev * , struct rc_scancode_filter * ) ;
   int (*s_wakeup_filter)(struct rc_dev * , struct rc_scancode_filter * ) ;
};
#line 286
struct IR_i2c;
#line 287 "include/media/rc-core.h"
struct IR_i2c {
   char *ir_codes ;
   struct i2c_client *c ;
   struct rc_dev *rc ;
   unsigned char old ;
   u32 polling_interval ;
   struct delayed_work work ;
   char name[32U] ;
   char phys[32U] ;
   int (*get_key)(struct IR_i2c * , enum rc_type * , u32 * , u8 * ) ;
};
#line 25 "include/media/ir-kbd-i2c.h"
enum ir_kbd_get_key_fn {
    IR_KBD_GET_KEY_CUSTOM = 0,
    IR_KBD_GET_KEY_PIXELVIEW = 1,
    IR_KBD_GET_KEY_HAUP = 2,
    IR_KBD_GET_KEY_KNC1 = 3,
    IR_KBD_GET_KEY_FUSIONHDTV = 4,
    IR_KBD_GET_KEY_HAUP_XVR = 5,
    IR_KBD_GET_KEY_AVERMEDIA_CARDBUS = 6
} ;
#line 35 "include/media/ir-kbd-i2c.h"
struct IR_i2c_init_data {
   char *ir_codes ;
   char const   *name ;
   u64 type ;
   u32 polling_interval ;
   int (*get_key)(struct IR_i2c * , enum rc_type * , u32 * , u8 * ) ;
   enum ir_kbd_get_key_fn internal_get_key_func ;
   struct rc_dev *rc_dev ;
};
#line 54
struct pvr2_hdw;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.h"
struct v4l2_edid {
   __u32 pad ;
   __u32 start_block ;
   __u32 blocks ;
   __u32 reserved[5U] ;
   __u8 *edid ;
};
#line 108 "./include/uapi/linux/v4l2-common.h"
enum v4l2_mpeg_stream_type {
    V4L2_MPEG_STREAM_TYPE_MPEG2_PS = 0,
    V4L2_MPEG_STREAM_TYPE_MPEG2_TS = 1,
    V4L2_MPEG_STREAM_TYPE_MPEG1_SS = 2,
    V4L2_MPEG_STREAM_TYPE_MPEG2_DVD = 3,
    V4L2_MPEG_STREAM_TYPE_MPEG1_VCD = 4,
    V4L2_MPEG_STREAM_TYPE_MPEG2_SVCD = 5
} ;
#line 117
enum v4l2_mpeg_stream_vbi_fmt {
    V4L2_MPEG_STREAM_VBI_FMT_NONE = 0,
    V4L2_MPEG_STREAM_VBI_FMT_IVTV = 1
} ;
#line 122
enum v4l2_mpeg_audio_sampling_freq {
    V4L2_MPEG_AUDIO_SAMPLING_FREQ_44100 = 0,
    V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000 = 1,
    V4L2_MPEG_AUDIO_SAMPLING_FREQ_32000 = 2
} ;
#line 128
enum v4l2_mpeg_audio_encoding {
    V4L2_MPEG_AUDIO_ENCODING_LAYER_1 = 0,
    V4L2_MPEG_AUDIO_ENCODING_LAYER_2 = 1,
    V4L2_MPEG_AUDIO_ENCODING_LAYER_3 = 2,
    V4L2_MPEG_AUDIO_ENCODING_AAC = 3,
    V4L2_MPEG_AUDIO_ENCODING_AC3 = 4
} ;
#line 153
enum v4l2_mpeg_audio_l2_bitrate {
    V4L2_MPEG_AUDIO_L2_BITRATE_32K = 0,
    V4L2_MPEG_AUDIO_L2_BITRATE_48K = 1,
    V4L2_MPEG_AUDIO_L2_BITRATE_56K = 2,
    V4L2_MPEG_AUDIO_L2_BITRATE_64K = 3,
    V4L2_MPEG_AUDIO_L2_BITRATE_80K = 4,
    V4L2_MPEG_AUDIO_L2_BITRATE_96K = 5,
    V4L2_MPEG_AUDIO_L2_BITRATE_112K = 6,
    V4L2_MPEG_AUDIO_L2_BITRATE_128K = 7,
    V4L2_MPEG_AUDIO_L2_BITRATE_160K = 8,
    V4L2_MPEG_AUDIO_L2_BITRATE_192K = 9,
    V4L2_MPEG_AUDIO_L2_BITRATE_224K = 10,
    V4L2_MPEG_AUDIO_L2_BITRATE_256K = 11,
    V4L2_MPEG_AUDIO_L2_BITRATE_320K = 12,
    V4L2_MPEG_AUDIO_L2_BITRATE_384K = 13
} ;
#line 187
enum v4l2_mpeg_audio_mode {
    V4L2_MPEG_AUDIO_MODE_STEREO = 0,
    V4L2_MPEG_AUDIO_MODE_JOINT_STEREO = 1,
    V4L2_MPEG_AUDIO_MODE_DUAL = 2,
    V4L2_MPEG_AUDIO_MODE_MONO = 3
} ;
#line 194
enum v4l2_mpeg_audio_mode_extension {
    V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_4 = 0,
    V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_8 = 1,
    V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_12 = 2,
    V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_16 = 3
} ;
#line 201
enum v4l2_mpeg_audio_emphasis {
    V4L2_MPEG_AUDIO_EMPHASIS_NONE = 0,
    V4L2_MPEG_AUDIO_EMPHASIS_50_DIV_15_uS = 1,
    V4L2_MPEG_AUDIO_EMPHASIS_CCITT_J17 = 2
} ;
#line 207
enum v4l2_mpeg_audio_crc {
    V4L2_MPEG_AUDIO_CRC_NONE = 0,
    V4L2_MPEG_AUDIO_CRC_CRC16 = 1
} ;
#line 212
enum v4l2_mpeg_audio_ac3_bitrate {
    V4L2_MPEG_AUDIO_AC3_BITRATE_32K = 0,
    V4L2_MPEG_AUDIO_AC3_BITRATE_40K = 1,
    V4L2_MPEG_AUDIO_AC3_BITRATE_48K = 2,
    V4L2_MPEG_AUDIO_AC3_BITRATE_56K = 3,
    V4L2_MPEG_AUDIO_AC3_BITRATE_64K = 4,
    V4L2_MPEG_AUDIO_AC3_BITRATE_80K = 5,
    V4L2_MPEG_AUDIO_AC3_BITRATE_96K = 6,
    V4L2_MPEG_AUDIO_AC3_BITRATE_112K = 7,
    V4L2_MPEG_AUDIO_AC3_BITRATE_128K = 8,
    V4L2_MPEG_AUDIO_AC3_BITRATE_160K = 9,
    V4L2_MPEG_AUDIO_AC3_BITRATE_192K = 10,
    V4L2_MPEG_AUDIO_AC3_BITRATE_224K = 11,
    V4L2_MPEG_AUDIO_AC3_BITRATE_256K = 12,
    V4L2_MPEG_AUDIO_AC3_BITRATE_320K = 13,
    V4L2_MPEG_AUDIO_AC3_BITRATE_384K = 14,
    V4L2_MPEG_AUDIO_AC3_BITRATE_448K = 15,
    V4L2_MPEG_AUDIO_AC3_BITRATE_512K = 16,
    V4L2_MPEG_AUDIO_AC3_BITRATE_576K = 17,
    V4L2_MPEG_AUDIO_AC3_BITRATE_640K = 18
} ;
#line 243
enum v4l2_mpeg_video_encoding {
    V4L2_MPEG_VIDEO_ENCODING_MPEG_1 = 0,
    V4L2_MPEG_VIDEO_ENCODING_MPEG_2 = 1,
    V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC = 2
} ;
#line 249
enum v4l2_mpeg_video_aspect {
    V4L2_MPEG_VIDEO_ASPECT_1x1 = 0,
    V4L2_MPEG_VIDEO_ASPECT_4x3 = 1,
    V4L2_MPEG_VIDEO_ASPECT_16x9 = 2,
    V4L2_MPEG_VIDEO_ASPECT_221x100 = 3
} ;
#line 256
enum v4l2_mpeg_video_bitrate_mode {
    V4L2_MPEG_VIDEO_BITRATE_MODE_VBR = 0,
    V4L2_MPEG_VIDEO_BITRATE_MODE_CBR = 1
} ;
#line 409
enum v4l2_mpeg_cx2341x_video_spatial_filter_mode {
    V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_MANUAL = 0,
    V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_AUTO = 1
} ;
#line 414
enum v4l2_mpeg_cx2341x_video_luma_spatial_filter_type {
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_OFF = 0,
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_HOR = 1,
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_VERT = 2,
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_HV_SEPARABLE = 3,
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_SYM_NON_SEPARABLE = 4
} ;
#line 422
enum v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type {
    V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_OFF = 0,
    V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_1D_HOR = 1
} ;
#line 427
enum v4l2_mpeg_cx2341x_video_temporal_filter_mode {
    V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_MANUAL = 0,
    V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_AUTO = 1
} ;
#line 432
enum v4l2_mpeg_cx2341x_video_median_filter_type {
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_OFF = 0,
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR = 1,
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_VERT = 2,
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR_VERT = 3,
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_DIAG = 4
} ;
#line 643
enum v4l2_priority {
    V4L2_PRIORITY_UNSET = 0,
    V4L2_PRIORITY_BACKGROUND = 1,
    V4L2_PRIORITY_INTERACTIVE = 2,
    V4L2_PRIORITY_RECORD = 3,
    V4L2_PRIORITY_DEFAULT = 2
} ;
#line 651 "./include/uapi/linux/v4l2-common.h"
struct v4l2_rect {
   __s32 left ;
   __s32 top ;
   __u32 width ;
   __u32 height ;
};
#line 370 "include/uapi/linux/videodev2.h"
struct v4l2_fract {
   __u32 numerator ;
   __u32 denominator ;
};
#line 972 "include/uapi/linux/videodev2.h"
struct v4l2_captureparm {
   __u32 capability ;
   __u32 capturemode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 readbuffers ;
   __u32 reserved[4U] ;
};
#line 984 "include/uapi/linux/videodev2.h"
struct v4l2_outputparm {
   __u32 capability ;
   __u32 outputmode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 writebuffers ;
   __u32 reserved[4U] ;
};
#line 997 "include/uapi/linux/videodev2.h"
struct v4l2_cropcap {
   __u32 type ;
   struct v4l2_rect bounds ;
   struct v4l2_rect defrect ;
   struct v4l2_fract pixelaspect ;
};
#line 1007 "include/uapi/linux/videodev2.h"
struct v4l2_crop {
   __u32 type ;
   struct v4l2_rect c ;
};
#line 1039 "include/uapi/linux/videodev2.h"
typedef __u64 v4l2_std_id;
#line 1175 "include/uapi/linux/videodev2.h"
struct v4l2_bt_timings {
   __u32 width ;
   __u32 height ;
   __u32 interlaced ;
   __u32 polarities ;
   __u64 pixelclock ;
   __u32 hfrontporch ;
   __u32 hsync ;
   __u32 hbackporch ;
   __u32 vfrontporch ;
   __u32 vsync ;
   __u32 vbackporch ;
   __u32 il_vfrontporch ;
   __u32 il_vsync ;
   __u32 il_vbackporch ;
   __u32 standards ;
   __u32 flags ;
   __u32 reserved[14U] ;
};
#line 1231 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_256 {
   struct v4l2_bt_timings bt ;
   __u32 reserved[32U] ;
};
#line 1231 "include/uapi/linux/videodev2.h"
struct v4l2_dv_timings {
   __u32 type ;
   union __anonunion____missing_field_name_256 __annonCompField76 ;
};
#line 1299 "include/uapi/linux/videodev2.h"
struct v4l2_enum_dv_timings {
   __u32 index ;
   __u32 pad ;
   __u32 reserved[2U] ;
   struct v4l2_dv_timings timings ;
};
#line 1317 "include/uapi/linux/videodev2.h"
struct v4l2_bt_timings_cap {
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u64 min_pixelclock ;
   __u64 max_pixelclock ;
   __u32 standards ;
   __u32 capabilities ;
   __u32 reserved[16U] ;
};
#line 1340 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_257 {
   struct v4l2_bt_timings_cap bt ;
   __u32 raw_data[32U] ;
};
#line 1340 "include/uapi/linux/videodev2.h"
struct v4l2_dv_timings_cap {
   __u32 type ;
   __u32 pad ;
   __u32 reserved[2U] ;
   union __anonunion____missing_field_name_257 __annonCompField77 ;
};
#line 1429 "include/uapi/linux/videodev2.h"
struct v4l2_control {
   __u32 id ;
   __s32 value ;
};
#line 1447 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_258 {
   __s32 value ;
   __s64 value64 ;
   char *string ;
   __u8 *p_u8 ;
   __u16 *p_u16 ;
   __u32 *p_u32 ;
   void *ptr ;
};
#line 1447 "include/uapi/linux/videodev2.h"
struct v4l2_ext_control {
   __u32 id ;
   __u32 size ;
   __u32 reserved2[1U] ;
   union __anonunion____missing_field_name_258 __annonCompField78 ;
};
#line 1462 "include/uapi/linux/videodev2.h"
struct v4l2_ext_controls {
   __u32 ctrl_class ;
   __u32 count ;
   __u32 error_idx ;
   __u32 reserved[2U] ;
   struct v4l2_ext_control *controls ;
};
#line 1470
enum v4l2_ctrl_type {
    V4L2_CTRL_TYPE_INTEGER = 1,
    V4L2_CTRL_TYPE_BOOLEAN = 2,
    V4L2_CTRL_TYPE_MENU = 3,
    V4L2_CTRL_TYPE_BUTTON = 4,
    V4L2_CTRL_TYPE_INTEGER64 = 5,
    V4L2_CTRL_TYPE_CTRL_CLASS = 6,
    V4L2_CTRL_TYPE_STRING = 7,
    V4L2_CTRL_TYPE_BITMASK = 8,
    V4L2_CTRL_TYPE_INTEGER_MENU = 9,
    V4L2_CTRL_COMPOUND_TYPES = 256,
    V4L2_CTRL_TYPE_U8 = 256,
    V4L2_CTRL_TYPE_U16 = 257,
    V4L2_CTRL_TYPE_U32 = 258
} ;
#line 1486 "include/uapi/linux/videodev2.h"
struct v4l2_queryctrl {
   __u32 id ;
   __u32 type ;
   __u8 name[32U] ;
   __s32 minimum ;
   __s32 maximum ;
   __s32 step ;
   __s32 default_value ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1523 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_259 {
   __u8 name[32U] ;
   __s64 value ;
};
#line 1523 "include/uapi/linux/videodev2.h"
struct v4l2_querymenu {
   __u32 id ;
   __u32 index ;
   union __anonunion____missing_field_name_259 __annonCompField79 ;
   __u32 reserved ;
};
#line 1534 "include/uapi/linux/videodev2.h"
struct v4l2_tuner {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 rxsubchans ;
   __u32 audmode ;
   __s32 signal ;
   __s32 afc ;
   __u32 reserved[4U] ;
};
#line 1573 "include/uapi/linux/videodev2.h"
struct v4l2_modulator {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 txsubchans ;
   __u32 reserved[4U] ;
};
#line 1583 "include/uapi/linux/videodev2.h"
struct v4l2_frequency {
   __u32 tuner ;
   __u32 type ;
   __u32 frequency ;
   __u32 reserved[8U] ;
};
#line 1622 "include/uapi/linux/videodev2.h"
struct v4l2_frequency_band {
   __u32 tuner ;
   __u32 type ;
   __u32 index ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 modulation ;
   __u32 reserved[9U] ;
};
#line 1790 "include/uapi/linux/videodev2.h"
struct v4l2_vbi_format {
   __u32 sampling_rate ;
   __u32 offset ;
   __u32 samples_per_line ;
   __u32 sample_format ;
   __s32 start[2U] ;
   __u32 count[2U] ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1810 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_format {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 io_size ;
   __u32 reserved[2U] ;
};
#line 1838 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_cap {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 type ;
   __u32 reserved[3U] ;
};
#line 1862 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_data {
   __u32 id ;
   __u32 field ;
   __u32 line ;
   __u32 reserved ;
   __u8 data[48U] ;
};
#line 1998 "include/uapi/linux/videodev2.h"
union __anonunion_parm_268 {
   struct v4l2_captureparm capture ;
   struct v4l2_outputparm output ;
   __u8 raw_data[200U] ;
};
#line 1998 "include/uapi/linux/videodev2.h"
struct v4l2_streamparm {
   __u32 type ;
   union __anonunion_parm_268 parm ;
};
#line 2089 "include/uapi/linux/videodev2.h"
struct v4l2_event_subscription {
   __u32 type ;
   __u32 id ;
   __u32 flags ;
   __u32 reserved[5U] ;
};
#line 2099 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_271 {
   __u32 addr ;
   char name[32U] ;
};
#line 2099 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_match {
   __u32 type ;
   union __anonunion____missing_field_name_271 __annonCompField84 ;
};
#line 2125 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_register {
   struct v4l2_dbg_match match ;
   __u32 size ;
   __u64 reg ;
   __u64 val ;
};
#line 253 "include/uapi/linux/usb/ch9.h"
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
};
#line 275 "include/uapi/linux/usb/ch9.h"
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
};
#line 343 "include/uapi/linux/usb/ch9.h"
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
};
#line 363 "include/uapi/linux/usb/ch9.h"
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
};
#line 613 "include/uapi/linux/usb/ch9.h"
struct usb_ss_ep_comp_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bMaxBurst ;
   __u8 bmAttributes ;
   __le16 wBytesPerInterval ;
};
#line 692 "include/uapi/linux/usb/ch9.h"
struct usb_interface_assoc_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bFirstInterface ;
   __u8 bInterfaceCount ;
   __u8 bFunctionClass ;
   __u8 bFunctionSubClass ;
   __u8 bFunctionProtocol ;
   __u8 iFunction ;
};
#line 751 "include/uapi/linux/usb/ch9.h"
struct usb_bos_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumDeviceCaps ;
};
#line 801 "include/uapi/linux/usb/ch9.h"
struct usb_ext_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __le32 bmAttributes ;
};
#line 811 "include/uapi/linux/usb/ch9.h"
struct usb_ss_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bmAttributes ;
   __le16 wSpeedSupported ;
   __u8 bFunctionalitySupport ;
   __u8 bU1devExitLat ;
   __le16 bU2DevExitLat ;
};
#line 840 "include/uapi/linux/usb/ch9.h"
struct usb_ss_container_id_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bReserved ;
   __u8 ContainerID[16U] ;
};
#line 905
enum usb_device_speed {
    USB_SPEED_UNKNOWN = 0,
    USB_SPEED_LOW = 1,
    USB_SPEED_FULL = 2,
    USB_SPEED_HIGH = 3,
    USB_SPEED_WIRELESS = 4,
    USB_SPEED_SUPER = 5
} ;
#line 914
enum usb_device_state {
    USB_STATE_NOTATTACHED = 0,
    USB_STATE_ATTACHED = 1,
    USB_STATE_POWERED = 2,
    USB_STATE_RECONNECTING = 3,
    USB_STATE_UNAUTHENTICATED = 4,
    USB_STATE_DEFAULT = 5,
    USB_STATE_ADDRESS = 6,
    USB_STATE_CONFIGURED = 7,
    USB_STATE_SUSPENDED = 8
} ;
#line 398 "include/linux/irq.h"
struct proc_dir_entry;
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 465 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 283 "include/linux/pm_runtime.h"
struct wusb_dev;
#line 284
struct ep_device;
#line 285 "include/linux/pm_runtime.h"
struct usb_host_endpoint {
   struct usb_endpoint_descriptor desc ;
   struct usb_ss_ep_comp_descriptor ss_ep_comp ;
   struct list_head urb_list ;
   void *hcpriv ;
   struct ep_device *ep_dev ;
   unsigned char *extra ;
   int extralen ;
   int enabled ;
   int streams ;
};
#line 77 "include/linux/usb.h"
struct usb_host_interface {
   struct usb_interface_descriptor desc ;
   int extralen ;
   unsigned char *extra ;
   struct usb_host_endpoint *endpoint ;
   char *string ;
};
#line 92
enum usb_interface_condition {
    USB_INTERFACE_UNBOUND = 0,
    USB_INTERFACE_BINDING = 1,
    USB_INTERFACE_BOUND = 2,
    USB_INTERFACE_UNBINDING = 3
} ;
#line 99 "include/linux/usb.h"
struct usb_interface {
   struct usb_host_interface *altsetting ;
   struct usb_host_interface *cur_altsetting ;
   unsigned int num_altsetting ;
   struct usb_interface_assoc_descriptor *intf_assoc ;
   int minor ;
   enum usb_interface_condition condition ;
   unsigned char sysfs_files_created : 1 ;
   unsigned char ep_devs_created : 1 ;
   unsigned char unregistering : 1 ;
   unsigned char needs_remote_wakeup : 1 ;
   unsigned char needs_altsetting0 : 1 ;
   unsigned char needs_binding : 1 ;
   unsigned char resetting_device : 1 ;
   struct device dev ;
   struct device *usb_dev ;
   atomic_t pm_usage_cnt ;
   struct work_struct reset_ws ;
};
#line 201 "include/linux/usb.h"
struct usb_interface_cache {
   unsigned int num_altsetting ;
   struct kref ref ;
   struct usb_host_interface altsetting[0U] ;
};
#line 256 "include/linux/usb.h"
struct usb_host_config {
   struct usb_config_descriptor desc ;
   char *string ;
   struct usb_interface_assoc_descriptor *intf_assoc[16U] ;
   struct usb_interface *interface[32U] ;
   struct usb_interface_cache *intf_cache[32U] ;
   unsigned char *extra ;
   int extralen ;
};
#line 320 "include/linux/usb.h"
struct usb_host_bos {
   struct usb_bos_descriptor *desc ;
   struct usb_ext_cap_descriptor *ext_cap ;
   struct usb_ss_cap_descriptor *ss_cap ;
   struct usb_ss_container_id_descriptor *ss_id ;
};
#line 332 "include/linux/usb.h"
struct usb_devmap {
   unsigned long devicemap[2U] ;
};
#line 344
struct mon_bus;
#line 344 "include/linux/usb.h"
struct usb_bus {
   struct device *controller ;
   int busnum ;
   char const   *bus_name ;
   u8 uses_dma ;
   u8 uses_pio_for_control ;
   u8 otg_port ;
   unsigned char is_b_host : 1 ;
   unsigned char b_hnp_enable : 1 ;
   unsigned char no_stop_on_short : 1 ;
   unsigned char no_sg_constraint : 1 ;
   unsigned int sg_tablesize ;
   int devnum_next ;
   struct usb_devmap devmap ;
   struct usb_device *root_hub ;
   struct usb_bus *hs_companion ;
   struct list_head bus_list ;
   struct mutex usb_address0_mutex ;
   int bandwidth_allocated ;
   int bandwidth_int_reqs ;
   int bandwidth_isoc_reqs ;
   unsigned int resuming_ports ;
   struct mon_bus *mon_bus ;
   int monitored ;
};
#line 395
struct usb_tt;
#line 396
enum usb_device_removable {
    USB_DEVICE_REMOVABLE_UNKNOWN = 0,
    USB_DEVICE_REMOVABLE = 1,
    USB_DEVICE_FIXED = 2
} ;
#line 409 "include/linux/usb.h"
struct usb2_lpm_parameters {
   unsigned int besl ;
   int timeout ;
};
#line 430 "include/linux/usb.h"
struct usb3_lpm_parameters {
   unsigned int mel ;
   unsigned int pel ;
   unsigned int sel ;
   int timeout ;
};
#line 469 "include/linux/usb.h"
struct usb_device {
   int devnum ;
   char devpath[16U] ;
   u32 route ;
   enum usb_device_state state ;
   enum usb_device_speed speed ;
   struct usb_tt *tt ;
   int ttport ;
   unsigned int toggle[2U] ;
   struct usb_device *parent ;
   struct usb_bus *bus ;
   struct usb_host_endpoint ep0 ;
   struct device dev ;
   struct usb_device_descriptor descriptor ;
   struct usb_host_bos *bos ;
   struct usb_host_config *config ;
   struct usb_host_config *actconfig ;
   struct usb_host_endpoint *ep_in[16U] ;
   struct usb_host_endpoint *ep_out[16U] ;
   char **rawdescriptors ;
   unsigned short bus_mA ;
   u8 portnum ;
   u8 level ;
   unsigned char can_submit : 1 ;
   unsigned char persist_enabled : 1 ;
   unsigned char have_langid : 1 ;
   unsigned char authorized : 1 ;
   unsigned char authenticated : 1 ;
   unsigned char wusb : 1 ;
   unsigned char lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_besl_capable : 1 ;
   unsigned char usb2_hw_lpm_enabled : 1 ;
   unsigned char usb2_hw_lpm_allowed : 1 ;
   unsigned char usb3_lpm_enabled : 1 ;
   int string_langid ;
   char *product ;
   char *manufacturer ;
   char *serial ;
   struct list_head filelist ;
   int maxchild ;
   u32 quirks ;
   atomic_t urbnum ;
   unsigned long active_duration ;
   unsigned long connect_time ;
   unsigned char do_remote_wakeup : 1 ;
   unsigned char reset_resume : 1 ;
   unsigned char port_is_suspended : 1 ;
   struct wusb_dev *wusb_dev ;
   int slot_id ;
   enum usb_device_removable removable ;
   struct usb2_lpm_parameters l1_params ;
   struct usb3_lpm_parameters u1_params ;
   struct usb3_lpm_parameters u2_params ;
   unsigned int lpm_disable_count ;
};
#line 1200 "include/linux/usb.h"
struct usb_iso_packet_descriptor {
   unsigned int offset ;
   unsigned int length ;
   unsigned int actual_length ;
   int status ;
};
#line 1242
struct urb;
#line 1243 "include/linux/usb.h"
struct usb_anchor {
   struct list_head urb_list ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
   atomic_t suspend_wakeups ;
   unsigned char poisoned : 1 ;
};
#line 1262 "include/linux/usb.h"
struct urb {
   struct kref kref ;
   void *hcpriv ;
   atomic_t use_count ;
   atomic_t reject ;
   int unlinked ;
   struct list_head urb_list ;
   struct list_head anchor_list ;
   struct usb_anchor *anchor ;
   struct usb_device *dev ;
   struct usb_host_endpoint *ep ;
   unsigned int pipe ;
   unsigned int stream_id ;
   int status ;
   unsigned int transfer_flags ;
   void *transfer_buffer ;
   dma_addr_t transfer_dma ;
   struct scatterlist *sg ;
   int num_mapped_sgs ;
   int num_sgs ;
   u32 transfer_buffer_length ;
   u32 actual_length ;
   unsigned char *setup_packet ;
   dma_addr_t setup_dma ;
   int start_frame ;
   int number_of_packets ;
   int interval ;
   int error_count ;
   void *context ;
   void (*complete)(struct urb * ) ;
   struct usb_iso_packet_descriptor iso_frame_desc[0U] ;
};
#line 1894 "include/linux/usb.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 163 "include/linux/poll.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 169 "./include/uapi/linux/media.h"
struct media_pipeline {

};
#line 172
struct media_pad;
#line 172 "./include/uapi/linux/media.h"
struct media_link {
   struct media_pad *source ;
   struct media_pad *sink ;
   struct media_link *reverse ;
   unsigned long flags ;
};
#line 40 "include/media/media-entity.h"
struct media_entity;
#line 40 "include/media/media-entity.h"
struct media_pad {
   struct media_entity *entity ;
   u16 index ;
   unsigned long flags ;
};
#line 46 "include/media/media-entity.h"
struct media_entity_operations {
   int (*link_setup)(struct media_entity * , struct media_pad  const  * , struct media_pad  const  * ,
                     u32  ) ;
   int (*link_validate)(struct media_link * ) ;
};
#line 62
struct media_device;
#line 62 "include/media/media-entity.h"
struct __anonstruct_dev_287 {
   u32 major ;
   u32 minor ;
};
#line 62 "include/media/media-entity.h"
union __anonunion_info_286 {
   struct __anonstruct_dev_287 dev ;
};
#line 62 "include/media/media-entity.h"
struct media_entity {
   struct list_head list ;
   struct media_device *parent ;
   u32 id ;
   char const   *name ;
   u32 type ;
   u32 revision ;
   unsigned long flags ;
   u32 group_id ;
   u16 num_pads ;
   u16 num_links ;
   u16 num_backlinks ;
   u16 max_links ;
   struct media_pad *pads ;
   struct media_link *links ;
   struct media_entity_operations  const  *ops ;
   int stream_count ;
   int use_count ;
   struct media_pipeline *pipe ;
   union __anonunion_info_286 info ;
};
#line 155
struct video_device;
#line 156
struct v4l2_device;
#line 157
struct v4l2_ctrl_handler;
#line 158 "include/media/media-entity.h"
struct v4l2_prio_state {
   atomic_t prios[4U] ;
};
#line 61 "include/media/v4l2-dev.h"
struct v4l2_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl32)(struct file * , unsigned int  , unsigned long  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 78
struct vb2_queue;
#line 78
struct v4l2_ioctl_ops;
#line 78 "include/media/v4l2-dev.h"
struct video_device {
   struct media_entity entity ;
   struct v4l2_file_operations  const  *fops ;
   struct device dev ;
   struct cdev *cdev ;
   struct v4l2_device *v4l2_dev ;
   struct device *dev_parent ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct vb2_queue *queue ;
   struct v4l2_prio_state *prio ;
   char name[32U] ;
   int vfl_type ;
   int vfl_dir ;
   int minor ;
   u16 num ;
   unsigned long flags ;
   int index ;
   spinlock_t fh_lock ;
   struct list_head fh_list ;
   int dev_debug ;
   v4l2_std_id tvnorms ;
   void (*release)(struct video_device * ) ;
   struct v4l2_ioctl_ops  const  *ioctl_ops ;
   unsigned long valid_ioctls[3U] ;
   unsigned long disable_locking[3U] ;
   struct mutex *lock ;
};
#line 34 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-io.h"
struct pvr2_stream;
#line 91
struct pvr2_ctrl;
#line 92
enum pvr2_ctl_type {
    pvr2_ctl_int = 0,
    pvr2_ctl_enum = 1,
    pvr2_ctl_bitmask = 2,
    pvr2_ctl_bool = 3
} ;
#line 108 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-ctrl.h"
enum pvr2_config {
    pvr2_config_empty = 0,
    pvr2_config_mpeg = 1,
    pvr2_config_vbi = 2,
    pvr2_config_pcm = 3,
    pvr2_config_rawvideo = 4
} ;
#line 341 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw.h"
struct media_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 53 "include/media/media-devnode.h"
struct media_devnode {
   struct media_file_operations  const  *fops ;
   struct device dev ;
   struct cdev cdev ;
   struct device *parent ;
   int minor ;
   unsigned long flags ;
   void (*release)(struct media_devnode * ) ;
};
#line 98 "include/media/media-devnode.h"
struct media_device {
   struct device *dev ;
   struct media_devnode devnode ;
   char model[32U] ;
   char serial[40U] ;
   char bus_info[32U] ;
   u32 hw_revision ;
   u32 driver_version ;
   u32 entity_id ;
   struct list_head entities ;
   spinlock_t lock ;
   struct mutex graph_mutex ;
   int (*link_notify)(struct media_link * , u32  , unsigned int  ) ;
};
#line 98 "include/media/media-device.h"
struct v4l2_mbus_framefmt {
   __u32 width ;
   __u32 height ;
   __u32 code ;
   __u32 field ;
   __u32 colorspace ;
   __u16 ycbcr_enc ;
   __u16 quantization ;
   __u16 xfer_func ;
   __u16 reserved[11U] ;
};
#line 45 "./include/uapi/linux/v4l2-mediabus.h"
struct v4l2_subdev_format {
   __u32 which ;
   __u32 pad ;
   struct v4l2_mbus_framefmt format ;
   __u32 reserved[8U] ;
};
#line 66 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_mbus_code_enum {
   __u32 pad ;
   __u32 index ;
   __u32 code ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 81 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_size_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 100 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval {
   __u32 pad ;
   struct v4l2_fract interval ;
   __u32 reserved[9U] ;
};
#line 111 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 width ;
   __u32 height ;
   struct v4l2_fract interval ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 132 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_selection {
   __u32 which ;
   __u32 pad ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[8U] ;
};
#line 156
struct v4l2_subdev;
#line 157
struct v4l2_async_notifier;
#line 158
enum v4l2_async_match_type {
    V4L2_ASYNC_MATCH_CUSTOM = 0,
    V4L2_ASYNC_MATCH_DEVNAME = 1,
    V4L2_ASYNC_MATCH_I2C = 2,
    V4L2_ASYNC_MATCH_OF = 3
} ;
#line 165 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_of_290 {
   struct device_node  const  *node ;
};
#line 165 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_device_name_291 {
   char const   *name ;
};
#line 165 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_i2c_292 {
   int adapter_id ;
   unsigned short address ;
};
#line 165 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_custom_293 {
   bool (*match)(struct device * , struct v4l2_async_subdev * ) ;
   void *priv ;
};
#line 165 "./include/uapi/linux/v4l2-subdev.h"
union __anonunion_match_289 {
   struct __anonstruct_of_290 of ;
   struct __anonstruct_device_name_291 device_name ;
   struct __anonstruct_i2c_292 i2c ;
   struct __anonstruct_custom_293 custom ;
};
#line 165 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_async_subdev {
   enum v4l2_async_match_type match_type ;
   union __anonunion_match_289 match ;
   struct list_head list ;
};
#line 63 "include/media/v4l2-async.h"
struct v4l2_async_notifier {
   unsigned int num_subdevs ;
   struct v4l2_async_subdev **subdevs ;
   struct v4l2_device *v4l2_dev ;
   struct list_head waiting ;
   struct list_head done ;
   struct list_head list ;
   int (*bound)(struct v4l2_async_notifier * , struct v4l2_subdev * , struct v4l2_async_subdev * ) ;
   int (*complete)(struct v4l2_async_notifier * ) ;
   void (*unbind)(struct v4l2_async_notifier * , struct v4l2_subdev * , struct v4l2_async_subdev * ) ;
};
#line 86 "include/media/v4l2-common.h"
struct v4l2_subdev_ops;
#line 147 "include/media/v4l2-common.h"
struct v4l2_priv_tun_config {
   int tuner ;
   void *priv ;
};
#line 191
struct v4l2_m2m_ctx;
#line 191 "include/media/v4l2-common.h"
struct v4l2_fh {
   struct list_head list ;
   struct video_device *vdev ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   enum v4l2_priority prio ;
   wait_queue_head_t wait ;
   struct list_head subscribed ;
   struct list_head available ;
   unsigned int navailable ;
   u32 sequence ;
   struct v4l2_m2m_ctx *m2m_ctx ;
};
#line 106 "include/media/v4l2-fh.h"
enum v4l2_mbus_type {
    V4L2_MBUS_PARALLEL = 0,
    V4L2_MBUS_BT656 = 1,
    V4L2_MBUS_CSI2 = 2
} ;
#line 112 "include/media/v4l2-fh.h"
struct v4l2_mbus_config {
   enum v4l2_mbus_type type ;
   unsigned int flags ;
};
#line 115 "include/media/v4l2-mediabus.h"
struct v4l2_subdev_fh;
#line 116
struct tuner_setup;
#line 117
struct v4l2_mbus_frame_desc;
#line 118 "include/media/v4l2-mediabus.h"
struct v4l2_decode_vbi_line {
   u32 is_second_field ;
   u8 *p ;
   u32 line ;
   u32 type ;
};
#line 63 "include/media/v4l2-subdev.h"
struct v4l2_subdev_io_pin_config {
   u32 flags ;
   u8 pin ;
   u8 function ;
   u8 value ;
   u8 strength ;
};
#line 119 "include/media/v4l2-subdev.h"
struct v4l2_subdev_core_ops {
   int (*log_status)(struct v4l2_subdev * ) ;
   int (*s_io_pin_config)(struct v4l2_subdev * , size_t  , struct v4l2_subdev_io_pin_config * ) ;
   int (*init)(struct v4l2_subdev * , u32  ) ;
   int (*load_fw)(struct v4l2_subdev * ) ;
   int (*reset)(struct v4l2_subdev * , u32  ) ;
   int (*s_gpio)(struct v4l2_subdev * , u32  ) ;
   int (*queryctrl)(struct v4l2_subdev * , struct v4l2_queryctrl * ) ;
   int (*g_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*s_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*g_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*s_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*try_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*querymenu)(struct v4l2_subdev * , struct v4l2_querymenu * ) ;
   long (*ioctl)(struct v4l2_subdev * , unsigned int  , void * ) ;
   long (*compat_ioctl32)(struct v4l2_subdev * , unsigned int  , unsigned long  ) ;
   int (*g_register)(struct v4l2_subdev * , struct v4l2_dbg_register * ) ;
   int (*s_register)(struct v4l2_subdev * , struct v4l2_dbg_register  const  * ) ;
   int (*s_power)(struct v4l2_subdev * , int  ) ;
   int (*interrupt_service_routine)(struct v4l2_subdev * , u32  , bool * ) ;
   int (*subscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
   int (*unsubscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
};
#line 180 "include/media/v4l2-subdev.h"
struct v4l2_subdev_tuner_ops {
   int (*s_radio)(struct v4l2_subdev * ) ;
   int (*s_frequency)(struct v4l2_subdev * , struct v4l2_frequency  const  * ) ;
   int (*g_frequency)(struct v4l2_subdev * , struct v4l2_frequency * ) ;
   int (*enum_freq_bands)(struct v4l2_subdev * , struct v4l2_frequency_band * ) ;
   int (*g_tuner)(struct v4l2_subdev * , struct v4l2_tuner * ) ;
   int (*s_tuner)(struct v4l2_subdev * , struct v4l2_tuner  const  * ) ;
   int (*g_modulator)(struct v4l2_subdev * , struct v4l2_modulator * ) ;
   int (*s_modulator)(struct v4l2_subdev * , struct v4l2_modulator  const  * ) ;
   int (*s_type_addr)(struct v4l2_subdev * , struct tuner_setup * ) ;
   int (*s_config)(struct v4l2_subdev * , struct v4l2_priv_tun_config  const  * ) ;
};
#line 207 "include/media/v4l2-subdev.h"
struct v4l2_subdev_audio_ops {
   int (*s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_i2s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
};
#line 234 "include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc_entry {
   u16 flags ;
   u32 pixelcode ;
   u32 length ;
};
#line 255 "include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc {
   struct v4l2_mbus_frame_desc_entry entry[4U] ;
   unsigned short num_entries ;
};
#line 267 "include/media/v4l2-subdev.h"
struct v4l2_subdev_video_ops {
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_crystal_freq)(struct v4l2_subdev * , u32  , u32  ) ;
   int (*g_std)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*s_std)(struct v4l2_subdev * , v4l2_std_id  ) ;
   int (*s_std_output)(struct v4l2_subdev * , v4l2_std_id  ) ;
   int (*g_std_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*querystd)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_tvnorms)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_tvnorms_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_input_status)(struct v4l2_subdev * , u32 * ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
   int (*cropcap)(struct v4l2_subdev * , struct v4l2_cropcap * ) ;
   int (*g_crop)(struct v4l2_subdev * , struct v4l2_crop * ) ;
   int (*s_crop)(struct v4l2_subdev * , struct v4l2_crop  const  * ) ;
   int (*g_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*s_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*g_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*s_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*s_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*g_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*query_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*g_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config * ) ;
   int (*s_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config  const  * ) ;
   int (*s_rx_buffer)(struct v4l2_subdev * , void * , unsigned int * ) ;
};
#line 341 "include/media/v4l2-subdev.h"
struct v4l2_subdev_vbi_ops {
   int (*decode_vbi_line)(struct v4l2_subdev * , struct v4l2_decode_vbi_line * ) ;
   int (*s_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data  const  * ) ;
   int (*g_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data * ) ;
   int (*g_sliced_vbi_cap)(struct v4l2_subdev * , struct v4l2_sliced_vbi_cap * ) ;
   int (*s_raw_fmt)(struct v4l2_subdev * , struct v4l2_vbi_format * ) ;
   int (*g_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
   int (*s_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
};
#line 381 "include/media/v4l2-subdev.h"
struct v4l2_subdev_sensor_ops {
   int (*g_skip_top_lines)(struct v4l2_subdev * , u32 * ) ;
   int (*g_skip_frames)(struct v4l2_subdev * , u32 * ) ;
};
#line 396
enum v4l2_subdev_ir_mode {
    V4L2_SUBDEV_IR_MODE_PULSE_WIDTH = 0
} ;
#line 400 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_parameters {
   unsigned int bytes_per_data_element ;
   enum v4l2_subdev_ir_mode mode ;
   bool enable ;
   bool interrupt_enable ;
   bool shutdown ;
   bool modulation ;
   u32 max_pulse_width ;
   unsigned int carrier_freq ;
   unsigned int duty_cycle ;
   bool invert_level ;
   bool invert_carrier_sense ;
   u32 noise_filter_min_width ;
   unsigned int carrier_range_lower ;
   unsigned int carrier_range_upper ;
   u32 resolution ;
};
#line 448 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_ops {
   int (*rx_read)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*rx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*rx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_write)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*tx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
};
#line 467 "include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_config {
   struct v4l2_mbus_framefmt try_fmt ;
   struct v4l2_rect try_crop ;
   struct v4l2_rect try_compose ;
};
#line 480 "include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_ops {
   int (*enum_mbus_code)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * ,
                         struct v4l2_subdev_mbus_code_enum * ) ;
   int (*enum_frame_size)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * ,
                          struct v4l2_subdev_frame_size_enum * ) ;
   int (*enum_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * ,
                              struct v4l2_subdev_frame_interval_enum * ) ;
   int (*get_fmt)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_format * ) ;
   int (*set_fmt)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_format * ) ;
   int (*get_selection)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_selection * ) ;
   int (*set_selection)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_selection * ) ;
   int (*get_edid)(struct v4l2_subdev * , struct v4l2_edid * ) ;
   int (*set_edid)(struct v4l2_subdev * , struct v4l2_edid * ) ;
   int (*dv_timings_cap)(struct v4l2_subdev * , struct v4l2_dv_timings_cap * ) ;
   int (*enum_dv_timings)(struct v4l2_subdev * , struct v4l2_enum_dv_timings * ) ;
   int (*link_validate)(struct v4l2_subdev * , struct media_link * , struct v4l2_subdev_format * ,
                        struct v4l2_subdev_format * ) ;
   int (*get_frame_desc)(struct v4l2_subdev * , unsigned int  , struct v4l2_mbus_frame_desc * ) ;
   int (*set_frame_desc)(struct v4l2_subdev * , unsigned int  , struct v4l2_mbus_frame_desc * ) ;
};
#line 524 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ops {
   struct v4l2_subdev_core_ops  const  *core ;
   struct v4l2_subdev_tuner_ops  const  *tuner ;
   struct v4l2_subdev_audio_ops  const  *audio ;
   struct v4l2_subdev_video_ops  const  *video ;
   struct v4l2_subdev_vbi_ops  const  *vbi ;
   struct v4l2_subdev_ir_ops  const  *ir ;
   struct v4l2_subdev_sensor_ops  const  *sensor ;
   struct v4l2_subdev_pad_ops  const  *pad ;
};
#line 536 "include/media/v4l2-subdev.h"
struct v4l2_subdev_internal_ops {
   int (*registered)(struct v4l2_subdev * ) ;
   void (*unregistered)(struct v4l2_subdev * ) ;
   int (*open)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
   int (*close)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
};
#line 557
struct regulator_bulk_data;
#line 558 "include/media/v4l2-subdev.h"
struct v4l2_subdev_platform_data {
   struct regulator_bulk_data *regulators ;
   int num_regulators ;
   void *host_priv ;
};
#line 579 "include/media/v4l2-subdev.h"
struct v4l2_subdev {
   struct media_entity entity ;
   struct list_head list ;
   struct module *owner ;
   bool owner_v4l2_dev ;
   u32 flags ;
   struct v4l2_device *v4l2_dev ;
   struct v4l2_subdev_ops  const  *ops ;
   struct v4l2_subdev_internal_ops  const  *internal_ops ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   char name[32U] ;
   u32 grp_id ;
   void *dev_priv ;
   void *host_priv ;
   struct video_device *devnode ;
   struct device *dev ;
   struct device_node *of_node ;
   struct list_head async_list ;
   struct v4l2_async_subdev *asd ;
   struct v4l2_async_notifier *notifier ;
   struct v4l2_subdev_platform_data *pdata ;
};
#line 619 "include/media/v4l2-subdev.h"
struct v4l2_subdev_fh {
   struct v4l2_fh vfh ;
   struct v4l2_subdev_pad_config *pad ;
};
#line 684 "include/media/v4l2-subdev.h"
struct v4l2_device {
   struct device *dev ;
   struct media_device *mdev ;
   struct list_head subdevs ;
   spinlock_t lock ;
   char name[36U] ;
   void (*notify)(struct v4l2_subdev * , unsigned int  , void * ) ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct v4l2_prio_state prio ;
   struct kref ref ;
   void (*release)(struct v4l2_device * ) ;
};
#line 128 "include/media/v4l2-device.h"
struct v4l2_ctrl_helper;
#line 129
struct v4l2_ctrl;
#line 131 "include/media/v4l2-device.h"
union v4l2_ctrl_ptr {
   s32 *p_s32 ;
   s64 *p_s64 ;
   u8 *p_u8 ;
   u16 *p_u16 ;
   u32 *p_u32 ;
   char *p_char ;
   void *p ;
};
#line 57 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_ops {
   int (*g_volatile_ctrl)(struct v4l2_ctrl * ) ;
   int (*try_ctrl)(struct v4l2_ctrl * ) ;
   int (*s_ctrl)(struct v4l2_ctrl * ) ;
};
#line 75 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_type_ops {
   bool (*equal)(struct v4l2_ctrl  const  * , u32  , union v4l2_ctrl_ptr  , union v4l2_ctrl_ptr  ) ;
   void (*init)(struct v4l2_ctrl  const  * , u32  , union v4l2_ctrl_ptr  ) ;
   void (*log)(struct v4l2_ctrl  const  * ) ;
   int (*validate)(struct v4l2_ctrl  const  * , u32  , union v4l2_ctrl_ptr  ) ;
};
#line 94 "include/media/v4l2-ctrls.h"
union __anonunion____missing_field_name_294 {
   u64 step ;
   u64 menu_skip_mask ;
};
#line 94 "include/media/v4l2-ctrls.h"
union __anonunion____missing_field_name_295 {
   char const   * const  *qmenu ;
   s64 const   *qmenu_int ;
};
#line 94 "include/media/v4l2-ctrls.h"
struct __anonstruct_cur_296 {
   s32 val ;
};
#line 94 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl {
   struct list_head node ;
   struct list_head ev_subs ;
   struct v4l2_ctrl_handler *handler ;
   struct v4l2_ctrl **cluster ;
   unsigned int ncontrols ;
   unsigned char done : 1 ;
   unsigned char is_new : 1 ;
   unsigned char has_changed : 1 ;
   unsigned char is_private : 1 ;
   unsigned char is_auto : 1 ;
   unsigned char is_int : 1 ;
   unsigned char is_string : 1 ;
   unsigned char is_ptr : 1 ;
   unsigned char is_array : 1 ;
   unsigned char has_volatiles : 1 ;
   unsigned char call_notify : 1 ;
   unsigned char manual_mode_value ;
   struct v4l2_ctrl_ops  const  *ops ;
   struct v4l2_ctrl_type_ops  const  *type_ops ;
   u32 id ;
   char const   *name ;
   enum v4l2_ctrl_type type ;
   s64 minimum ;
   s64 maximum ;
   s64 default_value ;
   u32 elems ;
   u32 elem_size ;
   u32 dims[4U] ;
   u32 nr_of_dims ;
   union __anonunion____missing_field_name_294 __annonCompField93 ;
   union __anonunion____missing_field_name_295 __annonCompField94 ;
   unsigned long flags ;
   void *priv ;
   s32 val ;
   struct __anonstruct_cur_296 cur ;
   union v4l2_ctrl_ptr p_new ;
   union v4l2_ctrl_ptr p_cur ;
};
#line 212 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_ref {
   struct list_head node ;
   struct v4l2_ctrl_ref *next ;
   struct v4l2_ctrl *ctrl ;
   struct v4l2_ctrl_helper *helper ;
};
#line 229 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_handler {
   struct mutex _lock ;
   struct mutex *lock ;
   struct list_head ctrls ;
   struct list_head ctrl_refs ;
   struct v4l2_ctrl_ref *cached ;
   struct v4l2_ctrl_ref **buckets ;
   void (*notify)(struct v4l2_ctrl * , void * ) ;
   void *notify_priv ;
   u16 nr_of_buckets ;
   int error ;
};
#line 837
enum cx2341x_port {
    CX2341X_PORT_MEMORY = 0,
    CX2341X_PORT_STREAMING = 1,
    CX2341X_PORT_SERIAL = 2
} ;
#line 849 "include/media/v4l2-ctrls.h"
struct cx2341x_mpeg_params {
   u32 capabilities ;
   enum cx2341x_port port ;
   u16 width ;
   u16 height ;
   u16 is_50hz ;
   enum v4l2_mpeg_stream_type stream_type ;
   enum v4l2_mpeg_stream_vbi_fmt stream_vbi_fmt ;
   u16 stream_insert_nav_packets ;
   enum v4l2_mpeg_audio_sampling_freq audio_sampling_freq ;
   enum v4l2_mpeg_audio_encoding audio_encoding ;
   enum v4l2_mpeg_audio_l2_bitrate audio_l2_bitrate ;
   enum v4l2_mpeg_audio_ac3_bitrate audio_ac3_bitrate ;
   enum v4l2_mpeg_audio_mode audio_mode ;
   enum v4l2_mpeg_audio_mode_extension audio_mode_extension ;
   enum v4l2_mpeg_audio_emphasis audio_emphasis ;
   enum v4l2_mpeg_audio_crc audio_crc ;
   u32 audio_properties ;
   u16 audio_mute ;
   enum v4l2_mpeg_video_encoding video_encoding ;
   enum v4l2_mpeg_video_aspect video_aspect ;
   u16 video_b_frames ;
   u16 video_gop_size ;
   u16 video_gop_closure ;
   enum v4l2_mpeg_video_bitrate_mode video_bitrate_mode ;
   u32 video_bitrate ;
   u32 video_bitrate_peak ;
   u16 video_temporal_decimation ;
   u16 video_mute ;
   u32 video_mute_yuv ;
   enum v4l2_mpeg_cx2341x_video_spatial_filter_mode video_spatial_filter_mode ;
   u16 video_spatial_filter ;
   enum v4l2_mpeg_cx2341x_video_luma_spatial_filter_type video_luma_spatial_filter_type ;
   enum v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type video_chroma_spatial_filter_type ;
   enum v4l2_mpeg_cx2341x_video_temporal_filter_mode video_temporal_filter_mode ;
   u16 video_temporal_filter ;
   enum v4l2_mpeg_cx2341x_video_median_filter_type video_median_filter_type ;
   u16 video_luma_median_filter_top ;
   u16 video_luma_median_filter_bottom ;
   u16 video_chroma_median_filter_top ;
   u16 video_chroma_median_filter_bottom ;
};
#line 198 "include/media/cx2341x.h"
enum fe_type {
    FE_QPSK = 0,
    FE_QAM = 1,
    FE_OFDM = 2,
    FE_ATSC = 3
} ;
#line 205
enum fe_caps {
    FE_IS_STUPID = 0,
    FE_CAN_INVERSION_AUTO = 1,
    FE_CAN_FEC_1_2 = 2,
    FE_CAN_FEC_2_3 = 4,
    FE_CAN_FEC_3_4 = 8,
    FE_CAN_FEC_4_5 = 16,
    FE_CAN_FEC_5_6 = 32,
    FE_CAN_FEC_6_7 = 64,
    FE_CAN_FEC_7_8 = 128,
    FE_CAN_FEC_8_9 = 256,
    FE_CAN_FEC_AUTO = 512,
    FE_CAN_QPSK = 1024,
    FE_CAN_QAM_16 = 2048,
    FE_CAN_QAM_32 = 4096,
    FE_CAN_QAM_64 = 8192,
    FE_CAN_QAM_128 = 16384,
    FE_CAN_QAM_256 = 32768,
    FE_CAN_QAM_AUTO = 65536,
    FE_CAN_TRANSMISSION_MODE_AUTO = 131072,
    FE_CAN_BANDWIDTH_AUTO = 262144,
    FE_CAN_GUARD_INTERVAL_AUTO = 524288,
    FE_CAN_HIERARCHY_AUTO = 1048576,
    FE_CAN_8VSB = 2097152,
    FE_CAN_16VSB = 4194304,
    FE_HAS_EXTENDED_CAPS = 8388608,
    FE_CAN_MULTISTREAM = 67108864,
    FE_CAN_TURBO_FEC = 134217728,
    FE_CAN_2G_MODULATION = 268435456,
    FE_NEEDS_BENDING = 536870912,
    FE_CAN_RECOVER = 1073741824,
    FE_CAN_MUTE_TS = 2147483648U
} ;
#line 239 "include/media/cx2341x.h"
struct dvb_frontend_info {
   char name[128U] ;
   enum fe_type type ;
   __u32 frequency_min ;
   __u32 frequency_max ;
   __u32 frequency_stepsize ;
   __u32 frequency_tolerance ;
   __u32 symbol_rate_min ;
   __u32 symbol_rate_max ;
   __u32 symbol_rate_tolerance ;
   __u32 notifier_delay ;
   enum fe_caps caps ;
};
#line 85 "./include/uapi/linux/dvb/frontend.h"
struct dvb_diseqc_master_cmd {
   __u8 msg[6U] ;
   __u8 msg_len ;
};
#line 95 "./include/uapi/linux/dvb/frontend.h"
struct dvb_diseqc_slave_reply {
   __u8 msg[4U] ;
   __u8 msg_len ;
   int timeout ;
};
#line 101
enum fe_sec_voltage {
    SEC_VOLTAGE_13 = 0,
    SEC_VOLTAGE_18 = 1,
    SEC_VOLTAGE_OFF = 2
} ;
#line 107
enum fe_sec_tone_mode {
    SEC_TONE_ON = 0,
    SEC_TONE_OFF = 1
} ;
#line 112
enum fe_sec_mini_cmd {
    SEC_MINI_A = 0,
    SEC_MINI_B = 1
} ;
#line 117
enum fe_status {
    FE_HAS_SIGNAL = 1,
    FE_HAS_CARRIER = 2,
    FE_HAS_VITERBI = 4,
    FE_HAS_SYNC = 8,
    FE_HAS_LOCK = 16,
    FE_TIMEDOUT = 32,
    FE_REINIT = 64
} ;
#line 127
enum fe_spectral_inversion {
    INVERSION_OFF = 0,
    INVERSION_ON = 1,
    INVERSION_AUTO = 2
} ;
#line 133
enum fe_code_rate {
    FEC_NONE = 0,
    FEC_1_2 = 1,
    FEC_2_3 = 2,
    FEC_3_4 = 3,
    FEC_4_5 = 4,
    FEC_5_6 = 5,
    FEC_6_7 = 6,
    FEC_7_8 = 7,
    FEC_8_9 = 8,
    FEC_AUTO = 9,
    FEC_3_5 = 10,
    FEC_9_10 = 11,
    FEC_2_5 = 12
} ;
#line 149
enum fe_modulation {
    QPSK = 0,
    QAM_16 = 1,
    QAM_32 = 2,
    QAM_64 = 3,
    QAM_128 = 4,
    QAM_256 = 5,
    QAM_AUTO = 6,
    VSB_8 = 7,
    VSB_16 = 8,
    PSK_8 = 9,
    APSK_16 = 10,
    APSK_32 = 11,
    DQPSK = 12,
    QAM_4_NR = 13
} ;
#line 166
enum fe_transmit_mode {
    TRANSMISSION_MODE_2K = 0,
    TRANSMISSION_MODE_8K = 1,
    TRANSMISSION_MODE_AUTO = 2,
    TRANSMISSION_MODE_4K = 3,
    TRANSMISSION_MODE_1K = 4,
    TRANSMISSION_MODE_16K = 5,
    TRANSMISSION_MODE_32K = 6,
    TRANSMISSION_MODE_C1 = 7,
    TRANSMISSION_MODE_C3780 = 8
} ;
#line 178
enum fe_guard_interval {
    GUARD_INTERVAL_1_32 = 0,
    GUARD_INTERVAL_1_16 = 1,
    GUARD_INTERVAL_1_8 = 2,
    GUARD_INTERVAL_1_4 = 3,
    GUARD_INTERVAL_AUTO = 4,
    GUARD_INTERVAL_1_128 = 5,
    GUARD_INTERVAL_19_128 = 6,
    GUARD_INTERVAL_19_256 = 7,
    GUARD_INTERVAL_PN420 = 8,
    GUARD_INTERVAL_PN595 = 9,
    GUARD_INTERVAL_PN945 = 10
} ;
#line 192
enum fe_hierarchy {
    HIERARCHY_NONE = 0,
    HIERARCHY_1 = 1,
    HIERARCHY_2 = 2,
    HIERARCHY_4 = 3,
    HIERARCHY_AUTO = 4
} ;
#line 200
enum fe_interleaving {
    INTERLEAVING_NONE = 0,
    INTERLEAVING_AUTO = 1,
    INTERLEAVING_240 = 2,
    INTERLEAVING_720 = 3
} ;
#line 207
enum fe_pilot {
    PILOT_ON = 0,
    PILOT_OFF = 1,
    PILOT_AUTO = 2
} ;
#line 213
enum fe_rolloff {
    ROLLOFF_35 = 0,
    ROLLOFF_20 = 1,
    ROLLOFF_25 = 2,
    ROLLOFF_AUTO = 3
} ;
#line 220
enum fe_delivery_system {
    SYS_UNDEFINED = 0,
    SYS_DVBC_ANNEX_A = 1,
    SYS_DVBC_ANNEX_B = 2,
    SYS_DVBT = 3,
    SYS_DSS = 4,
    SYS_DVBS = 5,
    SYS_DVBS2 = 6,
    SYS_DVBH = 7,
    SYS_ISDBT = 8,
    SYS_ISDBS = 9,
    SYS_ISDBC = 10,
    SYS_ATSC = 11,
    SYS_ATSCMH = 12,
    SYS_DTMB = 13,
    SYS_CMMB = 14,
    SYS_DAB = 15,
    SYS_DVBT2 = 16,
    SYS_TURBO = 17,
    SYS_DVBC_ANNEX_C = 18
} ;
#line 403 "./include/uapi/linux/dvb/frontend.h"
union __anonunion____missing_field_name_305 {
   __u64 uvalue ;
   __s64 svalue ;
};
#line 403 "./include/uapi/linux/dvb/frontend.h"
struct dtv_stats {
   __u8 scale ;
   union __anonunion____missing_field_name_305 __annonCompField103 ;
};
#line 454 "./include/uapi/linux/dvb/frontend.h"
struct dtv_fe_stats {
   __u8 len ;
   struct dtv_stats stat[4U] ;
};
#line 462 "./include/uapi/linux/dvb/frontend.h"
struct __anonstruct_buffer_307 {
   __u8 data[32U] ;
   __u32 len ;
   __u32 reserved1[3U] ;
   void *reserved2 ;
};
#line 462 "./include/uapi/linux/dvb/frontend.h"
union __anonunion_u_306 {
   __u32 data ;
   struct dtv_fe_stats st ;
   struct __anonstruct_buffer_307 buffer ;
};
#line 462 "./include/uapi/linux/dvb/frontend.h"
struct dtv_property {
   __u32 cmd ;
   __u32 reserved[3U] ;
   union __anonunion_u_306 u ;
   int result ;
};
#line 486
struct dvb_frontend;
#line 487
struct dvb_device;
#line 487 "./include/uapi/linux/dvb/frontend.h"
struct dvb_adapter {
   int num ;
   struct list_head list_head ;
   struct list_head device_list ;
   char const   *name ;
   u8 proposed_mac[6U] ;
   void *priv ;
   struct device *device ;
   struct module *module ;
   int mfe_shared ;
   struct dvb_device *mfe_dvbdev ;
   struct mutex mfe_lock ;
};
#line 76 "drivers/media/dvb-core/dvbdev.h"
struct dvb_device {
   struct list_head list_head ;
   struct file_operations  const  *fops ;
   struct dvb_adapter *adapter ;
   int type ;
   int minor ;
   u32 id ;
   int readers ;
   int writers ;
   int users ;
   wait_queue_head_t wait_queue ;
   int (*kernel_ioctl)(struct file * , unsigned int  , void * ) ;
   void *priv ;
};
#line 149 "drivers/media/dvb-core/dvbdev.h"
struct dvb_frontend_tune_settings {
   int min_delay_ms ;
   int step_size ;
   int max_drift ;
};
#line 56 "drivers/media/dvb-core/dvb_frontend.h"
struct dvb_tuner_info {
   char name[128U] ;
   u32 frequency_min ;
   u32 frequency_max ;
   u32 frequency_step ;
   u32 bandwidth_min ;
   u32 bandwidth_max ;
   u32 bandwidth_step ;
};
#line 70 "drivers/media/dvb-core/dvb_frontend.h"
struct analog_parameters {
   unsigned int frequency ;
   unsigned int mode ;
   unsigned int audmode ;
   u64 std ;
};
#line 113
enum tuner_param {
    DVBFE_TUNER_FREQUENCY = 1,
    DVBFE_TUNER_TUNERSTEP = 2,
    DVBFE_TUNER_IFFREQ = 4,
    DVBFE_TUNER_BANDWIDTH = 8,
    DVBFE_TUNER_REFCLOCK = 16,
    DVBFE_TUNER_IQSENSE = 32,
    DVBFE_TUNER_DUMMY = (-0x7FFFFFFF-1)
} ;
#line 123
enum dvbfe_algo {
    DVBFE_ALGO_HW = 1,
    DVBFE_ALGO_SW = 2,
    DVBFE_ALGO_CUSTOM = 4,
    DVBFE_ALGO_RECOVERY = (-0x7FFFFFFF-1)
} ;
#line 130 "drivers/media/dvb-core/dvb_frontend.h"
struct tuner_state {
   u32 frequency ;
   u32 tunerstep ;
   u32 ifreq ;
   u32 bandwidth ;
   u32 iqsense ;
   u32 refclock ;
};
#line 164
enum dvbfe_search {
    DVBFE_ALGO_SEARCH_SUCCESS = 1,
    DVBFE_ALGO_SEARCH_ASLEEP = 2,
    DVBFE_ALGO_SEARCH_FAILED = 4,
    DVBFE_ALGO_SEARCH_INVALID = 8,
    DVBFE_ALGO_SEARCH_AGAIN = 16,
    DVBFE_ALGO_SEARCH_ERROR = (-0x7FFFFFFF-1)
} ;
#line 173 "drivers/media/dvb-core/dvb_frontend.h"
struct dvb_tuner_ops {
   struct dvb_tuner_info info ;
   int (*release)(struct dvb_frontend * ) ;
   int (*init)(struct dvb_frontend * ) ;
   int (*sleep)(struct dvb_frontend * ) ;
   int (*suspend)(struct dvb_frontend * ) ;
   int (*resume)(struct dvb_frontend * ) ;
   int (*set_params)(struct dvb_frontend * ) ;
   int (*set_analog_params)(struct dvb_frontend * , struct analog_parameters * ) ;
   int (*calc_regs)(struct dvb_frontend * , u8 * , int  ) ;
   int (*set_config)(struct dvb_frontend * , void * ) ;
   int (*get_frequency)(struct dvb_frontend * , u32 * ) ;
   int (*get_bandwidth)(struct dvb_frontend * , u32 * ) ;
   int (*get_if_frequency)(struct dvb_frontend * , u32 * ) ;
   int (*get_status)(struct dvb_frontend * , u32 * ) ;
   int (*get_rf_strength)(struct dvb_frontend * , u16 * ) ;
   int (*get_afc)(struct dvb_frontend * , s32 * ) ;
   int (*set_frequency)(struct dvb_frontend * , u32  ) ;
   int (*set_bandwidth)(struct dvb_frontend * , u32  ) ;
   int (*set_state)(struct dvb_frontend * , enum tuner_param  , struct tuner_state * ) ;
   int (*get_state)(struct dvb_frontend * , enum tuner_param  , struct tuner_state * ) ;
};
#line 239 "drivers/media/dvb-core/dvb_frontend.h"
struct analog_demod_info {
   char *name ;
};
#line 243 "drivers/media/dvb-core/dvb_frontend.h"
struct analog_demod_ops {
   struct analog_demod_info info ;
   void (*set_params)(struct dvb_frontend * , struct analog_parameters * ) ;
   int (*has_signal)(struct dvb_frontend * , u16 * ) ;
   int (*get_afc)(struct dvb_frontend * , s32 * ) ;
   void (*tuner_status)(struct dvb_frontend * ) ;
   void (*standby)(struct dvb_frontend * ) ;
   void (*release)(struct dvb_frontend * ) ;
   int (*i2c_gate_ctrl)(struct dvb_frontend * , int  ) ;
   int (*set_config)(struct dvb_frontend * , void * ) ;
};
#line 260
struct dtv_frontend_properties;
#line 261 "drivers/media/dvb-core/dvb_frontend.h"
struct dvb_frontend_ops {
   struct dvb_frontend_info info ;
   u8 delsys[8U] ;
   void (*release)(struct dvb_frontend * ) ;
   void (*release_sec)(struct dvb_frontend * ) ;
   int (*init)(struct dvb_frontend * ) ;
   int (*sleep)(struct dvb_frontend * ) ;
   int (*write)(struct dvb_frontend * , u8 const   * , int  ) ;
   int (*tune)(struct dvb_frontend * , bool  , unsigned int  , unsigned int * , enum fe_status * ) ;
   enum dvbfe_algo (*get_frontend_algo)(struct dvb_frontend * ) ;
   int (*set_frontend)(struct dvb_frontend * ) ;
   int (*get_tune_settings)(struct dvb_frontend * , struct dvb_frontend_tune_settings * ) ;
   int (*get_frontend)(struct dvb_frontend * ) ;
   int (*read_status)(struct dvb_frontend * , enum fe_status * ) ;
   int (*read_ber)(struct dvb_frontend * , u32 * ) ;
   int (*read_signal_strength)(struct dvb_frontend * , u16 * ) ;
   int (*read_snr)(struct dvb_frontend * , u16 * ) ;
   int (*read_ucblocks)(struct dvb_frontend * , u32 * ) ;
   int (*diseqc_reset_overload)(struct dvb_frontend * ) ;
   int (*diseqc_send_master_cmd)(struct dvb_frontend * , struct dvb_diseqc_master_cmd * ) ;
   int (*diseqc_recv_slave_reply)(struct dvb_frontend * , struct dvb_diseqc_slave_reply * ) ;
   int (*diseqc_send_burst)(struct dvb_frontend * , enum fe_sec_mini_cmd  ) ;
   int (*set_tone)(struct dvb_frontend * , enum fe_sec_tone_mode  ) ;
   int (*set_voltage)(struct dvb_frontend * , enum fe_sec_voltage  ) ;
   int (*enable_high_lnb_voltage)(struct dvb_frontend * , long  ) ;
   int (*dishnetwork_send_legacy_command)(struct dvb_frontend * , unsigned long  ) ;
   int (*i2c_gate_ctrl)(struct dvb_frontend * , int  ) ;
   int (*ts_bus_ctrl)(struct dvb_frontend * , int  ) ;
   int (*set_lna)(struct dvb_frontend * ) ;
   enum dvbfe_search (*search)(struct dvb_frontend * ) ;
   struct dvb_tuner_ops tuner_ops ;
   struct analog_demod_ops analog_ops ;
   int (*set_property)(struct dvb_frontend * , struct dtv_property * ) ;
   int (*get_property)(struct dvb_frontend * , struct dtv_property * ) ;
};
#line 323 "drivers/media/dvb-core/dvb_frontend.h"
struct __anonstruct_layer_308 {
   u8 segment_count ;
   enum fe_code_rate fec ;
   enum fe_modulation modulation ;
   u8 interleaving ;
};
#line 323 "drivers/media/dvb-core/dvb_frontend.h"
struct dtv_frontend_properties {
   u32 state ;
   u32 frequency ;
   enum fe_modulation modulation ;
   enum fe_sec_voltage voltage ;
   enum fe_sec_tone_mode sectone ;
   enum fe_spectral_inversion inversion ;
   enum fe_code_rate fec_inner ;
   enum fe_transmit_mode transmission_mode ;
   u32 bandwidth_hz ;
   enum fe_guard_interval guard_interval ;
   enum fe_hierarchy hierarchy ;
   u32 symbol_rate ;
   enum fe_code_rate code_rate_HP ;
   enum fe_code_rate code_rate_LP ;
   enum fe_pilot pilot ;
   enum fe_rolloff rolloff ;
   enum fe_delivery_system delivery_system ;
   enum fe_interleaving interleaving ;
   u8 isdbt_partial_reception ;
   u8 isdbt_sb_mode ;
   u8 isdbt_sb_subchannel ;
   u32 isdbt_sb_segment_idx ;
   u32 isdbt_sb_segment_count ;
   u8 isdbt_layer_enabled ;
   struct __anonstruct_layer_308 layer[3U] ;
   u32 stream_id ;
   u8 atscmh_fic_ver ;
   u8 atscmh_parade_id ;
   u8 atscmh_nog ;
   u8 atscmh_tnog ;
   u8 atscmh_sgn ;
   u8 atscmh_prc ;
   u8 atscmh_rs_frame_mode ;
   u8 atscmh_rs_frame_ensemble ;
   u8 atscmh_rs_code_mode_pri ;
   u8 atscmh_rs_code_mode_sec ;
   u8 atscmh_sccc_block_mode ;
   u8 atscmh_sccc_code_mode_a ;
   u8 atscmh_sccc_code_mode_b ;
   u8 atscmh_sccc_code_mode_c ;
   u8 atscmh_sccc_code_mode_d ;
   u32 lna ;
   struct dtv_fe_stats strength ;
   struct dtv_fe_stats cnr ;
   struct dtv_fe_stats pre_bit_error ;
   struct dtv_fe_stats pre_bit_count ;
   struct dtv_fe_stats post_bit_error ;
   struct dtv_fe_stats post_bit_count ;
   struct dtv_fe_stats block_error ;
   struct dtv_fe_stats block_count ;
};
#line 411 "drivers/media/dvb-core/dvb_frontend.h"
struct dvb_frontend {
   struct dvb_frontend_ops ops ;
   struct dvb_adapter *dvb ;
   void *demodulator_priv ;
   void *tuner_priv ;
   void *frontend_priv ;
   void *sec_priv ;
   void *analog_demod_priv ;
   struct dtv_frontend_properties dtv_property_cache ;
   int (*callback)(void * , int  , int  , int  ) ;
   int id ;
   unsigned int exit ;
};
#line 445
enum dmx_output {
    DMX_OUT_DECODER = 0,
    DMX_OUT_TAP = 1,
    DMX_OUT_TS_TAP = 2,
    DMX_OUT_TSDEMUX_TAP = 3
} ;
#line 46 "./include/uapi/linux/dvb/dmx.h"
typedef enum dmx_output dmx_output_t;
#line 47
enum dmx_input {
    DMX_IN_FRONTEND = 0,
    DMX_IN_DVR = 1
} ;
#line 52 "./include/uapi/linux/dvb/dmx.h"
typedef enum dmx_input dmx_input_t;
#line 53
enum dmx_ts_pes {
    DMX_PES_AUDIO0 = 0,
    DMX_PES_VIDEO0 = 1,
    DMX_PES_TELETEXT0 = 2,
    DMX_PES_SUBTITLE0 = 3,
    DMX_PES_PCR0 = 4,
    DMX_PES_AUDIO1 = 5,
    DMX_PES_VIDEO1 = 6,
    DMX_PES_TELETEXT1 = 7,
    DMX_PES_SUBTITLE1 = 8,
    DMX_PES_PCR1 = 9,
    DMX_PES_AUDIO2 = 10,
    DMX_PES_VIDEO2 = 11,
    DMX_PES_TELETEXT2 = 12,
    DMX_PES_SUBTITLE2 = 13,
    DMX_PES_PCR2 = 14,
    DMX_PES_AUDIO3 = 15,
    DMX_PES_VIDEO3 = 16,
    DMX_PES_TELETEXT3 = 17,
    DMX_PES_SUBTITLE3 = 18,
    DMX_PES_PCR3 = 19,
    DMX_PES_OTHER = 20
} ;
#line 82 "./include/uapi/linux/dvb/dmx.h"
typedef enum dmx_ts_pes dmx_pes_type_t;
#line 83 "./include/uapi/linux/dvb/dmx.h"
struct dmx_filter {
   __u8 filter[16U] ;
   __u8 mask[16U] ;
   __u8 mode[16U] ;
};
#line 96 "./include/uapi/linux/dvb/dmx.h"
typedef struct dmx_filter dmx_filter_t;
#line 97 "./include/uapi/linux/dvb/dmx.h"
struct dmx_sct_filter_params {
   __u16 pid ;
   dmx_filter_t filter ;
   __u32 timeout ;
   __u32 flags ;
};
#line 106 "./include/uapi/linux/dvb/dmx.h"
struct dmx_pes_filter_params {
   __u16 pid ;
   dmx_input_t input ;
   dmx_output_t output ;
   dmx_pes_type_t pes_type ;
   __u32 flags ;
};
#line 120 "./include/uapi/linux/dvb/dmx.h"
struct dmx_caps {
   __u32 caps ;
   int num_decoders ;
};
#line 125
enum dmx_source {
    DMX_SOURCE_FRONT0 = 0,
    DMX_SOURCE_FRONT1 = 1,
    DMX_SOURCE_FRONT2 = 2,
    DMX_SOURCE_FRONT3 = 3,
    DMX_SOURCE_DVR0 = 16,
    DMX_SOURCE_DVR1 = 17,
    DMX_SOURCE_DVR2 = 18,
    DMX_SOURCE_DVR3 = 19
} ;
#line 135 "./include/uapi/linux/dvb/dmx.h"
typedef enum dmx_source dmx_source_t;
#line 142
enum dmx_success {
    DMX_OK = 0,
    DMX_LENGTH_ERROR = 1,
    DMX_OVERRUN_ERROR = 2,
    DMX_CRC_ERROR = 3,
    DMX_FRAME_ERROR = 4,
    DMX_FIFO_ERROR = 5,
    DMX_MISSED_ERROR = 6
} ;
#line 152
struct dmx_demux;
#line 152 "./include/uapi/linux/dvb/dmx.h"
struct dmx_ts_feed {
   int is_filtering ;
   struct dmx_demux *parent ;
   void *priv ;
   int (*set)(struct dmx_ts_feed * , u16  , int  , enum dmx_ts_pes  , size_t  , struct timespec  ) ;
   int (*start_filtering)(struct dmx_ts_feed * ) ;
   int (*stop_filtering)(struct dmx_ts_feed * ) ;
};
#line 99 "drivers/media/dvb-core/demux.h"
struct dmx_section_feed;
#line 99 "drivers/media/dvb-core/demux.h"
struct dmx_section_filter {
   u8 filter_value[18U] ;
   u8 filter_mask[18U] ;
   u8 filter_mode[18U] ;
   struct dmx_section_feed *parent ;
   void *priv ;
};
#line 111 "drivers/media/dvb-core/demux.h"
struct dmx_section_feed {
   int is_filtering ;
   struct dmx_demux *parent ;
   void *priv ;
   int check_crc ;
   u32 crc_val ;
   u8 *secbuf ;
   u8 secbuf_base[4284U] ;
   u16 secbufp ;
   u16 seclen ;
   u16 tsfeedp ;
   int (*set)(struct dmx_section_feed * , u16  , size_t  , int  ) ;
   int (*allocate_filter)(struct dmx_section_feed * , struct dmx_section_filter ** ) ;
   int (*release_filter)(struct dmx_section_feed * , struct dmx_section_filter * ) ;
   int (*start_filtering)(struct dmx_section_feed * ) ;
   int (*stop_filtering)(struct dmx_section_feed * ) ;
};
#line 148
enum dmx_frontend_source {
    DMX_MEMORY_FE = 0,
    DMX_FRONTEND_0 = 1,
    DMX_FRONTEND_1 = 2,
    DMX_FRONTEND_2 = 3,
    DMX_FRONTEND_3 = 4,
    DMX_STREAM_0 = 5,
    DMX_STREAM_1 = 6,
    DMX_STREAM_2 = 7,
    DMX_STREAM_3 = 8
} ;
#line 160 "drivers/media/dvb-core/demux.h"
struct dmx_frontend {
   struct list_head connectivity_list ;
   enum dmx_frontend_source source ;
};
#line 176 "drivers/media/dvb-core/demux.h"
struct dmx_demux {
   u32 capabilities ;
   struct dmx_frontend *frontend ;
   void *priv ;
   int (*open)(struct dmx_demux * ) ;
   int (*close)(struct dmx_demux * ) ;
   int (*write)(struct dmx_demux * , char const   * , size_t  ) ;
   int (*allocate_ts_feed)(struct dmx_demux * , struct dmx_ts_feed ** , int (*)(u8 const   * ,
                                                                                size_t  ,
                                                                                u8 const   * ,
                                                                                size_t  ,
                                                                                struct dmx_ts_feed * ,
                                                                                enum dmx_success  ) ) ;
   int (*release_ts_feed)(struct dmx_demux * , struct dmx_ts_feed * ) ;
   int (*allocate_section_feed)(struct dmx_demux * , struct dmx_section_feed ** ,
                                int (*)(u8 const   * , size_t  , u8 const   * , size_t  ,
                                        struct dmx_section_filter * , enum dmx_success  ) ) ;
   int (*release_section_feed)(struct dmx_demux * , struct dmx_section_feed * ) ;
   int (*add_frontend)(struct dmx_demux * , struct dmx_frontend * ) ;
   int (*remove_frontend)(struct dmx_demux * , struct dmx_frontend * ) ;
   struct list_head *(*get_frontends)(struct dmx_demux * ) ;
   int (*connect_frontend)(struct dmx_demux * , struct dmx_frontend * ) ;
   int (*disconnect_frontend)(struct dmx_demux * ) ;
   int (*get_pes_pids)(struct dmx_demux * , u16 * ) ;
   int (*get_caps)(struct dmx_demux * , struct dmx_caps * ) ;
   int (*set_source)(struct dmx_demux * , dmx_source_t const   * ) ;
   int (*get_stc)(struct dmx_demux * , unsigned int  , u64 * , unsigned int * ) ;
};
#line 239
struct dvb_demux_feed;
#line 239 "drivers/media/dvb-core/demux.h"
struct dvb_demux_filter {
   struct dmx_section_filter filter ;
   u8 maskandmode[18U] ;
   u8 maskandnotmode[18U] ;
   int doneq ;
   struct dvb_demux_filter *next ;
   struct dvb_demux_feed *feed ;
   int index ;
   int state ;
   int type ;
   u16 hw_handle ;
   struct timer_list timer ;
};
#line 64 "drivers/media/dvb-core/dvb_demux.h"
union __anonunion_feed_309 {
   struct dmx_ts_feed ts ;
   struct dmx_section_feed sec ;
};
#line 64 "drivers/media/dvb-core/dvb_demux.h"
union __anonunion_cb_310 {
   int (*ts)(u8 const   * , size_t  , u8 const   * , size_t  , struct dmx_ts_feed * ,
             enum dmx_success  ) ;
   int (*sec)(u8 const   * , size_t  , u8 const   * , size_t  , struct dmx_section_filter * ,
              enum dmx_success  ) ;
};
#line 64
struct dvb_demux;
#line 64 "drivers/media/dvb-core/dvb_demux.h"
struct dvb_demux_feed {
   union __anonunion_feed_309 feed ;
   union __anonunion_cb_310 cb ;
   struct dvb_demux *demux ;
   void *priv ;
   int type ;
   int state ;
   u16 pid ;
   u8 *buffer ;
   int buffer_size ;
   struct timespec timeout ;
   struct dvb_demux_filter *filter ;
   int ts_type ;
   enum dmx_ts_pes pes_type ;
   int cc ;
   int pusi_seen ;
   u16 peslen ;
   struct list_head list_head ;
   unsigned int index ;
};
#line 100 "drivers/media/dvb-core/dvb_demux.h"
struct dvb_demux {
   struct dmx_demux dmx ;
   void *priv ;
   int filternum ;
   int feednum ;
   int (*start_feed)(struct dvb_demux_feed * ) ;
   int (*stop_feed)(struct dvb_demux_feed * ) ;
   int (*write_to_decoder)(struct dvb_demux_feed * , u8 const   * , size_t  ) ;
   u32 (*check_crc32)(struct dvb_demux_feed * , u8 const   * , size_t  ) ;
   void (*memcopy)(struct dvb_demux_feed * , u8 * , u8 const   * , size_t  ) ;
   int users ;
   struct dvb_demux_filter *filter ;
   struct dvb_demux_feed *feed ;
   struct list_head frontend_list ;
   struct dvb_demux_feed *pesfilter[20U] ;
   u16 pids[20U] ;
   int playing ;
   int recording ;
   struct list_head feed_list ;
   u8 tsbuf[204U] ;
   int tsbufp ;
   struct mutex mutex ;
   spinlock_t lock ;
   uint8_t *cnt_storage ;
   struct timespec speed_last_time ;
   uint32_t speed_pkts_cnt ;
};
#line 56 "include/linux/prefetch.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 21 "include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion____missing_field_name_311 {
   struct iovec  const  *iov ;
   struct kvec  const  *kvec ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion____missing_field_name_311 __annonCompField104 ;
   unsigned long nr_segs ;
};
#line 1182 "include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_313 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_313 sync_serial_settings;
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_314 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_314 te1_settings;
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_315 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_315 raw_hdlc_proto;
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_316 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_316 fr_proto;
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_317 {
   unsigned int dlci ;
};
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_317 fr_proto_pvc;
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_318 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_318 fr_proto_pvc_info;
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_319 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_319 cisco_proto;
#line 117 "./include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 177 "./include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_320 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 177 "./include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_320 ifs_ifsu ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_321 {
   char ifrn_name[16U] ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifru_322 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 195 "./include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_321 ifr_ifrn ;
   union __anonunion_ifr_ifru_322 ifr_ifru ;
};
#line 18 "./arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 39 "./arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "./arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 45 "./arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 276 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 280 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 161 "./arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 140 "include/net/checksum.h"
struct sk_buff;
#line 187 "include/net/checksum.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 15 "include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 66 "include/linux/netdev_features.h"
union __anonunion_in6_u_338 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 66 "include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_338 in6_u ;
};
#line 46 "include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 218 "include/net/flow_dissector.h"
struct pipe_buf_operations;
#line 218 "include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations  const  *ops ;
   unsigned int flags ;
   unsigned long private ;
};
#line 27 "include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};
#line 61 "include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*release)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   int (*steal)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*get)(struct pipe_inode_info * , struct pipe_buffer * ) ;
};
#line 86 "include/linux/splice.h"
struct napi_struct;
#line 87 "include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_343 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_344 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};
#line 172 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned char orig_proto ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion____missing_field_name_343 __annonCompField108 ;
   union __anonunion____missing_field_name_344 __annonCompField109 ;
};
#line 189 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 403 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 404 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_347 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
#line 404 "include/linux/skbuff.h"
union __anonunion____missing_field_name_346 {
   u64 v64 ;
   struct __anonstruct____missing_field_name_347 __annonCompField110 ;
};
#line 404 "include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion____missing_field_name_346 __annonCompField111 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_350 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_349 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion____missing_field_name_350 __annonCompField112 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_348 {
   struct __anonstruct____missing_field_name_349 __annonCompField113 ;
   struct rb_node rbnode ;
};
#line 457
struct sec_path;
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_352 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_351 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_352 __annonCompField115 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_353 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_354 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_355 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};
#line 457 "include/linux/skbuff.h"
struct sk_buff {
   union __anonunion____missing_field_name_348 __annonCompField114 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff * ) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   unsigned char cloned : 1 ;
   unsigned char nohdr : 1 ;
   unsigned char fclone : 2 ;
   unsigned char peeked : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   unsigned char pkt_type : 3 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ignore_df : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char nf_trace : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char sw_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   unsigned char csum_level : 2 ;
   unsigned char csum_bad : 1 ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char inner_protocol_type : 1 ;
   unsigned char remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion____missing_field_name_351 __annonCompField116 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion____missing_field_name_353 __annonCompField117 ;
   __u32 secmark ;
   union __anonunion____missing_field_name_354 __annonCompField118 ;
   union __anonunion____missing_field_name_355 __annonCompField119 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 718
struct dst_entry;
#line 34 "include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 125 "include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 189 "include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 233 "include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};
#line 245 "include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 267 "include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 293 "include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 322 "include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 339 "include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 438 "include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 475 "include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 503 "include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 605 "include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 637 "include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 679 "include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 712 "include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 728 "include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 748 "include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 759 "include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 778 "include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 828 "include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 999 "include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 1007 "include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1083 "include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 99 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * , u8 const    ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*get_tunable)(struct net_device * , struct ethtool_tunable  const  * , void * ) ;
   int (*set_tunable)(struct net_device * , struct ethtool_tunable  const  * , void const   * ) ;
};
#line 235 "include/net/flow.h"
struct prot_inuse;
#line 236 "include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "include/net/snmp.h"
struct u64_stats_sync {

};
#line 146 "include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 83 "include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 93 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};
#line 106 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};
#line 112 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118 "include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
#line 26 "include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 179 "include/net/inet_frag.h"
struct ipv4_devconf;
#line 180
struct fib_rules_ops;
#line 181
struct fib_table;
#line 182 "include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};
#line 24 "include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 29
struct inet_peer_base;
#line 29
struct xt_table;
#line 29 "include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 113
struct neighbour;
#line 113 "include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 72 "include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};
#line 39 "include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 39
struct rt6_info;
#line 39
struct rt6_statistics;
#line 39
struct fib6_table;
#line 39 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};
#line 85 "include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 91 "include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 14 "include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};
#line 20
struct sctp_mib;
#line 21 "include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 134 "include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 79 "include/uapi/linux/netfilter.h"
struct nf_logger;
#line 80 "include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 23 "include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 25 "include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 30 "include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 44 "include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 49 "include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 54 "include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 65 "include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
#line 73
struct ip_conntrack_stat;
#line 73
struct nf_ct_event_notifier;
#line 73
struct nf_exp_event_notifier;
#line 73 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 115
struct nft_af_info;
#line 116 "include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};
#line 508 "./include/uapi/linux/xfrm.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
#line 16 "include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
#line 25 "include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};
#line 21 "include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};
#line 30 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
#line 88
struct mpls_route;
#line 89 "include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};
#line 16 "include/net/netns/mpls.h"
struct proc_ns_operations;
#line 17 "include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations  const  *ops ;
   unsigned int inum ;
};
#line 11 "include/linux/ns_common.h"
struct net_generic;
#line 12
struct netns_ipvs;
#line 13 "include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 241 "include/net/net_namespace.h"
struct __anonstruct_possible_net_t_364 {
   struct net *net ;
};
#line 241 "include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_364 possible_net_t;
#line 338 "include/linux/mii.h"
enum ldv_30819 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
} ;
#line 80 "include/linux/phy.h"
typedef enum ldv_30819 phy_interface_t;
#line 126
enum ldv_30873 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
} ;
#line 133
struct phy_device;
#line 133 "include/linux/phy.h"
struct mii_bus {
   char const   *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus * , int  , int  ) ;
   int (*write)(struct mii_bus * , int  , int  , u16  ) ;
   int (*reset)(struct mii_bus * ) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_30873 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};
#line 214
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
} ;
#line 229 "include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};
#line 323
struct phy_driver;
#line 323 "include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device * ) ;
};
#line 429 "include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const   *driver_data ;
   int (*soft_reset)(struct phy_device * ) ;
   int (*config_init)(struct phy_device * ) ;
   int (*probe)(struct phy_device * ) ;
   int (*suspend)(struct phy_device * ) ;
   int (*resume)(struct phy_device * ) ;
   int (*config_aneg)(struct phy_device * ) ;
   int (*aneg_done)(struct phy_device * ) ;
   int (*read_status)(struct phy_device * ) ;
   int (*ack_interrupt)(struct phy_device * ) ;
   int (*config_intr)(struct phy_device * ) ;
   int (*did_interrupt)(struct phy_device * ) ;
   void (*remove)(struct phy_device * ) ;
   int (*match_phy_device)(struct phy_device * ) ;
   int (*ts_info)(struct phy_device * , struct ethtool_ts_info * ) ;
   int (*hwtstamp)(struct phy_device * , struct ifreq * ) ;
   bool (*rxtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   void (*txtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   int (*set_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*get_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*link_change_notify)(struct phy_device * ) ;
   int (*read_mmd_indirect)(struct phy_device * , int  , int  , int  ) ;
   void (*write_mmd_indirect)(struct phy_device * , int  , int  , int  , u32  ) ;
   int (*module_info)(struct phy_device * , struct ethtool_modinfo * ) ;
   int (*module_eeprom)(struct phy_device * , struct ethtool_eeprom * , u8 * ) ;
   struct device_driver driver ;
};
#line 803 "include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};
#line 25 "include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
} ;
#line 33 "include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};
#line 68 "include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 84
struct packet_type;
#line 85
struct dsa_switch;
#line 85 "include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 123
struct dsa_switch_driver;
#line 123 "include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 194 "include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   u32 (*get_phy_flags)(struct dsa_switch * , int  ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*adjust_link)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*fixed_link_update)(struct dsa_switch * , int  , struct fixed_phy_status * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
   void (*get_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*suspend)(struct dsa_switch * ) ;
   int (*resume)(struct dsa_switch * ) ;
   int (*port_enable)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*port_disable)(struct dsa_switch * , int  , struct phy_device * ) ;
   int (*set_eee)(struct dsa_switch * , int  , struct phy_device * , struct ethtool_eee * ) ;
   int (*get_eee)(struct dsa_switch * , int  , struct ethtool_eee * ) ;
   int (*get_temp)(struct dsa_switch * , int * ) ;
   int (*get_temp_limit)(struct dsa_switch * , int * ) ;
   int (*set_temp_limit)(struct dsa_switch * , int  ) ;
   int (*get_temp_alarm)(struct dsa_switch * , bool * ) ;
   int (*get_eeprom_len)(struct dsa_switch * ) ;
   int (*get_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_regs_len)(struct dsa_switch * , int  ) ;
   void (*get_regs)(struct dsa_switch * , int  , struct ethtool_regs * , void * ) ;
   int (*port_join_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_leave_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_stp_update)(struct dsa_switch * , int  , u8  ) ;
   int (*fdb_add)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_del)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_getnext)(struct dsa_switch * , int  , unsigned char * , bool * ) ;
};
#line 320 "include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "./include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 87 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};
#line 132 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};
#line 144 "./include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 164 "./include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 187 "./include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 202 "./include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 236 "./include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_setqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_getqcnstats)(struct net_device * , struct ieee_qcn_stats * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   int (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   int (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 105 "include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 515 "include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 1628 "include/linux/security.h"
struct mnt_namespace;
#line 1629
struct ipc_namespace;
#line 1630 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 147 "include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 106 "include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 182 "include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 643 "include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};
#line 16 "include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};
#line 118 "include/uapi/linux/if_bonding.h"
struct netpoll_info;
#line 119
struct wireless_dev;
#line 120
struct wpan_dev;
#line 121
struct mpls_dev;
#line 65 "include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 110 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 129 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 190
struct neigh_parms;
#line 211 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 216 "include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 245 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 295 "include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 340
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 388 "include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 389 "include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 537
struct Qdisc;
#line 537 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};
#line 607 "include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 619 "include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 631 "include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 683 "include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 706 "include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 719 "include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 730 "include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 741 "include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 757 "include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 770 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_get_vf_stats)(struct net_device * , int  , struct ifla_vf_stats * ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device * , int  , bool  ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  , u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       struct net_device * , int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  , int  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_item_id * ) ;
   int (*ndo_get_phys_port_name)(struct net_device * , char * , size_t  ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff * , struct net_device * ,
                                           netdev_features_t  ) ;
   int (*ndo_set_tx_maxrate)(struct net_device * , int  , u32  ) ;
   int (*ndo_get_iflink)(struct net_device  const  * ) ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_adj_list_373 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_all_adj_list_374 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257
struct iw_handler_def;
#line 1257
struct iw_public_data;
#line 1257
struct switchdev_ops;
#line 1257
struct vlan_info;
#line 1257
struct tipc_bearer;
#line 1257
struct in_device;
#line 1257
struct dn_dev;
#line 1257
struct inet6_dev;
#line 1257
struct tcf_proto;
#line 1257
struct cpu_rmap;
#line 1257
struct pcpu_lstats;
#line 1257
struct pcpu_sw_netstats;
#line 1257
struct pcpu_dstats;
#line 1257
struct pcpu_vstats;
#line 1257 "include/linux/netdevice.h"
union __anonunion____missing_field_name_375 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1257
struct garp_port;
#line 1257
struct mrp_port;
#line 1257
struct rtnl_link_ops;
#line 1257 "include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_373 adj_list ;
   struct __anonstruct_all_adj_list_374 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct switchdev_ops  const  *switchdev_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion____missing_field_name_375 __annonCompField122 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};
#line 1978 "include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   bool (*id_match)(struct packet_type * , struct sock * ) ;
   void *af_packet_priv ;
   struct list_head list ;
};
#line 2025 "include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 116 "include/linux/rtnetlink.h"
struct ipv4_devconf {
   void *sysctl ;
   int data[29U] ;
   unsigned long state[1U] ;
};
#line 20 "include/linux/inetdevice.h"
struct in_ifaddr;
#line 20
struct ip_mc_list;
#line 20 "include/linux/inetdevice.h"
struct in_device {
   struct net_device *dev ;
   atomic_t refcnt ;
   int dead ;
   struct in_ifaddr *ifa_list ;
   struct ip_mc_list *mc_list ;
   struct ip_mc_list **mc_hash ;
   int mc_count ;
   spinlock_t mc_tomb_lock ;
   struct ip_mc_list *mc_tomb ;
   unsigned long mr_v1_seen ;
   unsigned long mr_v2_seen ;
   unsigned long mr_maxdelay ;
   unsigned char mr_qrv ;
   unsigned char mr_gq_running ;
   unsigned char mr_ifc_count ;
   struct timer_list mr_gq_timer ;
   struct timer_list mr_ifc_timer ;
   struct neigh_parms *arp_parms ;
   struct ipv4_devconf cnf ;
   struct callback_head callback_head ;
};
#line 71 "include/linux/inetdevice.h"
struct in_ifaddr {
   struct hlist_node hash ;
   struct in_ifaddr *ifa_next ;
   struct in_device *ifa_dev ;
   struct callback_head callback_head ;
   __be32 ifa_local ;
   __be32 ifa_address ;
   __be32 ifa_mask ;
   __be32 ifa_broadcast ;
   unsigned char ifa_scope ;
   unsigned char ifa_prefixlen ;
   __u32 ifa_flags ;
   char ifa_label[16U] ;
   __u32 ifa_valid_lft ;
   __u32 ifa_preferred_lft ;
   unsigned long ifa_cstamp ;
   unsigned long ifa_tstamp ;
};
#line 449 "include/linux/etherdevice.h"
struct dvb_net {
   struct dvb_device *dvbdev ;
   struct net_device *device[10U] ;
   int state[10U] ;
   unsigned char exit : 1 ;
   struct dmx_demux *demux ;
   struct mutex ioctl_mutex ;
};
#line 48 "drivers/media/dvb-core/dvb_net.h"
struct dvb_ringbuffer {
   u8 *data ;
   ssize_t size ;
   ssize_t pread ;
   ssize_t pwrite ;
   int error ;
   wait_queue_head_t queue ;
   spinlock_t lock ;
};
#line 186 "drivers/media/dvb-core/dvb_ringbuffer.h"
enum dmxdev_type {
    DMXDEV_TYPE_NONE = 0,
    DMXDEV_TYPE_SEC = 1,
    DMXDEV_TYPE_PES = 2
} ;
#line 192
enum dmxdev_state {
    DMXDEV_STATE_FREE = 0,
    DMXDEV_STATE_ALLOCATED = 1,
    DMXDEV_STATE_SET = 2,
    DMXDEV_STATE_GO = 3,
    DMXDEV_STATE_DONE = 4,
    DMXDEV_STATE_TIMEDOUT = 5
} ;
#line 63 "drivers/media/dvb-core/dmxdev.h"
union __anonunion_filter_389 {
   struct dmx_section_filter *sec ;
};
#line 63 "drivers/media/dvb-core/dmxdev.h"
union __anonunion_feed_390 {
   struct list_head ts ;
   struct dmx_section_feed *sec ;
};
#line 63 "drivers/media/dvb-core/dmxdev.h"
union __anonunion_params_391 {
   struct dmx_sct_filter_params sec ;
   struct dmx_pes_filter_params pes ;
};
#line 63
struct dmxdev;
#line 63 "drivers/media/dvb-core/dmxdev.h"
struct dmxdev_filter {
   union __anonunion_filter_389 filter ;
   union __anonunion_feed_390 feed ;
   union __anonunion_params_391 params ;
   enum dmxdev_type type ;
   enum dmxdev_state state ;
   struct dmxdev *dev ;
   struct dvb_ringbuffer buffer ;
   struct mutex mutex ;
   struct timer_list timer ;
   int todo ;
   u8 secheader[3U] ;
};
#line 92 "drivers/media/dvb-core/dmxdev.h"
struct dmxdev {
   struct dvb_device *dvbdev ;
   struct dvb_device *dvr_dvbdev ;
   struct dmxdev_filter *filter ;
   struct dmx_demux *demux ;
   int filternum ;
   int capabilities ;
   unsigned char exit : 1 ;
   struct dmx_frontend *dvr_orig_fe ;
   struct dvb_ringbuffer dvr_buffer ;
   struct mutex mutex ;
   spinlock_t lock ;
};
#line 118
struct pvr2_context;
#line 119
struct pvr2_channel;
#line 120
struct pvr2_context_stream;
#line 122 "drivers/media/dvb-core/dmxdev.h"
struct pvr2_context_stream {
   struct pvr2_channel *user ;
   struct pvr2_stream *stream ;
};
#line 38 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-context.h"
struct pvr2_context {
   struct pvr2_channel *mc_first ;
   struct pvr2_channel *mc_last ;
   struct pvr2_context *exist_next ;
   struct pvr2_context *exist_prev ;
   struct pvr2_context *notify_next ;
   struct pvr2_context *notify_prev ;
   struct pvr2_hdw *hdw ;
   struct pvr2_context_stream video_stream ;
   struct mutex mutex ;
   int notify_flag ;
   int initialized_flag ;
   int disconnect_flag ;
   void (*setup_func)(struct pvr2_context * ) ;
};
#line 56 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-context.h"
struct pvr2_channel {
   struct pvr2_context *mc_head ;
   struct pvr2_channel *mc_next ;
   struct pvr2_channel *mc_prev ;
   struct pvr2_context_stream *stream ;
   struct pvr2_hdw *hdw ;
   unsigned int input_mask ;
   void (*check_func)(struct pvr2_channel * ) ;
};
#line 84 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-context.h"
struct pvr2_dvb_adapter {
   struct pvr2_channel channel ;
   struct dvb_adapter dvb_adap ;
   struct dmxdev dmxdev ;
   struct dvb_demux demux ;
   struct dvb_net dvb_net ;
   struct dvb_frontend *fe ;
   int feedcount ;
   int max_feed_count ;
   struct task_struct *thread ;
   struct mutex lock ;
   unsigned char stream_run : 1 ;
   wait_queue_head_t buffer_wait_data ;
   char *buffer_storage[32U] ;
};
#line 33 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-dvb.h"
struct pvr2_dvb_props {
   int (*frontend_attach)(struct pvr2_dvb_adapter * ) ;
   int (*tuner_attach)(struct pvr2_dvb_adapter * ) ;
};
#line 40 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-dvb.h"
struct pvr2_device_client_desc {
   unsigned char module_id ;
   unsigned char *i2c_address_list ;
};
#line 57 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-devattr.h"
struct pvr2_device_client_table {
   struct pvr2_device_client_desc  const  *lst ;
   unsigned char cnt ;
};
#line 62 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-devattr.h"
struct pvr2_string_table {
   char const   **lst ;
   unsigned int cnt ;
};
#line 68 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-devattr.h"
struct pvr2_device_desc {
   char const   *description ;
   char const   *shortname ;
   struct pvr2_string_table client_modules ;
   struct pvr2_device_client_table client_table ;
   struct pvr2_string_table fx2_firmware ;
   struct pvr2_dvb_props  const  *dvb_props ;
   v4l2_std_id default_std_mask ;
   int default_tuner_type ;
   unsigned char signal_routing_scheme ;
   unsigned char led_scheme ;
   unsigned char digital_control_scheme ;
   unsigned char flag_skip_cx23416_firmware : 1 ;
   unsigned char flag_digital_requires_cx23416 : 1 ;
   unsigned char flag_has_hauppauge_rom : 1 ;
   unsigned char flag_no_powerup : 1 ;
   unsigned char flag_has_cx25840 : 1 ;
   unsigned char flag_has_wm8775 : 1 ;
   unsigned char ir_scheme : 3 ;
   unsigned char flag_has_fmradio : 1 ;
   unsigned char flag_has_analogtuner : 1 ;
   unsigned char flag_has_composite : 1 ;
   unsigned char flag_has_svideo : 1 ;
   unsigned char flag_fx2_16kb : 1 ;
   unsigned char flag_is_experimental : 1 ;
};
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
struct __anonstruct_type_int_393 {
   long min_value ;
   long max_value ;
};
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
struct __anonstruct_type_enum_394 {
   unsigned int count ;
   char const   * const  *value_names ;
};
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
struct __anonstruct_type_bitmask_395 {
   unsigned int valid_bits ;
   char const   **bit_names ;
};
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
union __anonunion_def_392 {
   struct __anonstruct_type_int_393 type_int ;
   struct __anonstruct_type_enum_394 type_enum ;
   struct __anonstruct_type_bitmask_395 type_bitmask ;
};
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
struct pvr2_ctl_info {
   char const   *name ;
   char const   *desc ;
   int (*get_value)(struct pvr2_ctrl * , int * ) ;
   int (*get_def_value)(struct pvr2_ctrl * , int * ) ;
   int (*get_min_value)(struct pvr2_ctrl * , int * ) ;
   int (*get_max_value)(struct pvr2_ctrl * , int * ) ;
   int (*set_value)(struct pvr2_ctrl * , int  , int  ) ;
   int (*check_value)(struct pvr2_ctrl * , int  ) ;
   int (*val_to_sym)(struct pvr2_ctrl * , int  , int  , char * , unsigned int  , unsigned int * ) ;
   int (*sym_to_val)(struct pvr2_ctrl * , char const   * , unsigned int  , int * ,
                     int * ) ;
   int (*is_dirty)(struct pvr2_ctrl * ) ;
   void (*clear_dirty)(struct pvr2_ctrl * ) ;
   unsigned int (*get_v4lflags)(struct pvr2_ctrl * ) ;
   enum pvr2_ctl_type type ;
   int v4l_id ;
   int internal_id ;
   int skip_init ;
   int default_value ;
   union __anonunion_def_392 def ;
};
#line 127 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
struct pvr2_ctld_info {
   struct pvr2_ctl_info info ;
   char desc[32U] ;
};
#line 135 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
struct pvr2_ctrl {
   struct pvr2_ctl_info  const  *info ;
   struct pvr2_hdw *hdw ;
};
#line 155 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
typedef int (*pvr2_i2c_func)(struct pvr2_hdw * , u8  , u8 * , u16  , u8 * , u16  );
#line 156 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
struct pvr2_hdw {
   struct usb_device *usb_dev ;
   struct usb_interface *usb_intf ;
   struct v4l2_device v4l2_dev ;
   struct pvr2_device_desc  const  *hdw_desc ;
   struct workqueue_struct *workqueue ;
   struct work_struct workpoll ;
   struct pvr2_stream *vid_stream ;
   struct mutex big_lock_mutex ;
   int big_lock_held ;
   char name[32U] ;
   char identifier[32U] ;
   struct i2c_adapter i2c_adap ;
   struct i2c_algorithm i2c_algo ;
   pvr2_i2c_func i2c_func[128U] ;
   int i2c_cx25840_hack_state ;
   int i2c_linked ;
   unsigned int ir_scheme_active ;
   struct IR_i2c_init_data ir_init_data ;
   unsigned int freqTable[500U] ;
   unsigned int freqProgSlot ;
   struct mutex ctl_lock_mutex ;
   int ctl_lock_held ;
   struct urb *ctl_write_urb ;
   struct urb *ctl_read_urb ;
   unsigned char *ctl_write_buffer ;
   unsigned char *ctl_read_buffer ;
   int ctl_write_pend_flag ;
   int ctl_read_pend_flag ;
   int ctl_timeout_flag ;
   struct completion ctl_done ;
   unsigned char cmd_buffer[64U] ;
   int cmd_debug_state ;
   unsigned char cmd_debug_code ;
   unsigned int cmd_debug_write_len ;
   unsigned int cmd_debug_read_len ;
   int state_pathway_ok ;
   int state_encoder_ok ;
   int state_encoder_run ;
   int state_encoder_config ;
   int state_encoder_waitok ;
   int state_encoder_runok ;
   int state_decoder_run ;
   int state_decoder_ready ;
   int state_usbstream_run ;
   int state_decoder_quiescent ;
   int state_pipeline_config ;
   int state_pipeline_req ;
   int state_pipeline_pause ;
   int state_pipeline_idle ;
   unsigned int master_state ;
   int led_on ;
   int state_stale ;
   void (*state_func)(void * ) ;
   void *state_data ;
   struct timer_list quiescent_timer ;
   struct timer_list decoder_stabilization_timer ;
   struct timer_list encoder_wait_timer ;
   struct timer_list encoder_run_timer ;
   wait_queue_head_t state_wait_data ;
   int force_dirty ;
   int flag_ok ;
   int flag_modulefail ;
   int flag_disconnected ;
   int flag_init_ok ;
   int fw1_state ;
   int pathway_state ;
   int flag_decoder_missed ;
   int flag_tripped ;
   unsigned int decoder_client_id ;
   char *fw_buffer ;
   unsigned int fw_size ;
   int fw_cpu_flag ;
   unsigned int tuner_type ;
   int tuner_updated ;
   unsigned int freqValTelevision ;
   unsigned int freqValRadio ;
   unsigned int freqSlotTelevision ;
   unsigned int freqSlotRadio ;
   unsigned int freqSelector ;
   int freqDirty ;
   struct v4l2_tuner tuner_signal_info ;
   int tuner_signal_stale ;
   struct v4l2_cropcap cropcap_info ;
   int cropcap_stale ;
   v4l2_std_id std_mask_eeprom ;
   v4l2_std_id std_mask_avail ;
   v4l2_std_id std_mask_cur ;
   int std_enum_cur ;
   int std_dirty ;
   struct pvr2_ctl_info std_info_enum ;
   struct pvr2_ctl_info std_info_avail ;
   struct pvr2_ctl_info std_info_cur ;
   struct pvr2_ctl_info std_info_detect ;
   char const   *std_mask_ptrs[32U] ;
   char std_mask_names[32U][16U] ;
   int unit_number ;
   unsigned long serial_number ;
   char bus_info[32U] ;
   int v4l_minor_number_video ;
   int v4l_minor_number_vbi ;
   int v4l_minor_number_radio ;
   unsigned int input_avail_mask ;
   unsigned int input_allowed_mask ;
   int eeprom_addr ;
   enum pvr2_config active_stream_type ;
   enum pvr2_config desired_stream_type ;
   struct cx2341x_mpeg_params enc_cur_state ;
   struct cx2341x_mpeg_params enc_ctl_state ;
   int enc_stale ;
   int enc_unsafe_stale ;
   int enc_cur_valid ;
   int brightness_val ;
   int brightness_dirty ;
   int contrast_val ;
   int contrast_dirty ;
   int saturation_val ;
   int saturation_dirty ;
   int hue_val ;
   int hue_dirty ;
   int volume_val ;
   int volume_dirty ;
   int balance_val ;
   int balance_dirty ;
   int bass_val ;
   int bass_dirty ;
   int treble_val ;
   int treble_dirty ;
   int mute_val ;
   int mute_dirty ;
   int cropl_val ;
   int cropl_dirty ;
   int cropt_val ;
   int cropt_dirty ;
   int cropw_val ;
   int cropw_dirty ;
   int croph_val ;
   int croph_dirty ;
   int input_val ;
   int input_dirty ;
   int audiomode_val ;
   int audiomode_dirty ;
   int res_hor_val ;
   int res_hor_dirty ;
   int res_ver_val ;
   int res_ver_dirty ;
   int srate_val ;
   int srate_dirty ;
   struct pvr2_ctld_info *mpeg_ctrl_info ;
   struct pvr2_ctrl *controls ;
   unsigned int control_cnt ;
};
#line 387 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
typedef bool ldv_func_ret_type;
#line 398 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
typedef bool ldv_func_ret_type___0;
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
typedef bool ldv_func_ret_type___1;
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
typedef bool ldv_func_ret_type___2;
#line 463 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
typedef int ldv_func_ret_type___3;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 23 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-debug.h"
struct routing_scheme {
   int const   *def ;
   unsigned int cnt ;
};
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c"
struct va_list;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c"

#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 243 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 487 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
typedef int ldv_func_ret_type___4;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 30 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-debug.h"
struct tveeprom {
   u32 has_radio ;
   u32 has_ir ;
   u32 has_MAC_address ;
   u32 tuner_type ;
   u32 tuner_formats ;
   u32 tuner_hauppauge_model ;
   u32 tuner2_type ;
   u32 tuner2_formats ;
   u32 tuner2_hauppauge_model ;
   u32 digitizer ;
   u32 digitizer_formats ;
   u32 audio_processor ;
   u32 decoder_processor ;
   u32 model ;
   u32 revision ;
   u32 serial_number ;
   char rev_str[5U] ;
   u8 MAC_address[6U] ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 225 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct v4l2_format;
#line 231
struct v4l2_audio;
#line 39 "include/linux/mod_devicetable.h"
struct usb_device_id {
   __u16 match_flags ;
   __u16 idVendor ;
   __u16 idProduct ;
   __u16 bcdDevice_lo ;
   __u16 bcdDevice_hi ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 bInterfaceNumber ;
   kernel_ulong_t driver_info ;
};
#line 282 "include/linux/pm_runtime.h"
struct usb_driver;
#line 819 "include/linux/usb.h"
struct usb_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 1007 "include/linux/usb.h"
struct usbdrv_wrap {
   struct device_driver driver ;
   int for_devices ;
};
#line 1017 "include/linux/usb.h"
struct usb_driver {
   char const   *name ;
   int (*probe)(struct usb_interface * , struct usb_device_id  const  * ) ;
   void (*disconnect)(struct usb_interface * ) ;
   int (*unlocked_ioctl)(struct usb_interface * , unsigned int  , void * ) ;
   int (*suspend)(struct usb_interface * , pm_message_t  ) ;
   int (*resume)(struct usb_interface * ) ;
   int (*reset_resume)(struct usb_interface * ) ;
   int (*pre_reset)(struct usb_interface * ) ;
   int (*post_reset)(struct usb_interface * ) ;
   struct usb_device_id  const  *id_table ;
   struct usb_dynids dynids ;
   struct usbdrv_wrap drvwrap ;
   unsigned char no_dynamic_id : 1 ;
   unsigned char supports_autosuspend : 1 ;
   unsigned char disable_hub_initiated_lpm : 1 ;
   unsigned char soft_unbind : 1 ;
};
#line 396 "include/uapi/linux/videodev2.h"
struct v4l2_pix_format {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 bytesperline ;
   __u32 sizeimage ;
   __u32 colorspace ;
   __u32 priv ;
   __u32 flags ;
   __u32 ycbcr_enc ;
   __u32 quantization ;
   __u32 xfer_func ;
};
#line 940 "include/uapi/linux/videodev2.h"
struct v4l2_clip {
   struct v4l2_rect c ;
   struct v4l2_clip *next ;
};
#line 962 "include/uapi/linux/videodev2.h"
struct v4l2_window {
   struct v4l2_rect w ;
   __u32 field ;
   __u32 chromakey ;
   struct v4l2_clip *clips ;
   __u32 clipcount ;
   void *bitmap ;
   __u8 global_alpha ;
};
#line 1658 "include/uapi/linux/videodev2.h"
struct v4l2_audio {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 1917 "include/uapi/linux/videodev2.h"
struct v4l2_plane_pix_format {
   __u32 sizeimage ;
   __u32 bytesperline ;
   __u16 reserved[6U] ;
};
#line 1934 "include/uapi/linux/videodev2.h"
struct v4l2_pix_format_mplane {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 colorspace ;
   struct v4l2_plane_pix_format plane_fmt[8U] ;
   __u8 num_planes ;
   __u8 flags ;
   __u8 ycbcr_enc ;
   __u8 quantization ;
   __u8 xfer_func ;
   __u8 reserved[7U] ;
};
#line 1964 "include/uapi/linux/videodev2.h"
struct v4l2_sdr_format {
   __u32 pixelformat ;
   __u32 buffersize ;
   __u8 reserved[24U] ;
};
#line 1975 "include/uapi/linux/videodev2.h"
union __anonunion_fmt_268 {
   struct v4l2_pix_format pix ;
   struct v4l2_pix_format_mplane pix_mp ;
   struct v4l2_window win ;
   struct v4l2_vbi_format vbi ;
   struct v4l2_sliced_vbi_format sliced ;
   struct v4l2_sdr_format sdr ;
   __u8 raw_data[200U] ;
};
#line 1975 "include/uapi/linux/videodev2.h"
struct v4l2_format {
   __u32 type ;
   union __anonunion_fmt_268 fmt ;
};
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 23 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-debug.h"
struct pvr2_v4l2;
#line 28 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-v4l2.h"
struct pvr2_sysfs;
#line 29
struct pvr2_sysfs_class;
#line 303 "include/linux/timer.h"
enum hrtimer_restart;
#line 12 "include/linux/wait.h"
struct __wait_queue;
#line 12 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 712 "include/linux/module.h"
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
#line 196 "include/media/v4l2-common.h"
struct tuner_setup {
   unsigned short addr ;
   unsigned int type ;
   unsigned int mode_mask ;
   void *config ;
   int (*tuner_callback)(void * , int  , int  , int  ) ;
};
#line 36 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-io.h"
struct pvr2_stream_stats {
   unsigned int buffers_in_queue ;
   unsigned int buffers_in_idle ;
   unsigned int buffers_in_ready ;
   unsigned int buffers_processed ;
   unsigned int buffers_failed ;
   unsigned int bytes_processed ;
};
#line 116 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-ctrl.h"
enum pvr2_v4l_type {
    pvr2_v4l_type_video = 0,
    pvr2_v4l_type_vbi = 1,
    pvr2_v4l_type_radio = 2
} ;
#line 40 "include/linux/i2c.h"
enum i2c_slave_event;
#line 40
enum i2c_slave_event;
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
typedef void (*pvr2_subdev_update_func)(struct pvr2_hdw * , struct v4l2_subdev * );
#line 151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
struct pvr2_mpeg_ids {
   char const   *strid ;
   int id ;
};
#line 289 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
struct pvr2_fx2cmd_descdef {
   unsigned char id ;
   unsigned char *desc ;
};
#line 1840 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
struct pvr2_std_hack {
   v4l2_std_id pat ;
   v4l2_std_id msk ;
   v4l2_std_id std ;
};
#line 4139 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
typedef void (*led_method_func)(struct pvr2_hdw * , int  );
#line 4640 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
typedef int (*state_eval_func)(struct pvr2_hdw * );
#line 1466 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___5;
#line 1477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___6;
#line 1488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___7;
#line 1499 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___8;
#line 1542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___9;
#line 1553 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___10;
#line 1564 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___11;
#line 1575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___12;
#line 1778 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___13;
#line 1851 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___14;
#line 1862 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___15;
#line 1873 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___16;
#line 1884 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___17;
#line 1895 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___18;
#line 1906 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
typedef int ldv_func_ret_type___19;
#line 40 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 13 "include/uapi/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 735 "include/linux/pm.h"
enum dpm_order {
    DPM_ORDER_NONE = 0,
    DPM_ORDER_DEV_AFTER_PARENT = 1,
    DPM_ORDER_PARENT_BEFORE_DEV = 2,
    DPM_ORDER_DEV_LAST = 3
} ;
#line 1899 "include/linux/usb.h"
struct pvr2_ioread;
#line 571 "./include/uapi/linux/v4l2-common.h"
enum v4l2_buf_type {
    V4L2_BUF_TYPE_VIDEO_CAPTURE = 1,
    V4L2_BUF_TYPE_VIDEO_OUTPUT = 2,
    V4L2_BUF_TYPE_VIDEO_OVERLAY = 3,
    V4L2_BUF_TYPE_VBI_CAPTURE = 4,
    V4L2_BUF_TYPE_VBI_OUTPUT = 5,
    V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6,
    V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
    V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE = 10,
    V4L2_BUF_TYPE_SDR_CAPTURE = 11,
    V4L2_BUF_TYPE_PRIVATE = 128
} ;
#line 375 "include/uapi/linux/videodev2.h"
struct v4l2_capability {
   __u8 driver[16U] ;
   __u8 card[32U] ;
   __u8 bus_info[32U] ;
   __u32 version ;
   __u32 capabilities ;
   __u32 device_caps ;
   __u32 reserved[3U] ;
};
#line 450 "include/uapi/linux/videodev2.h"
struct v4l2_fmtdesc {
   __u32 index ;
   __u32 type ;
   __u32 flags ;
   __u8 description[32U] ;
   __u32 pixelformat ;
   __u32 reserved[4U] ;
};
#line 640 "include/uapi/linux/videodev2.h"
struct v4l2_frmsize_discrete {
   __u32 width ;
   __u32 height ;
};
#line 653 "include/uapi/linux/videodev2.h"
struct v4l2_frmsize_stepwise {
   __u32 min_width ;
   __u32 max_width ;
   __u32 step_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 step_height ;
};
#line 662 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_241 {
   struct v4l2_frmsize_discrete discrete ;
   struct v4l2_frmsize_stepwise stepwise ;
};
#line 662 "include/uapi/linux/videodev2.h"
struct v4l2_frmsizeenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 type ;
   union __anonunion____missing_field_name_241 __annonCompField75 ;
   __u32 reserved[2U] ;
};
#line 681 "include/uapi/linux/videodev2.h"
struct v4l2_frmival_stepwise {
   struct v4l2_fract min ;
   struct v4l2_fract max ;
   struct v4l2_fract step ;
};
#line 690 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_242 {
   struct v4l2_fract discrete ;
   struct v4l2_frmival_stepwise stepwise ;
};
#line 690 "include/uapi/linux/videodev2.h"
struct v4l2_frmivalenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 width ;
   __u32 height ;
   __u32 type ;
   union __anonunion____missing_field_name_242 __annonCompField76 ;
   __u32 reserved[2U] ;
};
#line 705 "include/uapi/linux/videodev2.h"
struct v4l2_timecode {
   __u32 type ;
   __u32 flags ;
   __u8 frames ;
   __u8 seconds ;
   __u8 minutes ;
   __u8 hours ;
   __u8 userbits[4U] ;
};
#line 719 "include/uapi/linux/videodev2.h"
struct v4l2_jpegcompression {
   int quality ;
   int APPn ;
   int APP_len ;
   char APP_data[60U] ;
   int COM_len ;
   char COM_data[60U] ;
   __u32 jpeg_markers ;
};
#line 748 "include/uapi/linux/videodev2.h"
struct v4l2_requestbuffers {
   __u32 count ;
   __u32 type ;
   __u32 memory ;
   __u32 reserved[2U] ;
};
#line 773 "include/uapi/linux/videodev2.h"
union __anonunion_m_243 {
   __u32 mem_offset ;
   unsigned long userptr ;
   __s32 fd ;
};
#line 773 "include/uapi/linux/videodev2.h"
struct v4l2_plane {
   __u32 bytesused ;
   __u32 length ;
   union __anonunion_m_243 m ;
   __u32 data_offset ;
   __u32 reserved[11U] ;
};
#line 805 "include/uapi/linux/videodev2.h"
union __anonunion_m_244 {
   __u32 offset ;
   unsigned long userptr ;
   struct v4l2_plane *planes ;
   __s32 fd ;
};
#line 805 "include/uapi/linux/videodev2.h"
struct v4l2_buffer {
   __u32 index ;
   __u32 type ;
   __u32 bytesused ;
   __u32 flags ;
   __u32 field ;
   struct timeval timestamp ;
   struct v4l2_timecode timecode ;
   __u32 sequence ;
   __u32 memory ;
   union __anonunion_m_244 m ;
   __u32 length ;
   __u32 reserved2 ;
   __u32 reserved ;
};
#line 858 "include/uapi/linux/videodev2.h"
struct v4l2_exportbuffer {
   __u32 type ;
   __u32 index ;
   __u32 plane ;
   __u32 flags ;
   __s32 fd ;
   __u32 reserved[11U] ;
};
#line 919 "include/uapi/linux/videodev2.h"
struct __anonstruct_fmt_245 {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 bytesperline ;
   __u32 sizeimage ;
   __u32 colorspace ;
   __u32 priv ;
};
#line 919 "include/uapi/linux/videodev2.h"
struct v4l2_framebuffer {
   __u32 capability ;
   __u32 flags ;
   void *base ;
   struct __anonstruct_fmt_245 fmt ;
};
#line 1012 "include/uapi/linux/videodev2.h"
struct v4l2_selection {
   __u32 type ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[9U] ;
};
#line 1365 "include/uapi/linux/videodev2.h"
struct v4l2_input {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 tuner ;
   v4l2_std_id std ;
   __u32 status ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1381 "include/uapi/linux/videodev2.h"
struct v4l2_output {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 modulator ;
   v4l2_std_id std ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1506 "include/uapi/linux/videodev2.h"
struct v4l2_query_ext_ctrl {
   __u32 id ;
   __u32 type ;
   char name[32U] ;
   __s64 minimum ;
   __s64 maximum ;
   __u64 step ;
   __s64 default_value ;
   __u32 flags ;
   __u32 elem_size ;
   __u32 elems ;
   __u32 nr_of_dims ;
   __u32 dims[4U] ;
   __u32 reserved[32U] ;
};
#line 1637 "include/uapi/linux/videodev2.h"
struct v4l2_hw_freq_seek {
   __u32 tuner ;
   __u32 type ;
   __u32 seek_upward ;
   __u32 wrap_around ;
   __u32 spacing ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 reserved[5U] ;
};
#line 1680 "include/uapi/linux/videodev2.h"
struct v4l2_audioout {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 1695 "include/uapi/linux/videodev2.h"
struct v4l2_enc_idx_entry {
   __u64 offset ;
   __u64 pts ;
   __u32 length ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1714 "include/uapi/linux/videodev2.h"
struct v4l2_enc_idx {
   __u32 entries ;
   __u32 entries_cap ;
   __u32 reserved[4U] ;
   struct v4l2_enc_idx_entry entry[64U] ;
};
#line 1722 "include/uapi/linux/videodev2.h"
struct __anonstruct_raw_251 {
   __u32 data[8U] ;
};
#line 1722 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_250 {
   struct __anonstruct_raw_251 raw ;
};
#line 1722 "include/uapi/linux/videodev2.h"
struct v4l2_encoder_cmd {
   __u32 cmd ;
   __u32 flags ;
   union __anonunion____missing_field_name_250 __annonCompField81 ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct __anonstruct_stop_253 {
   __u64 pts ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct __anonstruct_start_254 {
   __s32 speed ;
   __u32 format ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct __anonstruct_raw_255 {
   __u32 data[16U] ;
};
#line 1741 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_252 {
   struct __anonstruct_stop_253 stop ;
   struct __anonstruct_start_254 start ;
   struct __anonstruct_raw_255 raw ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct v4l2_decoder_cmd {
   __u32 cmd ;
   __u32 flags ;
   union __anonunion____missing_field_name_252 __annonCompField82 ;
};
#line 2132 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_chip_info {
   struct v4l2_dbg_match match ;
   char name[32U] ;
   __u32 flags ;
   __u32 reserved[32U] ;
};
#line 2143 "include/uapi/linux/videodev2.h"
struct v4l2_create_buffers {
   __u32 index ;
   __u32 count ;
   __u32 memory ;
   struct v4l2_format format ;
   __u32 reserved[8U] ;
};
#line 40 "include/linux/poll.h"
typedef struct poll_table_struct poll_table;
#line 128 "include/media/v4l2-device.h"
struct v4l2_ioctl_ops {
   int (*vidioc_querycap)(struct file * , void * , struct v4l2_capability * ) ;
   int (*vidioc_enum_fmt_vid_cap)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_overlay)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_out)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_sdr_cap)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_g_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_reqbufs)(struct file * , void * , struct v4l2_requestbuffers * ) ;
   int (*vidioc_querybuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_qbuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_expbuf)(struct file * , void * , struct v4l2_exportbuffer * ) ;
   int (*vidioc_dqbuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_create_bufs)(struct file * , void * , struct v4l2_create_buffers * ) ;
   int (*vidioc_prepare_buf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_overlay)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_g_fbuf)(struct file * , void * , struct v4l2_framebuffer * ) ;
   int (*vidioc_s_fbuf)(struct file * , void * , struct v4l2_framebuffer  const  * ) ;
   int (*vidioc_streamon)(struct file * , void * , enum v4l2_buf_type  ) ;
   int (*vidioc_streamoff)(struct file * , void * , enum v4l2_buf_type  ) ;
   int (*vidioc_g_std)(struct file * , void * , v4l2_std_id * ) ;
   int (*vidioc_s_std)(struct file * , void * , v4l2_std_id  ) ;
   int (*vidioc_querystd)(struct file * , void * , v4l2_std_id * ) ;
   int (*vidioc_enum_input)(struct file * , void * , struct v4l2_input * ) ;
   int (*vidioc_g_input)(struct file * , void * , unsigned int * ) ;
   int (*vidioc_s_input)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_enum_output)(struct file * , void * , struct v4l2_output * ) ;
   int (*vidioc_g_output)(struct file * , void * , unsigned int * ) ;
   int (*vidioc_s_output)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_queryctrl)(struct file * , void * , struct v4l2_queryctrl * ) ;
   int (*vidioc_query_ext_ctrl)(struct file * , void * , struct v4l2_query_ext_ctrl * ) ;
   int (*vidioc_g_ctrl)(struct file * , void * , struct v4l2_control * ) ;
   int (*vidioc_s_ctrl)(struct file * , void * , struct v4l2_control * ) ;
   int (*vidioc_g_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_s_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_try_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_querymenu)(struct file * , void * , struct v4l2_querymenu * ) ;
   int (*vidioc_enumaudio)(struct file * , void * , struct v4l2_audio * ) ;
   int (*vidioc_g_audio)(struct file * , void * , struct v4l2_audio * ) ;
   int (*vidioc_s_audio)(struct file * , void * , struct v4l2_audio  const  * ) ;
   int (*vidioc_enumaudout)(struct file * , void * , struct v4l2_audioout * ) ;
   int (*vidioc_g_audout)(struct file * , void * , struct v4l2_audioout * ) ;
   int (*vidioc_s_audout)(struct file * , void * , struct v4l2_audioout  const  * ) ;
   int (*vidioc_g_modulator)(struct file * , void * , struct v4l2_modulator * ) ;
   int (*vidioc_s_modulator)(struct file * , void * , struct v4l2_modulator  const  * ) ;
   int (*vidioc_cropcap)(struct file * , void * , struct v4l2_cropcap * ) ;
   int (*vidioc_g_crop)(struct file * , void * , struct v4l2_crop * ) ;
   int (*vidioc_s_crop)(struct file * , void * , struct v4l2_crop  const  * ) ;
   int (*vidioc_g_selection)(struct file * , void * , struct v4l2_selection * ) ;
   int (*vidioc_s_selection)(struct file * , void * , struct v4l2_selection * ) ;
   int (*vidioc_g_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression * ) ;
   int (*vidioc_s_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression  const  * ) ;
   int (*vidioc_g_enc_index)(struct file * , void * , struct v4l2_enc_idx * ) ;
   int (*vidioc_encoder_cmd)(struct file * , void * , struct v4l2_encoder_cmd * ) ;
   int (*vidioc_try_encoder_cmd)(struct file * , void * , struct v4l2_encoder_cmd * ) ;
   int (*vidioc_decoder_cmd)(struct file * , void * , struct v4l2_decoder_cmd * ) ;
   int (*vidioc_try_decoder_cmd)(struct file * , void * , struct v4l2_decoder_cmd * ) ;
   int (*vidioc_g_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
   int (*vidioc_s_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
   int (*vidioc_g_tuner)(struct file * , void * , struct v4l2_tuner * ) ;
   int (*vidioc_s_tuner)(struct file * , void * , struct v4l2_tuner  const  * ) ;
   int (*vidioc_g_frequency)(struct file * , void * , struct v4l2_frequency * ) ;
   int (*vidioc_s_frequency)(struct file * , void * , struct v4l2_frequency  const  * ) ;
   int (*vidioc_enum_freq_bands)(struct file * , void * , struct v4l2_frequency_band * ) ;
   int (*vidioc_g_sliced_vbi_cap)(struct file * , void * , struct v4l2_sliced_vbi_cap * ) ;
   int (*vidioc_log_status)(struct file * , void * ) ;
   int (*vidioc_s_hw_freq_seek)(struct file * , void * , struct v4l2_hw_freq_seek  const  * ) ;
   int (*vidioc_g_register)(struct file * , void * , struct v4l2_dbg_register * ) ;
   int (*vidioc_s_register)(struct file * , void * , struct v4l2_dbg_register  const  * ) ;
   int (*vidioc_g_chip_info)(struct file * , void * , struct v4l2_dbg_chip_info * ) ;
   int (*vidioc_enum_framesizes)(struct file * , void * , struct v4l2_frmsizeenum * ) ;
   int (*vidioc_enum_frameintervals)(struct file * , void * , struct v4l2_frmivalenum * ) ;
   int (*vidioc_s_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_g_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_query_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_enum_dv_timings)(struct file * , void * , struct v4l2_enum_dv_timings * ) ;
   int (*vidioc_dv_timings_cap)(struct file * , void * , struct v4l2_dv_timings_cap * ) ;
   int (*vidioc_g_edid)(struct file * , void * , struct v4l2_edid * ) ;
   int (*vidioc_s_edid)(struct file * , void * , struct v4l2_edid * ) ;
   int (*vidioc_subscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
   int (*vidioc_unsubscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
   long (*vidioc_default)(struct file * , void * , bool  , unsigned int  , void * ) ;
};
#line 334 "include/media/v4l2-ioctl.h"
struct pvr2_v4l2_dev;
#line 335
struct pvr2_v4l2_fh;
#line 336 "include/media/v4l2-ioctl.h"
struct pvr2_v4l2_dev {
   struct video_device devbase ;
   struct pvr2_v4l2 *v4lp ;
   struct pvr2_context_stream *stream ;
   enum pvr2_config config ;
   int v4l_type ;
   enum pvr2_v4l_type minor_type ;
};
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
struct pvr2_v4l2_fh {
   struct v4l2_fh fh ;
   struct pvr2_channel channel ;
   struct pvr2_v4l2_dev *pdi ;
   struct pvr2_ioread *rhp ;
   struct file *file ;
   wait_queue_head_t wait_data ;
   int fw_mode_flag ;
   unsigned char *input_map ;
   unsigned int input_cnt ;
};
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
struct pvr2_v4l2 {
   struct pvr2_channel channel ;
   struct pvr2_v4l2_dev *dev_video ;
   struct pvr2_v4l2_dev *dev_radio ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 1040 "include/uapi/linux/videodev2.h"
struct v4l2_standard {
   __u32 index ;
   v4l2_std_id id ;
   __u8 name[24U] ;
   struct v4l2_fract frameperiod ;
   __u32 framelines ;
   __u32 reserved[4U] ;
};
#line 23 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-debug.h"
struct std_name {
   char const   *name ;
   v4l2_std_id id ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 395 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
enum lg_chip_t {
    UNDEFINED = 0,
    LGDT3302 = 1,
    LGDT3303 = 2
} ;
#line 31 "drivers/media/dvb-frontends/lgdt330x.h"
typedef enum lg_chip_t lg_chip_type;
#line 32 "drivers/media/dvb-frontends/lgdt330x.h"
struct lgdt330x_config {
   u8 demod_address ;
   lg_chip_type demod_chip ;
   int serial_mpeg ;
   int (*pll_rf_set)(struct dvb_frontend * , int  ) ;
   int (*set_ts_params)(struct dvb_frontend * , int  ) ;
   int clock_polarity_flip ;
};
#line 57 "drivers/media/dvb-frontends/lgdt330x.h"
struct s5h1409_config {
   u8 demod_address ;
   u8 output_mode ;
   u8 gpio ;
   u16 qam_if ;
   u8 inversion ;
   u8 status_mode ;
   u16 mpeg_timing ;
   u8 hvr1600_opt ;
};
#line 72 "drivers/media/dvb-frontends/s5h1409.h"
struct s5h1411_config {
   u8 output_mode ;
   u8 gpio ;
   u16 mpeg_timing ;
   u16 qam_if ;
   u16 vsb_if ;
   u8 inversion ;
   u8 status_mode ;
};
#line 52 "include/linux/firmware.h"
struct tda10048_config {
   u8 demod_address ;
   u8 output_mode ;
   u8 fwbulkwritelen ;
   u8 inversion ;
   u16 dtv6_if_freq_khz ;
   u16 dtv7_if_freq_khz ;
   u16 dtv8_if_freq_khz ;
   u16 clk_freq_khz ;
   u8 disable_gate_access ;
   bool no_firmware ;
   bool set_pll ;
   u8 pll_m ;
   u8 pll_p ;
   u8 pll_n ;
};
#line 78 "drivers/media/dvb-frontends/tda10048.h"
struct tda18271_std_map_item {
   u16 if_freq ;
   unsigned char agc_mode : 2 ;
   unsigned char std : 3 ;
   unsigned char fm_rfn : 1 ;
   unsigned char if_lvl : 3 ;
   unsigned char rfagc_top : 7 ;
};
#line 41 "drivers/media/tuners/tda18271.h"
struct tda18271_std_map {
   struct tda18271_std_map_item fm_radio ;
   struct tda18271_std_map_item atv_b ;
   struct tda18271_std_map_item atv_dk ;
   struct tda18271_std_map_item atv_gh ;
   struct tda18271_std_map_item atv_i ;
   struct tda18271_std_map_item atv_l ;
   struct tda18271_std_map_item atv_lc ;
   struct tda18271_std_map_item atv_mn ;
   struct tda18271_std_map_item atsc_6 ;
   struct tda18271_std_map_item dvbt_6 ;
   struct tda18271_std_map_item dvbt_7 ;
   struct tda18271_std_map_item dvbt_8 ;
   struct tda18271_std_map_item qam_6 ;
   struct tda18271_std_map_item qam_7 ;
   struct tda18271_std_map_item qam_8 ;
};
#line 59
enum tda18271_role {
    TDA18271_MASTER = 0,
    TDA18271_SLAVE = 1
} ;
#line 64
enum tda18271_i2c_gate {
    TDA18271_GATE_AUTO = 0,
    TDA18271_GATE_ANALOG = 1,
    TDA18271_GATE_DIGITAL = 2
} ;
#line 70
enum tda18271_output_options {
    TDA18271_OUTPUT_LT_XT_ON = 0,
    TDA18271_OUTPUT_LT_OFF = 1,
    TDA18271_OUTPUT_XT_OFF = 2
} ;
#line 76
enum tda18271_small_i2c {
    TDA18271_39_BYTE_CHUNK_INIT = 0,
    TDA18271_16_BYTE_CHUNK_INIT = 16,
    TDA18271_08_BYTE_CHUNK_INIT = 8,
    TDA18271_03_BYTE_CHUNK_INIT = 3
} ;
#line 83 "drivers/media/tuners/tda18271.h"
struct tda18271_config {
   struct tda18271_std_map *std_map ;
   enum tda18271_role role ;
   enum tda18271_i2c_gate gate ;
   enum tda18271_output_options output_opt ;
   enum tda18271_small_i2c small_i2c ;
   unsigned char rf_cal_on_startup : 1 ;
   unsigned char delay_cal : 1 ;
   unsigned int config ;
};
#line 126
enum tda8290_lna {
    TDA8290_LNA_OFF = 0,
    TDA8290_LNA_GP0_HIGH_ON = 1,
    TDA8290_LNA_GP0_HIGH_OFF = 2,
    TDA8290_LNA_ON_BRIDGE = 3
} ;
#line 133 "drivers/media/tuners/tda18271.h"
struct tda829x_config {
   enum tda8290_lna lna_cfg ;
   unsigned char probe_tuner : 1 ;
   unsigned char no_i2c_gate : 1 ;
   struct tda18271_std_map *tda18271_std_map ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 239
enum hrtimer_restart;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-io.h"
enum pvr2_buffer_state {
    pvr2_buffer_state_none = 0,
    pvr2_buffer_state_idle = 1,
    pvr2_buffer_state_queued = 2,
    pvr2_buffer_state_ready = 3
} ;
#line 35
struct pvr2_buffer;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
struct pvr2_stream {
   struct list_head queued_list ;
   unsigned int q_count ;
   unsigned int q_bcount ;
   struct list_head ready_list ;
   unsigned int r_count ;
   unsigned int r_bcount ;
   struct list_head idle_list ;
   unsigned int i_count ;
   unsigned int i_bcount ;
   struct pvr2_buffer **buffers ;
   unsigned int buffer_slot_count ;
   unsigned int buffer_total_count ;
   unsigned int buffer_target_count ;
   void (*callback_func)(void * ) ;
   void *callback_data ;
   struct usb_device *dev ;
   int endpoint ;
   spinlock_t list_lock ;
   struct mutex mutex ;
   unsigned int fail_count ;
   unsigned int fail_tolerance ;
   unsigned int buffers_processed ;
   unsigned int buffers_failed ;
   unsigned int bytes_processed ;
};
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
struct pvr2_buffer {
   int id ;
   int signature ;
   enum pvr2_buffer_state state ;
   void *ptr ;
   unsigned int max_count ;
   unsigned int used_count ;
   int status ;
   struct pvr2_stream *stream ;
   struct list_head list_overhead ;
   struct urb *purb ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 2242 "include/linux/mm.h"
struct pvr2_ioread {
   struct pvr2_stream *stream ;
   char *buffer_storage[32U] ;
   char *sync_key_ptr ;
   unsigned int sync_key_len ;
   unsigned int sync_buf_offs ;
   unsigned int sync_state ;
   unsigned int sync_trashed_count ;
   int enabled ;
   int spigot_open ;
   int stream_running ;
   struct pvr2_buffer *c_buf ;
   char *c_data_ptr ;
   unsigned int c_data_len ;
   unsigned int c_data_offs ;
   struct mutex mutex ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 23 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-debug.h"
enum cx25840_video_input {
    CX25840_COMPOSITE1 = 1,
    CX25840_COMPOSITE2 = 2,
    CX25840_COMPOSITE3 = 3,
    CX25840_COMPOSITE4 = 4,
    CX25840_COMPOSITE5 = 5,
    CX25840_COMPOSITE6 = 6,
    CX25840_COMPOSITE7 = 7,
    CX25840_COMPOSITE8 = 8,
    CX25840_SVIDEO_LUMA1 = 16,
    CX25840_SVIDEO_LUMA2 = 32,
    CX25840_SVIDEO_LUMA3 = 48,
    CX25840_SVIDEO_LUMA4 = 64,
    CX25840_SVIDEO_LUMA5 = 80,
    CX25840_SVIDEO_LUMA6 = 96,
    CX25840_SVIDEO_LUMA7 = 112,
    CX25840_SVIDEO_LUMA8 = 128,
    CX25840_SVIDEO_CHROMA4 = 1024,
    CX25840_SVIDEO_CHROMA5 = 1280,
    CX25840_SVIDEO_CHROMA6 = 1536,
    CX25840_SVIDEO_CHROMA7 = 1792,
    CX25840_SVIDEO_CHROMA8 = 2048,
    CX25840_SVIDEO1 = 1296,
    CX25840_SVIDEO2 = 1568,
    CX25840_SVIDEO3 = 1840,
    CX25840_SVIDEO4 = 2112,
    CX25840_VIN1_CH1 = 2147483648U,
    CX25840_VIN2_CH1 = 2147483649U,
    CX25840_VIN3_CH1 = 2147483650U,
    CX25840_VIN4_CH1 = 2147483651U,
    CX25840_VIN5_CH1 = 2147483652U,
    CX25840_VIN6_CH1 = 2147483653U,
    CX25840_VIN7_CH1 = 2147483654U,
    CX25840_VIN8_CH1 = 2147483655U,
    CX25840_VIN4_CH2 = 2147483648U,
    CX25840_VIN5_CH2 = 2147483664U,
    CX25840_VIN6_CH2 = 2147483680U,
    CX25840_NONE_CH2 = 2147483696U,
    CX25840_VIN7_CH3 = 2147483648U,
    CX25840_VIN8_CH3 = 2147483712U,
    CX25840_NONE0_CH3 = 2147483776U,
    CX25840_NONE1_CH3 = 2147483840U,
    CX25840_SVIDEO_ON = 2147483904U,
    CX25840_COMPONENT_ON = 2147484160U,
    CX25840_DIF_ON = 2147484672U
} ;
#line 70
enum cx25840_audio_input {
    CX25840_AUDIO_SERIAL = 0,
    CX25840_AUDIO4 = 4,
    CX25840_AUDIO5 = 5,
    CX25840_AUDIO6 = 6,
    CX25840_AUDIO7 = 7,
    CX25840_AUDIO8 = 8
} ;
#line 187 "include/media/cx25840.h"
struct routing_scheme_item {
   int vid ;
   int aud ;
};
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.c"
struct routing_scheme___0 {
   struct routing_scheme_item  const  *def ;
   unsigned int cnt ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 43 "include/linux/i2c.h"
enum i2c_slave_event;
#line 43
enum i2c_slave_event;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 40 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-debugifc.h"
struct pvr2_sysfs_debugifc;
#line 40
struct pvr2_sysfs_ctl_item;
#line 40 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-debugifc.h"
struct pvr2_sysfs {
   struct pvr2_channel channel ;
   struct device *class_dev ;
   struct pvr2_sysfs_debugifc *debugifc ;
   struct pvr2_sysfs_ctl_item *item_first ;
   struct pvr2_sysfs_ctl_item *item_last ;
   struct device_attribute attr_v4l_minor_number ;
   struct device_attribute attr_v4l_radio_minor_number ;
   struct device_attribute attr_unit_number ;
   struct device_attribute attr_bus_info ;
   struct device_attribute attr_hdw_name ;
   struct device_attribute attr_hdw_desc ;
   int v4l_minor_number_created_ok ;
   int v4l_radio_minor_number_created_ok ;
   int unit_number_created_ok ;
   int bus_info_created_ok ;
   int hdw_name_created_ok ;
   int hdw_desc_created_ok ;
};
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
struct pvr2_sysfs_debugifc {
   struct device_attribute attr_debugcmd ;
   struct device_attribute attr_debuginfo ;
   int debugcmd_created_ok ;
   int debuginfo_created_ok ;
};
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
struct pvr2_sysfs_ctl_item {
   struct device_attribute attr_name ;
   struct device_attribute attr_type ;
   struct device_attribute attr_min ;
   struct device_attribute attr_max ;
   struct device_attribute attr_def ;
   struct device_attribute attr_enum ;
   struct device_attribute attr_bits ;
   struct device_attribute attr_val ;
   struct device_attribute attr_custom ;
   struct pvr2_ctrl *cptr ;
   int ctl_id ;
   struct pvr2_sysfs *chptr ;
   struct pvr2_sysfs_ctl_item *item_next ;
   struct attribute *attr_gen[8U] ;
   struct attribute_group grp ;
   int created_ok ;
   char name[80U] ;
};
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
struct pvr2_sysfs_class {
   struct class class ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 142 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 57
extern void *memset(void * , int  , size_t  ) ;
#line 26 "include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 173 "include/linux/mutex.h"
extern int mutex_trylock(struct mutex * ) ;
#line 176
int ldv_mutex_trylock_13(struct mutex *ldv_func_arg1 ) ;
#line 178
extern void mutex_unlock(struct mutex * ) ;
#line 181
void ldv_mutex_unlock_11(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_14(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_15(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_18(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_20(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_22(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_24(struct mutex *ldv_func_arg1 ) ;
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 18 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
extern void mutex_lock(struct mutex * ) ;
#line 21
void ldv_mutex_lock_10(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_12(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_16(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_17(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_19(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_21(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_23(struct mutex *ldv_func_arg1 ) ;
#line 63
void ldv_mutex_lock_ctl_lock_mutex_of_pvr2_hdw(struct mutex *lock ) ;
#line 67
void ldv_mutex_unlock_ctl_lock_mutex_of_pvr2_hdw(struct mutex *lock ) ;
#line 76
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) ;
#line 80
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) ;
#line 89
void ldv_mutex_lock_lock(struct mutex *lock ) ;
#line 93
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
#line 115
void ldv_mutex_lock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) ;
#line 119
void ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) ;
#line 128
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) ;
#line 129
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) ;
#line 132
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) ;
#line 429 "include/linux/workqueue.h"
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 433
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 439
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 443
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 452
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 455
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) ;
#line 227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 240
int ldv_state_variable_15 ;
#line 273
struct i2c_adapter *pvr2_i2c_algo_template_group0 ;
#line 282
void activate_work_1(struct work_struct *work , int state ) ;
#line 302
void call_and_disable_all_1(int state ) ;
#line 307
void ldv_initialize_i2c_algorithm_15(void) ;
#line 868 "include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 870
  dev->driver_data = data;
#line 871
  return;
}
}
#line 69 "include/linux/i2c.h"
extern int i2c_transfer(struct i2c_adapter * , struct i2c_msg * , int  ) ;
#line 326
extern struct i2c_client *i2c_new_device(struct i2c_adapter * , struct i2c_board_info  const  * ) ;
#line 528 "include/linux/i2c.h"
__inline static void i2c_set_adapdata(struct i2c_adapter *dev , void *data ) 
{ 


  {
#line 530
  dev_set_drvdata(& dev->dev, data);
#line 531
  return;
}
}
#line 579
extern int i2c_add_adapter(struct i2c_adapter * ) ;
#line 580
extern void i2c_del_adapter(struct i2c_adapter * ) ;
#line 25 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.h"
void pvr2_i2c_core_init(struct pvr2_hdw *hdw ) ;
#line 26
void pvr2_i2c_core_done(struct pvr2_hdw *hdw ) ;
#line 246 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw.h"
int pvr2_send_request(struct pvr2_hdw *hdw , void *write_data , unsigned int write_len ,
                      void *read_data , unsigned int read_len ) ;
#line 255
void pvr2_hdw_render_useless(struct pvr2_hdw *hdw ) ;
#line 22 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-debug.h"
int pvrusb2_debug ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
static unsigned int i2c_scan  ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
static int ir_mode[20U]  = 
#line 43
  {      1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1};
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
static int pvr2_disable_ir_video  ;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
static int pvr2_i2c_write(struct pvr2_hdw *hdw , u8 i2c_addr , u8 *data , u16 length ) 
{ 
  int ret ;

  {
#line 62
  if ((unsigned long )data == (unsigned long )((u8 *)0U)) {
#line 62
    length = 0U;
  } else {

  }
#line 63
  if ((unsigned int )length > 61U) {
#line 64
    if ((pvrusb2_debug & 2) != 0) {
#line 64
      printk("\016pvrusb2: Killing an I2C write to %u that is too large (desired=%u limit=%u)\n",
             (int )i2c_addr, (int )length, 61U);
    } else {

    }
#line 69
    return (-524);
  } else {

  }
#line 72
  ldv_mutex_lock_19(& hdw->ctl_lock_mutex);
#line 72
  hdw->ctl_lock_held = 1;
#line 75
  memset((void *)(& hdw->cmd_buffer), 0, 64UL);
#line 78
  hdw->cmd_buffer[0] = 8U;
#line 79
  hdw->cmd_buffer[1] = i2c_addr;
#line 80
  hdw->cmd_buffer[2] = (unsigned char )length;
#line 81
  if ((unsigned int )length != 0U) {
#line 81
    memcpy((void *)(& hdw->cmd_buffer) + 3U, (void const   *)data, (size_t )length);
  } else {

  }
#line 84
  ret = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), (unsigned int )((int )length + 3),
                          (void *)(& hdw->cmd_buffer), 1U);
#line 89
  if (ret == 0) {
#line 90
    if ((unsigned int )hdw->cmd_buffer[0] != 8U) {
#line 91
      ret = -5;
#line 92
      if ((unsigned int )hdw->cmd_buffer[0] != 7U) {
#line 93
        if ((pvrusb2_debug & 131072) != 0) {
#line 93
          printk("\016pvrusb2: unexpected status from i2_write[%d]: %d\n", (int )i2c_addr,
                 (int )hdw->cmd_buffer[0]);
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 100
  hdw->ctl_lock_held = 0;
#line 100
  ldv_mutex_unlock_20(& hdw->ctl_lock_mutex);
#line 102
  return (ret);
}
}
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
static int pvr2_i2c_read(struct pvr2_hdw *hdw , u8 i2c_addr , u8 *data , u16 dlen ,
                         u8 *res , u16 rlen ) 
{ 
  int ret ;

  {
#line 116
  if ((unsigned long )data == (unsigned long )((u8 *)0U)) {
#line 116
    dlen = 0U;
  } else {

  }
#line 117
  if ((unsigned int )dlen > 60U) {
#line 118
    if ((pvrusb2_debug & 2) != 0) {
#line 118
      printk("\016pvrusb2: Killing an I2C read to %u that has wlen too large (desired=%u limit=%u)\n",
             (int )i2c_addr, (int )dlen, 60U);
    } else {

    }
#line 123
    return (-524);
  } else {

  }
#line 125
  if ((unsigned long )res != (unsigned long )((u8 *)0U) && (unsigned int )rlen > 63U) {
#line 126
    if ((pvrusb2_debug & 2) != 0) {
#line 126
      printk("\016pvrusb2: Killing an I2C read to %u that has rlen too large (desired=%u limit=%u)\n",
             (int )i2c_addr, (int )rlen, 63U);
    } else {

    }
#line 131
    return (-524);
  } else {

  }
#line 134
  ldv_mutex_lock_21(& hdw->ctl_lock_mutex);
#line 134
  hdw->ctl_lock_held = 1;
#line 137
  memset((void *)(& hdw->cmd_buffer), 0, 64UL);
#line 140
  hdw->cmd_buffer[0] = 9U;
#line 141
  hdw->cmd_buffer[1] = (unsigned char )dlen;
#line 142
  hdw->cmd_buffer[2] = (unsigned char )rlen;
#line 144
  hdw->cmd_buffer[3] = i2c_addr;
#line 145
  if ((unsigned int )dlen != 0U) {
#line 145
    memcpy((void *)(& hdw->cmd_buffer) + 4U, (void const   *)data, (size_t )dlen);
  } else {

  }
#line 148
  ret = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), (unsigned int )((int )dlen + 4),
                          (void *)(& hdw->cmd_buffer), (unsigned int )((int )rlen + 1));
#line 153
  if (ret == 0) {
#line 154
    if ((unsigned int )hdw->cmd_buffer[0] != 8U) {
#line 155
      ret = -5;
#line 156
      if ((unsigned int )hdw->cmd_buffer[0] != 7U) {
#line 157
        if ((pvrusb2_debug & 131072) != 0) {
#line 157
          printk("\016pvrusb2: unexpected status from i2_read[%d]: %d\n", (int )i2c_addr,
                 (int )hdw->cmd_buffer[0]);
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 165
  if ((unsigned long )res != (unsigned long )((u8 *)0U) && (unsigned int )rlen != 0U) {
#line 166
    if (ret != 0) {
#line 168
      memset((void *)res, 0, (size_t )rlen);
    } else {
#line 170
      memcpy((void *)res, (void const   *)(& hdw->cmd_buffer) + 1U, (size_t )rlen);
    }
  } else {

  }
#line 174
  hdw->ctl_lock_held = 0;
#line 174
  ldv_mutex_unlock_22(& hdw->ctl_lock_mutex);
#line 176
  return (ret);
}
}
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
static int pvr2_i2c_basic_op(struct pvr2_hdw *hdw , u8 i2c_addr , u8 *wdata , u16 wlen ,
                             u8 *rdata , u16 rlen ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 188
  if ((unsigned long )rdata == (unsigned long )((u8 *)0U)) {
#line 188
    rlen = 0U;
  } else {

  }
#line 189
  if ((unsigned long )wdata == (unsigned long )((u8 *)0U)) {
#line 189
    wlen = 0U;
  } else {

  }
#line 190
  if ((unsigned int )rlen != 0U || (unsigned int )wlen == 0U) {
#line 191
    tmp = pvr2_i2c_read(hdw, (int )i2c_addr, wdata, (int )wlen, rdata, (int )rlen);
#line 191
    return (tmp);
  } else {
#line 193
    tmp___0 = pvr2_i2c_write(hdw, (int )i2c_addr, wdata, (int )wlen);
#line 193
    return (tmp___0);
  }
}
}
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
static int i2c_24xxx_ir(struct pvr2_hdw *hdw , u8 i2c_addr , u8 *wdata , u16 wlen ,
                        u8 *rdata , u16 rlen ) 
{ 
  u8 dat[4U] ;
  unsigned int stat ;
  int tmp ;
  u16 val ;

  {
#line 210
  if ((unsigned int )rlen == 0U && (unsigned int )wlen == 0U) {
#line 212
    return (0);
  } else {

  }
#line 216
  if ((unsigned int )wlen != 0U || (unsigned int )rlen == 0U) {
#line 216
    return (-5);
  } else {

  }
#line 218
  if ((unsigned int )rlen <= 2U) {
#line 226
    if ((unsigned int )rlen != 0U) {
#line 226
      *rdata = 0U;
    } else {

    }
#line 227
    if ((unsigned int )rlen > 1U) {
#line 227
      *(rdata + 1UL) = 0U;
    } else {

    }
#line 228
    return (0);
  } else {

  }
#line 232
  ldv_mutex_lock_23(& hdw->ctl_lock_mutex);
#line 232
  hdw->ctl_lock_held = 1;
#line 233
  hdw->cmd_buffer[0] = 236U;
#line 234
  tmp = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), 1U, (void *)(& hdw->cmd_buffer),
                          4U);
#line 234
  stat = (unsigned int )tmp;
#line 237
  dat[0] = hdw->cmd_buffer[0];
#line 238
  dat[1] = hdw->cmd_buffer[1];
#line 239
  dat[2] = hdw->cmd_buffer[2];
#line 240
  dat[3] = hdw->cmd_buffer[3];
#line 241
  hdw->ctl_lock_held = 0;
#line 241
  ldv_mutex_unlock_24(& hdw->ctl_lock_mutex);
#line 244
  if (stat != 0U) {
#line 244
    return ((int )stat);
  } else {

  }
#line 248
  *(rdata + 2UL) = 193U;
#line 249
  if ((unsigned int )dat[0] != 1U) {
#line 251
    *rdata = 0U;
#line 252
    *(rdata + 1UL) = 0U;
  } else {
#line 257
    val = (u16 )dat[1];
#line 258
    val = (int )val << 8U;
#line 259
    val = (int )((u16 )dat[2]) | (int )val;
#line 260
    val = (u16 )((int )val >> 1);
#line 261
    val = (unsigned int )val & 65532U;
#line 262
    val = (u16 )((unsigned int )val | 32768U);
#line 263
    *rdata = (u8 )((int )val >> 8);
#line 264
    *(rdata + 1UL) = (u8 )val;
  }
#line 267
  return (0);
}
}
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
static int i2c_hack_wm8775(struct pvr2_hdw *hdw , u8 i2c_addr , u8 *wdata , u16 wlen ,
                           u8 *rdata , u16 rlen ) 
{ 
  int tmp ;

  {
#line 277
  if ((unsigned int )rlen == 0U && (unsigned int )wlen == 0U) {
#line 279
    return (0);
  } else {

  }
#line 281
  tmp = pvr2_i2c_basic_op(hdw, (int )i2c_addr, wdata, (int )wlen, rdata, (int )rlen);
#line 281
  return (tmp);
}
}
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
static int i2c_black_hole(struct pvr2_hdw *hdw , u8 i2c_addr , u8 *wdata , u16 wlen ,
                          u8 *rdata , u16 rlen ) 
{ 


  {
#line 290
  return (-5);
}
}
#line 300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
static int i2c_hack_cx25840(struct pvr2_hdw *hdw , u8 i2c_addr , u8 *wdata , u16 wlen ,
                            u8 *rdata , u16 rlen ) 
{ 
  int ret ;
  unsigned int subaddr ;
  u8 wbuf[2U] ;
  int state ;
  int tmp ;

  {
#line 306
  state = hdw->i2c_cx25840_hack_state;
#line 308
  if ((unsigned int )rlen == 0U && (unsigned int )wlen == 0U) {
#line 312
    return (0);
  } else {

  }
#line 315
  if (state == 3) {
#line 316
    tmp = pvr2_i2c_basic_op(hdw, (int )i2c_addr, wdata, (int )wlen, rdata, (int )rlen);
#line 316
    return (tmp);
  } else {

  }
#line 327
  if ((unsigned int )wlen == 0U) {
#line 328
    switch (state) {
    case 1: 
#line 329
    subaddr = 256U;
#line 329
    goto ldv_51932;
    case 2: 
#line 330
    subaddr = 257U;
#line 330
    goto ldv_51932;
    default: ;
#line 331
    goto fail;
    }
    ldv_51932: ;
  } else
#line 333
  if ((unsigned int )wlen == 2U) {
#line 334
    subaddr = (unsigned int )(((int )*wdata << 8) | (int )*(wdata + 1UL));
#line 335
    switch (subaddr) {
    case 256U: 
#line 336
    state = 1;
#line 336
    goto ldv_51937;
    case 257U: 
#line 337
    state = 2;
#line 337
    goto ldv_51937;
    default: ;
#line 338
    goto fail;
    }
    ldv_51937: ;
  } else {
#line 341
    goto fail;
  }
#line 343
  if ((unsigned int )rlen == 0U) {
#line 343
    goto success;
  } else {

  }
#line 344
  state = 0;
#line 345
  if ((unsigned int )rlen != 1U) {
#line 345
    goto fail;
  } else {

  }
#line 349
  wbuf[0] = (u8 )(subaddr >> 8);
#line 350
  wbuf[1] = (u8 )subaddr;
#line 351
  ret = pvr2_i2c_basic_op(hdw, (int )i2c_addr, (u8 *)(& wbuf), 2, rdata, (int )rlen);
#line 353
  if ((ret != 0 || (unsigned int )*rdata == 4U) || (unsigned int )*rdata == 10U) {
#line 354
    if ((pvrusb2_debug & 2) != 0) {
#line 354
      printk("\016pvrusb2: WARNING: Detected a wedged cx25840 chip; the device will not work.\n");
    } else {

    }
#line 357
    if ((pvrusb2_debug & 2) != 0) {
#line 357
      printk("\016pvrusb2: WARNING: Try power cycling the pvrusb2 device.\n");
    } else {

    }
#line 359
    if ((pvrusb2_debug & 2) != 0) {
#line 359
      printk("\016pvrusb2: WARNING: Disabling further access to the device to prevent other foul-ups.\n");
    } else {

    }
#line 363
    hdw->i2c_func[68] = (int (*)(struct pvr2_hdw * , u8  , u8 * , u16  , u8 * , u16  ))0;
#line 364
    pvr2_hdw_render_useless(hdw);
#line 365
    goto fail;
  } else {

  }
#line 369
  if ((pvrusb2_debug & 65536) != 0) {
#line 369
    printk("\016pvrusb2: cx25840 appears to be OK.\n");
  } else {

  }
#line 370
  state = 3;
  success: 
#line 373
  hdw->i2c_cx25840_hack_state = state;
#line 374
  return (0);
  fail: 
#line 377
  hdw->i2c_cx25840_hack_state = state;
#line 378
  return (-5);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
static int pvr2_i2c_xfer(struct i2c_adapter *i2c_adap , struct i2c_msg *msgs , int num ) 
{ 
  int ret ;
  int (*funcp)(struct pvr2_hdw * , u8  , u8 * , u16  , u8 * , u16  ) ;
  struct pvr2_hdw *hdw ;
  u16 tcnt ;
  u16 bcnt ;
  u16 offs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u16 tcnt___0 ;
  u16 bcnt___0 ;
  u16 wcnt ;
  u16 offs___0 ;
  int tmp___2 ;
  unsigned int idx ;
  unsigned int offs___1 ;
  unsigned int cnt ;

  {
#line 387
  ret = -524;
#line 388
  funcp = (int (*)(struct pvr2_hdw * , u8  , u8 * , u16  , u8 * , u16  ))0;
#line 389
  hdw = (struct pvr2_hdw *)i2c_adap->algo_data;
#line 391
  if (num == 0) {
#line 392
    ret = -22;
#line 393
    goto done;
  } else {

  }
#line 395
  if ((unsigned int )msgs->addr <= 127U) {
#line 396
    funcp = hdw->i2c_func[(int )msgs->addr];
  } else {

  }
#line 398
  if ((unsigned long )funcp == (unsigned long )((int (*)(struct pvr2_hdw * , u8  ,
                                                         u8 * , u16  , u8 * , u16  ))0)) {
#line 399
    ret = -5;
#line 400
    goto done;
  } else {

  }
#line 403
  if (num == 1) {
#line 404
    if ((int )msgs->flags & 1) {
#line 407
      if ((unsigned int )msgs->len == 0U) {
#line 409
        tmp = (*funcp)(hdw, (int )((u8 )msgs->addr), (u8 *)0U, 0, (u8 *)0U, 0);
#line 409
        if (tmp != 0) {
#line 410
          ret = -5;
#line 411
          goto done;
        } else {

        }
#line 413
        ret = 1;
#line 414
        goto done;
      } else {

      }
#line 419
      tcnt = msgs->len;
#line 420
      offs = 0U;
#line 421
      goto ldv_51954;
      ldv_51953: 
#line 422
      bcnt = tcnt;
#line 423
      if ((unsigned int )bcnt > 63U) {
#line 424
        bcnt = 63U;
      } else {

      }
#line 426
      tmp___0 = (*funcp)(hdw, (int )((u8 )msgs->addr), (u8 *)0U, 0, msgs->buf + (unsigned long )offs,
                         (int )bcnt);
#line 426
      if (tmp___0 != 0) {
#line 428
        ret = -5;
#line 429
        goto done;
      } else {

      }
#line 431
      offs = (int )offs + (int )bcnt;
#line 432
      tcnt = (int )tcnt - (int )bcnt;
      ldv_51954: ;
#line 421
      if ((unsigned int )tcnt != 0U) {
#line 423
        goto ldv_51953;
      } else {

      }
#line 434
      ret = 1;
#line 435
      goto done;
    } else {
#line 438
      ret = 1;
#line 439
      tmp___1 = (*funcp)(hdw, (int )((u8 )msgs->addr), msgs->buf, (int )msgs->len,
                         (u8 *)0U, 0);
#line 439
      if (tmp___1 != 0) {
#line 441
        ret = -5;
      } else {

      }
#line 443
      goto done;
    }
  } else
#line 445
  if (num == 2) {
#line 446
    if ((int )msgs->addr != (int )(msgs + 1UL)->addr) {
#line 447
      if ((pvrusb2_debug & 131072) != 0) {
#line 447
        printk("\016pvrusb2: i2c refusing 2 phase transfer with conflicting target addresses\n");
      } else {

      }
#line 449
      ret = -524;
#line 450
      goto done;
    } else {

    }
#line 452
    if (((int )msgs->flags & 1) == 0 && (int )(msgs + 1UL)->flags & 1) {
#line 459
      tcnt___0 = (msgs + 1UL)->len;
#line 460
      wcnt = msgs->len;
#line 461
      offs___0 = 0U;
#line 462
      goto ldv_51961;
      ldv_51960: 
#line 463
      bcnt___0 = tcnt___0;
#line 464
      if ((unsigned int )bcnt___0 > 63U) {
#line 465
        bcnt___0 = 63U;
      } else {

      }
#line 467
      tmp___2 = (*funcp)(hdw, (int )((u8 )msgs->addr), msgs->buf, (int )wcnt, (msgs + 1UL)->buf + (unsigned long )offs___0,
                         (int )bcnt___0);
#line 467
      if (tmp___2 != 0) {
#line 470
        ret = -5;
#line 471
        goto done;
      } else {

      }
#line 473
      offs___0 = (int )offs___0 + (int )bcnt___0;
#line 474
      tcnt___0 = (int )tcnt___0 - (int )bcnt___0;
#line 475
      wcnt = 0U;
      ldv_51961: ;
#line 462
      if ((unsigned int )tcnt___0 != 0U || (unsigned int )wcnt != 0U) {
#line 464
        goto ldv_51960;
      } else {

      }
#line 477
      ret = 2;
#line 478
      goto done;
    } else
#line 480
    if ((pvrusb2_debug & 131072) != 0) {
#line 480
      printk("\016pvrusb2: i2c refusing complex transfer read0=%d read1=%d\n", (int )msgs->flags & 1,
             (int )(msgs + 1UL)->flags & 1);
    } else {

    }
  } else
#line 486
  if ((pvrusb2_debug & 131072) != 0) {
#line 486
    printk("\016pvrusb2: i2c refusing %d phase transfer\n", num);
  } else {

  }
  done: ;
#line 490
  if ((pvrusb2_debug & 1048576) != 0) {
#line 492
    idx = 0U;
#line 492
    goto ldv_51970;
    ldv_51969: 
#line 493
    cnt = (unsigned int )(msgs + (unsigned long )idx)->len;
#line 494
    printk("\016pvrusb2 i2c xfer %u/%u: addr=0x%x len=%d %s", idx + 1U, num, (int )(msgs + (unsigned long )idx)->addr,
           cnt, (int )(msgs + (unsigned long )idx)->flags & 1 ? (char *)"read" : (char *)"write");
#line 502
    if (ret > 0 || ((int )(msgs + (unsigned long )idx)->flags & 1) == 0) {
#line 503
      if (cnt > 8U) {
#line 503
        cnt = 8U;
      } else {

      }
#line 504
      printk(" [");
#line 505
      offs___1 = 0U;
#line 505
      goto ldv_51967;
      ldv_51966: ;
#line 506
      if (offs___1 != 0U) {
#line 506
        printk(" ");
      } else {

      }
#line 507
      printk("%02x", (int )*((msgs + (unsigned long )idx)->buf + (unsigned long )offs___1));
#line 505
      offs___1 = offs___1 + 1U;
      ldv_51967: ;
#line 505
      if ((8U < cnt ? 8U : cnt) > offs___1) {
#line 507
        goto ldv_51966;
      } else {

      }

#line 509
      if (offs___1 < cnt) {
#line 509
        printk(" ...");
      } else {

      }
#line 510
      printk("]");
    } else {

    }
#line 512
    if (idx + 1U == (unsigned int )num) {
#line 513
      printk(" result=%d", ret);
    } else {

    }
#line 515
    printk("\n");
#line 492
    idx = idx + 1U;
    ldv_51970: ;
#line 492
    if ((unsigned int )num > idx) {
#line 494
      goto ldv_51969;
    } else {

    }

#line 517
    if (num == 0) {
#line 518
      printk("\016pvrusb2 i2c xfer null transfer result=%d\n", ret);
    } else {

    }
  } else {

  }
#line 523
  return (ret);
}
}
#line 526 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
static u32 pvr2_i2c_functionality(struct i2c_adapter *adap ) 
{ 


  {
#line 528
  return (251592713U);
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
static struct i2c_algorithm pvr2_i2c_algo_template  =    {& pvr2_i2c_xfer, 0, & pvr2_i2c_functionality, 0, 0};
#line 536 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
static struct i2c_adapter pvr2_i2c_adap_template  = 
#line 536
     {& __this_module, 0U, 0, 0, {{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}, {0}, 0,
                                0, 0, 0, 0, 0, 0}, 0, 0, {0, 0, {0, {0, 0}, 0, 0,
                                                                 0, 0, {{0}}, {{{0L},
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
                                                                               {{0,
                                                                                 0},
                                                                                0UL,
                                                                                0,
                                                                                0UL,
                                                                                0U,
                                                                                0,
                                                                                0,
                                                                                0,
                                                                                {(char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0},
                                                                                {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
                                                                               0,
                                                                               0},
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0,
                                                                 (unsigned char)0},
                                                          0, 0, {{0}, {{{{{0}}, 0U,
                                                                         0U, 0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}}}},
                                                                 {0, 0}, 0, 0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}},
                                                          0, 0, 0, 0, {{0}, (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (_Bool)0, (_Bool)0,
                                                                       (_Bool)0, (_Bool)0,
                                                                       (_Bool)0, (_Bool)0,
                                                                       (_Bool)0, {{{{{0}},
                                                                                    0U,
                                                                                    0U,
                                                                                    0,
                                                                                    {0,
                                                                                     {0,
                                                                                      0},
                                                                                     0,
                                                                                     0,
                                                                                     0UL}}}},
                                                                       {0, 0}, {0U,
                                                                                {{{{{{0}},
                                                                                    0U,
                                                                                    0U,
                                                                                    0,
                                                                                    {0,
                                                                                     {0,
                                                                                      0},
                                                                                     0,
                                                                                     0,
                                                                                     0UL}}}},
                                                                                 {0,
                                                                                  0}}},
                                                                       0, (_Bool)0,
                                                                       (_Bool)0, {{0,
                                                                                   0},
                                                                                  0UL,
                                                                                  0,
                                                                                  0UL,
                                                                                  0U,
                                                                                  0,
                                                                                  0,
                                                                                  0,
                                                                                  {(char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0},
                                                                                  {0,
                                                                                   {0,
                                                                                    0},
                                                                                   0,
                                                                                   0,
                                                                                   0UL}},
                                                                       0UL, {{0L},
                                                                             {0, 0},
                                                                             0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
                                                                       {{{{{{0}},
                                                                           0U, 0U,
                                                                           0, {0,
                                                                               {0,
                                                                                0},
                                                                               0,
                                                                               0,
                                                                               0UL}}}},
                                                                        {0, 0}}, 0,
                                                                       {0}, {0}, (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       0, 0, 0, 0,
                                                                       0UL, 0UL, 0UL,
                                                                       0UL, 0, 0,
                                                                       0}, 0, 0, 0,
                                                          0, 0ULL, 0UL, 0, {0, 0},
                                                          0, 0, {0, 0}, 0, 0, 0U,
                                                          0U, {{{{{0}}, 0U, 0U, 0,
                                                                 {0, {0, 0}, 0, 0,
                                                                  0UL}}}}, {0, 0},
                                                          {0, {0, 0}, {{0}}}, 0, 0,
                                                          0, 0, (_Bool)0, (_Bool)0},
    0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
        (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
        (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
        (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
        (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
        (char)0, (char)0, (char)0}, {0U, {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}},
                                          {0, 0}}}, {{0}, {{{{{0}}, 0U, 0U, 0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}}}},
                                                     {0, 0}, 0, 0, {0, {0, 0}, 0,
                                                                    0, 0UL}}, {0,
                                                                               0},
    0, 0};
#line 543 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
static int do_i2c_probe(struct pvr2_hdw *hdw , int addr ) 
{ 
  struct i2c_msg msg[1U] ;
  int rc ;

  {
#line 547
  msg[0].addr = 0U;
#line 548
  msg[0].flags = 1U;
#line 549
  msg[0].len = 0U;
#line 550
  msg[0].buf = (__u8 *)0U;
#line 551
  msg[0].addr = (__u16 )addr;
#line 552
  rc = i2c_transfer(& hdw->i2c_adap, (struct i2c_msg *)(& msg), 1);
#line 553
  return (rc == 1);
}
}
#line 556 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
static void do_i2c_scan(struct pvr2_hdw *hdw ) 
{ 
  int i ;
  int tmp ;

  {
#line 559
  printk("\016%s: i2c scan beginning\n", (char *)(& hdw->name));
#line 560
  i = 0;
#line 560
  goto ldv_51990;
  ldv_51989: 
#line 561
  tmp = do_i2c_probe(hdw, i);
#line 561
  if (tmp != 0) {
#line 562
    printk("\016%s: i2c scan: found device @ 0x%x\n", (char *)(& hdw->name), i);
  } else {

  }
#line 560
  i = i + 1;
  ldv_51990: ;
#line 560
  if (i <= 127) {
#line 562
    goto ldv_51989;
  } else {

  }
#line 566
  printk("\016%s: i2c scan done.\n", (char *)(& hdw->name));
#line 567
  return;
}
}
#line 569 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
static void pvr2_i2c_register_ir(struct pvr2_hdw *hdw ) 
{ 
  struct i2c_board_info info ;
  struct IR_i2c_init_data *init_data ;

  {
#line 572
  init_data = & hdw->ir_init_data;
#line 573
  if (pvr2_disable_ir_video != 0) {
#line 574
    if (pvrusb2_debug & 1) {
#line 574
      printk("\016pvrusb2: Automatic binding of ir_video has been disabled.\n");
    } else {

    }
#line 576
    return;
  } else {

  }
#line 578
  memset((void *)(& info), 0, 64UL);
#line 579
  switch (hdw->ir_scheme_active) {
  case 1U: ;
  case 4U: 
#line 582
  init_data->ir_codes = (char *)"rc-hauppauge";
#line 583
  init_data->internal_get_key_func = 2;
#line 584
  init_data->type = 8ULL;
#line 585
  init_data->name = (hdw->hdw_desc)->description;
#line 586
  init_data->polling_interval = 100U;
#line 588
  info.addr = 24U;
#line 589
  info.platform_data = (void *)init_data;
#line 590
  strlcpy((char *)(& info.type), "ir_video", 20UL);
#line 591
  if (pvrusb2_debug & 1) {
#line 591
    printk("\016pvrusb2: Binding %s to i2c address 0x%02x.\n", (char *)(& info.type),
           (int )info.addr);
  } else {

  }
#line 593
  i2c_new_device(& hdw->i2c_adap, (struct i2c_board_info  const  *)(& info));
#line 594
  goto ldv_51999;
  case 2U: ;
  case 3U: 
#line 597
  init_data->ir_codes = (char *)"rc-hauppauge";
#line 598
  init_data->internal_get_key_func = 5;
#line 599
  init_data->type = 8ULL;
#line 600
  init_data->name = (hdw->hdw_desc)->description;
#line 602
  info.addr = 113U;
#line 603
  info.platform_data = (void *)init_data;
#line 604
  strlcpy((char *)(& info.type), "ir_rx_z8f0811_haup", 20UL);
#line 605
  if (pvrusb2_debug & 1) {
#line 605
    printk("\016pvrusb2: Binding %s to i2c address 0x%02x.\n", (char *)(& info.type),
           (int )info.addr);
  } else {

  }
#line 607
  i2c_new_device(& hdw->i2c_adap, (struct i2c_board_info  const  *)(& info));
#line 609
  info.addr = 112U;
#line 610
  info.platform_data = (void *)init_data;
#line 611
  strlcpy((char *)(& info.type), "ir_tx_z8f0811_haup", 20UL);
#line 612
  if (pvrusb2_debug & 1) {
#line 612
    printk("\016pvrusb2: Binding %s to i2c address 0x%02x.\n", (char *)(& info.type),
           (int )info.addr);
  } else {

  }
#line 614
  i2c_new_device(& hdw->i2c_adap, (struct i2c_board_info  const  *)(& info));
#line 615
  goto ldv_51999;
  default: ;
#line 619
  goto ldv_51999;
  }
  ldv_51999: ;
#line 622
  return;
}
}
#line 623 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
void pvr2_i2c_core_init(struct pvr2_hdw *hdw ) 
{ 
  unsigned int idx ;
  int tmp ;

  {
#line 629
  idx = 0U;
#line 629
  goto ldv_52008;
  ldv_52007: 
#line 630
  hdw->i2c_func[idx] = & pvr2_i2c_basic_op;
#line 629
  idx = idx + 1U;
  ldv_52008: ;
#line 629
  if (idx <= 127U) {
#line 631
    goto ldv_52007;
  } else {

  }

#line 634
  if (ir_mode[hdw->unit_number] == 0) {
#line 635
    printk("\016%s: IR disabled\n", (char *)(& hdw->name));
#line 636
    hdw->i2c_func[24] = & i2c_black_hole;
  } else
#line 637
  if (ir_mode[hdw->unit_number] == 1) {
#line 638
    if (hdw->ir_scheme_active == 1U) {
#line 641
      hdw->i2c_func[24] = & i2c_24xxx_ir;
    } else {

    }
  } else {

  }
#line 644
  if ((unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) != 0U) {
#line 645
    hdw->i2c_func[68] = & i2c_hack_cx25840;
  } else {

  }
#line 647
  if ((unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) != 0U) {
#line 648
    hdw->i2c_func[27] = & i2c_hack_wm8775;
  } else {

  }
#line 652
  hdw->i2c_adap = pvr2_i2c_adap_template;
#line 653
  hdw->i2c_algo = pvr2_i2c_algo_template;
#line 654
  strlcpy((char *)(& hdw->i2c_adap.name), (char const   *)(& hdw->name), 48UL);
#line 655
  hdw->i2c_adap.dev.parent = & (hdw->usb_dev)->dev;
#line 656
  hdw->i2c_adap.algo = (struct i2c_algorithm  const  *)(& hdw->i2c_algo);
#line 657
  hdw->i2c_adap.algo_data = (void *)hdw;
#line 658
  hdw->i2c_linked = 1;
#line 659
  i2c_set_adapdata(& hdw->i2c_adap, (void *)(& hdw->v4l2_dev));
#line 660
  i2c_add_adapter(& hdw->i2c_adap);
#line 661
  if ((unsigned long )hdw->i2c_func[24] == (unsigned long )(& i2c_24xxx_ir)) {
#line 668
    tmp = do_i2c_probe(hdw, 113);
#line 668
    if (tmp != 0) {
#line 669
      if (pvrusb2_debug & 1) {
#line 669
        printk("\016pvrusb2: Device has newer IR hardware; disabling unneeded virtual IR device\n");
      } else {

      }
#line 672
      hdw->i2c_func[24] = (int (*)(struct pvr2_hdw * , u8  , u8 * , u16  , u8 * ,
                                   u16  ))0;
#line 674
      hdw->ir_scheme_active = 3U;
    } else {

    }
  } else {

  }
#line 677
  if (i2c_scan != 0U) {
#line 677
    do_i2c_scan(hdw);
  } else {

  }
#line 679
  pvr2_i2c_register_ir(hdw);
#line 680
  return;
}
}
#line 682 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.c"
void pvr2_i2c_core_done(struct pvr2_hdw *hdw ) 
{ 


  {
#line 684
  if (hdw->i2c_linked != 0) {
#line 685
    i2c_del_adapter(& hdw->i2c_adap);
#line 686
    hdw->i2c_linked = 0;
  } else {

  }
#line 688
  return;
}
}
#line 327 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_initialize_i2c_algorithm_15(void) 
{ 
  void *tmp ;

  {
#line 328
  tmp = ldv_init_zalloc(1936UL);
#line 328
  pvr2_i2c_algo_template_group0 = (struct i2c_adapter *)tmp;
#line 329
  return;
}
}
#line 331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_main_exported_15(void) 
{ 
  struct i2c_msg *ldvarg59 ;
  void *tmp ;
  int ldvarg58 ;
  int tmp___0 ;

  {
#line 332
  tmp = ldv_init_zalloc(16UL);
#line 332
  ldvarg59 = (struct i2c_msg *)tmp;
#line 333
  ldv_memset((void *)(& ldvarg58), 0, 4UL);
#line 335
  tmp___0 = __VERIFIER_nondet_int();
#line 335
  switch (tmp___0) {
  case 0: ;
#line 338
  if (ldv_state_variable_15 == 1) {
#line 340
    pvr2_i2c_xfer(pvr2_i2c_algo_template_group0, ldvarg59, ldvarg58);
#line 342
    ldv_state_variable_15 = 1;
  } else {

  }
#line 345
  goto ldv_52022;
  case 1: ;
#line 348
  if (ldv_state_variable_15 == 1) {
#line 350
    pvr2_i2c_functionality(pvr2_i2c_algo_template_group0);
#line 352
    ldv_state_variable_15 = 1;
  } else {

  }
#line 355
  goto ldv_52022;
  default: 
#line 356
  ldv_stop();
  }
  ldv_52022: ;
#line 360
  return;
}
}
#line 385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 389
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 389
  ldv_func_res = tmp;
#line 391
  activate_work_1(ldv_func_arg3, 2);
#line 393
  return (ldv_func_res);
}
}
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 400
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 400
  ldv_func_res = tmp;
#line 402
  activate_work_1(& ldv_func_arg3->work, 2);
#line 404
  return (ldv_func_res);
}
}
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 411
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 411
  ldv_func_res = tmp;
#line 413
  activate_work_1(ldv_func_arg3, 2);
#line 415
  return (ldv_func_res);
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 421
  flush_workqueue(ldv_func_arg1);
#line 423
  call_and_disable_all_1(2);
#line 424
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 430
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 430
  ldv_func_res = tmp;
#line 432
  activate_work_1(& ldv_func_arg3->work, 2);
#line 434
  return (ldv_func_res);
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_mutex_lock_10(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 440
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 442
  mutex_lock(ldv_func_arg1);
#line 443
  return;
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_mutex_unlock_11(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 448
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 450
  mutex_unlock(ldv_func_arg1);
#line 451
  return;
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_mutex_lock_12(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 456
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 458
  mutex_lock(ldv_func_arg1);
#line 459
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
int ldv_mutex_trylock_13(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 465
  tmp = mutex_trylock(ldv_func_arg1);
#line 465
  ldv_func_res = tmp;
#line 467
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 467
  return (tmp___0);
#line 469
  return (ldv_func_res);
}
}
#line 472 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_mutex_unlock_14(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 475
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 477
  mutex_unlock(ldv_func_arg1);
#line 478
  return;
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_mutex_unlock_15(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 483
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 485
  mutex_unlock(ldv_func_arg1);
#line 486
  return;
}
}
#line 488 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_mutex_lock_16(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 491
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 493
  mutex_lock(ldv_func_arg1);
#line 494
  return;
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_mutex_lock_17(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 499
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 501
  mutex_lock(ldv_func_arg1);
#line 502
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_mutex_unlock_18(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 507
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 509
  mutex_unlock(ldv_func_arg1);
#line 510
  return;
}
}
#line 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_mutex_lock_19(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 515
  ldv_mutex_lock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 517
  mutex_lock(ldv_func_arg1);
#line 518
  return;
}
}
#line 520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_mutex_unlock_20(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 523
  ldv_mutex_unlock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 525
  mutex_unlock(ldv_func_arg1);
#line 526
  return;
}
}
#line 528 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_mutex_lock_21(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 531
  ldv_mutex_lock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 533
  mutex_lock(ldv_func_arg1);
#line 534
  return;
}
}
#line 536 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_mutex_unlock_22(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 539
  ldv_mutex_unlock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 541
  mutex_unlock(ldv_func_arg1);
#line 542
  return;
}
}
#line 544 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_mutex_lock_23(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 547
  ldv_mutex_lock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 549
  mutex_lock(ldv_func_arg1);
#line 550
  return;
}
}
#line 552 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-i2c-core.o.c.prepared"
void ldv_mutex_unlock_24(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 555
  ldv_mutex_unlock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 557
  mutex_unlock(ldv_func_arg1);
#line 558
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_57(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_55(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_58(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_59(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_62(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
void ldv_mutex_lock_54(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_56(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_60(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_61(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_49(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_51(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_50(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_53(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_52(struct workqueue_struct *ldv_func_arg1 ) ;
#line 26 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-audio.h"
void pvr2_msp3400_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.c"
static int const   routing_scheme0[5U]  = {      0,      0,      2236960,      2236960, 
        2236961};
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.c"
static struct routing_scheme  const  routing_def0  =    {(int const   *)(& routing_scheme0), 5U};
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.c"
static struct routing_scheme  const  *routing_schemes[1U]  = {      & routing_def0};
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.c"
void pvr2_msp3400_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) 
{ 
  struct routing_scheme  const  *sp ;
  unsigned int sid ;
  u32 input ;

  {
#line 62
  if (hdw->input_dirty != 0 || hdw->force_dirty != 0) {
#line 64
    sid = (unsigned int )(hdw->hdw_desc)->signal_routing_scheme;
#line 67
    if ((pvrusb2_debug & 65536) != 0) {
#line 67
      printk("\016pvrusb2: subdev msp3400 v4l2 set_stereo\n");
    } else {

    }
#line 68
    sp = sid == 0U ? routing_schemes[sid] : (struct routing_scheme  const  *)0;
#line 71
    if (((unsigned long )sp != (unsigned long )((struct routing_scheme  const  *)0) && hdw->input_val >= 0) && (unsigned int )hdw->input_val < (unsigned int )sp->cnt) {
#line 74
      input = (u32 )*(sp->def + (unsigned long )hdw->input_val);
    } else {
#line 76
      if ((pvrusb2_debug & 2) != 0) {
#line 76
        printk("\016pvrusb2: *** WARNING *** subdev msp3400 set_input: Invalid routing scheme (%u) and/or input (%d)\n",
               sid, hdw->input_val);
      } else {

      }
#line 81
      return;
    }
#line 83
    (*(((sd->ops)->audio)->s_routing))(sd, input, 68U, 0U);
  } else {

  }
#line 85
  return;
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
bool ldv_queue_work_on_49(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 354
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 354
  ldv_func_res = tmp;
#line 356
  activate_work_1(ldv_func_arg3, 2);
#line 358
  return (ldv_func_res);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
bool ldv_queue_delayed_work_on_50(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 365
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 365
  ldv_func_res = tmp;
#line 367
  activate_work_1(& ldv_func_arg3->work, 2);
#line 369
  return (ldv_func_res);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
bool ldv_queue_work_on_51(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 376
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 376
  ldv_func_res = tmp;
#line 378
  activate_work_1(ldv_func_arg3, 2);
#line 380
  return (ldv_func_res);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
void ldv_flush_workqueue_52(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 386
  flush_workqueue(ldv_func_arg1);
#line 388
  call_and_disable_all_1(2);
#line 389
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
bool ldv_queue_delayed_work_on_53(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 395
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 395
  ldv_func_res = tmp;
#line 397
  activate_work_1(& ldv_func_arg3->work, 2);
#line 399
  return (ldv_func_res);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
void ldv_mutex_lock_54(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 405
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 407
  mutex_lock(ldv_func_arg1);
#line 408
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
void ldv_mutex_unlock_55(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 413
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 415
  mutex_unlock(ldv_func_arg1);
#line 416
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
void ldv_mutex_lock_56(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 421
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 423
  mutex_lock(ldv_func_arg1);
#line 424
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
int ldv_mutex_trylock_57(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 430
  tmp = mutex_trylock(ldv_func_arg1);
#line 430
  ldv_func_res = tmp;
#line 432
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 432
  return (tmp___0);
#line 434
  return (ldv_func_res);
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
void ldv_mutex_unlock_58(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 440
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 442
  mutex_unlock(ldv_func_arg1);
#line 443
  return;
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
void ldv_mutex_unlock_59(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 448
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 450
  mutex_unlock(ldv_func_arg1);
#line 451
  return;
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
void ldv_mutex_lock_60(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 456
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 458
  mutex_lock(ldv_func_arg1);
#line 459
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
void ldv_mutex_lock_61(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 464
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 466
  mutex_lock(ldv_func_arg1);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-audio.o.c.prepared"
void ldv_mutex_unlock_62(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 472
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 474
  mutex_unlock(ldv_func_arg1);
#line 475
  return;
}
}
#line 1 "<compiler builtins>"
void ldv__builtin_va_end(__builtin_va_list  ) ;
#line 1
void ldv__builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;
#line 1
void ldv__builtin_va_start(__builtin_va_list  ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_89(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_87(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_90(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_91(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_94(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_97(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
void ldv_mutex_lock_86(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_88(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_92(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_93(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_95(struct mutex *ldv_func_arg1 ) ;
#line 229 "include/linux/timer.h"
extern int del_timer_sync(struct timer_list * ) ;
#line 232
int ldv_del_timer_sync_96(struct timer_list *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_81(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_83(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_82(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_85(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_84(struct workqueue_struct *ldv_func_arg1 ) ;
#line 291 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
void disable_suitable_timer_2(struct timer_list *timer ) ;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-encoder.h"
int pvr2_encoder_adjust(struct pvr2_hdw *hdw ) ;
#line 28
int pvr2_encoder_configure(struct pvr2_hdw *hdw ) ;
#line 29
int pvr2_encoder_start(struct pvr2_hdw *hdw ) ;
#line 30
int pvr2_encoder_stop(struct pvr2_hdw *hdw ) ;
#line 251 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw.h"
int pvr2_write_register(struct pvr2_hdw *hdw , u16 reg , u32 data ) ;
#line 93 "include/media/cx2341x.h"
extern int cx2341x_update(void * , int (*)(void * , u32  , int  , int  , u32 * ) ,
                          struct cx2341x_mpeg_params  const  * , struct cx2341x_mpeg_params  const  * ) ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.c"
static int pvr2_encoder_write_words(struct pvr2_hdw *hdw , unsigned int offs , u32 const   *data ,
                                    unsigned int dlen ) 
{ 
  unsigned int idx ;
  unsigned int addr ;
  unsigned int bAddr ;
  int ret ;
  unsigned int chunkCnt ;
  unsigned int tmp ;

  {
#line 59
  goto ldv_51841;
  ldv_51840: 
#line 60
  chunkCnt = 8U;
#line 61
  if (chunkCnt > dlen) {
#line 61
    chunkCnt = dlen;
  } else {

  }
#line 62
  memset((void *)(& hdw->cmd_buffer), 0, 64UL);
#line 63
  bAddr = 0U;
#line 64
  tmp = bAddr;
#line 64
  bAddr = bAddr + 1U;
#line 64
  hdw->cmd_buffer[tmp] = 1U;
#line 65
  idx = 0U;
#line 65
  goto ldv_51838;
  ldv_51837: 
#line 66
  addr = idx + offs;
#line 67
  hdw->cmd_buffer[bAddr + 6U] = (unsigned char )addr;
#line 68
  hdw->cmd_buffer[bAddr + 5U] = (unsigned char )(addr >> 8);
#line 69
  hdw->cmd_buffer[bAddr + 4U] = (unsigned char )(addr >> 16);
#line 70
  hdw->cmd_buffer[bAddr] = (unsigned char )*(data + (unsigned long )idx);
#line 70
  hdw->cmd_buffer[bAddr + 1U] = (unsigned char )(*(data + (unsigned long )idx) >> 8);
#line 70
  hdw->cmd_buffer[bAddr + 2U] = (unsigned char )(*(data + (unsigned long )idx) >> 16);
#line 70
  hdw->cmd_buffer[bAddr + 3U] = (unsigned char )(*(data + (unsigned long )idx) >> 24);
#line 71
  bAddr = bAddr + 7U;
#line 65
  idx = idx + 1U;
  ldv_51838: ;
#line 65
  if (idx < chunkCnt) {
#line 67
    goto ldv_51837;
  } else {

  }
#line 73
  ret = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), chunkCnt * 7U + 1U, (void *)0,
                          0U);
#line 76
  if (ret != 0) {
#line 76
    return (ret);
  } else {

  }
#line 77
  data = data + (unsigned long )chunkCnt;
#line 78
  dlen = dlen - chunkCnt;
#line 79
  offs = offs + chunkCnt;
  ldv_51841: ;
#line 59
  if (dlen != 0U) {
#line 61
    goto ldv_51840;
  } else {

  }

#line 82
  return (0);
}
}
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.c"
static int pvr2_encoder_read_words(struct pvr2_hdw *hdw , unsigned int offs , u32 *data ,
                                   unsigned int dlen ) 
{ 
  unsigned int idx ;
  int ret ;
  unsigned int chunkCnt ;

  {
#line 104
  goto ldv_51856;
  ldv_51855: 
#line 105
  chunkCnt = 16U;
#line 106
  if (chunkCnt > dlen) {
#line 106
    chunkCnt = dlen;
  } else {

  }
#line 107
  if (chunkCnt <= 15U) {
#line 107
    chunkCnt = 1U;
  } else {

  }
#line 108
  hdw->cmd_buffer[0] = chunkCnt == 1U ? 2U : 40U;
#line 111
  hdw->cmd_buffer[1] = 0U;
#line 112
  hdw->cmd_buffer[2] = 0U;
#line 113
  hdw->cmd_buffer[3] = 0U;
#line 114
  hdw->cmd_buffer[4] = 0U;
#line 115
  hdw->cmd_buffer[5] = (unsigned char )(offs >> 16);
#line 116
  hdw->cmd_buffer[6] = (unsigned char )(offs >> 8);
#line 117
  hdw->cmd_buffer[7] = (unsigned char )offs;
#line 118
  ret = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), 8U, (void *)(& hdw->cmd_buffer),
                          chunkCnt == 1U ? 4U : 64U);
#line 122
  if (ret != 0) {
#line 122
    return (ret);
  } else {

  }
#line 124
  idx = 0U;
#line 124
  goto ldv_51853;
  ldv_51852: 
#line 125
  *(data + (unsigned long )idx) = ((((unsigned int )hdw->cmd_buffer[idx * 4U + 3U] << 24) | ((unsigned int )hdw->cmd_buffer[idx * 4U + 2U] << 16)) | ((unsigned int )hdw->cmd_buffer[idx * 4U + 1U] << 8)) | (unsigned int )hdw->cmd_buffer[idx * 4U];
#line 124
  idx = idx + 1U;
  ldv_51853: ;
#line 124
  if (idx < chunkCnt) {
#line 126
    goto ldv_51852;
  } else {

  }
#line 127
  data = data + (unsigned long )chunkCnt;
#line 128
  dlen = dlen - chunkCnt;
#line 129
  offs = offs + chunkCnt;
  ldv_51856: ;
#line 104
  if (dlen != 0U) {
#line 106
    goto ldv_51855;
  } else {

  }

#line 132
  return (0);
}
}
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.c"
static int pvr2_encoder_cmd(void *ctxt , u32 cmd , int arg_cnt_send , int arg_cnt_recv ,
                            u32 *argp ) 
{ 
  unsigned int poll_count ;
  unsigned int try_count ;
  int retry_flag ;
  int ret ;
  unsigned int idx ;
  u32 wrData[16U] ;
  u32 rdData[16U] ;
  struct pvr2_hdw *hdw ;

  {
#line 148
  try_count = 0U;
#line 150
  ret = 0;
#line 155
  hdw = (struct pvr2_hdw *)ctxt;
#line 188
  if ((unsigned int )arg_cnt_send > 12U) {
#line 189
    if ((pvrusb2_debug & 2) != 0) {
#line 189
      printk("\016pvrusb2: Failed to write cx23416 command - too many input arguments (was given %u limit %lu)\n",
             arg_cnt_send, 12UL);
    } else {

    }
#line 195
    return (-22);
  } else {

  }
#line 198
  if ((unsigned int )arg_cnt_recv > 12U) {
#line 199
    if ((pvrusb2_debug & 2) != 0) {
#line 199
      printk("\016pvrusb2: Failed to write cx23416 command - too many return arguments (was given %u limit %lu)\n",
             arg_cnt_recv, 12UL);
    } else {

    }
#line 205
    return (-22);
  } else {

  }
#line 209
  ldv_mutex_lock_95(& hdw->ctl_lock_mutex);
#line 209
  hdw->ctl_lock_held = 1;
#line 211
  if (hdw->state_encoder_ok == 0) {
#line 212
    ret = -5;
#line 213
    goto ldv_51881;
  } else {

  }
#line 216
  retry_flag = 0;
#line 217
  try_count = try_count + 1U;
#line 218
  ret = 0;
#line 219
  wrData[0] = 0U;
#line 220
  wrData[1] = cmd;
#line 221
  wrData[2] = 0U;
#line 222
  wrData[3] = 393216U;
#line 223
  idx = 0U;
#line 223
  goto ldv_51883;
  ldv_51882: 
#line 224
  wrData[idx + 4U] = *(argp + (unsigned long )idx);
#line 223
  idx = idx + 1U;
  ldv_51883: ;
#line 223
  if ((unsigned int )arg_cnt_send > idx) {
#line 225
    goto ldv_51882;
  } else {

  }

#line 226
  goto ldv_51888;
  ldv_51887: 
#line 227
  wrData[idx + 4U] = 0U;
#line 226
  idx = idx + 1U;
  ldv_51888: ;
#line 226
  if (idx <= 11U) {
#line 228
    goto ldv_51887;
  } else {

  }
#line 230
  ret = pvr2_encoder_write_words(hdw, 68U, (u32 const   *)(& wrData), idx);
#line 231
  if (ret != 0) {
#line 231
    goto ldv_51881;
  } else {

  }
#line 232
  wrData[0] = 3U;
#line 233
  ret = pvr2_encoder_write_words(hdw, 68U, (u32 const   *)(& wrData), 1U);
#line 234
  if (ret != 0) {
#line 234
    goto ldv_51881;
  } else {

  }
#line 235
  poll_count = 0U;
  ldv_51895: 
#line 237
  poll_count = poll_count + 1U;
#line 238
  ret = pvr2_encoder_read_words(hdw, 68U, (u32 *)(& rdData), (unsigned int )(arg_cnt_recv + 4));
#line 240
  if (ret != 0) {
#line 241
    goto ldv_51890;
  } else {

  }
#line 243
  if ((rdData[0] & 4U) != 0U) {
#line 244
    goto ldv_51890;
  } else {

  }
#line 246
  if (rdData[0] != 0U && poll_count <= 999U) {
#line 246
    goto ldv_51891;
  } else {

  }
#line 247
  if (rdData[0] == 0U) {
#line 248
    retry_flag = 1;
#line 249
    if ((pvrusb2_debug & 2) != 0) {
#line 249
      printk("\016pvrusb2: Encoder timed out waiting for us; arranging to retry\n");
    } else {

    }
  } else
#line 254
  if ((pvrusb2_debug & 2) != 0) {
#line 254
    printk("\016pvrusb2: ***WARNING*** device\'s encoder appears to be stuck (status=0x%08x)\n",
           rdData[0]);
  } else {

  }
#line 260
  if ((pvrusb2_debug & 2) != 0) {
#line 260
    printk("\016pvrusb2: Encoder command: 0x%02x\n", cmd);
  } else {

  }
#line 263
  idx = 4U;
#line 263
  goto ldv_51893;
  ldv_51892: ;
#line 264
  if ((pvrusb2_debug & 2) != 0) {
#line 264
    printk("\016pvrusb2: Encoder arg%d: 0x%08x\n", idx - 3U, wrData[idx]);
  } else {

  }
#line 263
  idx = idx + 1U;
  ldv_51893: ;
#line 263
  if ((unsigned int )arg_cnt_send > idx) {
#line 265
    goto ldv_51892;
  } else {

  }
#line 269
  ret = -16;
#line 270
  goto ldv_51890;
  ldv_51891: ;
#line 271
  goto ldv_51895;
  ldv_51890: ;
#line 272
  if (retry_flag != 0) {
#line 273
    if (try_count <= 19U) {
#line 273
      goto ldv_51896;
    } else {

    }
#line 274
    if ((pvrusb2_debug & 2) != 0) {
#line 274
      printk("\016pvrusb2: Too many retries...\n");
    } else {

    }
#line 277
    ret = -16;
  } else {

  }
#line 279
  if (ret != 0) {
#line 280
    ldv_del_timer_sync_96(& hdw->encoder_run_timer);
#line 281
    hdw->state_encoder_ok = 0;
#line 282
    if ((pvrusb2_debug & 512) != 0) {
#line 282
      printk("\016pvrusb2: State bit %s <-- %s\n", (char *)"state_encoder_ok", hdw->state_encoder_ok != 0 ? (char *)"true" : (char *)"false");
    } else {

    }
#line 286
    if (hdw->state_encoder_runok != 0) {
#line 287
      hdw->state_encoder_runok = 0;
#line 288
      if ((pvrusb2_debug & 512) != 0) {
#line 288
        printk("\016pvrusb2: State bit %s <-- %s\n", (char *)"state_encoder_runok",
               hdw->state_encoder_runok != 0 ? (char *)"true" : (char *)"false");
      } else {

      }
    } else {

    }
#line 294
    if ((pvrusb2_debug & 2) != 0) {
#line 294
      printk("\016pvrusb2: Giving up on command.  This is normally recovered via a firmware reload and re-initialization; concern is only warranted if this happens repeatedly and rapidly.\n");
    } else {

    }
#line 301
    goto ldv_51881;
  } else {

  }
#line 303
  wrData[0] = 7U;
#line 304
  idx = 0U;
#line 304
  goto ldv_51898;
  ldv_51897: 
#line 305
  *(argp + (unsigned long )idx) = rdData[idx + 4U];
#line 304
  idx = idx + 1U;
  ldv_51898: ;
#line 304
  if ((unsigned int )arg_cnt_recv > idx) {
#line 306
    goto ldv_51897;
  } else {

  }
#line 308
  wrData[0] = 0U;
#line 309
  ret = pvr2_encoder_write_words(hdw, 68U, (u32 const   *)(& wrData), 1U);
#line 310
  if (ret != 0) {
#line 310
    goto ldv_51881;
  } else {

  }
  ldv_51896: ;
  ldv_51881: 
#line 312
  hdw->ctl_lock_held = 0;
#line 312
  ldv_mutex_unlock_97(& hdw->ctl_lock_mutex);
#line 314
  return (ret);
}
}
#line 318 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.c"
static int pvr2_encoder_vcmd(struct pvr2_hdw *hdw , int cmd , int args  , ...) 
{ 
  va_list vl ;
  unsigned int idx ;
  u32 data[12U] ;
  u32 tmp ;
  int tmp___0 ;

  {
#line 325
  if ((unsigned int )args > 12U) {
#line 326
    if ((pvrusb2_debug & 2) != 0) {
#line 326
      printk("\016pvrusb2: Failed to write cx23416 command - too many arguments (was given %u limit %lu)\n",
             args, 12UL);
    } else {

    }
#line 332
    return (-22);
  } else {

  }
#line 335
  ldv__builtin_va_start((va_list *)(& vl));
#line 336
  idx = 0U;
#line 336
  goto ldv_51913;
  ldv_51912: 
#line 337
  ldv__builtin_va_arg(vl, sizeof(u32 ), (void *)(& tmp));
#line 337
  data[idx] = tmp;
#line 336
  idx = idx + 1U;
  ldv_51913: ;
#line 336
  if ((unsigned int )args > idx) {
#line 338
    goto ldv_51912;
  } else {

  }
#line 339
  ldv__builtin_va_end((va_list *)(& vl));
#line 341
  tmp___0 = pvr2_encoder_cmd((void *)hdw, (u32 )cmd, args, 0, (u32 *)(& data));
#line 341
  return (tmp___0);
}
}
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.c"
static int pvr2_encoder_prep_config(struct pvr2_hdw *hdw ) 
{ 
  int ret ;
  int encMisc3Arg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 349
  ret = 0;
#line 350
  encMisc3Arg = 0;
#line 386
  if ((unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) != 0U) {
#line 387
    encMisc3Arg = 1;
  } else {
#line 389
    encMisc3Arg = 0;
  }
#line 391
  tmp = pvr2_encoder_vcmd(hdw, 220, 4, 3, encMisc3Arg, 0, 0);
#line 391
  ret = tmp | ret;
#line 394
  tmp___0 = pvr2_encoder_vcmd(hdw, 220, 4, 8, 0, 0, 0);
#line 394
  ret = tmp___0 | ret;
#line 405
  tmp___1 = pvr2_encoder_vcmd(hdw, 220, 4, 0, 3, 0, 0);
#line 405
  ret = tmp___1 | ret;
#line 406
  tmp___2 = pvr2_encoder_vcmd(hdw, 220, 4, 15, 0, 0, 0);
#line 406
  ret = tmp___2 | ret;
#line 410
  tmp___3 = pvr2_encoder_vcmd(hdw, 220, 2, 4, 1);
#line 410
  ret = tmp___3 | ret;
#line 412
  return (ret);
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.c"
int pvr2_encoder_adjust(struct pvr2_hdw *hdw ) 
{ 
  int ret ;

  {
#line 418
  ret = cx2341x_update((void *)hdw, & pvr2_encoder_cmd, hdw->enc_cur_valid != 0 ? (struct cx2341x_mpeg_params  const  *)(& hdw->enc_cur_state) : (struct cx2341x_mpeg_params  const  *)0,
                       (struct cx2341x_mpeg_params  const  *)(& hdw->enc_ctl_state));
#line 421
  if (ret != 0) {
#line 422
    if ((pvrusb2_debug & 2) != 0) {
#line 422
      printk("\016pvrusb2: Error from cx2341x module code=%d\n", ret);
    } else {

    }
  } else {
#line 425
    hdw->enc_cur_state = hdw->enc_ctl_state;
#line 426
    hdw->enc_cur_valid = 1;
  }
#line 428
  return (ret);
}
}
#line 432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.c"
int pvr2_encoder_configure(struct pvr2_hdw *hdw ) 
{ 
  int ret ;
  int val ;
  int tmp ;

  {
#line 436
  if ((pvrusb2_debug & 4194304) != 0) {
#line 436
    printk("\016pvrusb2: pvr2_encoder_configure (cx2341x module)\n");
  } else {

  }
#line 438
  hdw->enc_ctl_state.port = 1;
#line 439
  hdw->enc_ctl_state.width = (u16 )hdw->res_hor_val;
#line 440
  hdw->enc_ctl_state.height = (u16 )hdw->res_ver_val;
#line 441
  hdw->enc_ctl_state.is_50hz = (hdw->std_mask_cur & 63744ULL) == 0ULL;
#line 444
  ret = 0;
#line 446
  tmp = pvr2_encoder_prep_config(hdw);
#line 446
  ret = tmp | ret;
#line 449
  val = 240;
#line 450
  if ((unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) != 0U) {
#line 452
    val = 320;
  } else {

  }
#line 455
  if (ret == 0) {
#line 455
    ret = pvr2_encoder_vcmd(hdw, 214, 2, val, val);
  } else {

  }
#line 460
  if (ret == 0) {
#line 460
    ret = pvr2_encoder_vcmd(hdw, 213, 4, 0, 0, 268435456, 4294967295U);
  } else {

  }
#line 464
  if (ret == 0) {
#line 464
    ret = pvr2_encoder_vcmd(hdw, 183, 5, 4294967295U, 0, 0, 0, 0);
  } else {

  }
#line 468
  if (ret != 0) {
#line 469
    if ((pvrusb2_debug & 2) != 0) {
#line 469
      printk("\016pvrusb2: Failed to configure cx23416\n");
    } else {

    }
#line 471
    return (ret);
  } else {

  }
#line 474
  ret = pvr2_encoder_adjust(hdw);
#line 475
  if (ret != 0) {
#line 475
    return (ret);
  } else {

  }
#line 477
  ret = pvr2_encoder_vcmd(hdw, 205, 0);
#line 480
  if (ret != 0) {
#line 481
    if ((pvrusb2_debug & 2) != 0) {
#line 481
      printk("\016pvrusb2: Failed to initialize cx23416 video input\n");
    } else {

    }
#line 483
    return (ret);
  } else {

  }
#line 486
  return (0);
}
}
#line 490 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.c"
int pvr2_encoder_start(struct pvr2_hdw *hdw ) 
{ 
  int status ;

  {
#line 495
  pvr2_write_register(hdw, 72, 3221225471U);
#line 497
  pvr2_encoder_vcmd(hdw, 217, 1, hdw->input_val == 4);
#line 500
  switch ((unsigned int )hdw->active_stream_type) {
  case 2U: 
#line 502
  status = pvr2_encoder_vcmd(hdw, 129, 2, 1, 20);
#line 504
  goto ldv_51934;
  case 1U: 
#line 506
  status = pvr2_encoder_vcmd(hdw, 129, 2, 0, 19);
#line 508
  goto ldv_51934;
  default: 
#line 510
  status = pvr2_encoder_vcmd(hdw, 129, 2, 0, 19);
#line 512
  goto ldv_51934;
  }
  ldv_51934: ;
#line 514
  return (status);
}
}
#line 517 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.c"
int pvr2_encoder_stop(struct pvr2_hdw *hdw ) 
{ 
  int status ;

  {
#line 522
  pvr2_write_register(hdw, 72, 4294967295U);
#line 524
  switch ((unsigned int )hdw->active_stream_type) {
  case 2U: 
#line 526
  status = pvr2_encoder_vcmd(hdw, 130, 3, 1, 1, 20);
#line 528
  goto ldv_51942;
  case 1U: 
#line 530
  status = pvr2_encoder_vcmd(hdw, 130, 3, 1, 0, 19);
#line 532
  goto ldv_51942;
  default: 
#line 534
  status = pvr2_encoder_vcmd(hdw, 130, 3, 1, 0, 19);
#line 536
  goto ldv_51942;
  }
  ldv_51942: ;
#line 539
  return (status);
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
bool ldv_queue_work_on_81(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 354
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 354
  ldv_func_res = tmp;
#line 356
  activate_work_1(ldv_func_arg3, 2);
#line 358
  return (ldv_func_res);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
bool ldv_queue_delayed_work_on_82(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 365
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 365
  ldv_func_res = tmp;
#line 367
  activate_work_1(& ldv_func_arg3->work, 2);
#line 369
  return (ldv_func_res);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
bool ldv_queue_work_on_83(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 376
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 376
  ldv_func_res = tmp;
#line 378
  activate_work_1(ldv_func_arg3, 2);
#line 380
  return (ldv_func_res);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
void ldv_flush_workqueue_84(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 386
  flush_workqueue(ldv_func_arg1);
#line 388
  call_and_disable_all_1(2);
#line 389
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
bool ldv_queue_delayed_work_on_85(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 395
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 395
  ldv_func_res = tmp;
#line 397
  activate_work_1(& ldv_func_arg3->work, 2);
#line 399
  return (ldv_func_res);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
void ldv_mutex_lock_86(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 405
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 407
  mutex_lock(ldv_func_arg1);
#line 408
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
void ldv_mutex_unlock_87(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 413
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 415
  mutex_unlock(ldv_func_arg1);
#line 416
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
void ldv_mutex_lock_88(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 421
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 423
  mutex_lock(ldv_func_arg1);
#line 424
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
int ldv_mutex_trylock_89(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 430
  tmp = mutex_trylock(ldv_func_arg1);
#line 430
  ldv_func_res = tmp;
#line 432
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 432
  return (tmp___0);
#line 434
  return (ldv_func_res);
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
void ldv_mutex_unlock_90(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 440
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 442
  mutex_unlock(ldv_func_arg1);
#line 443
  return;
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
void ldv_mutex_unlock_91(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 448
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 450
  mutex_unlock(ldv_func_arg1);
#line 451
  return;
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
void ldv_mutex_lock_92(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 456
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 458
  mutex_lock(ldv_func_arg1);
#line 459
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
void ldv_mutex_lock_93(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 464
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 466
  mutex_lock(ldv_func_arg1);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
void ldv_mutex_unlock_94(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 472
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 474
  mutex_unlock(ldv_func_arg1);
#line 475
  return;
}
}
#line 477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
void ldv_mutex_lock_95(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 480
  ldv_mutex_lock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 482
  mutex_lock(ldv_func_arg1);
#line 483
  return;
}
}
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
int ldv_del_timer_sync_96(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 489
  tmp = del_timer_sync(ldv_func_arg1);
#line 489
  ldv_func_res = tmp;
#line 491
  disable_suitable_timer_2(ldv_func_arg1);
#line 493
  return (ldv_func_res);
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-encoder.o.c.prepared"
void ldv_mutex_unlock_97(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 499
  ldv_mutex_unlock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 501
  mutex_unlock(ldv_func_arg1);
#line 502
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_127(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_125(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_128(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_129(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_132(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
void ldv_mutex_lock_124(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_126(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_130(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_131(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_119(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_121(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_120(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_123(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_122(struct workqueue_struct *ldv_func_arg1 ) ;
#line 36 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.h"
void pvr2_saa7115_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) ;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.c"
static int const   routing_scheme0___0[5U]  = {      4,      0,      5,      8, 
        5};
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.c"
static struct routing_scheme  const  routing_def0___0  =    {(int const   *)(& routing_scheme0___0), 5U};
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.c"
static int const   routing_scheme1[5U]  = {      4,      0,      3,      8, 
        5};
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.c"
static struct routing_scheme  const  routing_def1  =    {(int const   *)(& routing_scheme1), 5U};
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.c"
static struct routing_scheme  const  *routing_schemes___0[3U]  = {      & routing_def0___0,      0,      & routing_def1};
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.c"
void pvr2_saa7115_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) 
{ 
  struct routing_scheme  const  *sp ;
  unsigned int sid ;
  u32 input ;

  {
#line 80
  if (hdw->input_dirty != 0 || hdw->force_dirty != 0) {
#line 82
    sid = (unsigned int )(hdw->hdw_desc)->signal_routing_scheme;
#line 85
    if ((pvrusb2_debug & 65536) != 0) {
#line 85
      printk("\016pvrusb2: subdev v4l2 set_input(%d)\n", hdw->input_val);
    } else {

    }
#line 88
    sp = sid <= 2U ? routing_schemes___0[sid] : (struct routing_scheme  const  *)0;
#line 90
    if (((unsigned long )sp == (unsigned long )((struct routing_scheme  const  *)0) || hdw->input_val < 0) || (unsigned int )hdw->input_val >= (unsigned int )sp->cnt) {
#line 93
      if ((pvrusb2_debug & 2) != 0) {
#line 93
        printk("\016pvrusb2: *** WARNING *** subdev v4l2 set_input: Invalid routing scheme (%u) and/or input (%d)\n",
               sid, hdw->input_val);
      } else {

      }
#line 98
      return;
    } else {

    }
#line 100
    input = (u32 )*(sp->def + (unsigned long )hdw->input_val);
#line 101
    (*(((sd->ops)->video)->s_routing))(sd, input, 0U, 0U);
  } else {

  }
#line 103
  return;
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
bool ldv_queue_work_on_119(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 354
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 354
  ldv_func_res = tmp;
#line 356
  activate_work_1(ldv_func_arg3, 2);
#line 358
  return (ldv_func_res);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
bool ldv_queue_delayed_work_on_120(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 365
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 365
  ldv_func_res = tmp;
#line 367
  activate_work_1(& ldv_func_arg3->work, 2);
#line 369
  return (ldv_func_res);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
bool ldv_queue_work_on_121(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 376
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 376
  ldv_func_res = tmp;
#line 378
  activate_work_1(ldv_func_arg3, 2);
#line 380
  return (ldv_func_res);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
void ldv_flush_workqueue_122(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 386
  flush_workqueue(ldv_func_arg1);
#line 388
  call_and_disable_all_1(2);
#line 389
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
bool ldv_queue_delayed_work_on_123(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 395
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 395
  ldv_func_res = tmp;
#line 397
  activate_work_1(& ldv_func_arg3->work, 2);
#line 399
  return (ldv_func_res);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
void ldv_mutex_lock_124(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 405
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 407
  mutex_lock(ldv_func_arg1);
#line 408
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
void ldv_mutex_unlock_125(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 413
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 415
  mutex_unlock(ldv_func_arg1);
#line 416
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
void ldv_mutex_lock_126(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 421
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 423
  mutex_lock(ldv_func_arg1);
#line 424
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
int ldv_mutex_trylock_127(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 430
  tmp = mutex_trylock(ldv_func_arg1);
#line 430
  ldv_func_res = tmp;
#line 432
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 432
  return (tmp___0);
#line 434
  return (ldv_func_res);
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
void ldv_mutex_unlock_128(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 440
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 442
  mutex_unlock(ldv_func_arg1);
#line 443
  return;
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
void ldv_mutex_unlock_129(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 448
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 450
  mutex_unlock(ldv_func_arg1);
#line 451
  return;
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
void ldv_mutex_lock_130(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 456
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 458
  mutex_lock(ldv_func_arg1);
#line 459
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
void ldv_mutex_lock_131(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 464
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 466
  mutex_lock(ldv_func_arg1);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-video-v4l.o.c.prepared"
void ldv_mutex_unlock_132(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 472
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 474
  mutex_unlock(ldv_func_arg1);
#line 475
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_159(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_157(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_160(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_161(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_164(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
void ldv_mutex_lock_156(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_158(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_162(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_163(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_151(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_153(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_152(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_155(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_154(struct workqueue_struct *ldv_func_arg1 ) ;
#line 143 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 289
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 418 "include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 435
  tmp___2 = __kmalloc(size, flags);
#line 435
  return (tmp___2);
}
}
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-eeprom.h"
int pvr2_eeprom_analyze(struct pvr2_hdw *hdw ) ;
#line 48 "include/media/tveeprom.h"
extern void tveeprom_hauppauge_analog(struct i2c_client * , struct tveeprom * , unsigned char * ) ;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c"
static u8 *pvr2_eeprom_fetch(struct pvr2_hdw *hdw ) 
{ 
  struct i2c_msg msg[2U] ;
  u8 *eeprom ;
  u8 iadd[2U] ;
  u8 addr ;
  u16 eepromSize ;
  unsigned int offs ;
  int ret ;
  int mode16 ;
  unsigned int pcnt ;
  unsigned int tcnt ;
  void *tmp ;

  {
#line 54
  mode16 = 0;
#line 56
  tmp = kmalloc(128UL, 208U);
#line 56
  eeprom = (u8 *)tmp;
#line 57
  if ((unsigned long )eeprom == (unsigned long )((u8 *)0U)) {
#line 58
    if ((pvrusb2_debug & 2) != 0) {
#line 58
      printk("\016pvrusb2: Failed to allocate memory required to read eeprom\n");
    } else {

    }
#line 61
    return ((u8 *)0U);
  } else {

  }
#line 64
  if ((pvrusb2_debug & 1024) != 0) {
#line 64
    printk("\016pvrusb2: Value for eeprom addr from controller was 0x%x\n", hdw->eeprom_addr);
  } else {

  }
#line 66
  addr = (u8 )hdw->eeprom_addr;
#line 70
  if ((int )((signed char )addr) < 0) {
#line 70
    addr = (u8 )((int )addr >> 1);
  } else {

  }
#line 75
  mode16 = (int )addr & 1;
#line 76
  eepromSize = mode16 != 0 ? 4096U : 256U;
#line 77
  if ((pvrusb2_debug & 1024) != 0) {
#line 77
    printk("\016pvrusb2: Examining %d byte eeprom at location 0x%x using %d bit addressing\n",
           (int )eepromSize, (int )addr, mode16 != 0 ? 16 : 8);
  } else {

  }
#line 81
  msg[0].addr = (__u16 )addr;
#line 82
  msg[0].flags = 0U;
#line 83
  msg[0].len = mode16 != 0 ? 2U : 1U;
#line 84
  msg[0].buf = (__u8 *)(& iadd);
#line 85
  msg[1].addr = (__u16 )addr;
#line 86
  msg[1].flags = 1U;
#line 92
  memset((void *)eeprom, 0, 128UL);
#line 93
  tcnt = 0U;
#line 93
  goto ldv_51827;
  ldv_51826: 
#line 94
  pcnt = 16U;
#line 95
  if (pcnt + tcnt > 128U) {
#line 95
    pcnt = 128U - tcnt;
  } else {

  }
#line 96
  offs = ((unsigned int )eepromSize + tcnt) + 4294967168U;
#line 97
  if (mode16 != 0) {
#line 98
    iadd[0] = (u8 )(offs >> 8);
#line 99
    iadd[1] = (u8 )offs;
  } else {
#line 101
    iadd[0] = (u8 )offs;
  }
#line 103
  msg[1].len = (__u16 )pcnt;
#line 104
  msg[1].buf = eeprom + (unsigned long )tcnt;
#line 105
  ret = i2c_transfer(& hdw->i2c_adap, (struct i2c_msg *)(& msg), 2);
#line 105
  if (ret != 2) {
#line 107
    if ((pvrusb2_debug & 2) != 0) {
#line 107
      printk("\016pvrusb2: eeprom fetch set offs err=%d\n", ret);
    } else {

    }
#line 109
    kfree((void const   *)eeprom);
#line 110
    return ((u8 *)0U);
  } else {

  }
#line 93
  tcnt = tcnt + pcnt;
  ldv_51827: ;
#line 93
  if (tcnt <= 127U) {
#line 95
    goto ldv_51826;
  } else {

  }

#line 113
  return (eeprom);
}
}
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c"
int pvr2_eeprom_analyze(struct pvr2_hdw *hdw ) 
{ 
  u8 *eeprom ;
  struct tveeprom tvdata ;
  struct i2c_client fake_client ;

  {
#line 123
  memset((void *)(& tvdata), 0, 76UL);
#line 125
  eeprom = pvr2_eeprom_fetch(hdw);
#line 126
  if ((unsigned long )eeprom == (unsigned long )((u8 *)0U)) {
#line 126
    return (-22);
  } else {

  }
#line 131
  fake_client.addr = (unsigned short )hdw->eeprom_addr;
#line 132
  fake_client.adapter = & hdw->i2c_adap;
#line 133
  tveeprom_hauppauge_analog(& fake_client, & tvdata, eeprom);
#line 136
  if ((pvrusb2_debug & 1024) != 0) {
#line 136
    printk("\016pvrusb2: eeprom assumed v4l tveeprom module\n");
  } else {

  }
#line 137
  if ((pvrusb2_debug & 1024) != 0) {
#line 137
    printk("\016pvrusb2: eeprom direct call results:\n");
  } else {

  }
#line 138
  if ((pvrusb2_debug & 1024) != 0) {
#line 138
    printk("\016pvrusb2: has_radio=%d\n", tvdata.has_radio);
  } else {

  }
#line 139
  if ((pvrusb2_debug & 1024) != 0) {
#line 139
    printk("\016pvrusb2: tuner_type=%d\n", tvdata.tuner_type);
  } else {

  }
#line 140
  if ((pvrusb2_debug & 1024) != 0) {
#line 140
    printk("\016pvrusb2: tuner_formats=0x%x\n", tvdata.tuner_formats);
  } else {

  }
#line 141
  if ((pvrusb2_debug & 1024) != 0) {
#line 141
    printk("\016pvrusb2: audio_processor=%d\n", tvdata.audio_processor);
  } else {

  }
#line 142
  if ((pvrusb2_debug & 1024) != 0) {
#line 142
    printk("\016pvrusb2: model=%d\n", tvdata.model);
  } else {

  }
#line 143
  if ((pvrusb2_debug & 1024) != 0) {
#line 143
    printk("\016pvrusb2: revision=%d\n", tvdata.revision);
  } else {

  }
#line 144
  if ((pvrusb2_debug & 1024) != 0) {
#line 144
    printk("\016pvrusb2: serial_number=%d\n", tvdata.serial_number);
  } else {

  }
#line 145
  if ((pvrusb2_debug & 1024) != 0) {
#line 145
    printk("\016pvrusb2: rev_str=%s\n", (char *)(& tvdata.rev_str));
  } else {

  }
#line 146
  hdw->tuner_type = tvdata.tuner_type;
#line 147
  hdw->tuner_updated = 1;
#line 148
  hdw->serial_number = (unsigned long )tvdata.serial_number;
#line 149
  hdw->std_mask_eeprom = (v4l2_std_id )tvdata.tuner_formats;
#line 151
  kfree((void const   *)eeprom);
#line 153
  return (0);
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
bool ldv_queue_work_on_151(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 354
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 354
  ldv_func_res = tmp;
#line 356
  activate_work_1(ldv_func_arg3, 2);
#line 358
  return (ldv_func_res);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
bool ldv_queue_delayed_work_on_152(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 365
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 365
  ldv_func_res = tmp;
#line 367
  activate_work_1(& ldv_func_arg3->work, 2);
#line 369
  return (ldv_func_res);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
bool ldv_queue_work_on_153(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 376
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 376
  ldv_func_res = tmp;
#line 378
  activate_work_1(ldv_func_arg3, 2);
#line 380
  return (ldv_func_res);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
void ldv_flush_workqueue_154(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 386
  flush_workqueue(ldv_func_arg1);
#line 388
  call_and_disable_all_1(2);
#line 389
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
bool ldv_queue_delayed_work_on_155(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 395
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 395
  ldv_func_res = tmp;
#line 397
  activate_work_1(& ldv_func_arg3->work, 2);
#line 399
  return (ldv_func_res);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
void ldv_mutex_lock_156(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 405
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 407
  mutex_lock(ldv_func_arg1);
#line 408
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
void ldv_mutex_unlock_157(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 413
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 415
  mutex_unlock(ldv_func_arg1);
#line 416
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
void ldv_mutex_lock_158(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 421
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 423
  mutex_lock(ldv_func_arg1);
#line 424
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
int ldv_mutex_trylock_159(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 430
  tmp = mutex_trylock(ldv_func_arg1);
#line 430
  ldv_func_res = tmp;
#line 432
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 432
  return (tmp___0);
#line 434
  return (ldv_func_res);
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
void ldv_mutex_unlock_160(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 440
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 442
  mutex_unlock(ldv_func_arg1);
#line 443
  return;
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
void ldv_mutex_unlock_161(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 448
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 450
  mutex_unlock(ldv_func_arg1);
#line 451
  return;
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
void ldv_mutex_lock_162(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 456
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 458
  mutex_lock(ldv_func_arg1);
#line 459
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
void ldv_mutex_lock_163(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 464
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 466
  mutex_lock(ldv_func_arg1);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.o.c.prepared"
void ldv_mutex_unlock_164(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 472
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 474
  mutex_unlock(ldv_func_arg1);
#line 475
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_191(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_189(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_192(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_193(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
void ldv_mutex_lock_188(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_190(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_194(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_183(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_185(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_184(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_187(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_186(struct workqueue_struct *ldv_func_arg1 ) ;
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_2_0  ;
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_0  ;
#line 196 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_5_2  ;
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_work_1_1  ;
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_12  ;
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_5_0  ;
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_14  ;
#line 201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_3_2  ;
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_6_2  ;
#line 203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_2_2  ;
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_3_3  ;
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_5_3  ;
#line 206 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_4_3  ;
#line 207 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_9  ;
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_6_0  ;
#line 209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_5_1  ;
#line 210 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ref_cnt  ;
#line 211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_7  ;
#line 212 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct file *vdev_fops_group0  ;
#line 213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_6_3  ;
#line 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_6_2  ;
#line 215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct v4l2_control *pvr2_ioctl_ops_group4  ;
#line 216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct work_struct *ldv_work_struct_1_1  ;
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_4_0  ;
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct pvr2_dvb_adapter *pvr2_751xx_dvb_props_group0  ;
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_work_1_3  ;
#line 220 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_2_1  ;
#line 221 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_6  ;
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_2_0  ;
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_6_0  ;
#line 224 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int usb_counter  ;
#line 225 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct v4l2_format *pvr2_ioctl_ops_group3  ;
#line 226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_4_3  ;
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_5_3  ;
#line 229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_3_2  ;
#line 230 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_3  ;
#line 231 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct v4l2_audio *pvr2_ioctl_ops_group1  ;
#line 232 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_3_0  ;
#line 233 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_4_1  ;
#line 234 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_work_1_0  ;
#line 235 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_4_1  ;
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct pvr2_dvb_adapter *pvr2_750xx_dvb_props_group0  ;
#line 237 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_2_2  ;
#line 238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_4  ;
#line 239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_8  ;
#line 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_15  ;
#line 241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_4_0  ;
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct usb_interface *pvr_driver_group1  ;
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct work_struct *ldv_work_struct_1_3  ;
#line 244 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_2_1  ;
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_5_2  ;
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_5  ;
#line 247 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_13  ;
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_3_1  ;
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct pvr2_dvb_adapter *pvr2_73xxx_dvb_props_group0  ;
#line 250 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_5_1  ;
#line 251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_2_3  ;
#line 252 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_3_3  ;
#line 253 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct pvr2_dvb_adapter *pvr2_onair_usb2_fe_props_group0  ;
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_6_1  ;
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct v4l2_ext_controls *pvr2_ioctl_ops_group0  ;
#line 256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_3_1  ;
#line 257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct pvr2_dvb_adapter *pvr2_onair_creator_fe_props_group0  ;
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_1  ;
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_6_3  ;
#line 260 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_4_2  ;
#line 261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct work_struct *ldv_work_struct_1_0  ;
#line 262 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_10  ;
#line 263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_2  ;
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_5_0  ;
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct file *pvr2_ioctl_ops_group2  ;
#line 266 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_state_variable_11  ;
#line 267 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_work_1_2  ;
#line 268 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_4_2  ;
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct work_struct *ldv_work_struct_1_2  ;
#line 271 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_timer_6_1  ;
#line 272 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_2_3  ;
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct timer_list *ldv_timer_list_3_0  ;
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
struct i2c_adapter *pvr2_i2c_algo_template_group0  ;
#line 275
void ldv_initialize_pvr2_dvb_props_10(void) ;
#line 282
void timer_init_4(void) ;
#line 284
void timer_init_2(void) ;
#line 285
void ldv_initialize_pvr2_dvb_props_9(void) ;
#line 288
void timer_init_6(void) ;
#line 290
void timer_init_5(void) ;
#line 291
void work_init_1(void) ;
#line 299
void ldv_initialize_pvr2_dvb_props_7(void) ;
#line 305
void timer_init_3(void) ;
#line 307
void ldv_usb_driver_14(void) ;
#line 310
void ldv_initialize_v4l2_file_operations_12(void) ;
#line 311
void ldv_initialize_pvr2_dvb_props_11(void) ;
#line 316
void ldv_initialize_v4l2_ioctl_ops_13(void) ;
#line 320
void ldv_initialize_pvr2_dvb_props_8(void) ;
#line 863 "include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 865
  return ((void *)dev->driver_data);
}
}
#line 189 "include/linux/usb.h"
__inline static void *usb_get_intfdata(struct usb_interface *intf ) 
{ 
  void *tmp ;

  {
#line 191
  tmp = dev_get_drvdata((struct device  const  *)(& intf->dev));
#line 191
  return (tmp);
}
}
#line 194 "include/linux/usb.h"
__inline static void usb_set_intfdata(struct usb_interface *intf , void *data ) 
{ 


  {
#line 196
  dev_set_drvdata(& intf->dev, data);
#line 197
  return;
}
}
#line 1169
extern int usb_register_driver(struct usb_driver * , struct module * , char const   * ) ;
#line 1173
int ldv_usb_register_driver_195(struct usb_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                char const   *ldv_func_arg3 ) ;
#line 1180
extern void usb_deregister(struct usb_driver * ) ;
#line 1183
void ldv_usb_deregister_196(struct usb_driver *arg ) ;
#line 68 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-context.h"
struct pvr2_context *pvr2_context_create(struct usb_interface *intf , struct usb_device_id  const  *devid ,
                                         void (*setup_func)(struct pvr2_context * ) ) ;
#line 71
void pvr2_context_disconnect(struct pvr2_context *mp ) ;
#line 82
int pvr2_context_global_init(void) ;
#line 83
void pvr2_context_global_done(void) ;
#line 39 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-dvb.h"
struct pvr2_dvb_adapter *pvr2_dvb_create(struct pvr2_context *pvr ) ;
#line 187 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-devattr.h"
struct usb_device_id pvr2_device_table[12U] ;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-v4l2.h"
struct pvr2_v4l2 *pvr2_v4l2_create(struct pvr2_context *mnp ) ;
#line 30
struct pvr2_sysfs_class *pvr2_sysfs_class_create(void) ;
#line 31
void pvr2_sysfs_class_destroy(struct pvr2_sysfs_class *clp ) ;
#line 33 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-sysfs.h"
struct pvr2_sysfs *pvr2_sysfs_create(struct pvr2_context *mp , struct pvr2_sysfs_class *class_ptr___0 ) ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.c"
int pvrusb2_debug  =    31;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.c"
static struct pvr2_sysfs_class *class_ptr  =    (struct pvr2_sysfs_class *)0;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.c"
static void pvr_setup_attach(struct pvr2_context *pvr ) 
{ 


  {
#line 60
  pvr2_v4l2_create(pvr);
#line 63
  pvr2_dvb_create(pvr);
#line 66
  pvr2_sysfs_create(pvr, class_ptr);
#line 67
  return;
}
}
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.c"
static int pvr_probe(struct usb_interface *intf , struct usb_device_id  const  *devid ) 
{ 
  struct pvr2_context *pvr ;

  {
#line 76
  pvr = pvr2_context_create(intf, devid, & pvr_setup_attach);
#line 77
  if ((unsigned long )pvr == (unsigned long )((struct pvr2_context *)0)) {
#line 78
    if ((pvrusb2_debug & 2) != 0) {
#line 78
      printk("\016pvrusb2: Failed to create hdw handler\n");
    } else {

    }
#line 80
    return (-12);
  } else {

  }
#line 83
  if ((pvrusb2_debug & 32) != 0) {
#line 83
    printk("\016pvrusb2: pvr_probe(pvr=%p)\n", pvr);
  } else {

  }
#line 85
  usb_set_intfdata(intf, (void *)pvr);
#line 87
  return (0);
}
}
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.c"
static void pvr_disconnect(struct usb_interface *intf ) 
{ 
  struct pvr2_context *pvr ;
  void *tmp ;

  {
#line 96
  tmp = usb_get_intfdata(intf);
#line 96
  pvr = (struct pvr2_context *)tmp;
#line 98
  if ((pvrusb2_debug & 32) != 0) {
#line 98
    printk("\016pvrusb2: pvr_disconnect(pvr=%p) BEGIN\n", pvr);
  } else {

  }
#line 100
  usb_set_intfdata(intf, (void *)0);
#line 101
  pvr2_context_disconnect(pvr);
#line 103
  if ((pvrusb2_debug & 32) != 0) {
#line 103
    printk("\016pvrusb2: pvr_disconnect(pvr=%p) DONE\n", pvr);
  } else {

  }
#line 104
  return;
}
}
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.c"
static struct usb_driver pvr_driver  = 
#line 107
     {"pvrusb2", & pvr_probe, & pvr_disconnect, 0, 0, 0, 0, 0, 0, (struct usb_device_id  const  *)(& pvr2_device_table),
    {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}, {{0, 0, 0, 0, (_Bool)0,
                                                                0, 0, 0, 0, 0, 0,
                                                                0, 0, 0, 0, 0}, 0},
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0};
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.c"
static int pvr_init(void) 
{ 
  int ret ;

  {
#line 124
  if ((pvrusb2_debug & 32) != 0) {
#line 124
    printk("\016pvrusb2: pvr_init\n");
  } else {

  }
#line 126
  ret = pvr2_context_global_init();
#line 127
  if (ret != 0) {
#line 128
    if ((pvrusb2_debug & 32) != 0) {
#line 128
      printk("\016pvrusb2: pvr_init failure code=%d\n", ret);
    } else {

    }
#line 129
    return (ret);
  } else {

  }
#line 133
  class_ptr = pvr2_sysfs_class_create();
#line 136
  ret = ldv_usb_register_driver_195(& pvr_driver, & __this_module, "pvrusb2");
#line 138
  if (ret == 0) {
#line 139
    printk("\016pvrusb2: V4L in-tree version:Hauppauge WinTV-PVR-USB2 MPEG2 Encoder/Tuner\n");
  } else {

  }
#line 141
  if (pvrusb2_debug != 0) {
#line 142
    printk("\016pvrusb2: Debug mask is %d (0x%x)\n", pvrusb2_debug, pvrusb2_debug);
  } else {

  }
#line 145
  if ((pvrusb2_debug & 32) != 0) {
#line 145
    printk("\016pvrusb2: pvr_init complete\n");
  } else {

  }
#line 147
  return (ret);
}
}
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.c"
static void pvr_exit(void) 
{ 


  {
#line 152
  if ((pvrusb2_debug & 32) != 0) {
#line 152
    printk("\016pvrusb2: pvr_exit\n");
  } else {

  }
#line 154
  ldv_usb_deregister_196(& pvr_driver);
#line 156
  pvr2_context_global_done();
#line 159
  pvr2_sysfs_class_destroy(class_ptr);
#line 162
  if ((pvrusb2_debug & 32) != 0) {
#line 162
    printk("\016pvrusb2: pvr_exit complete\n");
  } else {

  }
#line 163
  return;
}
}
#line 327 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_retval_0  ;
#line 328
extern void ldv_initialize(void) ;
#line 329
void ldv_check_final_state(void) ;
#line 330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_retval_2  ;
#line 333 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
void ldv_usb_driver_14(void) 
{ 
  void *tmp ;

  {
#line 334
  tmp = ldv_init_zalloc(1560UL);
#line 334
  pvr_driver_group1 = (struct usb_interface *)tmp;
#line 335
  return;
}
}
#line 340
void ldv_main_exported_13(void) ;
#line 341
void ldv_main_exported_12(void) ;
#line 343
void ldv_main_exported_8(void) ;
#line 344
void ldv_main_exported_11(void) ;
#line 345
void ldv_main_exported_7(void) ;
#line 346
void ldv_main_exported_10(void) ;
#line 347
void ldv_main_exported_9(void) ;
#line 353 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
void main(void) 
{ 
  struct usb_device_id *ldvarg57 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 356
  tmp = ldv_init_zalloc(32UL);
#line 356
  ldvarg57 = (struct usb_device_id *)tmp;
#line 354
  ldv_initialize();
#line 358
  ldv_state_variable_11 = 0;
#line 359
  ldv_state_variable_7 = 0;
#line 361
  timer_init_2();
#line 363
  ldv_state_variable_2 = 1;
#line 365
  work_init_1();
#line 367
  ldv_state_variable_1 = 1;
#line 368
  ref_cnt = 0;
#line 369
  ldv_state_variable_0 = 1;
#line 370
  ldv_state_variable_13 = 0;
#line 372
  timer_init_6();
#line 374
  ldv_state_variable_6 = 1;
#line 376
  timer_init_3();
#line 378
  ldv_state_variable_3 = 1;
#line 379
  ldv_state_variable_9 = 0;
#line 380
  ldv_state_variable_12 = 0;
#line 381
  ldv_state_variable_14 = 0;
#line 382
  ldv_state_variable_15 = 0;
#line 383
  ldv_state_variable_8 = 0;
#line 385
  timer_init_4();
#line 387
  ldv_state_variable_4 = 1;
#line 388
  ldv_state_variable_10 = 0;
#line 390
  timer_init_5();
#line 392
  ldv_state_variable_5 = 1;
  ldv_49338: 
#line 394
  tmp___0 = __VERIFIER_nondet_int();
#line 394
  switch (tmp___0) {
  case 0: ;
#line 398
  if (ldv_state_variable_11 != 0) {
#line 399
    ldv_main_exported_11();
  } else {

  }
#line 402
  goto ldv_49312;
  case 1: ;
#line 406
  if (ldv_state_variable_7 != 0) {
#line 407
    ldv_main_exported_7();
  } else {

  }
#line 410
  goto ldv_49312;
  case 2: ;
#line 417
  goto ldv_49312;
  case 3: ;
#line 424
  goto ldv_49312;
  case 4: ;
#line 428
  if (ldv_state_variable_0 != 0) {
#line 429
    tmp___1 = __VERIFIER_nondet_int();
#line 429
    switch (tmp___1) {
    case 0: ;
#line 432
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 434
      pvr_exit();
#line 435
      ldv_state_variable_0 = 2;
#line 436
      goto ldv_final;
    } else {

    }
#line 439
    goto ldv_49319;
    case 1: ;
#line 442
    if (ldv_state_variable_0 == 1) {
#line 444
      ldv_retval_0 = pvr_init();
#line 446
      if (ldv_retval_0 == 0) {
#line 447
        ldv_state_variable_0 = 3;
#line 448
        ldv_state_variable_13 = 1;
#line 449
        ldv_initialize_v4l2_ioctl_ops_13();
#line 450
        ldv_state_variable_10 = 1;
#line 451
        ldv_initialize_pvr2_dvb_props_10();
#line 452
        ldv_state_variable_8 = 1;
#line 453
        ldv_initialize_pvr2_dvb_props_8();
#line 454
        ldv_state_variable_15 = 1;
#line 455
        ldv_initialize_i2c_algorithm_15();
#line 456
        ldv_state_variable_12 = 1;
#line 457
        ldv_initialize_v4l2_file_operations_12();
#line 458
        ldv_state_variable_9 = 1;
#line 459
        ldv_initialize_pvr2_dvb_props_9();
#line 460
        ldv_state_variable_7 = 1;
#line 461
        ldv_initialize_pvr2_dvb_props_7();
#line 462
        ldv_state_variable_11 = 1;
#line 463
        ldv_initialize_pvr2_dvb_props_11();
      } else {

      }
#line 465
      if (ldv_retval_0 != 0) {
#line 466
        ldv_state_variable_0 = 2;
#line 467
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 471
    goto ldv_49319;
    default: 
#line 472
    ldv_stop();
    }
    ldv_49319: ;
  } else {

  }
#line 476
  goto ldv_49312;
  case 5: ;
#line 480
  if (ldv_state_variable_13 != 0) {
#line 481
    ldv_main_exported_13();
  } else {

  }
#line 484
  goto ldv_49312;
  case 6: ;
#line 491
  goto ldv_49312;
  case 7: ;
#line 498
  goto ldv_49312;
  case 8: ;
#line 502
  if (ldv_state_variable_9 != 0) {
#line 503
    ldv_main_exported_9();
  } else {

  }
#line 506
  goto ldv_49312;
  case 9: ;
#line 510
  if (ldv_state_variable_12 != 0) {
#line 511
    ldv_main_exported_12();
  } else {

  }
#line 514
  goto ldv_49312;
  case 10: ;
#line 518
  if (ldv_state_variable_14 != 0) {
#line 519
    tmp___2 = __VERIFIER_nondet_int();
#line 519
    switch (tmp___2) {
    case 0: ;
#line 522
    if (ldv_state_variable_14 == 1) {
#line 524
      ldv_retval_2 = pvr_probe(pvr_driver_group1, (struct usb_device_id  const  *)ldvarg57);
#line 525
      if (ldv_retval_2 == 0) {
#line 526
        ldv_state_variable_14 = 2;
#line 527
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 531
    goto ldv_49329;
    case 1: ;
#line 534
    if (ldv_state_variable_14 == 2 && usb_counter == 0) {
#line 536
      pvr_disconnect(pvr_driver_group1);
#line 537
      ldv_state_variable_14 = 1;
#line 538
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 541
    goto ldv_49329;
    default: 
#line 542
    ldv_stop();
    }
    ldv_49329: ;
  } else {

  }
#line 546
  goto ldv_49312;
  case 11: ;
#line 550
  if (ldv_state_variable_15 != 0) {
#line 551
    ldv_main_exported_15();
  } else {

  }
#line 554
  goto ldv_49312;
  case 12: ;
#line 558
  if (ldv_state_variable_8 != 0) {
#line 559
    ldv_main_exported_8();
  } else {

  }
#line 562
  goto ldv_49312;
  case 13: ;
#line 569
  goto ldv_49312;
  case 14: ;
#line 573
  if (ldv_state_variable_10 != 0) {
#line 574
    ldv_main_exported_10();
  } else {

  }
#line 577
  goto ldv_49312;
  case 15: ;
#line 584
  goto ldv_49312;
  default: 
#line 585
  ldv_stop();
  }
  ldv_49312: ;
#line 587
  goto ldv_49338;
  ldv_final: 
#line 589
  ldv_check_final_state();
#line 590
  return;
}
}
#line 617 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
bool ldv_queue_work_on_183(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 621
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 621
  ldv_func_res = tmp;
#line 623
  activate_work_1(ldv_func_arg3, 2);
#line 625
  return (ldv_func_res);
}
}
#line 628 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
bool ldv_queue_delayed_work_on_184(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 632
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 632
  ldv_func_res = tmp;
#line 634
  activate_work_1(& ldv_func_arg3->work, 2);
#line 636
  return (ldv_func_res);
}
}
#line 639 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
bool ldv_queue_work_on_185(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 643
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 643
  ldv_func_res = tmp;
#line 645
  activate_work_1(ldv_func_arg3, 2);
#line 647
  return (ldv_func_res);
}
}
#line 650 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
void ldv_flush_workqueue_186(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 653
  flush_workqueue(ldv_func_arg1);
#line 655
  call_and_disable_all_1(2);
#line 656
  return;
}
}
#line 658 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
bool ldv_queue_delayed_work_on_187(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 662
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 662
  ldv_func_res = tmp;
#line 664
  activate_work_1(& ldv_func_arg3->work, 2);
#line 666
  return (ldv_func_res);
}
}
#line 669 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
void ldv_mutex_lock_188(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 672
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 674
  mutex_lock(ldv_func_arg1);
#line 675
  return;
}
}
#line 677 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
void ldv_mutex_unlock_189(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 680
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 682
  mutex_unlock(ldv_func_arg1);
#line 683
  return;
}
}
#line 685 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
void ldv_mutex_lock_190(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 688
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 690
  mutex_lock(ldv_func_arg1);
#line 691
  return;
}
}
#line 693 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_mutex_trylock_191(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 697
  tmp = mutex_trylock(ldv_func_arg1);
#line 697
  ldv_func_res = tmp;
#line 699
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 699
  return (tmp___0);
#line 701
  return (ldv_func_res);
}
}
#line 704 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
void ldv_mutex_unlock_192(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 707
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 709
  mutex_unlock(ldv_func_arg1);
#line 710
  return;
}
}
#line 712 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
void ldv_mutex_unlock_193(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 715
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 717
  mutex_unlock(ldv_func_arg1);
#line 718
  return;
}
}
#line 720 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
void ldv_mutex_lock_194(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 723
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 725
  mutex_lock(ldv_func_arg1);
#line 726
  return;
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
int ldv_usb_register_driver_195(struct usb_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 732
  tmp = usb_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 732
  ldv_func_res = tmp;
#line 734
  ldv_state_variable_14 = 1;
#line 735
  usb_counter = 0;
#line 736
  ldv_usb_driver_14();
#line 739
  return (ldv_func_res);
}
}
#line 742 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-main.o.c.prepared"
void ldv_usb_deregister_196(struct usb_driver *arg ) 
{ 


  {
#line 745
  usb_deregister(arg);
#line 747
  ldv_state_variable_14 = 0;
#line 748
  return;
}
}
#line 7 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 57 "include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  __u32 tmp ;

  {
#line 62
  tmp = __arch_swab32(val);
#line 62
  return (tmp);
}
}
#line 178 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 405
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 409
extern int scnprintf(char * , size_t  , char const   *  , ...) ;
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 23 "include/linux/string.h"
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
#line 280 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 119 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 176
int ldv_mutex_trylock_225(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_221(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_222(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_226(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_228(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_231(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_233(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_235(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_237(struct mutex *ldv_func_arg1 ) ;
#line 213
void ldv_mutex_unlock_239(struct mutex *ldv_func_arg1 ) ;
#line 217
void ldv_mutex_unlock_241(struct mutex *ldv_func_arg1 ) ;
#line 221
void ldv_mutex_unlock_255(struct mutex *ldv_func_arg1 ) ;
#line 225
void ldv_mutex_unlock_258(struct mutex *ldv_func_arg1 ) ;
#line 229
void ldv_mutex_unlock_259(struct mutex *ldv_func_arg1 ) ;
#line 233
void ldv_mutex_unlock_261(struct mutex *ldv_func_arg1 ) ;
#line 237
void ldv_mutex_unlock_263(struct mutex *ldv_func_arg1 ) ;
#line 241
void ldv_mutex_unlock_265(struct mutex *ldv_func_arg1 ) ;
#line 245
void ldv_mutex_unlock_267(struct mutex *ldv_func_arg1 ) ;
#line 249
void ldv_mutex_unlock_269(struct mutex *ldv_func_arg1 ) ;
#line 253
void ldv_mutex_unlock_271(struct mutex *ldv_func_arg1 ) ;
#line 257
void ldv_mutex_unlock_273(struct mutex *ldv_func_arg1 ) ;
#line 261
void ldv_mutex_unlock_275(struct mutex *ldv_func_arg1 ) ;
#line 265
void ldv_mutex_unlock_277(struct mutex *ldv_func_arg1 ) ;
#line 269
void ldv_mutex_unlock_280(struct mutex *ldv_func_arg1 ) ;
#line 273
void ldv_mutex_unlock_282(struct mutex *ldv_func_arg1 ) ;
#line 277
void ldv_mutex_unlock_284(struct mutex *ldv_func_arg1 ) ;
#line 281
void ldv_mutex_unlock_294(struct mutex *ldv_func_arg1 ) ;
#line 285
void ldv_mutex_unlock_296(struct mutex *ldv_func_arg1 ) ;
#line 289
void ldv_mutex_unlock_298(struct mutex *ldv_func_arg1 ) ;
#line 13 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
extern void __ldv_usb_unlock_device(struct usb_device * ) ;
#line 16
void ldv___ldv_usb_unlock_device_286(struct usb_device *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_220(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_223(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_224(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_227(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_230(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_232(struct mutex *ldv_func_arg1 ) ;
#line 49
void ldv_mutex_lock_234(struct mutex *ldv_func_arg1 ) ;
#line 53
void ldv_mutex_lock_236(struct mutex *ldv_func_arg1 ) ;
#line 57
void ldv_mutex_lock_238(struct mutex *ldv_func_arg1 ) ;
#line 61
void ldv_mutex_lock_240(struct mutex *ldv_func_arg1 ) ;
#line 65
void ldv_mutex_lock_254(struct mutex *ldv_func_arg1 ) ;
#line 69
void ldv_mutex_lock_256(struct mutex *ldv_func_arg1 ) ;
#line 73
void ldv_mutex_lock_257(struct mutex *ldv_func_arg1 ) ;
#line 77
void ldv_mutex_lock_260(struct mutex *ldv_func_arg1 ) ;
#line 81
void ldv_mutex_lock_262(struct mutex *ldv_func_arg1 ) ;
#line 85
void ldv_mutex_lock_264(struct mutex *ldv_func_arg1 ) ;
#line 89
void ldv_mutex_lock_266(struct mutex *ldv_func_arg1 ) ;
#line 93
void ldv_mutex_lock_268(struct mutex *ldv_func_arg1 ) ;
#line 97
void ldv_mutex_lock_270(struct mutex *ldv_func_arg1 ) ;
#line 101
void ldv_mutex_lock_272(struct mutex *ldv_func_arg1 ) ;
#line 105
void ldv_mutex_lock_274(struct mutex *ldv_func_arg1 ) ;
#line 109
void ldv_mutex_lock_276(struct mutex *ldv_func_arg1 ) ;
#line 113
void ldv_mutex_lock_279(struct mutex *ldv_func_arg1 ) ;
#line 117
void ldv_mutex_lock_281(struct mutex *ldv_func_arg1 ) ;
#line 121
void ldv_mutex_lock_283(struct mutex *ldv_func_arg1 ) ;
#line 125
void ldv_mutex_lock_293(struct mutex *ldv_func_arg1 ) ;
#line 129
void ldv_mutex_lock_295(struct mutex *ldv_func_arg1 ) ;
#line 133
void ldv_mutex_lock_297(struct mutex *ldv_func_arg1 ) ;
#line 138
void ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(struct mutex *lock ) ;
#line 142
void ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(struct mutex *lock ) ;
#line 281
void ldv_mutex_lock_pvr2_unit_mtx(struct mutex *lock ) ;
#line 285
void ldv_mutex_unlock_pvr2_unit_mtx(struct mutex *lock ) ;
#line 301
void ldv_usb_unlock_device_usb_dev_of_pvr2_hdw(void) ;
#line 303
int ldv_usb_lock_device_for_reset_usb_dev_of_pvr2_hdw(void) ;
#line 78 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 292
extern unsigned long __msecs_to_jiffies(unsigned int const    ) ;
#line 354 "include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const   m ) 
{ 
  unsigned long tmp___0 ;

  {
#line 361
  tmp___0 = __msecs_to_jiffies(m);
#line 361
  return (tmp___0);
}
}
#line 163 "include/linux/timer.h"
__inline static int timer_pending(struct timer_list  const  *timer ) 
{ 


  {
#line 165
  return ((unsigned long )timer->entry.pprev != (unsigned long )((struct hlist_node **/* const  */)0));
}
}
#line 224
extern void add_timer(struct timer_list * ) ;
#line 232
int ldv_del_timer_sync_229(struct timer_list *ldv_func_arg1 ) ;
#line 236
int ldv_del_timer_sync_242(struct timer_list *ldv_func_arg1 ) ;
#line 240
int ldv_del_timer_sync_243(struct timer_list *ldv_func_arg1 ) ;
#line 244
int ldv_del_timer_sync_244(struct timer_list *ldv_func_arg1 ) ;
#line 248
int ldv_del_timer_sync_245(struct timer_list *ldv_func_arg1 ) ;
#line 252
int ldv_del_timer_sync_250(struct timer_list *ldv_func_arg1 ) ;
#line 256
int ldv_del_timer_sync_251(struct timer_list *ldv_func_arg1 ) ;
#line 260
int ldv_del_timer_sync_252(struct timer_list *ldv_func_arg1 ) ;
#line 264
int ldv_del_timer_sync_253(struct timer_list *ldv_func_arg1 ) ;
#line 268
int ldv_del_timer_sync_278(struct timer_list *ldv_func_arg1 ) ;
#line 272
int ldv_del_timer_sync_287(struct timer_list *ldv_func_arg1 ) ;
#line 276
int ldv_del_timer_sync_288(struct timer_list *ldv_func_arg1 ) ;
#line 280
int ldv_del_timer_sync_289(struct timer_list *ldv_func_arg1 ) ;
#line 284
int ldv_del_timer_sync_290(struct timer_list *ldv_func_arg1 ) ;
#line 288
int ldv_del_timer_sync_291(struct timer_list *ldv_func_arg1 ) ;
#line 292
int ldv_del_timer_sync_292(struct timer_list *ldv_func_arg1 ) ;
#line 72 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 149
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 926
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 927
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 91
extern void wait_for_completion(struct completion * ) ;
#line 106
extern void complete(struct completion * ) ;
#line 181 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 361
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
#line 421
extern void destroy_workqueue(struct workqueue_struct * ) ;
#line 424
void ldv_destroy_workqueue_247(struct workqueue_struct *ldv_func_arg1 ) ;
#line 428
void ldv_destroy_workqueue_249(struct workqueue_struct *ldv_func_arg1 ) ;
#line 441
bool ldv_queue_work_on_215(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 445
bool ldv_queue_work_on_217(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 451
bool ldv_queue_delayed_work_on_216(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
bool ldv_queue_delayed_work_on_219(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 463
void ldv_flush_workqueue_218(struct workqueue_struct *ldv_func_arg1 ) ;
#line 467
void ldv_flush_workqueue_246(struct workqueue_struct *ldv_func_arg1 ) ;
#line 471
void ldv_flush_workqueue_248(struct workqueue_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_215(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 425 "include/linux/sched.h"
extern void schedule(void) ;
#line 525 "include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 527
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
#line 528
    return ((void *)0);
  } else {

  }
#line 529
  tmp = __kmalloc(n * size, flags);
#line 529
  return (tmp);
}
}
#line 538 "include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 540
  tmp = kmalloc_array(n, size, flags | 32768U);
#line 540
  return (tmp);
}
}
#line 581 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 583
  tmp = kmalloc(size, flags | 32768U);
#line 583
  return (tmp);
}
}
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void activate_suitable_timer_6(struct timer_list *timer , unsigned long data ) ;
#line 276
void call_and_disable_work_1(struct work_struct *work ) ;
#line 277
void ldv_timer_5(int state , struct timer_list *timer ) ;
#line 278
void choose_timer_5(void) ;
#line 279
void activate_pending_timer_2(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 280
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 285
void disable_suitable_timer_3(struct timer_list *timer ) ;
#line 286
void activate_suitable_timer_3(struct timer_list *timer , unsigned long data ) ;
#line 288
void disable_work_1(struct work_struct *work ) ;
#line 292
int reg_timer_3(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 293
void disable_suitable_timer_6(struct timer_list *timer ) ;
#line 294
void disable_suitable_timer_5(struct timer_list *timer ) ;
#line 295
void activate_pending_timer_6(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 296
void activate_suitable_timer_4(struct timer_list *timer , unsigned long data ) ;
#line 297
void ldv_timer_2(int state , struct timer_list *timer ) ;
#line 299
void choose_timer_2(void) ;
#line 300
int reg_timer_2(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 301
void choose_timer_3(void) ;
#line 303
void choose_timer_6(void) ;
#line 305
int reg_timer_6(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 308
void ldv_timer_6(int state , struct timer_list *timer ) ;
#line 311
void choose_timer_4(void) ;
#line 312
void disable_suitable_timer_4(struct timer_list *timer ) ;
#line 313
int reg_timer_4(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 314
void invoke_work_1(void) ;
#line 316
void activate_pending_timer_3(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 318
void activate_pending_timer_5(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 320
int reg_timer_5(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 321
void ldv_timer_4(int state , struct timer_list *timer ) ;
#line 322
void activate_suitable_timer_5(struct timer_list *timer , unsigned long data ) ;
#line 323
void activate_suitable_timer_2(struct timer_list *timer , unsigned long data ) ;
#line 324
void ldv_timer_3(int state , struct timer_list *timer ) ;
#line 36 "include/linux/kmod.h"
extern int __request_module(bool  , char const   *  , ...) ;
#line 42 "include/linux/firmware.h"
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
#line 51
extern void release_firmware(struct firmware  const  * ) ;
#line 102 "include/media/v4l2-common.h"
extern struct v4l2_subdev *v4l2_i2c_new_subdev(struct v4l2_device * , struct i2c_adapter * ,
                                               char const   * , u8  , unsigned short const   * ) ;
#line 30 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-std.h"
int pvr2_std_str_to_id(v4l2_std_id *idPtr , char const   *bufPtr , unsigned int bufSize ) ;
#line 37
unsigned int pvr2_std_id_to_str(char *bufPtr , unsigned int bufSize , v4l2_std_id id ) ;
#line 47
v4l2_std_id pvr2_std_get_usable(void) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 616 "include/linux/usb.h"
__inline static struct usb_device *interface_to_usbdev(struct usb_interface *intf ) 
{ 
  struct device  const  *__mptr ;

  {
#line 618
  __mptr = (struct device  const  *)intf->dev.parent;
#line 618
  return ((struct usb_device *)__mptr + 0xffffffffffffff70UL);
}
}
#line 646
int ldv_usb_lock_device_for_reset_285(struct usb_device *ldv_func_arg1 , struct usb_interface  const  *ldv_func_arg2 ) ;
#line 650
extern int usb_reset_device(struct usb_device * ) ;
#line 812 "include/linux/usb.h"
__inline static int usb_make_path(struct usb_device *dev , char *buf , size_t size ) 
{ 
  int actual ;

  {
#line 815
  actual = snprintf(buf, size, "usb-%s-%s", (dev->bus)->bus_name, (char *)(& dev->devpath));
#line 817
  return ((int )size > actual ? actual : -1);
}
}
#line 1532 "include/linux/usb.h"
__inline static void usb_fill_bulk_urb(struct urb *urb , struct usb_device *dev ,
                                       unsigned int pipe , void *transfer_buffer ,
                                       int buffer_length , void (*complete_fn)(struct urb * ) ,
                                       void *context ) 
{ 


  {
#line 1540
  urb->dev = dev;
#line 1541
  urb->pipe = pipe;
#line 1542
  urb->transfer_buffer = transfer_buffer;
#line 1543
  urb->transfer_buffer_length = (u32 )buffer_length;
#line 1544
  urb->complete = complete_fn;
#line 1545
  urb->context = context;
#line 1546
  return;
}
}
#line 1602
extern struct urb *usb_alloc_urb(int  , gfp_t  ) ;
#line 1603
extern void usb_free_urb(struct urb * ) ;
#line 1606
extern int usb_submit_urb(struct urb * , gfp_t  ) ;
#line 1607
extern int usb_unlink_urb(struct urb * ) ;
#line 1608
extern void usb_kill_urb(struct urb * ) ;
#line 1677
extern int usb_control_msg(struct usb_device * , unsigned int  , __u8  , __u8  , __u16  ,
                           __u16  , void * , __u16  , int  ) ;
#line 1682
extern int usb_bulk_msg(struct usb_device * , unsigned int  , void * , int  , int * ,
                        int  ) ;
#line 1695
extern int usb_clear_halt(struct usb_device * , int  ) ;
#line 1697
extern int usb_set_interface(struct usb_device * , int  , int  ) ;
#line 1805 "include/linux/usb.h"
__inline static unsigned int __create_pipe(struct usb_device *dev , unsigned int endpoint ) 
{ 


  {
#line 1808
  return ((unsigned int )(dev->devnum << 8) | (endpoint << 15));
}
}
#line 48 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-io.h"
struct pvr2_stream *pvr2_stream_create(void) ;
#line 49
void pvr2_stream_destroy(struct pvr2_stream *sp ) ;
#line 50
void pvr2_stream_setup(struct pvr2_stream *sp , struct usb_device *dev , int endpoint ,
                       unsigned int tolerance___0 ) ;
#line 56
void pvr2_stream_get_stats(struct pvr2_stream *sp , struct pvr2_stream_stats *stats ,
                           int zero_counts ) ;
#line 107 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-ctrl.h"
int pvr2_ctrl_value_to_sym_internal(struct pvr2_ctrl *cptr , int mask , int val ,
                                    char *buf , unsigned int maxlen , unsigned int *len ) ;
#line 102 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw.h"
char const   *pvr2_config_get_name(enum pvr2_config cfg ) ;
#line 108
struct pvr2_hdw *pvr2_hdw_create(struct usb_interface *intf , struct usb_device_id  const  *devid ) ;
#line 113
int pvr2_hdw_initialize(struct pvr2_hdw *hdw , void (*callback_func)(void * ) , void *callback_data ) ;
#line 118
void pvr2_hdw_destroy(struct pvr2_hdw *hdw ) ;
#line 121
int pvr2_hdw_dev_ok(struct pvr2_hdw *hdw ) ;
#line 125
int pvr2_hdw_get_unit_number(struct pvr2_hdw *hdw ) ;
#line 128
struct usb_device *pvr2_hdw_get_dev(struct pvr2_hdw *hdw ) ;
#line 131
unsigned long pvr2_hdw_get_sn(struct pvr2_hdw *hdw ) ;
#line 134
char const   *pvr2_hdw_get_bus_info(struct pvr2_hdw *hdw ) ;
#line 137
char const   *pvr2_hdw_get_device_identifier(struct pvr2_hdw *hdw ) ;
#line 140
void pvr2_hdw_disconnect(struct pvr2_hdw *hdw ) ;
#line 143
void pvr2_hdw_set_v4l2_dev(struct pvr2_hdw *hdw , struct video_device *vdev ) ;
#line 146
unsigned int pvr2_hdw_get_ctrl_count(struct pvr2_hdw *hdw ) ;
#line 149
struct pvr2_ctrl *pvr2_hdw_get_ctrl_by_index(struct pvr2_hdw *hdw , unsigned int idx ) ;
#line 152
struct pvr2_ctrl *pvr2_hdw_get_ctrl_by_id(struct pvr2_hdw *hdw , unsigned int ctl_id ) ;
#line 155
struct pvr2_ctrl *pvr2_hdw_get_ctrl_v4l(struct pvr2_hdw *hdw , unsigned int ctl_id ) ;
#line 158
struct pvr2_ctrl *pvr2_hdw_get_ctrl_nextv4l(struct pvr2_hdw *hdw , unsigned int ctl_id ) ;
#line 162
int pvr2_hdw_commit_ctl(struct pvr2_hdw *hdw ) ;
#line 166
unsigned int pvr2_hdw_get_input_available(struct pvr2_hdw *hdw ) ;
#line 170
unsigned int pvr2_hdw_get_input_allowed(struct pvr2_hdw *hdw ) ;
#line 177
int pvr2_hdw_set_input_allowed(struct pvr2_hdw *hdw , unsigned int change_mask , unsigned int change_val ) ;
#line 182
char const   *pvr2_hdw_get_driver_name(struct pvr2_hdw *hdw ) ;
#line 185
void pvr2_hdw_execute_tuner_poll(struct pvr2_hdw *hdw ) ;
#line 188
int pvr2_hdw_get_tuner_status(struct pvr2_hdw *hdw , struct v4l2_tuner *vtp ) ;
#line 191
int pvr2_hdw_get_cropcap(struct pvr2_hdw *hdw , struct v4l2_cropcap *pp ) ;
#line 194
int pvr2_hdw_is_hsm(struct pvr2_hdw *hdw ) ;
#line 197
char const   *pvr2_hdw_get_type(struct pvr2_hdw *hdw ) ;
#line 200
char const   *pvr2_hdw_get_desc(struct pvr2_hdw *hdw ) ;
#line 203
int pvr2_hdw_set_streaming(struct pvr2_hdw *hdw , int enable_flag ) ;
#line 206
int pvr2_hdw_get_streaming(struct pvr2_hdw *hdw ) ;
#line 209
int pvr2_hdw_get_state(struct pvr2_hdw *hdw ) ;
#line 212
int pvr2_hdw_set_stream_type(struct pvr2_hdw *hdw , enum pvr2_config config ) ;
#line 215
struct pvr2_stream *pvr2_hdw_get_video_stream(struct pvr2_hdw *hp ) ;
#line 221
void pvr2_hdw_cpufw_set_enabled(struct pvr2_hdw *hdw , int mode , int enable_flag ) ;
#line 226
int pvr2_hdw_cpufw_get_enabled(struct pvr2_hdw *hdw ) ;
#line 231
int pvr2_hdw_cpufw_get(struct pvr2_hdw *hdw , unsigned int offs , char *buf , unsigned int cnt ) ;
#line 235
int pvr2_hdw_v4l_get_minor_number(struct pvr2_hdw *hdw , enum pvr2_v4l_type index ) ;
#line 238
void pvr2_hdw_v4l_store_minor_number(struct pvr2_hdw *hdw , enum pvr2_v4l_type index ,
                                     int v ) ;
#line 258
void pvr2_hdw_cpureset_assert(struct pvr2_hdw *hdw , int val ) ;
#line 261
void pvr2_hdw_device_reset(struct pvr2_hdw *hdw ) ;
#line 264
int pvr2_hdw_untrip(struct pvr2_hdw *hdw ) ;
#line 269
int pvr2_hdw_cmd_deep_reset(struct pvr2_hdw *hdw ) ;
#line 272
int pvr2_hdw_cmd_powerup(struct pvr2_hdw *hdw ) ;
#line 275
int pvr2_hdw_cmd_decoder_reset(struct pvr2_hdw *hdw ) ;
#line 278
int pvr2_hdw_gpio_get_dir(struct pvr2_hdw *hdw , u32 *dp ) ;
#line 279
int pvr2_hdw_gpio_get_out(struct pvr2_hdw *hdw , u32 *dp ) ;
#line 280
int pvr2_hdw_gpio_get_in(struct pvr2_hdw *hdw , u32 *dp ) ;
#line 281
int pvr2_hdw_gpio_chg_dir(struct pvr2_hdw *hdw , u32 msk , u32 val ) ;
#line 282
int pvr2_hdw_gpio_chg_out(struct pvr2_hdw *hdw , u32 msk , u32 val ) ;
#line 331
unsigned int pvr2_hdw_state_report(struct pvr2_hdw *hdw , char *buf , unsigned int acnt ) ;
#line 335
void pvr2_hdw_trigger_module_log(struct pvr2_hdw *hdw ) ;
#line 340
int pvr2_upload_firmware2(struct pvr2_hdw *hdw ) ;
#line 661 "include/media/v4l2-subdev.h"
__inline static void *v4l2_get_subdevdata(struct v4l2_subdev  const  *sd ) 
{ 


  {
#line 663
  return ((void *)sd->dev_priv);
}
}
#line 77 "include/media/v4l2-device.h"
extern int v4l2_device_register(struct device * , struct v4l2_device * ) ;
#line 101
extern void v4l2_device_disconnect(struct v4l2_device * ) ;
#line 104
extern void v4l2_device_unregister(struct v4l2_device * ) ;
#line 96 "include/media/cx2341x.h"
extern int cx2341x_ctrl_query(struct cx2341x_mpeg_params  const  * , struct v4l2_queryctrl * ) ;
#line 98
extern char const   * const  *cx2341x_ctrl_get_menu(struct cx2341x_mpeg_params  const  * ,
                                                    u32  ) ;
#line 99
extern int cx2341x_ext_ctrls(struct cx2341x_mpeg_params * , int  , struct v4l2_ext_controls * ,
                             unsigned int  ) ;
#line 101
extern void cx2341x_fill_defaults(struct cx2341x_mpeg_params * ) ;
#line 102
extern void cx2341x_log_status(struct cx2341x_mpeg_params  const  * , char const   * ) ;
#line 392 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-hdw-internal.h"
unsigned long pvr2_hdw_get_cur_freq(struct pvr2_hdw *hdw ) ;
#line 394
void pvr2_hdw_status_poll(struct pvr2_hdw *hdw ) ;
#line 39 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-wm8775.h"
void pvr2_wm8775_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) ;
#line 39 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.h"
void pvr2_cx25840_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) ;
#line 36 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.h"
void pvr2_cs53l32a_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) ;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static struct pvr2_hdw *unit_pointers[20U]  = 
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
  {      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0, 
        (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0, 
        (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0, 
        (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0, 
        (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0,      (struct pvr2_hdw *)0};
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static struct mutex pvr2_unit_mtx  =    {{1}, {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "pvr2_unit_mtx.wait_lock",
                                                          0, 0UL}}}}, {& pvr2_unit_mtx.wait_list,
                                                                       & pvr2_unit_mtx.wait_list},
    0, (void *)(& pvr2_unit_mtx), {0, {0, 0}, "pvr2_unit_mtx", 0, 0UL}};
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int procreload  ;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int tuner[20U]  = 
#line 72
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int tolerance[20U]  = 
#line 73
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int video_std[20U]  = 
#line 74
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int init_pause_msec  ;
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int default_tv_freq  =    61250000;
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int default_radio_freq  =    104300000;
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static pvr2_subdev_update_func pvr2_module_update_functions[7U]  = {      0,      & pvr2_msp3400_subdev_update,      & pvr2_cx25840_subdev_update,      & pvr2_saa7115_subdev_update, 
        0,      & pvr2_cs53l32a_subdev_update,      & pvr2_wm8775_subdev_update};
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static char const   *module_names[8U]  = 
#line 126
  {      0,      "msp3400",      "cx25840",      "saa7115", 
        "tuner",      "cs53l32a",      "wm8775",      "tuner"};
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static unsigned char const   *module_i2c_addresses[8U]  = 
#line 137
  {      0,      (unsigned char const   *)"@",      (unsigned char const   *)"D",      (unsigned char const   *)"!", 
        (unsigned char const   *)"`abc",      (unsigned char const   *)"\021",      (unsigned char const   *)"\033",      (unsigned char const   *)"C"};
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static char const   *ir_scheme_names[5U]  = {      "none",      "24xxx (29xxx emulation)",      "Zilog",      "24xxx (MCE device)", 
        "29xxx"};
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static struct pvr2_mpeg_ids  const  mpeg_ids[26U]  = 
#line 163
  {      {"audio_layer", 10029413}, 
        {"audio_bitrate", 10029415}, 
        {"mpeg_audio_mode", 10029417}, 
        {"mpeg_audio_mode_extension", 10029418}, 
        {"audio_emphasis", 10029419}, 
        {"audio_crc", 10029420}, 
        {"video_aspect", 10029513}, 
        {"video_b_frames", 10029514}, 
        {"video_gop_size", 10029515}, 
        {"video_gop_closure", 10029516}, 
        {"video_bitrate_mode", 10029518}, 
        {"video_bitrate", 10029519}, 
        {"video_bitrate_peak", 10029520}, 
        {"video_temporal_decimation", 10029521}, 
        {"stream_type", 10029312}, 
        {"video_spatial_filter_mode", 10031104}, 
        {"video_spatial_filter", 10031105}, 
        {"video_luma_spatial_filter_type", 10031106}, 
        {"video_chroma_spatial_filter_type", 10031107}, 
        {"video_temporal_filter_mode", 10031108}, 
        {"video_temporal_filter", 10031109}, 
        {"video_median_filter_type", 10031110}, 
        {"video_luma_median_filter_top", 10031112}, 
        {"video_luma_median_filter_bottom", 10031111}, 
        {"video_chroma_median_filter_top", 10031114}, 
        {"video_chroma_median_filter_bottom", 10031113}};
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static char const   *control_values_srate[3U]  = {      "44.1 kHz",      "48 kHz",      "32 kHz"};
#line 256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static char const   *control_values_input[5U]  = {      "television",      "dtv",      "composite",      "s-video", 
        "radio"};
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static char const   *control_values_audiomode[5U]  = {      "Mono",      "Stereo",      "Lang2",      "Lang1", 
        "Lang1+Lang2"};
#line 274 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static char const   *control_values_hsm[3U]  = {      "Fail",      "Full",      "High"};
#line 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static char const   *pvr2_state_names[7U]  = {      "none",      "dead",      "cold",      "warm", 
        "error",      "ready",      "run"};
#line 297 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static struct pvr2_fx2cmd_descdef  const  pvr2_fx2cmd_desc[25U]  = 
#line 297
  {      {1U, (unsigned char *)"write encoder dword"}, 
        {2U, (unsigned char *)"read encoder dword"}, 
        {16U, (unsigned char *)"zilog IR reset control"}, 
        {40U, (unsigned char *)"read encoder 64bytes"}, 
        {4U, (unsigned char *)"write encoder register"}, 
        {5U, (unsigned char *)"read encoder register"}, 
        {6U, (unsigned char *)"encoder memsel"}, 
        {8U, (unsigned char *)"i2c write"}, 
        {9U, (unsigned char *)"i2c read"}, 
        {11U, (unsigned char *)"get USB speed"}, 
        {54U, (unsigned char *)"stream on"}, 
        {55U, (unsigned char *)"stream off"}, 
        {82U, (unsigned char *)"fwpost1"}, 
        {220U, (unsigned char *)"power off"}, 
        {222U, (unsigned char *)"power on"}, 
        {221U, (unsigned char *)"deep reset"}, 
        {235U, (unsigned char *)"get rom addr"}, 
        {236U, (unsigned char *)"get IR code"}, 
        {240U, (unsigned char *)"hcw demod resetin"}, 
        {241U, (unsigned char *)"hcw dtv stream on"}, 
        {242U, (unsigned char *)"hcw dtv stream off"}, 
        {160U, (unsigned char *)"onair dtv stream on"}, 
        {161U, (unsigned char *)"onair dtv stream off"}, 
        {162U, (unsigned char *)"onair dtv power on"}, 
        {163U, (unsigned char *)"onair dtv power off"}};
#line 326
static int pvr2_hdw_set_input(struct pvr2_hdw *hdw , int v ) ;
#line 327
static void pvr2_hdw_state_sched(struct pvr2_hdw *hdw ) ;
#line 328
static int pvr2_hdw_state_eval(struct pvr2_hdw *hdw ) ;
#line 329
static void pvr2_hdw_set_cur_freq(struct pvr2_hdw *hdw , unsigned long val ) ;
#line 330
static void pvr2_hdw_worker_poll(struct work_struct *work ) ;
#line 331
static int pvr2_hdw_wait(struct pvr2_hdw *hdw , int state ) ;
#line 332
static int pvr2_hdw_untrip_unlocked(struct pvr2_hdw *hdw ) ;
#line 333
static void pvr2_hdw_state_log_state(struct pvr2_hdw *hdw ) ;
#line 334
static int pvr2_hdw_cmd_usbstream(struct pvr2_hdw *hdw , int runFl ) ;
#line 335
static int pvr2_hdw_commit_setup(struct pvr2_hdw *hdw ) ;
#line 336
static int pvr2_hdw_get_eeprom_addr(struct pvr2_hdw *hdw ) ;
#line 337
static void pvr2_hdw_quiescent_timeout(unsigned long data ) ;
#line 338
static void pvr2_hdw_decoder_stabilization_timeout(unsigned long data ) ;
#line 339
static void pvr2_hdw_encoder_wait_timeout(unsigned long data ) ;
#line 340
static void pvr2_hdw_encoder_run_timeout(unsigned long data ) ;
#line 341
static int pvr2_issue_simple_cmd(struct pvr2_hdw *hdw , u32 cmdcode ) ;
#line 342
static int pvr2_send_request_ex(struct pvr2_hdw *hdw , unsigned int timeout , int probe_fl ,
                                void *write_data , unsigned int write_len , void *read_data ,
                                unsigned int read_len ) ;
#line 346
static int pvr2_hdw_check_cropcap(struct pvr2_hdw *hdw ) ;
#line 347
static v4l2_std_id pvr2_hdw_get_detected_std(struct pvr2_hdw *hdw ) ;
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void trace_stbit(char const   *name , int val ) 
{ 


  {
#line 351
  if ((pvrusb2_debug & 512) != 0) {
#line 351
    printk("\016pvrusb2: State bit %s <-- %s\n", name, val != 0 ? (char *)"true" : (char *)"false");
  } else {

  }
#line 352
  return;
}
}
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_channelfreq_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 358
  hdw = cptr->hdw;
#line 359
  if (hdw->freqProgSlot != 0U && hdw->freqProgSlot <= 500U) {
#line 360
    *vp = (int )hdw->freqTable[hdw->freqProgSlot - 1U];
  } else {
#line 362
    *vp = 0;
  }
#line 364
  return (0);
}
}
#line 367 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_channelfreq_set(struct pvr2_ctrl *cptr , int m , int v ) 
{ 
  struct pvr2_hdw *hdw ;
  unsigned int slotId ;

  {
#line 369
  hdw = cptr->hdw;
#line 370
  slotId = hdw->freqProgSlot;
#line 371
  if (slotId != 0U && slotId <= 500U) {
#line 372
    hdw->freqTable[slotId - 1U] = (unsigned int )v;
#line 376
    if (hdw->freqSelector != 0U) {
#line 377
      if (hdw->freqSlotRadio == slotId) {
#line 378
        hdw->freqSlotRadio = 0U;
      } else {

      }
    } else
#line 381
    if (hdw->freqSlotTelevision == slotId) {
#line 382
      hdw->freqSlotTelevision = 0U;
    } else {

    }
  } else {

  }
#line 386
  return (0);
}
}
#line 389 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_channelprog_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 391
  *vp = (int )(cptr->hdw)->freqProgSlot;
#line 392
  return (0);
}
}
#line 395 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_channelprog_set(struct pvr2_ctrl *cptr , int m , int v ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 397
  hdw = cptr->hdw;
#line 398
  if (v >= 0 && v <= 500) {
#line 399
    hdw->freqProgSlot = (unsigned int )v;
  } else {

  }
#line 401
  return (0);
}
}
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_channel_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 406
  hdw = cptr->hdw;
#line 407
  *vp = (int )(hdw->freqSelector != 0U ? hdw->freqSlotRadio : hdw->freqSlotTelevision);
#line 408
  return (0);
}
}
#line 411 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_channel_set(struct pvr2_ctrl *cptr , int m , int slotId ) 
{ 
  unsigned int freq ;
  struct pvr2_hdw *hdw ;

  {
#line 413
  freq = 0U;
#line 414
  hdw = cptr->hdw;
#line 415
  if (slotId < 0 || slotId > 500) {
#line 415
    return (0);
  } else {

  }
#line 416
  if (slotId > 0) {
#line 417
    freq = hdw->freqTable[slotId + -1];
#line 418
    if (freq == 0U) {
#line 418
      return (0);
    } else {

    }
#line 419
    pvr2_hdw_set_cur_freq(hdw, (unsigned long )freq);
  } else {

  }
#line 421
  if (hdw->freqSelector != 0U) {
#line 422
    hdw->freqSlotRadio = (unsigned int )slotId;
  } else {
#line 424
    hdw->freqSlotTelevision = (unsigned int )slotId;
  }
#line 426
  return (0);
}
}
#line 429 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_freq_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  unsigned long tmp ;

  {
#line 431
  tmp = pvr2_hdw_get_cur_freq(cptr->hdw);
#line 431
  *vp = (int )tmp;
#line 432
  return (0);
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_freq_is_dirty(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 437
  return ((cptr->hdw)->freqDirty != 0);
}
}
#line 440 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_freq_clear_dirty(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 442
  (cptr->hdw)->freqDirty = 0;
#line 443
  return;
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_freq_set(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 447
  pvr2_hdw_set_cur_freq(cptr->hdw, (unsigned long )v);
#line 448
  return (0);
}
}
#line 451 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_cropl_min_get(struct pvr2_ctrl *cptr , int *left ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 453
  cap = & (cptr->hdw)->cropcap_info;
#line 454
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 454
  stat = tmp;
#line 455
  if (stat != 0) {
#line 456
    return (stat);
  } else {

  }
#line 458
  *left = cap->bounds.left;
#line 459
  return (0);
}
}
#line 462 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_cropl_max_get(struct pvr2_ctrl *cptr , int *left ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 464
  cap = & (cptr->hdw)->cropcap_info;
#line 465
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 465
  stat = tmp;
#line 466
  if (stat != 0) {
#line 467
    return (stat);
  } else {

  }
#line 469
  *left = cap->bounds.left;
#line 470
  if (cap->bounds.width > (__u32 )(cptr->hdw)->cropw_val) {
#line 471
    *left = (int )((__u32 )*left + (cap->bounds.width - (__u32 )(cptr->hdw)->cropw_val));
  } else {

  }
#line 473
  return (0);
}
}
#line 476 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_cropt_min_get(struct pvr2_ctrl *cptr , int *top ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 478
  cap = & (cptr->hdw)->cropcap_info;
#line 479
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 479
  stat = tmp;
#line 480
  if (stat != 0) {
#line 481
    return (stat);
  } else {

  }
#line 483
  *top = cap->bounds.top;
#line 484
  return (0);
}
}
#line 487 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_cropt_max_get(struct pvr2_ctrl *cptr , int *top ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 489
  cap = & (cptr->hdw)->cropcap_info;
#line 490
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 490
  stat = tmp;
#line 491
  if (stat != 0) {
#line 492
    return (stat);
  } else {

  }
#line 494
  *top = cap->bounds.top;
#line 495
  if (cap->bounds.height > (__u32 )(cptr->hdw)->croph_val) {
#line 496
    *top = (int )((__u32 )*top + (cap->bounds.height - (__u32 )(cptr->hdw)->croph_val));
  } else {

  }
#line 498
  return (0);
}
}
#line 501 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_cropw_max_get(struct pvr2_ctrl *cptr , int *width ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int bleftend ;
  int cleft ;

  {
#line 503
  cap = & (cptr->hdw)->cropcap_info;
#line 506
  stat = pvr2_hdw_check_cropcap(cptr->hdw);
#line 507
  if (stat != 0) {
#line 508
    return (stat);
  } else {

  }
#line 510
  bleftend = (int )((__u32 )cap->bounds.left + cap->bounds.width);
#line 511
  cleft = (cptr->hdw)->cropl_val;
#line 513
  *width = cleft < bleftend ? bleftend - cleft : 0;
#line 514
  return (0);
}
}
#line 517 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_croph_max_get(struct pvr2_ctrl *cptr , int *height ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int btopend ;
  int ctop ;

  {
#line 519
  cap = & (cptr->hdw)->cropcap_info;
#line 522
  stat = pvr2_hdw_check_cropcap(cptr->hdw);
#line 523
  if (stat != 0) {
#line 524
    return (stat);
  } else {

  }
#line 526
  btopend = (int )((__u32 )cap->bounds.top + cap->bounds.height);
#line 527
  ctop = (cptr->hdw)->cropt_val;
#line 529
  *height = ctop < btopend ? btopend - ctop : 0;
#line 530
  return (0);
}
}
#line 533 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_cropcapbl(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 535
  cap = & (cptr->hdw)->cropcap_info;
#line 536
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 536
  stat = tmp;
#line 537
  if (stat != 0) {
#line 538
    return (stat);
  } else {

  }
#line 540
  *val = cap->bounds.left;
#line 541
  return (0);
}
}
#line 544 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_cropcapbt(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 546
  cap = & (cptr->hdw)->cropcap_info;
#line 547
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 547
  stat = tmp;
#line 548
  if (stat != 0) {
#line 549
    return (stat);
  } else {

  }
#line 551
  *val = cap->bounds.top;
#line 552
  return (0);
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_cropcapbw(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 557
  cap = & (cptr->hdw)->cropcap_info;
#line 558
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 558
  stat = tmp;
#line 559
  if (stat != 0) {
#line 560
    return (stat);
  } else {

  }
#line 562
  *val = (int )cap->bounds.width;
#line 563
  return (0);
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_cropcapbh(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 568
  cap = & (cptr->hdw)->cropcap_info;
#line 569
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 569
  stat = tmp;
#line 570
  if (stat != 0) {
#line 571
    return (stat);
  } else {

  }
#line 573
  *val = (int )cap->bounds.height;
#line 574
  return (0);
}
}
#line 577 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_cropcapdl(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 579
  cap = & (cptr->hdw)->cropcap_info;
#line 580
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 580
  stat = tmp;
#line 581
  if (stat != 0) {
#line 582
    return (stat);
  } else {

  }
#line 584
  *val = cap->defrect.left;
#line 585
  return (0);
}
}
#line 588 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_cropcapdt(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 590
  cap = & (cptr->hdw)->cropcap_info;
#line 591
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 591
  stat = tmp;
#line 592
  if (stat != 0) {
#line 593
    return (stat);
  } else {

  }
#line 595
  *val = cap->defrect.top;
#line 596
  return (0);
}
}
#line 599 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_cropcapdw(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 601
  cap = & (cptr->hdw)->cropcap_info;
#line 602
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 602
  stat = tmp;
#line 603
  if (stat != 0) {
#line 604
    return (stat);
  } else {

  }
#line 606
  *val = (int )cap->defrect.width;
#line 607
  return (0);
}
}
#line 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_cropcapdh(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 612
  cap = & (cptr->hdw)->cropcap_info;
#line 613
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 613
  stat = tmp;
#line 614
  if (stat != 0) {
#line 615
    return (stat);
  } else {

  }
#line 617
  *val = (int )cap->defrect.height;
#line 618
  return (0);
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_cropcappan(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 623
  cap = & (cptr->hdw)->cropcap_info;
#line 624
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 624
  stat = tmp;
#line 625
  if (stat != 0) {
#line 626
    return (stat);
  } else {

  }
#line 628
  *val = (int )cap->pixelaspect.numerator;
#line 629
  return (0);
}
}
#line 632 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_cropcappad(struct pvr2_ctrl *cptr , int *val ) 
{ 
  struct v4l2_cropcap *cap ;
  int stat ;
  int tmp ;

  {
#line 634
  cap = & (cptr->hdw)->cropcap_info;
#line 635
  tmp = pvr2_hdw_check_cropcap(cptr->hdw);
#line 635
  stat = tmp;
#line 636
  if (stat != 0) {
#line 637
    return (stat);
  } else {

  }
#line 639
  *val = (int )cap->pixelaspect.denominator;
#line 640
  return (0);
}
}
#line 643 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_vres_max_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 646
  if (((cptr->hdw)->std_mask_cur & 63744ULL) != 0ULL) {
#line 647
    *vp = 480;
  } else {
#line 649
    *vp = 576;
  }
#line 651
  return (0);
}
}
#line 654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_vres_min_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 657
  if ((unsigned int )*((unsigned char *)(cptr->hdw)->hdw_desc + 87UL) != 0U) {
#line 658
    *vp = 75;
  } else {
#line 660
    *vp = 17;
  }
#line 662
  return (0);
}
}
#line 665 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_input(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 667
  *vp = (cptr->hdw)->input_val;
#line 668
  return (0);
}
}
#line 671 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_check_input(struct pvr2_ctrl *cptr , int v ) 
{ 


  {
#line 673
  return (((unsigned int )(1 << v) & (cptr->hdw)->input_allowed_mask) != 0U);
}
}
#line 676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_set_input(struct pvr2_ctrl *cptr , int m , int v ) 
{ 
  int tmp ;

  {
#line 678
  tmp = pvr2_hdw_set_input(cptr->hdw, v);
#line 678
  return (tmp);
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_isdirty_input(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 683
  return ((cptr->hdw)->input_dirty != 0);
}
}
#line 686 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cleardirty_input(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 688
  (cptr->hdw)->input_dirty = 0;
#line 689
  return;
}
}
#line 692 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_freq_max_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  unsigned long fv ;
  struct pvr2_hdw *hdw ;

  {
#line 695
  hdw = cptr->hdw;
#line 696
  if (hdw->tuner_signal_stale != 0) {
#line 697
    pvr2_hdw_status_poll(hdw);
  } else {

  }
#line 699
  fv = (unsigned long )hdw->tuner_signal_info.rangehigh;
#line 700
  if (fv == 0UL) {
#line 702
    *vp = 850000000;
#line 703
    return (0);
  } else {

  }
#line 705
  if ((int )hdw->tuner_signal_info.capability & 1) {
#line 706
    fv = (fv * 125UL) / 2UL;
  } else {
#line 708
    fv = fv * 62500UL;
  }
#line 710
  *vp = (int )fv;
#line 711
  return (0);
}
}
#line 714 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_freq_min_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  unsigned long fv ;
  struct pvr2_hdw *hdw ;

  {
#line 717
  hdw = cptr->hdw;
#line 718
  if (hdw->tuner_signal_stale != 0) {
#line 719
    pvr2_hdw_status_poll(hdw);
  } else {

  }
#line 721
  fv = (unsigned long )hdw->tuner_signal_info.rangelow;
#line 722
  if (fv == 0UL) {
#line 724
    *vp = 55250000;
#line 725
    return (0);
  } else {

  }
#line 727
  if ((int )hdw->tuner_signal_info.capability & 1) {
#line 728
    fv = (fv * 125UL) / 2UL;
  } else {
#line 730
    fv = fv * 62500UL;
  }
#line 732
  *vp = (int )fv;
#line 733
  return (0);
}
}
#line 736 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_cx2341x_is_dirty(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 738
  return ((cptr->hdw)->enc_stale != 0);
}
}
#line 741 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cx2341x_clear_dirty(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 743
  (cptr->hdw)->enc_stale = 0;
#line 744
  (cptr->hdw)->enc_unsafe_stale = 0;
#line 745
  return;
}
}
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_cx2341x_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  int ret ;
  struct v4l2_ext_controls cs ;
  struct v4l2_ext_control c1 ;

  {
#line 752
  memset((void *)(& cs), 0, 32UL);
#line 753
  memset((void *)(& c1), 0, 20UL);
#line 754
  cs.controls = & c1;
#line 755
  cs.count = 1U;
#line 756
  c1.id = (__u32 )(cptr->info)->v4l_id;
#line 757
  ret = cx2341x_ext_ctrls(& (cptr->hdw)->enc_ctl_state, 0, & cs, 3223344711U);
#line 759
  if (ret != 0) {
#line 759
    return (ret);
  } else {

  }
#line 760
  *vp = c1.__annonCompField78.value;
#line 761
  return (0);
}
}
#line 764 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_cx2341x_set(struct pvr2_ctrl *cptr , int m , int v ) 
{ 
  int ret ;
  struct pvr2_hdw *hdw ;
  struct v4l2_ext_controls cs ;
  struct v4l2_ext_control c1 ;

  {
#line 767
  hdw = cptr->hdw;
#line 770
  memset((void *)(& cs), 0, 32UL);
#line 771
  memset((void *)(& c1), 0, 20UL);
#line 772
  cs.controls = & c1;
#line 773
  cs.count = 1U;
#line 774
  c1.id = (__u32 )(cptr->info)->v4l_id;
#line 775
  c1.__annonCompField78.value = v;
#line 776
  ret = cx2341x_ext_ctrls(& hdw->enc_ctl_state, hdw->state_encoder_run, & cs, 3223344712U);
#line 779
  if (ret == -16) {
#line 785
    ret = cx2341x_ext_ctrls(& hdw->enc_ctl_state, 0, & cs, 3223344712U);
#line 788
    if (ret == 0) {
#line 788
      hdw->enc_unsafe_stale = 1;
    } else {

    }
  } else {

  }
#line 790
  if (ret != 0) {
#line 790
    return (ret);
  } else {

  }
#line 791
  hdw->enc_stale = 1;
#line 792
  return (0);
}
}
#line 795 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static unsigned int ctrl_cx2341x_getv4lflags(struct pvr2_ctrl *cptr ) 
{ 
  struct v4l2_queryctrl qctrl ;
  struct pvr2_ctl_info *info ;

  {
#line 799
  qctrl.id = (__u32 )(cptr->info)->v4l_id;
#line 800
  cx2341x_ctrl_query((struct cx2341x_mpeg_params  const  *)(& (cptr->hdw)->enc_ctl_state),
                     & qctrl);
#line 807
  info = (struct pvr2_ctl_info *)cptr->info;
#line 808
  if ((qctrl.flags & 4U) != 0U) {
#line 809
    if ((unsigned long )info->set_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                     int  , int  ))0)) {
#line 810
      info->set_value = (int (*)(struct pvr2_ctrl * , int  , int  ))0;
    } else {

    }
  } else
#line 813
  if ((unsigned long )info->set_value == (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                   int  , int  ))0)) {
#line 814
    info->set_value = & ctrl_cx2341x_set;
  } else {

  }
#line 817
  return (qctrl.flags);
}
}
#line 820 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_streamingenabled_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 822
  *vp = (cptr->hdw)->state_pipeline_req;
#line 823
  return (0);
}
}
#line 826 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_masterstate_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 828
  *vp = (int )(cptr->hdw)->master_state;
#line 829
  return (0);
}
}
#line 832 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_hsm_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  int result ;
  int tmp ;

  {
#line 834
  tmp = pvr2_hdw_is_hsm(cptr->hdw);
#line 834
  result = tmp;
#line 835
  *vp = 1;
#line 836
  if (result < 0) {
#line 836
    *vp = 0;
  } else {

  }
#line 837
  if (result != 0) {
#line 837
    *vp = 2;
  } else {

  }
#line 838
  return (0);
}
}
#line 841 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_stddetect_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  v4l2_std_id tmp ;

  {
#line 843
  tmp = pvr2_hdw_get_detected_std(cptr->hdw);
#line 843
  *vp = (int )tmp;
#line 844
  return (0);
}
}
#line 847 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_stdavail_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 849
  *vp = (int )(cptr->hdw)->std_mask_avail;
#line 850
  return (0);
}
}
#line 853 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_stdavail_set(struct pvr2_ctrl *cptr , int m , int v ) 
{ 
  struct pvr2_hdw *hdw ;
  v4l2_std_id ns ;

  {
#line 855
  hdw = cptr->hdw;
#line 857
  ns = hdw->std_mask_avail;
#line 858
  ns = ((v4l2_std_id )(~ m) & ns) | (v4l2_std_id )(v & m);
#line 859
  if (hdw->std_mask_avail == ns) {
#line 859
    return (0);
  } else {

  }
#line 860
  hdw->std_mask_avail = ns;
#line 861
  hdw->std_info_cur.def.type_bitmask.valid_bits = (unsigned int )hdw->std_mask_avail;
#line 862
  return (0);
}
}
#line 865 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_std_val_to_sym(struct pvr2_ctrl *cptr , int msk , int val , char *bufPtr ,
                               unsigned int bufSize , unsigned int *len ) 
{ 


  {
#line 869
  *len = pvr2_std_id_to_str(bufPtr, bufSize, (v4l2_std_id )(msk & val));
#line 870
  return (0);
}
}
#line 873 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_std_sym_to_val(struct pvr2_ctrl *cptr , char const   *bufPtr , unsigned int bufSize ,
                               int *mskp , int *valp ) 
{ 
  int ret ;
  v4l2_std_id id ;

  {
#line 879
  ret = pvr2_std_str_to_id(& id, bufPtr, bufSize);
#line 880
  if (ret < 0) {
#line 880
    return (ret);
  } else {

  }
#line 881
  if ((unsigned long )mskp != (unsigned long )((int *)0)) {
#line 881
    *mskp = (int )id;
  } else {

  }
#line 882
  if ((unsigned long )valp != (unsigned long )((int *)0)) {
#line 882
    *valp = (int )id;
  } else {

  }
#line 883
  return (0);
}
}
#line 886 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_stdcur_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 888
  *vp = (int )(cptr->hdw)->std_mask_cur;
#line 889
  return (0);
}
}
#line 892 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_stdcur_set(struct pvr2_ctrl *cptr , int m , int v ) 
{ 
  struct pvr2_hdw *hdw ;
  v4l2_std_id ns ;

  {
#line 894
  hdw = cptr->hdw;
#line 896
  ns = hdw->std_mask_cur;
#line 897
  ns = ((v4l2_std_id )(~ m) & ns) | (v4l2_std_id )(v & m);
#line 898
  if (hdw->std_mask_cur == ns) {
#line 898
    return (0);
  } else {

  }
#line 899
  hdw->std_mask_cur = ns;
#line 900
  hdw->std_dirty = 1;
#line 901
  return (0);
}
}
#line 904 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_stdcur_is_dirty(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 906
  return ((cptr->hdw)->std_dirty != 0);
}
}
#line 909 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_stdcur_clear_dirty(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 911
  (cptr->hdw)->std_dirty = 0;
#line 912
  return;
}
}
#line 914 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_signal_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 916
  hdw = cptr->hdw;
#line 917
  pvr2_hdw_status_poll(hdw);
#line 918
  *vp = hdw->tuner_signal_info.signal;
#line 919
  return (0);
}
}
#line 922 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_audio_modes_present_get(struct pvr2_ctrl *cptr , int *vp ) 
{ 
  int val ;
  unsigned int subchan ;
  struct pvr2_hdw *hdw ;

  {
#line 924
  val = 0;
#line 926
  hdw = cptr->hdw;
#line 927
  pvr2_hdw_status_poll(hdw);
#line 928
  subchan = hdw->tuner_signal_info.rxsubchans;
#line 929
  if ((int )subchan & 1) {
#line 930
    val = val | 1;
  } else {

  }
#line 932
  if ((subchan & 2U) != 0U) {
#line 933
    val = val | 2;
  } else {

  }
#line 935
  if ((subchan & 8U) != 0U) {
#line 936
    val = val | 8;
  } else {

  }
#line 938
  if ((subchan & 4U) != 0U) {
#line 939
    val = val | 4;
  } else {

  }
#line 941
  *vp = val;
#line 942
  return (0);
}
}
#line 981 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_brightness(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 981
  *vp = (cptr->hdw)->brightness_val;
#line 981
  return (0);
}
}
#line 981 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_set_brightness(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 981
  (cptr->hdw)->brightness_val = v;
#line 981
  (cptr->hdw)->brightness_dirty = 1;
#line 981
  return (0);
}
}
#line 981 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_isdirty_brightness(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 981
  return ((cptr->hdw)->brightness_dirty != 0);
}
}
#line 981 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cleardirty_brightness(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 981
  (cptr->hdw)->brightness_dirty = 0;
#line 982
  return;
}
}
#line 982 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_contrast(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 982
  *vp = (cptr->hdw)->contrast_val;
#line 982
  return (0);
}
}
#line 982 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_set_contrast(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 982
  (cptr->hdw)->contrast_val = v;
#line 982
  (cptr->hdw)->contrast_dirty = 1;
#line 982
  return (0);
}
}
#line 982 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_isdirty_contrast(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 982
  return ((cptr->hdw)->contrast_dirty != 0);
}
}
#line 982 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cleardirty_contrast(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 982
  (cptr->hdw)->contrast_dirty = 0;
#line 983
  return;
}
}
#line 983 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_saturation(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 983
  *vp = (cptr->hdw)->saturation_val;
#line 983
  return (0);
}
}
#line 983 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_set_saturation(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 983
  (cptr->hdw)->saturation_val = v;
#line 983
  (cptr->hdw)->saturation_dirty = 1;
#line 983
  return (0);
}
}
#line 983 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_isdirty_saturation(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 983
  return ((cptr->hdw)->saturation_dirty != 0);
}
}
#line 983 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cleardirty_saturation(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 983
  (cptr->hdw)->saturation_dirty = 0;
#line 984
  return;
}
}
#line 984 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_hue(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 984
  *vp = (cptr->hdw)->hue_val;
#line 984
  return (0);
}
}
#line 984 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_set_hue(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 984
  (cptr->hdw)->hue_val = v;
#line 984
  (cptr->hdw)->hue_dirty = 1;
#line 984
  return (0);
}
}
#line 984 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_isdirty_hue(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 984
  return ((cptr->hdw)->hue_dirty != 0);
}
}
#line 984 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cleardirty_hue(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 984
  (cptr->hdw)->hue_dirty = 0;
#line 985
  return;
}
}
#line 985 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_volume(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 985
  *vp = (cptr->hdw)->volume_val;
#line 985
  return (0);
}
}
#line 985 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_set_volume(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 985
  (cptr->hdw)->volume_val = v;
#line 985
  (cptr->hdw)->volume_dirty = 1;
#line 985
  return (0);
}
}
#line 985 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_isdirty_volume(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 985
  return ((cptr->hdw)->volume_dirty != 0);
}
}
#line 985 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cleardirty_volume(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 985
  (cptr->hdw)->volume_dirty = 0;
#line 986
  return;
}
}
#line 986 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_balance(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 986
  *vp = (cptr->hdw)->balance_val;
#line 986
  return (0);
}
}
#line 986 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_set_balance(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 986
  (cptr->hdw)->balance_val = v;
#line 986
  (cptr->hdw)->balance_dirty = 1;
#line 986
  return (0);
}
}
#line 986 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_isdirty_balance(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 986
  return ((cptr->hdw)->balance_dirty != 0);
}
}
#line 986 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cleardirty_balance(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 986
  (cptr->hdw)->balance_dirty = 0;
#line 987
  return;
}
}
#line 987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_bass(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 987
  *vp = (cptr->hdw)->bass_val;
#line 987
  return (0);
}
}
#line 987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_set_bass(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 987
  (cptr->hdw)->bass_val = v;
#line 987
  (cptr->hdw)->bass_dirty = 1;
#line 987
  return (0);
}
}
#line 987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_isdirty_bass(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 987
  return ((cptr->hdw)->bass_dirty != 0);
}
}
#line 987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cleardirty_bass(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 987
  (cptr->hdw)->bass_dirty = 0;
#line 988
  return;
}
}
#line 988 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_treble(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 988
  *vp = (cptr->hdw)->treble_val;
#line 988
  return (0);
}
}
#line 988 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_set_treble(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 988
  (cptr->hdw)->treble_val = v;
#line 988
  (cptr->hdw)->treble_dirty = 1;
#line 988
  return (0);
}
}
#line 988 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_isdirty_treble(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 988
  return ((cptr->hdw)->treble_dirty != 0);
}
}
#line 988 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cleardirty_treble(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 988
  (cptr->hdw)->treble_dirty = 0;
#line 989
  return;
}
}
#line 989 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_mute(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 989
  *vp = (cptr->hdw)->mute_val;
#line 989
  return (0);
}
}
#line 989 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_set_mute(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 989
  (cptr->hdw)->mute_val = v;
#line 989
  (cptr->hdw)->mute_dirty = 1;
#line 989
  return (0);
}
}
#line 989 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_isdirty_mute(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 989
  return ((cptr->hdw)->mute_dirty != 0);
}
}
#line 989 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cleardirty_mute(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 989
  (cptr->hdw)->mute_dirty = 0;
#line 990
  return;
}
}
#line 990 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_cropl(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 990
  *vp = (cptr->hdw)->cropl_val;
#line 990
  return (0);
}
}
#line 990 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_set_cropl(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 990
  (cptr->hdw)->cropl_val = v;
#line 990
  (cptr->hdw)->cropl_dirty = 1;
#line 990
  return (0);
}
}
#line 990 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_isdirty_cropl(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 990
  return ((cptr->hdw)->cropl_dirty != 0);
}
}
#line 990 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cleardirty_cropl(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 990
  (cptr->hdw)->cropl_dirty = 0;
#line 991
  return;
}
}
#line 991 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_cropt(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 991
  *vp = (cptr->hdw)->cropt_val;
#line 991
  return (0);
}
}
#line 991 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_set_cropt(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 991
  (cptr->hdw)->cropt_val = v;
#line 991
  (cptr->hdw)->cropt_dirty = 1;
#line 991
  return (0);
}
}
#line 991 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_isdirty_cropt(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 991
  return ((cptr->hdw)->cropt_dirty != 0);
}
}
#line 991 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cleardirty_cropt(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 991
  (cptr->hdw)->cropt_dirty = 0;
#line 992
  return;
}
}
#line 992 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_cropw(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 992
  *vp = (cptr->hdw)->cropw_val;
#line 992
  return (0);
}
}
#line 992 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_set_cropw(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 992
  (cptr->hdw)->cropw_val = v;
#line 992
  (cptr->hdw)->cropw_dirty = 1;
#line 992
  return (0);
}
}
#line 992 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_isdirty_cropw(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 992
  return ((cptr->hdw)->cropw_dirty != 0);
}
}
#line 992 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cleardirty_cropw(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 992
  (cptr->hdw)->cropw_dirty = 0;
#line 993
  return;
}
}
#line 993 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_croph(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 993
  *vp = (cptr->hdw)->croph_val;
#line 993
  return (0);
}
}
#line 993 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_set_croph(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 993
  (cptr->hdw)->croph_val = v;
#line 993
  (cptr->hdw)->croph_dirty = 1;
#line 993
  return (0);
}
}
#line 993 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_isdirty_croph(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 993
  return ((cptr->hdw)->croph_dirty != 0);
}
}
#line 993 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cleardirty_croph(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 993
  (cptr->hdw)->croph_dirty = 0;
#line 994
  return;
}
}
#line 994 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_audiomode(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 994
  *vp = (cptr->hdw)->audiomode_val;
#line 994
  return (0);
}
}
#line 994 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_set_audiomode(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 994
  (cptr->hdw)->audiomode_val = v;
#line 994
  (cptr->hdw)->audiomode_dirty = 1;
#line 994
  return (0);
}
}
#line 994 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_isdirty_audiomode(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 994
  return ((cptr->hdw)->audiomode_dirty != 0);
}
}
#line 994 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cleardirty_audiomode(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 994
  (cptr->hdw)->audiomode_dirty = 0;
#line 995
  return;
}
}
#line 995 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_res_hor(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 995
  *vp = (cptr->hdw)->res_hor_val;
#line 995
  return (0);
}
}
#line 995 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_set_res_hor(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 995
  (cptr->hdw)->res_hor_val = v;
#line 995
  (cptr->hdw)->res_hor_dirty = 1;
#line 995
  return (0);
}
}
#line 995 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_isdirty_res_hor(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 995
  return ((cptr->hdw)->res_hor_dirty != 0);
}
}
#line 995 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cleardirty_res_hor(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 995
  (cptr->hdw)->res_hor_dirty = 0;
#line 996
  return;
}
}
#line 996 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_res_ver(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 996
  *vp = (cptr->hdw)->res_ver_val;
#line 996
  return (0);
}
}
#line 996 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_set_res_ver(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 996
  (cptr->hdw)->res_ver_val = v;
#line 996
  (cptr->hdw)->res_ver_dirty = 1;
#line 996
  return (0);
}
}
#line 996 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_isdirty_res_ver(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 996
  return ((cptr->hdw)->res_ver_dirty != 0);
}
}
#line 996 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cleardirty_res_ver(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 996
  (cptr->hdw)->res_ver_dirty = 0;
#line 997
  return;
}
}
#line 997 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_get_srate(struct pvr2_ctrl *cptr , int *vp ) 
{ 


  {
#line 997
  *vp = (cptr->hdw)->srate_val;
#line 997
  return (0);
}
}
#line 997 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_set_srate(struct pvr2_ctrl *cptr , int m , int v ) 
{ 


  {
#line 997
  (cptr->hdw)->srate_val = v;
#line 997
  (cptr->hdw)->srate_dirty = 1;
#line 997
  return (0);
}
}
#line 997 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int ctrl_isdirty_srate(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 997
  return ((cptr->hdw)->srate_dirty != 0);
}
}
#line 997 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void ctrl_cleardirty_srate(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 997
  (cptr->hdw)->srate_dirty = 0;
#line 998
  return;
}
}
#line 1000 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static struct pvr2_ctl_info  const  control_defs[36U]  = 
#line 1000
  {      {"brightness", "Brightness", & ctrl_get_brightness, 0, 0, 0, & ctrl_set_brightness,
      0, 0, 0, & ctrl_isdirty_brightness, & ctrl_cleardirty_brightness, 0, 0, 9963776,
      0, 0, 128, {{0L, 255L}}}, 
        {"contrast", "Contrast", & ctrl_get_contrast, 0, 0, 0, & ctrl_set_contrast, 0,
      0, 0, & ctrl_isdirty_contrast, & ctrl_cleardirty_contrast, 0, 0, 9963777, 0,
      0, 68, {{0L, 127L}}}, 
        {"saturation", "Saturation", & ctrl_get_saturation, 0, 0, 0, & ctrl_set_saturation,
      0, 0, 0, & ctrl_isdirty_saturation, & ctrl_cleardirty_saturation, 0, 0, 9963778,
      0, 0, 64, {{0L, 127L}}}, 
        {"hue", "Hue", & ctrl_get_hue, 0, 0, 0, & ctrl_set_hue, 0, 0, 0, & ctrl_isdirty_hue,
      & ctrl_cleardirty_hue, 0, 0, 9963779, 0, 0, 0, {{-128L, 127L}}}, 
        {"volume", "Volume", & ctrl_get_volume, 0, 0, 0, & ctrl_set_volume, 0, 0, 0,
      & ctrl_isdirty_volume, & ctrl_cleardirty_volume, 0, 0, 9963781, 0, 0, 62000,
      {{0L, 65535L}}}, 
        {"balance", "Balance", & ctrl_get_balance, 0, 0, 0, & ctrl_set_balance, 0, 0,
      0, & ctrl_isdirty_balance, & ctrl_cleardirty_balance, 0, 0, 9963782, 0, 0, 0,
      {{-32768L, 32767L}}}, 
        {"bass", "Bass", & ctrl_get_bass, 0, 0, 0, & ctrl_set_bass, 0, 0, 0, & ctrl_isdirty_bass,
      & ctrl_cleardirty_bass, 0, 0, 9963783, 0, 0, 0, {{-32768L, 32767L}}}, 
        {"treble", "Treble", & ctrl_get_treble, 0, 0, 0, & ctrl_set_treble, 0, 0, 0,
      & ctrl_isdirty_treble, & ctrl_cleardirty_treble, 0, 0, 9963784, 0, 0, 0, {{-32768L,
                                                                                 32767L}}}, 
        {"mute",
      "Mute", & ctrl_get_mute, 0, 0, 0, & ctrl_set_mute, 0, 0, 0, & ctrl_isdirty_mute,
      & ctrl_cleardirty_mute, 0, 3, 9963785, 0, 0, 0, {{0L, 0L}}}, 
        {"crop_left", "Capture crop left margin", & ctrl_get_cropl, & ctrl_get_cropcapdl,
      & ctrl_cropl_min_get, & ctrl_cropl_max_get, & ctrl_set_cropl, 0, 0, 0, & ctrl_isdirty_cropl,
      & ctrl_cleardirty_cropl, 0, 0, 0, 9, 0, 0, {{-129L, 340L}}}, 
        {"crop_top", "Capture crop top margin", & ctrl_get_cropt, & ctrl_get_cropcapdt,
      & ctrl_cropt_min_get, & ctrl_cropt_max_get, & ctrl_set_cropt, 0, 0, 0, & ctrl_isdirty_cropt,
      & ctrl_cleardirty_cropt, 0, 0, 0, 10, 0, 0, {{-35L, 544L}}}, 
        {"crop_width", "Capture crop width", & ctrl_get_cropw, & ctrl_get_cropcapdw,
      0, & ctrl_cropw_max_get, & ctrl_set_cropw, 0, 0, 0, & ctrl_isdirty_cropw, & ctrl_cleardirty_cropw,
      0, 0, 0, 11, 0, 720, {{0L, 864L}}}, 
        {"crop_height", "Capture crop height", & ctrl_get_croph, & ctrl_get_cropcapdh,
      0, & ctrl_croph_max_get, & ctrl_set_croph, 0, 0, 0, & ctrl_isdirty_croph, & ctrl_cleardirty_croph,
      0, 0, 0, 12, 0, 480, {{0L, 576L}}}, 
        {"cropcap_pixel_numerator", "Capture capability pixel aspect numerator", & ctrl_get_cropcappan,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, {{0L, 0L}}}, 
        {"cropcap_pixel_denominator", "Capture capability pixel aspect denominator",
      & ctrl_get_cropcappad, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, {{0L, 0L}}}, 
        {"cropcap_bounds_top",
      "Capture capability bounds top", & ctrl_get_cropcapbt, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 16, 0, 0, {{0L, 0L}}}, 
        {"cropcap_bounds_left", "Capture capability bounds left", & ctrl_get_cropcapbl,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, {{0L, 0L}}}, 
        {"cropcap_bounds_width", "Capture capability bounds width", & ctrl_get_cropcapbw,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, {{0L, 0L}}}, 
        {"cropcap_bounds_height", "Capture capability bounds height", & ctrl_get_cropcapbh,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, {{0L, 0L}}}, 
        {"input", "Video Source", & ctrl_get_input, 0, 0, 0, & ctrl_set_input, & ctrl_check_input,
      0, 0, & ctrl_isdirty_input, & ctrl_cleardirty_input, 0, 1, 0, 4, 0, 0, {.type_enum = {5U,
                                                                                            (char const   * const  *)(& control_values_input)}}}, 
        {"audio_mode",
      "Audio Mode", & ctrl_get_audiomode, 0, 0, 0, & ctrl_set_audiomode, 0, 0, 0,
      & ctrl_isdirty_audiomode, & ctrl_cleardirty_audiomode, 0, 1, 0, 5, 0, 1, {.type_enum = {5U,
                                                                                              (char const   * const  *)(& control_values_audiomode)}}}, 
        {"resolution_hor",
      "Horizontal capture resolution", & ctrl_get_res_hor, 0, 0, 0, & ctrl_set_res_hor,
      0, 0, 0, & ctrl_isdirty_res_hor, & ctrl_cleardirty_res_hor, 0, 0, 0, 7, 0, 720,
      {{19L, 720L}}}, 
        {"resolution_ver", "Vertical capture resolution", & ctrl_get_res_ver, 0, & ctrl_vres_min_get,
      & ctrl_vres_max_get, & ctrl_set_res_ver, 0, 0, 0, & ctrl_isdirty_res_ver, & ctrl_cleardirty_res_ver,
      0, 0, 0, 8, 0, 480, {{17L, 576L}}}, 
        {"srate", "Audio Sampling Frequency", & ctrl_get_srate, 0, 0, 0, & ctrl_set_srate,
      0, 0, 0, & ctrl_isdirty_srate, & ctrl_cleardirty_srate, 0, 1, 10029412, 0, 0,
      1, {.type_enum = {3U, (char const   * const  *)(& control_values_srate)}}}, 
        {"frequency", "Tuner Frequency (Hz)", & ctrl_freq_get, 0, & ctrl_freq_min_get,
      & ctrl_freq_max_get, & ctrl_freq_set, 0, 0, 0, & ctrl_freq_is_dirty, & ctrl_freq_clear_dirty,
      0, 0, 0, 6, 0, 0, {{0L, 0L}}}, 
        {"channel", "Channel", & ctrl_channel_get, 0, 0, 0, & ctrl_channel_set, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, {{0L, 500L}}}, 
        {"freq_table_value", "Channel Program Frequency", & ctrl_channelfreq_get, 0,
      & ctrl_freq_min_get, & ctrl_freq_max_get, & ctrl_channelfreq_set, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, {{0L, 0L}}}, 
        {"freq_table_channel", "Channel Program ID", & ctrl_channelprog_get, 0, 0, 0,
      & ctrl_channelprog_set, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, {{0L, 500L}}}, 
        {"streaming_enabled", "Streaming Enabled", & ctrl_streamingenabled_get, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, {{0L, 0L}}}, 
        {"usb_speed", "USB Speed", & ctrl_hsm_get, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
      0, 0, 0, {.type_enum = {3U, (char const   * const  *)(& control_values_hsm)}}}, 
        {"master_state",
      "Master State", & ctrl_masterstate_get, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
      0, 0, 0, {.type_enum = {7U, (char const   * const  *)(& pvr2_state_names)}}}, 
        {"signal_present",
      "Signal Present", & ctrl_signal_get, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, {{0L, 65535L}}}, 
        {"audio_modes_present", "Audio Modes Present", & ctrl_audio_modes_present_get,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, {.type_bitmask = {15U, (char const   **)(& control_values_audiomode)}}}, 
        {"video_standard_mask_available",
      "Video Standards Available Mask", & ctrl_stdavail_get, 0, 0, 0, & ctrl_stdavail_set,
      0, & ctrl_std_val_to_sym, & ctrl_std_sym_to_val, 0, 0, 0, 2, 0, 3, 1, 0, {{0L,
                                                                                 0L}}}, 
        {"video_standard_mask_active",
      "Video Standards In Use Mask", & ctrl_stdcur_get, 0, 0, 0, & ctrl_stdcur_set,
      0, & ctrl_std_val_to_sym, & ctrl_std_sym_to_val, & ctrl_stdcur_is_dirty, & ctrl_stdcur_clear_dirty,
      0, 2, 0, 2, 1, 0, {{0L, 0L}}}, 
        {"video_standard_mask_detected", "Video Standards Detected Mask", & ctrl_stddetect_get,
      0, 0, 0, 0, 0, & ctrl_std_val_to_sym, & ctrl_std_sym_to_val, 0, 0, 0, 2, 0,
      19, 1, 0, {{0L, 0L}}}};
#line 1278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
char const   *pvr2_config_get_name(enum pvr2_config cfg ) 
{ 


  {
#line 1280
  switch ((unsigned int )cfg) {
  case 0U: ;
#line 1281
  return ("empty");
  case 1U: ;
#line 1282
  return ("mpeg");
  case 2U: ;
#line 1283
  return ("vbi");
  case 3U: ;
#line 1284
  return ("pcm");
  case 4U: ;
#line 1285
  return ("raw video");
  }
#line 1287
  return ("<unknown>");
}
}
#line 1291 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
struct usb_device *pvr2_hdw_get_dev(struct pvr2_hdw *hdw ) 
{ 


  {
#line 1293
  return (hdw->usb_dev);
}
}
#line 1297 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
unsigned long pvr2_hdw_get_sn(struct pvr2_hdw *hdw ) 
{ 


  {
#line 1299
  return (hdw->serial_number);
}
}
#line 1303 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
char const   *pvr2_hdw_get_bus_info(struct pvr2_hdw *hdw ) 
{ 


  {
#line 1305
  return ((char const   *)(& hdw->bus_info));
}
}
#line 1309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
char const   *pvr2_hdw_get_device_identifier(struct pvr2_hdw *hdw ) 
{ 


  {
#line 1311
  return ((char const   *)(& hdw->identifier));
}
}
#line 1315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
unsigned long pvr2_hdw_get_cur_freq(struct pvr2_hdw *hdw ) 
{ 


  {
#line 1317
  return ((unsigned long )(hdw->freqSelector != 0U ? hdw->freqValTelevision : hdw->freqValRadio));
}
}
#line 1322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_hdw_set_cur_freq(struct pvr2_hdw *hdw , unsigned long val ) 
{ 


  {
#line 1324
  if (hdw->input_val == 4) {
#line 1325
    if (hdw->freqSelector != 0U) {
#line 1327
      hdw->freqSelector = 0U;
#line 1328
      hdw->freqDirty = 1;
    } else {

    }
#line 1330
    if ((unsigned long )hdw->freqValRadio != val) {
#line 1331
      hdw->freqValRadio = (unsigned int )val;
#line 1332
      hdw->freqSlotRadio = 0U;
#line 1333
      hdw->freqDirty = 1;
    } else {

    }
  } else {
#line 1336
    if (hdw->freqSelector == 0U) {
#line 1338
      hdw->freqSelector = 1U;
#line 1339
      hdw->freqDirty = 1;
    } else {

    }
#line 1341
    if ((unsigned long )hdw->freqValTelevision != val) {
#line 1342
      hdw->freqValTelevision = (unsigned int )val;
#line 1343
      hdw->freqSlotTelevision = 0U;
#line 1344
      hdw->freqDirty = 1;
    } else {

    }
  }
#line 1347
  return;
}
}
#line 1349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_get_unit_number(struct pvr2_hdw *hdw ) 
{ 


  {
#line 1351
  return (hdw->unit_number);
}
}
#line 1361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_locate_firmware(struct pvr2_hdw *hdw , struct firmware  const  **fw_entry ,
                                char const   *fwtypename , unsigned int fwcount ,
                                char const   **fwnames ) 
{ 
  unsigned int idx ;
  int ret ;

  {
#line 1368
  ret = -22;
#line 1369
  idx = 0U;
#line 1369
  goto ldv_52983;
  ldv_52982: 
#line 1370
  ret = request_firmware(fw_entry, *(fwnames + (unsigned long )idx), & (hdw->usb_dev)->dev);
#line 1373
  if (ret == 0) {
#line 1374
    if ((pvrusb2_debug & 32768) != 0) {
#line 1374
      printk("\016pvrusb2: Located %s firmware: %s; uploading...\n", fwtypename, *(fwnames + (unsigned long )idx));
    } else {

    }
#line 1378
    return ((int )idx);
  } else {

  }
#line 1380
  if (ret == -2) {
#line 1380
    goto ldv_52981;
  } else {

  }
#line 1381
  if ((pvrusb2_debug & 2) != 0) {
#line 1381
    printk("\016pvrusb2: request_firmware fatal error with code=%d\n", ret);
  } else {

  }
#line 1383
  return (ret);
  ldv_52981: 
#line 1369
  idx = idx + 1U;
  ldv_52983: ;
#line 1369
  if (idx < fwcount) {
#line 1371
    goto ldv_52982;
  } else {

  }

#line 1385
  if ((pvrusb2_debug & 2) != 0) {
#line 1385
    printk("\016pvrusb2: ***WARNING*** Device %s firmware seems to be missing.\n",
           fwtypename);
  } else {

  }
#line 1390
  if ((pvrusb2_debug & 2) != 0) {
#line 1390
    printk("\016pvrusb2: Did you install the pvrusb2 firmware files in their proper location?\n");
  } else {

  }
#line 1393
  if (fwcount == 1U) {
#line 1394
    if ((pvrusb2_debug & 2) != 0) {
#line 1394
      printk("\016pvrusb2: request_firmware unable to locate %s file %s\n", fwtypename,
             *fwnames);
    } else {

    }
  } else {
#line 1398
    if ((pvrusb2_debug & 2) != 0) {
#line 1398
      printk("\016pvrusb2: request_firmware unable to locate one of the following %s files:\n",
             fwtypename);
    } else {

    }
#line 1402
    idx = 0U;
#line 1402
    goto ldv_52986;
    ldv_52985: ;
#line 1403
    if ((pvrusb2_debug & 2) != 0) {
#line 1403
      printk("\016pvrusb2: request_firmware: Failed to find %s\n", *(fwnames + (unsigned long )idx));
    } else {

    }
#line 1402
    idx = idx + 1U;
    ldv_52986: ;
#line 1402
    if (idx < fwcount) {
#line 1404
      goto ldv_52985;
    } else {

    }

  }
#line 1408
  return (ret);
}
}
#line 1422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_upload_firmware1(struct pvr2_hdw *hdw ) 
{ 
  struct firmware  const  *fw_entry ;
  void *fw_ptr ;
  unsigned int pipe ;
  unsigned int fwsize ;
  int ret ;
  u16 address ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
#line 1424
  fw_entry = (struct firmware  const  *)0;
#line 1431
  if ((unsigned int )(hdw->hdw_desc)->fx2_firmware.cnt == 0U) {
#line 1432
    hdw->fw1_state = 4;
#line 1433
    if ((pvrusb2_debug & 2) != 0) {
#line 1433
      printk("\016pvrusb2: Connected device type defines no firmware to upload; ignoring firmware\n");
    } else {

    }
#line 1436
    return (-25);
  } else {

  }
#line 1439
  hdw->fw1_state = 2;
#line 1441
  if ((pvrusb2_debug & 32768) != 0) {
#line 1441
    printk("\016pvrusb2: pvr2_upload_firmware1\n");
  } else {

  }
#line 1443
  ret = pvr2_locate_firmware(hdw, & fw_entry, "fx2 controller", (hdw->hdw_desc)->fx2_firmware.cnt,
                             (hdw->hdw_desc)->fx2_firmware.lst);
#line 1446
  if (ret < 0) {
#line 1447
    if (ret == -2) {
#line 1447
      hdw->fw1_state = 1;
    } else {

    }
#line 1448
    return (ret);
  } else {

  }
#line 1451
  tmp = __create_pipe(hdw->usb_dev, 0U);
#line 1451
  usb_clear_halt(hdw->usb_dev, (int )(tmp | 3221225472U));
#line 1453
  tmp___0 = __create_pipe(hdw->usb_dev, 0U);
#line 1453
  pipe = tmp___0 | 2147483648U;
#line 1454
  fwsize = (unsigned int )fw_entry->size;
#line 1456
  if (fwsize != 8192U && ((unsigned int )*((unsigned char *)hdw->hdw_desc + 88UL) == 0U || fwsize != 16384U)) {
#line 1458
    if ((unsigned int )*((unsigned char *)hdw->hdw_desc + 88UL) != 0U) {
#line 1459
      if ((pvrusb2_debug & 2) != 0) {
#line 1459
        printk("\016pvrusb2: Wrong fx2 firmware size (expected 8192 or 16384, got %u)\n",
               fwsize);
      } else {

      }
    } else
#line 1464
    if ((pvrusb2_debug & 2) != 0) {
#line 1464
      printk("\016pvrusb2: Wrong fx2 firmware size (expected 8192, got %u)\n", fwsize);
    } else {

    }
#line 1469
    release_firmware(fw_entry);
#line 1470
    return (-12);
  } else {

  }
#line 1473
  fw_ptr = kmalloc(2048UL, 208U);
#line 1474
  if ((unsigned long )fw_ptr == (unsigned long )((void *)0)) {
#line 1475
    release_firmware(fw_entry);
#line 1476
    return (-12);
  } else {

  }
#line 1480
  pvr2_hdw_cpureset_assert(hdw, 1);
#line 1485
  ret = 0;
#line 1486
  address = 0U;
#line 1486
  goto ldv_52998;
  ldv_52997: 
#line 1487
  memcpy(fw_ptr, (void const   *)fw_entry->data + (unsigned long )address, 2048UL);
#line 1488
  tmp___1 = usb_control_msg(hdw->usb_dev, pipe, 160, 64, (int )address, 0, fw_ptr,
                            2048, 250);
#line 1488
  ret = tmp___1 + ret;
#line 1486
  address = (unsigned int )address + 2048U;
  ldv_52998: ;
#line 1486
  if ((unsigned int )address < fwsize) {
#line 1488
    goto ldv_52997;
  } else {

  }

#line 1492
  if ((pvrusb2_debug & 32768) != 0) {
#line 1492
    printk("\016pvrusb2: Upload done, releasing device\'s CPU\n");
  } else {

  }
#line 1495
  pvr2_hdw_cpureset_assert(hdw, 0);
#line 1497
  kfree((void const   *)fw_ptr);
#line 1498
  release_firmware(fw_entry);
#line 1500
  if ((pvrusb2_debug & 32768) != 0) {
#line 1500
    printk("\016pvrusb2: Upload done (%d bytes sent)\n", ret);
  } else {

  }
#line 1503
  if ((unsigned int )ret == fwsize) {
#line 1504
    hdw->fw1_state = 3;
#line 1505
    return (0);
  } else {

  }
#line 1508
  return (-5);
}
}
#line 1519 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_upload_firmware2(struct pvr2_hdw *hdw ) 
{ 
  struct firmware  const  *fw_entry ;
  void *fw_ptr ;
  unsigned int pipe ;
  unsigned int fw_len ;
  unsigned int fw_done ;
  unsigned int bcnt ;
  unsigned int icnt ;
  int actual_length ;
  int ret ;
  int fwidx ;
  char const   *fw_files[1U] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned int tmp___17 ;
  __u32 tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 1521
  fw_entry = (struct firmware  const  *)0;
#line 1525
  ret = 0;
#line 1527
  fw_files[0] = "v4l-cx2341x-enc.fw";
#line 1531
  if ((unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) != 0U) {
#line 1532
    return (0);
  } else {

  }
#line 1535
  if ((pvrusb2_debug & 32768) != 0) {
#line 1535
    printk("\016pvrusb2: pvr2_upload_firmware2\n");
  } else {

  }
#line 1537
  ret = pvr2_locate_firmware(hdw, & fw_entry, "encoder", 1U, (char const   **)(& fw_files));
#line 1539
  if (ret < 0) {
#line 1539
    return (ret);
  } else {

  }
#line 1540
  fwidx = ret;
#line 1541
  ret = 0;
#line 1545
  hdw->enc_cur_valid = 0;
#line 1549
  ldv_del_timer_sync_229(& hdw->encoder_run_timer);
#line 1550
  if (hdw->state_encoder_runok != 0) {
#line 1551
    hdw->state_encoder_runok = 0;
#line 1552
    trace_stbit("state_encoder_runok", hdw->state_encoder_runok);
  } else {

  }
#line 1556
  tmp = pvr2_write_register(hdw, 72, 4294967295U);
#line 1556
  ret = tmp | ret;
#line 1557
  tmp___0 = pvr2_hdw_gpio_chg_dir(hdw, 4294967295U, 136U);
#line 1557
  ret = tmp___0 | ret;
#line 1558
  tmp___1 = pvr2_hdw_gpio_chg_out(hdw, 4294967295U, 8U);
#line 1558
  ret = tmp___1 | ret;
#line 1559
  tmp___2 = pvr2_hdw_cmd_deep_reset(hdw);
#line 1559
  ret = tmp___2 | ret;
#line 1560
  tmp___3 = pvr2_write_register(hdw, 41060, 0U);
#line 1560
  ret = tmp___3 | ret;
#line 1561
  tmp___4 = pvr2_hdw_gpio_chg_dir(hdw, 4294967295U, 1032U);
#line 1561
  ret = tmp___4 | ret;
#line 1562
  tmp___5 = pvr2_hdw_gpio_chg_out(hdw, 4294967295U, 8U);
#line 1562
  ret = tmp___5 | ret;
#line 1563
  tmp___6 = pvr2_write_register(hdw, 36952, 4294967277U);
#line 1563
  ret = tmp___6 | ret;
#line 1564
  tmp___7 = pvr2_write_register(hdw, 36948, 4294967293U);
#line 1564
  ret = tmp___7 | ret;
#line 1565
  tmp___8 = pvr2_write_register(hdw, 2040, 2147485696U);
#line 1565
  ret = tmp___8 | ret;
#line 1566
  tmp___9 = pvr2_write_register(hdw, 2044, 26U);
#line 1566
  ret = tmp___9 | ret;
#line 1567
  tmp___10 = pvr2_write_register(hdw, 1792, 0U);
#line 1567
  ret = tmp___10 | ret;
#line 1568
  tmp___11 = pvr2_write_register(hdw, 43520, 0U);
#line 1568
  ret = tmp___11 | ret;
#line 1569
  tmp___12 = pvr2_write_register(hdw, 43524, 358416U);
#line 1569
  ret = tmp___12 | ret;
#line 1570
  tmp___13 = pvr2_write_register(hdw, 43536, 1344768U);
#line 1570
  ret = tmp___13 | ret;
#line 1571
  tmp___14 = pvr2_write_register(hdw, 43544, 8650752U);
#line 1571
  ret = tmp___14 | ret;
#line 1572
  tmp___15 = pvr2_issue_simple_cmd(hdw, 82U);
#line 1572
  ret = tmp___15 | ret;
#line 1573
  tmp___16 = pvr2_issue_simple_cmd(hdw, 262U);
#line 1573
  ret = tmp___16 | ret;
#line 1575
  if (ret != 0) {
#line 1576
    if ((pvrusb2_debug & 2) != 0) {
#line 1576
      printk("\016pvrusb2: firmware2 upload prep failed, ret=%d\n", ret);
    } else {

    }
#line 1578
    release_firmware(fw_entry);
#line 1579
    goto done;
  } else {

  }
#line 1584
  fw_len = (unsigned int )fw_entry->size;
#line 1586
  if ((fw_len & 3U) != 0U) {
#line 1587
    if ((pvrusb2_debug & 2) != 0) {
#line 1587
      printk("\016pvrusb2: size of %s firmware must be a multiple of %zu bytes\n",
             fw_files[fwidx], 4UL);
    } else {

    }
#line 1591
    release_firmware(fw_entry);
#line 1592
    ret = -22;
#line 1593
    goto done;
  } else {

  }
#line 1596
  fw_ptr = kmalloc(8192UL, 208U);
#line 1597
  if ((unsigned long )fw_ptr == (unsigned long )((void *)0)) {
#line 1598
    release_firmware(fw_entry);
#line 1599
    if ((pvrusb2_debug & 2) != 0) {
#line 1599
      printk("\016pvrusb2: failed to allocate memory for firmware2 upload\n");
    } else {

    }
#line 1601
    ret = -12;
#line 1602
    goto done;
  } else {

  }
#line 1605
  tmp___17 = __create_pipe(hdw->usb_dev, 2U);
#line 1605
  pipe = tmp___17 | 3221225472U;
#line 1607
  fw_done = 0U;
#line 1608
  fw_done = 0U;
#line 1608
  goto ldv_53022;
  ldv_53021: 
#line 1609
  bcnt = fw_len - fw_done;
#line 1610
  if (bcnt > 8192U) {
#line 1610
    bcnt = 8192U;
  } else {

  }
#line 1611
  memcpy(fw_ptr, (void const   *)fw_entry->data + (unsigned long )fw_done, (size_t )bcnt);
#line 1624
  icnt = 0U;
#line 1624
  goto ldv_53018;
  ldv_53017: 
#line 1625
  tmp___18 = __fswab32(*((u32 *)fw_ptr + (unsigned long )icnt));
#line 1625
  *((u32 *)fw_ptr + (unsigned long )icnt) = tmp___18;
#line 1624
  icnt = icnt + 1U;
  ldv_53018: ;
#line 1624
  if (bcnt / 4U > icnt) {
#line 1626
    goto ldv_53017;
  } else {

  }
#line 1627
  tmp___19 = usb_bulk_msg(hdw->usb_dev, pipe, fw_ptr, (int )bcnt, & actual_length,
                          250);
#line 1627
  ret = tmp___19 | ret;
#line 1629
  ret = ((unsigned int )actual_length != bcnt) | ret;
#line 1630
  if (ret != 0) {
#line 1630
    goto ldv_53020;
  } else {

  }
#line 1631
  fw_done = fw_done + bcnt;
  ldv_53022: ;
#line 1608
  if (fw_done < fw_len) {
#line 1610
    goto ldv_53021;
  } else {

  }
  ldv_53020: ;
#line 1634
  if ((pvrusb2_debug & 32768) != 0) {
#line 1634
    printk("\016pvrusb2: upload of %s : %i / %i \n", fw_files[fwidx], fw_done, fw_len);
  } else {

  }
#line 1637
  kfree((void const   *)fw_ptr);
#line 1638
  release_firmware(fw_entry);
#line 1640
  if (ret != 0) {
#line 1641
    if ((pvrusb2_debug & 2) != 0) {
#line 1641
      printk("\016pvrusb2: firmware2 upload transfer failure\n");
    } else {

    }
#line 1643
    goto done;
  } else {

  }
#line 1648
  tmp___20 = pvr2_write_register(hdw, 36948, 4294967295U);
#line 1648
  ret = tmp___20 | ret;
#line 1649
  tmp___21 = pvr2_write_register(hdw, 36952, 4294967272U);
#line 1649
  ret = tmp___21 | ret;
#line 1650
  tmp___22 = pvr2_issue_simple_cmd(hdw, 262U);
#line 1650
  ret = tmp___22 | ret;
#line 1652
  if (ret != 0) {
#line 1653
    if ((pvrusb2_debug & 2) != 0) {
#line 1653
      printk("\016pvrusb2: firmware2 upload post-proc failure\n");
    } else {

    }
  } else {

  }
  done: ;
#line 1658
  if ((unsigned int )((unsigned char )(hdw->hdw_desc)->signal_routing_scheme) == 1U) {
#line 1662
    pvr2_hdw_gpio_chg_dir(hdw, 2048U, 4294967295U);
  } else {

  }
#line 1664
  return (ret);
}
}
#line 1668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static char const   *pvr2_get_state_name(unsigned int st ) 
{ 


  {
#line 1670
  if (st <= 6U) {
#line 1671
    return (pvr2_state_names[st]);
  } else {

  }
#line 1673
  return ("???");
}
}
#line 1676 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_decoder_enable(struct pvr2_hdw *hdw , int enablefl ) 
{ 
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct v4l2_subdev *__sd___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
#line 1682
  if ((pvrusb2_debug & 65536) != 0) {
#line 1682
    printk("\016pvrusb2: subdev v4l2 stream=%s\n", enablefl != 0 ? (char *)"on" : (char *)"off");
  } else {

  }
#line 1684
  __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 1684
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 1684
  goto ldv_53038;
  ldv_53037: ;
#line 1684
  if ((unsigned long )(__sd->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->video)->s_stream != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                               int  ))0)) {
#line 1684
    (*(((__sd->ops)->video)->s_stream))(__sd, enablefl);
  } else {

  }
#line 1684
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1684
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_53038: ;
#line 1684
  if ((unsigned long )(& __sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 1686
    goto ldv_53037;
  } else {

  }
#line 1685
  __mptr___1 = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 1685
  __sd___0 = (struct v4l2_subdev *)__mptr___1 + 0xffffffffffffff88UL;
#line 1685
  goto ldv_53046;
  ldv_53045: ;
#line 1685
  if ((unsigned long )(__sd___0->ops)->audio != (unsigned long )((struct v4l2_subdev_audio_ops  const  */* const  */)0) && (unsigned long )((__sd___0->ops)->audio)->s_stream != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                       int  ))0)) {
#line 1685
    (*(((__sd___0->ops)->audio)->s_stream))(__sd___0, enablefl);
  } else {

  }
#line 1685
  __mptr___2 = (struct list_head  const  *)__sd___0->list.next;
#line 1685
  __sd___0 = (struct v4l2_subdev *)__mptr___2 + 0xffffffffffffff88UL;
  ldv_53046: ;
#line 1685
  if ((unsigned long )(& __sd___0->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 1687
    goto ldv_53045;
  } else {

  }

#line 1686
  if (hdw->decoder_client_id != 0U) {
#line 1690
    return (0);
  } else {

  }
#line 1692
  if (hdw->flag_decoder_missed == 0) {
#line 1693
    if ((pvrusb2_debug & 2) != 0) {
#line 1693
      printk("\016pvrusb2: WARNING: No decoder present\n");
    } else {

    }
#line 1695
    hdw->flag_decoder_missed = 1;
#line 1696
    trace_stbit("flag_decoder_missed", hdw->flag_decoder_missed);
  } else {

  }
#line 1699
  return (-5);
}
}
#line 1703 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_get_state(struct pvr2_hdw *hdw ) 
{ 


  {
#line 1705
  return ((int )hdw->master_state);
}
}
#line 1709 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_hdw_untrip_unlocked(struct pvr2_hdw *hdw ) 
{ 


  {
#line 1711
  if (hdw->flag_tripped == 0) {
#line 1711
    return (0);
  } else {

  }
#line 1712
  hdw->flag_tripped = 0;
#line 1713
  if ((pvrusb2_debug & 2) != 0) {
#line 1713
    printk("\016pvrusb2: Clearing driver error statuss\n");
  } else {

  }
#line 1715
  return (1);
}
}
#line 1719 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_untrip(struct pvr2_hdw *hdw ) 
{ 
  int fl ;

  {
#line 1722
  ldv_mutex_lock_230(& hdw->big_lock_mutex);
#line 1722
  hdw->big_lock_held = 1;
#line 1723
  fl = pvr2_hdw_untrip_unlocked(hdw);
#line 1724
  hdw->big_lock_held = 0;
#line 1724
  ldv_mutex_unlock_231(& hdw->big_lock_mutex);
#line 1725
  if (fl != 0) {
#line 1725
    pvr2_hdw_state_sched(hdw);
  } else {

  }
#line 1726
  return (0);
}
}
#line 1732 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_get_streaming(struct pvr2_hdw *hdw ) 
{ 


  {
#line 1734
  return (hdw->state_pipeline_req != 0);
}
}
#line 1738 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_set_streaming(struct pvr2_hdw *hdw , int enable_flag ) 
{ 
  int ret ;
  int st ;

  {
#line 1741
  ldv_mutex_lock_232(& hdw->big_lock_mutex);
#line 1741
  hdw->big_lock_held = 1;
#line 1742
  pvr2_hdw_untrip_unlocked(hdw);
#line 1743
  if ((enable_flag == 0) ^ (hdw->state_pipeline_req == 0)) {
#line 1744
    hdw->state_pipeline_req = enable_flag != 0;
#line 1745
    if ((pvrusb2_debug & 64) != 0) {
#line 1745
      printk("\016pvrusb2: /*--TRACE_STREAM--*/ %s\n", enable_flag != 0 ? (char *)"enable" : (char *)"disable");
    } else {

    }
  } else {

  }
#line 1749
  pvr2_hdw_state_sched(hdw);
#line 1750
  hdw->big_lock_held = 0;
#line 1750
  ldv_mutex_unlock_233(& hdw->big_lock_mutex);
#line 1751
  ret = pvr2_hdw_wait(hdw, 0);
#line 1751
  if (ret < 0) {
#line 1751
    return (ret);
  } else {

  }
#line 1752
  if (enable_flag != 0) {
#line 1753
    goto ldv_53068;
    ldv_53067: ;
#line 1754
    if (st != 5) {
#line 1754
      return (-5);
    } else {

    }
#line 1755
    ret = pvr2_hdw_wait(hdw, st);
#line 1755
    if (ret < 0) {
#line 1755
      return (ret);
    } else {

    }
    ldv_53068: 
#line 1753
    st = (int )hdw->master_state;
#line 1753
    if (st != 6) {
#line 1755
      goto ldv_53067;
    } else {

    }

  } else {

  }
#line 1758
  return (0);
}
}
#line 1762 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_set_stream_type(struct pvr2_hdw *hdw , enum pvr2_config config ) 
{ 
  int fl ;
  int tmp ;

  {
#line 1765
  ldv_mutex_lock_234(& hdw->big_lock_mutex);
#line 1765
  hdw->big_lock_held = 1;
#line 1766
  fl = (unsigned int )hdw->desired_stream_type != (unsigned int )config;
#line 1766
  if (fl != 0) {
#line 1767
    hdw->desired_stream_type = config;
#line 1768
    hdw->state_pipeline_config = 0;
#line 1769
    trace_stbit("state_pipeline_config", hdw->state_pipeline_config);
#line 1771
    pvr2_hdw_state_sched(hdw);
  } else {

  }
#line 1773
  hdw->big_lock_held = 0;
#line 1773
  ldv_mutex_unlock_235(& hdw->big_lock_mutex);
#line 1774
  if (fl != 0) {
#line 1774
    return (0);
  } else {

  }
#line 1775
  tmp = pvr2_hdw_wait(hdw, 0);
#line 1775
  return (tmp);
}
}
#line 1779 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int get_default_tuner_type(struct pvr2_hdw *hdw ) 
{ 
  int unit_number ;
  int tp ;

  {
#line 1781
  unit_number = hdw->unit_number;
#line 1782
  tp = -1;
#line 1783
  if (unit_number >= 0 && unit_number <= 19) {
#line 1784
    tp = tuner[unit_number];
  } else {

  }
#line 1786
  if (tp < 0) {
#line 1786
    return (-22);
  } else {

  }
#line 1787
  hdw->tuner_type = (unsigned int )tp;
#line 1788
  hdw->tuner_updated = 1;
#line 1789
  return (0);
}
}
#line 1793 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static v4l2_std_id get_default_standard(struct pvr2_hdw *hdw ) 
{ 
  int unit_number ;
  int tp ;

  {
#line 1795
  unit_number = hdw->unit_number;
#line 1796
  tp = 0;
#line 1797
  if (unit_number >= 0 && unit_number <= 19) {
#line 1798
    tp = video_std[unit_number];
#line 1799
    if (tp != 0) {
#line 1799
      return ((v4l2_std_id )tp);
    } else {

    }
  } else {

  }
#line 1801
  return (0ULL);
}
}
#line 1805 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static unsigned int get_default_error_tolerance(struct pvr2_hdw *hdw ) 
{ 
  int unit_number ;
  int tp ;

  {
#line 1807
  unit_number = hdw->unit_number;
#line 1808
  tp = 0;
#line 1809
  if (unit_number >= 0 && unit_number <= 19) {
#line 1810
    tp = tolerance[unit_number];
  } else {

  }
#line 1812
  return ((unsigned int )tp);
}
}
#line 1816 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_hdw_check_firmware(struct pvr2_hdw *hdw ) 
{ 
  int result ;

  {
#line 1823
  ldv_mutex_lock_236(& hdw->ctl_lock_mutex);
#line 1823
  hdw->ctl_lock_held = 1;
#line 1824
  hdw->cmd_buffer[0] = 235U;
#line 1825
  result = pvr2_send_request_ex(hdw, 250U, 1, (void *)(& hdw->cmd_buffer), 1U, (void *)(& hdw->cmd_buffer),
                                1U);
#line 1828
  if (result < 0) {

  } else {

  }
#line 1829
  hdw->ctl_lock_held = 0;
#line 1829
  ldv_mutex_unlock_237(& hdw->ctl_lock_mutex);
#line 1830
  if (result != 0) {
#line 1831
    if ((pvrusb2_debug & 32) != 0) {
#line 1831
      printk("\016pvrusb2: Probe of device endpoint 1 result status %d\n", result);
    } else {

    }
  } else
#line 1835
  if ((pvrusb2_debug & 32) != 0) {
#line 1835
    printk("\016pvrusb2: Probe of device endpoint 1 succeeded\n");
  } else {

  }
#line 1838
  return (result == 0);
}
}
#line 1856 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static struct pvr2_std_hack  const  std_eeprom_maps[5U]  = {      {851983ULL, 0ULL, 7ULL}, 
        {46848ULL, 0ULL, 4096ULL}, 
        {16ULL, 0ULL, 16ULL}, 
        {12582912ULL, 0ULL, 12582912ULL}, 
        {3277024ULL, 0ULL, 224ULL}};
#line 1879 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_hdw_setup_std(struct pvr2_hdw *hdw ) 
{ 
  char buf[40U] ;
  unsigned int bcnt ;
  v4l2_std_id std1 ;
  v4l2_std_id std2 ;
  v4l2_std_id std3 ;
  unsigned int idx ;

  {
#line 1885
  std1 = get_default_standard(hdw);
#line 1886
  std3 = std1 == 0ULL ? (hdw->hdw_desc)->default_std_mask : 0ULL;
#line 1888
  bcnt = pvr2_std_id_to_str((char *)(& buf), 40U, hdw->std_mask_eeprom);
#line 1889
  if ((pvrusb2_debug & 16) != 0) {
#line 1889
    printk("\016pvrusb2: Supported video standard(s) reported available in hardware: %.*s\n",
           bcnt, (char *)(& buf));
  } else {

  }
#line 1894
  hdw->std_mask_avail = hdw->std_mask_eeprom;
#line 1896
  std2 = (std1 | std3) & ~ hdw->std_mask_avail;
#line 1897
  if (std2 != 0ULL) {
#line 1898
    bcnt = pvr2_std_id_to_str((char *)(& buf), 40U, std2);
#line 1899
    if ((pvrusb2_debug & 16) != 0) {
#line 1899
      printk("\016pvrusb2: Expanding supported video standards to include: %.*s\n",
             bcnt, (char *)(& buf));
    } else {

    }
#line 1903
    hdw->std_mask_avail = hdw->std_mask_avail | std2;
  } else {

  }
#line 1906
  hdw->std_info_cur.def.type_bitmask.valid_bits = (unsigned int )hdw->std_mask_avail;
#line 1908
  if (std1 != 0ULL) {
#line 1909
    bcnt = pvr2_std_id_to_str((char *)(& buf), 40U, std1);
#line 1910
    if ((pvrusb2_debug & 16) != 0) {
#line 1910
      printk("\016pvrusb2: Initial video standard forced to %.*s\n", bcnt, (char *)(& buf));
    } else {

    }
#line 1913
    hdw->std_mask_cur = std1;
#line 1914
    hdw->std_dirty = 1;
#line 1915
    return;
  } else {

  }
#line 1917
  if (std3 != 0ULL) {
#line 1918
    bcnt = pvr2_std_id_to_str((char *)(& buf), 40U, std3);
#line 1919
    if ((pvrusb2_debug & 16) != 0) {
#line 1919
      printk("\016pvrusb2: Initial video standard (determined by device type): %.*s\n",
             bcnt, (char *)(& buf));
    } else {

    }
#line 1922
    hdw->std_mask_cur = std3;
#line 1923
    hdw->std_dirty = 1;
#line 1924
    return;
  } else {

  }
#line 1929
  idx = 0U;
#line 1929
  goto ldv_53113;
  ldv_53112: ;
#line 1930
  if ((unsigned long long )std_eeprom_maps[idx].msk != 0ULL ? (((unsigned long long )std_eeprom_maps[idx].pat ^ hdw->std_mask_eeprom) & (unsigned long long )std_eeprom_maps[idx].msk) != 0ULL : (unsigned long long )std_eeprom_maps[idx].pat != hdw->std_mask_eeprom) {
#line 1935
    goto ldv_53111;
  } else {

  }
#line 1936
  bcnt = pvr2_std_id_to_str((char *)(& buf), 40U, std_eeprom_maps[idx].std);
#line 1938
  if ((pvrusb2_debug & 16) != 0) {
#line 1938
    printk("\016pvrusb2: Initial video standard guessed as %.*s\n", bcnt, (char *)(& buf));
  } else {

  }
#line 1941
  hdw->std_mask_cur = std_eeprom_maps[idx].std;
#line 1942
  hdw->std_dirty = 1;
#line 1943
  return;
  ldv_53111: 
#line 1929
  idx = idx + 1U;
  ldv_53113: ;
#line 1929
  if (idx <= 4U) {
#line 1931
    goto ldv_53112;
  } else {

  }

#line 1937
  return;
}
}
#line 1950 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static unsigned int pvr2_copy_i2c_addr_list(unsigned short *dst , unsigned char const   *src ,
                                            unsigned int dst_max ) 
{ 
  unsigned int cnt ;

  {
#line 1954
  cnt = 0U;
#line 1955
  if ((unsigned long )src == (unsigned long )((unsigned char const   *)0U)) {
#line 1955
    return (0U);
  } else {

  }
#line 1956
  goto ldv_53122;
  ldv_53121: 
#line 1957
  *(dst + (unsigned long )cnt) = (unsigned short )*(src + (unsigned long )cnt);
#line 1958
  cnt = cnt + 1U;
  ldv_53122: ;
#line 1956
  if ((unsigned int )((unsigned char )*(src + (unsigned long )cnt)) != 0U && cnt + 1U < dst_max) {
#line 1958
    goto ldv_53121;
  } else {

  }
#line 1960
  *(dst + (unsigned long )cnt) = 65534U;
#line 1961
  return (cnt);
}
}
#line 1965 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_hdw_cx25840_vbi_hack(struct pvr2_hdw *hdw ) 
{ 
  struct v4l2_format fmt ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1977
  if (hdw->decoder_client_id != 2U) {
#line 1979
    return;
  } else {

  }
#line 1982
  if ((pvrusb2_debug & 32) != 0) {
#line 1982
    printk("\016pvrusb2: Module ID %u: Executing cx25840 VBI hack\n", hdw->decoder_client_id);
  } else {

  }
#line 1986
  memset((void *)(& fmt), 0, 208UL);
#line 1987
  fmt.type = 6U;
#line 1988
  fmt.fmt.sliced.service_lines[0][21] = 4096U;
#line 1989
  fmt.fmt.sliced.service_lines[1][21] = 4096U;
#line 1990
  __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 1990
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 1990
  goto ldv_53134;
  ldv_53133: ;
#line 1990
  if (((hdw->decoder_client_id == 0U || __sd->grp_id == hdw->decoder_client_id) && (unsigned long )(__sd->ops)->vbi != (unsigned long )((struct v4l2_subdev_vbi_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->vbi)->s_sliced_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                                                                           struct v4l2_sliced_vbi_format * ))0)) {
#line 1990
    (*(((__sd->ops)->vbi)->s_sliced_fmt))(__sd, & fmt.fmt.sliced);
  } else {

  }
#line 1990
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 1990
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_53134: ;
#line 1990
  if ((unsigned long )(& __sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 1992
    goto ldv_53133;
  } else {

  }

#line 1998
  return;
}
}
#line 1995 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_hdw_load_subdev(struct pvr2_hdw *hdw , struct pvr2_device_client_desc  const  *cd ) 
{ 
  char const   *fname ;
  unsigned char mid ;
  struct v4l2_subdev *sd ;
  unsigned int i2ccnt ;
  unsigned char const   *p ;
  unsigned short i2caddr[25U] ;

  {
#line 2006
  mid = cd->module_id;
#line 2007
  fname = (unsigned int )mid <= 7U ? module_names[(int )mid] : (char const   *)0;
#line 2008
  if ((unsigned long )fname == (unsigned long )((char const   *)0)) {
#line 2009
    if ((pvrusb2_debug & 2) != 0) {
#line 2009
      printk("\016pvrusb2: Module ID %u for device %s has no name?  The driver might have a configuration problem.\n",
             (int )mid, (hdw->hdw_desc)->description);
    } else {

    }
#line 2014
    return (-22);
  } else {

  }
#line 2016
  if ((pvrusb2_debug & 32) != 0) {
#line 2016
    printk("\016pvrusb2: Module ID %u (%s) for device %s being loaded...\n", (int )mid,
           fname, (hdw->hdw_desc)->description);
  } else {

  }
#line 2021
  i2ccnt = pvr2_copy_i2c_addr_list((unsigned short *)(& i2caddr), (unsigned char const   *)cd->i2c_address_list,
                                   25U);
#line 2023
  if (i2ccnt == 0U) {
#line 2023
    p = (unsigned int )mid <= 7U ? module_i2c_addresses[(int )mid] : (unsigned char const   *)0U;
#line 2023
    if ((unsigned long )p != (unsigned long )((unsigned char const   *)0U)) {
#line 2026
      i2ccnt = pvr2_copy_i2c_addr_list((unsigned short *)(& i2caddr), p, 25U);
#line 2028
      if (i2ccnt != 0U) {
#line 2029
        if ((pvrusb2_debug & 32) != 0) {
#line 2029
          printk("\016pvrusb2: Module ID %u: Using default i2c address list\n", (int )mid);
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 2036
  if (i2ccnt == 0U) {
#line 2037
    if ((pvrusb2_debug & 2) != 0) {
#line 2037
      printk("\016pvrusb2: Module ID %u (%s) for device %s: No i2c addresses.  The driver might have a configuration problem.\n",
             (int )mid, fname, (hdw->hdw_desc)->description);
    } else {

    }
#line 2042
    return (-22);
  } else {

  }
#line 2045
  if (i2ccnt == 1U) {
#line 2046
    if ((pvrusb2_debug & 32) != 0) {
#line 2046
      printk("\016pvrusb2: Module ID %u: Setting up with specified i2c address 0x%x\n",
             (int )mid, (int )i2caddr[0]);
    } else {

    }
#line 2050
    sd = v4l2_i2c_new_subdev(& hdw->v4l2_dev, & hdw->i2c_adap, fname, (int )((u8 )i2caddr[0]),
                             (unsigned short const   *)0U);
  } else {
#line 2053
    if ((pvrusb2_debug & 32) != 0) {
#line 2053
      printk("\016pvrusb2: Module ID %u: Setting up with address probe list\n", (int )mid);
    } else {

    }
#line 2057
    sd = v4l2_i2c_new_subdev(& hdw->v4l2_dev, & hdw->i2c_adap, fname, 0, (unsigned short const   *)(& i2caddr));
  }
#line 2061
  if ((unsigned long )sd == (unsigned long )((struct v4l2_subdev *)0)) {
#line 2062
    if ((pvrusb2_debug & 2) != 0) {
#line 2062
      printk("\016pvrusb2: Module ID %u (%s) for device %s failed to load.  Possible missing sub-device kernel module or initialization failure within module.\n",
             (int )mid, fname, (hdw->hdw_desc)->description);
    } else {

    }
#line 2067
    return (-5);
  } else {

  }
#line 2073
  sd->grp_id = (u32 )mid;
#line 2075
  if (pvrusb2_debug & 1) {
#line 2075
    printk("\016pvrusb2: Attached sub-driver %s\n", fname);
  } else {

  }
#line 2079
  switch ((int )mid) {
  case 2: ;
  case 3: 
#line 2082
  hdw->decoder_client_id = (unsigned int )mid;
#line 2083
  goto ldv_53156;
  default: ;
#line 2084
  goto ldv_53156;
  }
  ldv_53156: ;
#line 2087
  return (0);
}
}
#line 2091 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_hdw_load_modules(struct pvr2_hdw *hdw ) 
{ 
  unsigned int idx ;
  struct pvr2_string_table  const  *cm ;
  struct pvr2_device_client_table  const  *ct ;
  int okFl ;
  int tmp ;

  {
#line 2096
  okFl = 1;
#line 2098
  cm = & (hdw->hdw_desc)->client_modules;
#line 2099
  idx = 0U;
#line 2099
  goto ldv_53166;
  ldv_53165: 
#line 2100
  __request_module(1, *(cm->lst + (unsigned long )idx));
#line 2099
  idx = idx + 1U;
  ldv_53166: ;
#line 2099
  if ((unsigned int )cm->cnt > idx) {
#line 2101
    goto ldv_53165;
  } else {

  }
#line 2103
  ct = & (hdw->hdw_desc)->client_table;
#line 2104
  idx = 0U;
#line 2104
  goto ldv_53169;
  ldv_53168: 
#line 2105
  tmp = pvr2_hdw_load_subdev(hdw, ct->lst + (unsigned long )idx);
#line 2105
  if (tmp < 0) {
#line 2105
    okFl = 0;
  } else {

  }
#line 2104
  idx = idx + 1U;
  ldv_53169: ;
#line 2104
  if ((unsigned int )ct->cnt > idx) {
#line 2106
    goto ldv_53168;
  } else {

  }

#line 2107
  if (okFl == 0) {
#line 2108
    hdw->flag_modulefail = 1;
#line 2109
    pvr2_hdw_render_useless(hdw);
  } else {

  }
#line 2111
  return;
}
}
#line 2114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_hdw_setup_low(struct pvr2_hdw *hdw ) 
{ 
  int ret ;
  unsigned int idx ;
  struct pvr2_ctrl *cptr ;
  int reloadFl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 2119
  reloadFl = 0;
#line 2120
  if ((unsigned int )(hdw->hdw_desc)->fx2_firmware.cnt != 0U) {
#line 2121
    if (reloadFl == 0) {
#line 2122
      reloadFl = (unsigned int )((hdw->usb_intf)->cur_altsetting)->desc.bNumEndpoints == 0U;
#line 2125
      if (reloadFl != 0) {
#line 2126
        if ((pvrusb2_debug & 32) != 0) {
#line 2126
          printk("\016pvrusb2: USB endpoint config looks strange; possibly firmware needs to be loaded\n");
        } else {

        }
      } else {

      }
    } else {

    }
#line 2132
    if (reloadFl == 0) {
#line 2133
      tmp = pvr2_hdw_check_firmware(hdw);
#line 2133
      reloadFl = tmp == 0;
#line 2134
      if (reloadFl != 0) {
#line 2135
        if ((pvrusb2_debug & 32) != 0) {
#line 2135
          printk("\016pvrusb2: Check for FX2 firmware failed; possibly firmware needs to be loaded\n");
        } else {

        }
      } else {

      }
    } else {

    }
#line 2141
    if (reloadFl != 0) {
#line 2142
      tmp___0 = pvr2_upload_firmware1(hdw);
#line 2142
      if (tmp___0 != 0) {
#line 2143
        if ((pvrusb2_debug & 2) != 0) {
#line 2143
          printk("\016pvrusb2: Failure uploading firmware1\n");
        } else {

        }
      } else {

      }
#line 2146
      return;
    } else {

    }
  } else {

  }
#line 2149
  hdw->fw1_state = 4;
#line 2151
  tmp___1 = pvr2_hdw_dev_ok(hdw);
#line 2151
  if (tmp___1 == 0) {
#line 2151
    return;
  } else {

  }
#line 2153
  hdw->force_dirty = 1;
#line 2155
  if ((unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) == 0U) {
#line 2156
    pvr2_hdw_cmd_powerup(hdw);
#line 2157
    tmp___2 = pvr2_hdw_dev_ok(hdw);
#line 2157
    if (tmp___2 == 0) {
#line 2157
      return;
    } else {

    }
  } else {

  }
#line 2161
  if (hdw->ir_scheme_active == 2U) {
#line 2162
    pvr2_issue_simple_cmd(hdw, 272U);
  } else {

  }
#line 2169
  pvr2_i2c_core_init(hdw);
#line 2170
  tmp___3 = pvr2_hdw_dev_ok(hdw);
#line 2170
  if (tmp___3 == 0) {
#line 2170
    return;
  } else {

  }
#line 2172
  pvr2_hdw_load_modules(hdw);
#line 2173
  tmp___4 = pvr2_hdw_dev_ok(hdw);
#line 2173
  if (tmp___4 == 0) {
#line 2173
    return;
  } else {

  }
#line 2175
  __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 2175
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 2175
  goto ldv_53184;
  ldv_53183: ;
#line 2175
  if ((unsigned long )(__sd->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->core)->load_fw != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ))0)) {
#line 2175
    (*(((__sd->ops)->core)->load_fw))(__sd);
  } else {

  }
#line 2175
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 2175
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_53184: ;
#line 2175
  if ((unsigned long )(& __sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 2177
    goto ldv_53183;
  } else {

  }
#line 2177
  idx = 0U;
#line 2177
  goto ldv_53190;
  ldv_53189: 
#line 2178
  cptr = hdw->controls + (unsigned long )idx;
#line 2179
  if ((int )(cptr->info)->skip_init != 0) {
#line 2179
    goto ldv_53188;
  } else {

  }
#line 2180
  if ((unsigned long )(cptr->info)->set_value == (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                           int  ,
                                                                           int  ))0)) {
#line 2180
    goto ldv_53188;
  } else {

  }
#line 2181
  (*((cptr->info)->set_value))(cptr, -1, (cptr->info)->default_value);
  ldv_53188: 
#line 2177
  idx = idx + 1U;
  ldv_53190: ;
#line 2177
  if (idx <= 35U) {
#line 2179
    goto ldv_53189;
  } else {

  }
#line 2184
  pvr2_hdw_cx25840_vbi_hack(hdw);
#line 2191
  hdw->freqValTelevision = (unsigned int )default_tv_freq;
#line 2192
  hdw->freqValRadio = (unsigned int )default_radio_freq;
#line 2198
  if ((unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) != 0U) {
#line 2199
    ret = pvr2_hdw_get_eeprom_addr(hdw);
#line 2200
    tmp___5 = pvr2_hdw_dev_ok(hdw);
#line 2200
    if (tmp___5 == 0) {
#line 2200
      return;
    } else {

    }
#line 2201
    if (ret < 0) {
#line 2202
      if ((pvrusb2_debug & 2) != 0) {
#line 2202
        printk("\016pvrusb2: Unable to determine location of eeprom, skipping\n");
      } else {

      }
    } else {
#line 2206
      hdw->eeprom_addr = ret;
#line 2207
      pvr2_eeprom_analyze(hdw);
#line 2208
      tmp___6 = pvr2_hdw_dev_ok(hdw);
#line 2208
      if (tmp___6 == 0) {
#line 2208
        return;
      } else {

      }
    }
  } else {
#line 2211
    hdw->tuner_type = (unsigned int )(hdw->hdw_desc)->default_tuner_type;
#line 2212
    hdw->tuner_updated = 1;
#line 2213
    hdw->std_mask_eeprom = 16777215ULL;
  }
#line 2216
  if (hdw->serial_number != 0UL) {
#line 2217
    tmp___7 = scnprintf((char *)(& hdw->identifier), 31UL, "sn-%lu", hdw->serial_number);
#line 2217
    idx = (unsigned int )tmp___7;
  } else
#line 2219
  if (hdw->unit_number >= 0) {
#line 2220
    tmp___8 = scnprintf((char *)(& hdw->identifier), 31UL, "unit-%c", hdw->unit_number + 97);
#line 2220
    idx = (unsigned int )tmp___8;
  } else {
#line 2224
    tmp___9 = scnprintf((char *)(& hdw->identifier), 31UL, "unit-??");
#line 2224
    idx = (unsigned int )tmp___9;
  }
#line 2227
  hdw->identifier[idx] = 0;
#line 2229
  pvr2_hdw_setup_std(hdw);
#line 2231
  tmp___10 = get_default_tuner_type(hdw);
#line 2231
  if (tmp___10 == 0) {
#line 2232
    if ((pvrusb2_debug & 32) != 0) {
#line 2232
      printk("\016pvrusb2: pvr2_hdw_setup: Tuner type overridden to %d\n", hdw->tuner_type);
    } else {

    }
  } else {

  }
#line 2238
  tmp___11 = pvr2_hdw_dev_ok(hdw);
#line 2238
  if (tmp___11 == 0) {
#line 2238
    return;
  } else {

  }
#line 2240
  if ((unsigned int )((unsigned char )(hdw->hdw_desc)->signal_routing_scheme) == 1U) {
#line 2244
    pvr2_hdw_gpio_chg_dir(hdw, 2048U, 4294967295U);
  } else {

  }
#line 2247
  pvr2_hdw_commit_setup(hdw);
#line 2249
  hdw->vid_stream = pvr2_stream_create();
#line 2250
  tmp___12 = pvr2_hdw_dev_ok(hdw);
#line 2250
  if (tmp___12 == 0) {
#line 2250
    return;
  } else {

  }
#line 2251
  if ((pvrusb2_debug & 32) != 0) {
#line 2251
    printk("\016pvrusb2: pvr2_hdw_setup: video stream is %p\n", hdw->vid_stream);
  } else {

  }
#line 2253
  if ((unsigned long )hdw->vid_stream != (unsigned long )((struct pvr2_stream *)0)) {
#line 2254
    idx = get_default_error_tolerance(hdw);
#line 2255
    if (idx != 0U) {
#line 2256
      if ((pvrusb2_debug & 32) != 0) {
#line 2256
        printk("\016pvrusb2: pvr2_hdw_setup: video stream %p setting tolerance %u\n",
               hdw->vid_stream, idx);
      } else {

      }
    } else {

    }
#line 2261
    pvr2_stream_setup(hdw->vid_stream, hdw->usb_dev, 132, idx);
  } else {

  }
#line 2265
  tmp___13 = pvr2_hdw_dev_ok(hdw);
#line 2265
  if (tmp___13 == 0) {
#line 2265
    return;
  } else {

  }
#line 2267
  hdw->flag_init_ok = 1;
#line 2269
  pvr2_hdw_state_sched(hdw);
#line 2270
  return;
}
}
#line 2276 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_hdw_setup(struct pvr2_hdw *hdw ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2278
  if ((pvrusb2_debug & 32) != 0) {
#line 2278
    printk("\016pvrusb2: pvr2_hdw_setup(hdw=%p) begin\n", hdw);
  } else {

  }
#line 2280
  pvr2_hdw_setup_low(hdw);
#line 2281
  if ((pvrusb2_debug & 32) != 0) {
#line 2281
    tmp = pvr2_hdw_dev_ok(hdw);
#line 2281
    printk("\016pvrusb2: pvr2_hdw_setup(hdw=%p) done, ok=%d init_ok=%d\n", hdw, tmp,
           hdw->flag_init_ok);
  } else {

  }
#line 2284
  tmp___0 = pvr2_hdw_dev_ok(hdw);
#line 2284
  if (tmp___0 != 0) {
#line 2285
    if (hdw->flag_init_ok != 0) {
#line 2286
      if (pvrusb2_debug & 1) {
#line 2286
        printk("\016pvrusb2: Device initialization completed successfully.\n");
      } else {

      }
#line 2290
      goto ldv_53195;
    } else {

    }
#line 2292
    if (hdw->fw1_state == 3) {
#line 2293
      if (pvrusb2_debug & 1) {
#line 2293
        printk("\016pvrusb2: Device microcontroller firmware (re)loaded; it should now reset and reconnect.\n");
      } else {

      }
#line 2298
      goto ldv_53195;
    } else {

    }
#line 2300
    if ((pvrusb2_debug & 2) != 0) {
#line 2300
      printk("\016pvrusb2: Device initialization was not successful.\n");
    } else {

    }
#line 2303
    if (hdw->fw1_state == 1) {
#line 2304
      if ((pvrusb2_debug & 2) != 0) {
#line 2304
        printk("\016pvrusb2: Giving up since device microcontroller firmware appears to be missing.\n");
      } else {

      }
#line 2309
      goto ldv_53195;
    } else {

    }
  } else {

  }
#line 2312
  if (hdw->flag_modulefail != 0) {
#line 2313
    if ((pvrusb2_debug & 2) != 0) {
#line 2313
      printk("\016pvrusb2: ***WARNING*** pvrusb2 driver initialization failed due to the failure of one or more sub-device kernel modules.\n");
    } else {

    }
#line 2318
    if ((pvrusb2_debug & 2) != 0) {
#line 2318
      printk("\016pvrusb2: You need to resolve the failing condition before this driver can function.  There should be some earlier messages giving more information about the problem.\n");
    } else {

    }
#line 2324
    goto ldv_53195;
  } else {

  }
#line 2326
  if (procreload != 0) {
#line 2327
    if ((pvrusb2_debug & 2) != 0) {
#line 2327
      printk("\016pvrusb2: Attempting pvrusb2 recovery by reloading primary firmware.\n");
    } else {

    }
#line 2331
    if ((pvrusb2_debug & 2) != 0) {
#line 2331
      printk("\016pvrusb2: If this works, device should disconnect and reconnect in a sane state.\n");
    } else {

    }
#line 2335
    hdw->fw1_state = 0;
#line 2336
    pvr2_upload_firmware1(hdw);
  } else {
#line 2338
    if ((pvrusb2_debug & 2) != 0) {
#line 2338
      printk("\016pvrusb2: ***WARNING*** pvrusb2 device hardware appears to be jammed and I can\'t clear it.\n");
    } else {

    }
#line 2343
    if ((pvrusb2_debug & 2) != 0) {
#line 2343
      printk("\016pvrusb2: You might need to power cycle the pvrusb2 device in order to recover.\n");
    } else {

    }
  }
  ldv_53195: ;
#line 2350
  if ((pvrusb2_debug & 32) != 0) {
#line 2350
    printk("\016pvrusb2: pvr2_hdw_setup(hdw=%p) end\n", hdw);
  } else {

  }
#line 2351
  return;
}
}
#line 2357 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_initialize(struct pvr2_hdw *hdw , void (*callback_func)(void * ) , void *callback_data ) 
{ 


  {
#line 2361
  ldv_mutex_lock_238(& hdw->big_lock_mutex);
#line 2361
  hdw->big_lock_held = 1;
#line 2362
  if (hdw->flag_disconnected != 0) {
#line 2369
    goto ldv_53202;
  } else {

  }
#line 2371
  hdw->state_data = callback_data;
#line 2372
  hdw->state_func = callback_func;
#line 2373
  pvr2_hdw_setup(hdw);
  ldv_53202: 
#line 2374
  hdw->big_lock_held = 0;
#line 2374
  ldv_mutex_unlock_239(& hdw->big_lock_mutex);
#line 2375
  return (hdw->flag_init_ok);
}
}
#line 2381 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
struct pvr2_hdw *pvr2_hdw_create(struct usb_interface *intf , struct usb_device_id  const  *devid ) 
{ 
  unsigned int idx ;
  unsigned int cnt1 ;
  unsigned int cnt2 ;
  unsigned int m ;
  struct pvr2_hdw *hdw ;
  int valid_std_mask ;
  struct pvr2_ctrl *cptr ;
  struct usb_device *usb_dev ;
  struct pvr2_device_desc  const  *hdw_desc ;
  __u8 ifnum ;
  struct v4l2_queryctrl qctrl ;
  struct pvr2_ctl_info *ciptr ;
  void *tmp ;
  struct lock_class_key __key ;
  void *tmp___0 ;
  void *tmp___1 ;
  v4l2_std_id tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  struct lock_class_key __key___0 ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp___8 ;
  struct lock_class_key __key___1 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;

  {
#line 2385
  hdw = (struct pvr2_hdw *)0;
#line 2394
  usb_dev = interface_to_usbdev(intf);
#line 2396
  hdw_desc = (struct pvr2_device_desc  const  *)devid->driver_info;
#line 2398
  if ((unsigned long )hdw_desc == (unsigned long )((struct pvr2_device_desc  const  *)0)) {
#line 2399
    if ((pvrusb2_debug & 32) != 0) {
#line 2399
      printk("\016pvrusb2: pvr2_hdw_create: No device description pointer, unable to continue.\n");
    } else {

    }
#line 2402
    if ((pvrusb2_debug & 32) != 0) {
#line 2402
      printk("\016pvrusb2: If you have a new device type, please contact Mike Isely <isely@pobox.com> to get it included in the driver\n\n");
    } else {

    }
#line 2405
    goto fail;
  } else {

  }
#line 2408
  tmp = kzalloc(8848UL, 208U);
#line 2408
  hdw = (struct pvr2_hdw *)tmp;
#line 2409
  if ((pvrusb2_debug & 32) != 0) {
#line 2409
    printk("\016pvrusb2: pvr2_hdw_create: hdw=%p, type \"%s\"\n", hdw, hdw_desc->description);
  } else {

  }
#line 2411
  if (pvrusb2_debug & 1) {
#line 2411
    printk("\016pvrusb2: Hardware description: %s\n", hdw_desc->description);
  } else {

  }
#line 2413
  if ((unsigned int )*((unsigned char *)hdw_desc + 89UL) != 0U) {
#line 2414
    if (pvrusb2_debug & 1) {
#line 2414
      printk("\016pvrusb2: **********\n");
    } else {

    }
#line 2415
    if (pvrusb2_debug & 1) {
#line 2415
      printk("\016pvrusb2: WARNING: Support for this device (%s) is experimental.\n",
             hdw_desc->description);
    } else {

    }
#line 2418
    if (pvrusb2_debug & 1) {
#line 2418
      printk("\016pvrusb2: Important functionality might not be entirely working.\n");
    } else {

    }
#line 2421
    if (pvrusb2_debug & 1) {
#line 2421
      printk("\016pvrusb2: Please consider contacting the driver author to help with further stabilization of the driver.\n");
    } else {

    }
#line 2424
    if (pvrusb2_debug & 1) {
#line 2424
      printk("\016pvrusb2: **********\n");
    } else {

    }
  } else {

  }
#line 2426
  if ((unsigned long )hdw == (unsigned long )((struct pvr2_hdw *)0)) {
#line 2426
    goto fail;
  } else {

  }
#line 2428
  reg_timer_2(& hdw->quiescent_timer, & pvr2_hdw_quiescent_timeout, (unsigned long )hdw);
#line 2431
  reg_timer_2(& hdw->decoder_stabilization_timer, & pvr2_hdw_decoder_stabilization_timeout,
              (unsigned long )hdw);
#line 2435
  reg_timer_2(& hdw->encoder_wait_timer, & pvr2_hdw_encoder_wait_timeout, (unsigned long )hdw);
#line 2438
  reg_timer_2(& hdw->encoder_run_timer, & pvr2_hdw_encoder_run_timeout, (unsigned long )hdw);
#line 2441
  hdw->master_state = 1U;
#line 2443
  __init_waitqueue_head(& hdw->state_wait_data, "&hdw->state_wait_data", & __key);
#line 2445
  hdw->tuner_signal_stale = 1;
#line 2446
  cx2341x_fill_defaults(& hdw->enc_ctl_state);
#line 2449
  m = 0U;
#line 2450
  if ((unsigned int )*((unsigned char *)hdw_desc + 88UL) != 0U) {
#line 2450
    m = m | 1U;
  } else {

  }
#line 2451
  if ((unsigned int )((unsigned char )hdw_desc->digital_control_scheme) != 0U) {
#line 2452
    m = m | 2U;
  } else {

  }
#line 2454
  if ((unsigned int )*((unsigned char *)hdw_desc + 88UL) != 0U) {
#line 2454
    m = m | 8U;
  } else {

  }
#line 2455
  if ((unsigned int )*((unsigned char *)hdw_desc + 88UL) != 0U) {
#line 2455
    m = m | 4U;
  } else {

  }
#line 2456
  if ((unsigned int )*((unsigned char *)hdw_desc + 88UL) != 0U) {
#line 2456
    m = m | 16U;
  } else {

  }
#line 2457
  hdw->input_avail_mask = m;
#line 2458
  hdw->input_allowed_mask = hdw->input_avail_mask;
#line 2462
  if ((hdw->input_avail_mask & 2U) == 0U) {
#line 2463
    hdw->pathway_state = 1;
  } else
#line 2464
  if ((hdw->input_avail_mask & 1U) == 0U) {
#line 2465
    hdw->pathway_state = 2;
  } else {

  }
#line 2468
  hdw->control_cnt = 36U;
#line 2469
  hdw->control_cnt = hdw->control_cnt + 26U;
#line 2470
  tmp___0 = kzalloc((unsigned long )hdw->control_cnt * 16UL, 208U);
#line 2470
  hdw->controls = (struct pvr2_ctrl *)tmp___0;
#line 2472
  if ((unsigned long )hdw->controls == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 2472
    goto fail;
  } else {

  }
#line 2473
  hdw->hdw_desc = hdw_desc;
#line 2474
  hdw->ir_scheme_active = (unsigned int )(hdw->hdw_desc)->ir_scheme;
#line 2475
  idx = 0U;
#line 2475
  goto ldv_53226;
  ldv_53225: 
#line 2476
  cptr = hdw->controls + (unsigned long )idx;
#line 2477
  cptr->hdw = hdw;
#line 2475
  idx = idx + 1U;
  ldv_53226: ;
#line 2475
  if (hdw->control_cnt > idx) {
#line 2477
    goto ldv_53225;
  } else {

  }
#line 2479
  idx = 0U;
#line 2479
  goto ldv_53229;
  ldv_53228: 
#line 2480
  hdw->std_mask_ptrs[idx] = (char const   *)(& hdw->std_mask_names) + (unsigned long )idx;
#line 2479
  idx = idx + 1U;
  ldv_53229: ;
#line 2479
  if (idx <= 31U) {
#line 2481
    goto ldv_53228;
  } else {

  }
#line 2482
  idx = 0U;
#line 2482
  goto ldv_53234;
  ldv_53233: 
#line 2483
  cptr = hdw->controls + (unsigned long )idx;
#line 2484
  cptr->info = (struct pvr2_ctl_info  const  *)(& control_defs) + (unsigned long )idx;
#line 2482
  idx = idx + 1U;
  ldv_53234: ;
#line 2482
  if (idx <= 35U) {
#line 2484
    goto ldv_53233;
  } else {

  }
#line 2488
  m = hdw->input_avail_mask;
#line 2489
  if (m != 0U) {
#line 2489
    idx = 0U;
#line 2489
    goto ldv_53239;
    ldv_53238: ;
#line 2490
    if (((unsigned int )(1 << (int )idx) & m) == 0U) {
#line 2490
      goto ldv_53236;
    } else {

    }
#line 2491
    hdw->input_val = (int )idx;
#line 2492
    goto ldv_53237;
    ldv_53236: 
#line 2489
    idx = idx + 1U;
    ldv_53239: ;
#line 2489
    if (idx <= 31U) {
#line 2491
      goto ldv_53238;
    } else {

    }
    ldv_53237: ;
  } else {

  }
#line 2496
  tmp___1 = kcalloc(26UL, 176UL, 208U);
#line 2496
  hdw->mpeg_ctrl_info = (struct pvr2_ctld_info *)tmp___1;
#line 2499
  if ((unsigned long )hdw->mpeg_ctrl_info == (unsigned long )((struct pvr2_ctld_info *)0)) {
#line 2499
    goto fail;
  } else {

  }
#line 2500
  idx = 0U;
#line 2500
  goto ldv_53255;
  ldv_53254: 
#line 2501
  cptr = hdw->controls + ((unsigned long )idx + 36UL);
#line 2502
  ciptr = & (hdw->mpeg_ctrl_info + (unsigned long )idx)->info;
#line 2503
  ciptr->desc = (char const   *)(& (hdw->mpeg_ctrl_info + (unsigned long )idx)->desc);
#line 2504
  ciptr->name = mpeg_ids[idx].strid;
#line 2505
  ciptr->v4l_id = mpeg_ids[idx].id;
#line 2506
  ciptr->skip_init = 1;
#line 2507
  ciptr->get_value = & ctrl_cx2341x_get;
#line 2508
  ciptr->get_v4lflags = & ctrl_cx2341x_getv4lflags;
#line 2509
  ciptr->is_dirty = & ctrl_cx2341x_is_dirty;
#line 2510
  if (idx == 0U) {
#line 2510
    ciptr->clear_dirty = & ctrl_cx2341x_clear_dirty;
  } else {

  }
#line 2511
  qctrl.id = (__u32 )ciptr->v4l_id;
#line 2512
  cx2341x_ctrl_query((struct cx2341x_mpeg_params  const  *)(& hdw->enc_ctl_state),
                     & qctrl);
#line 2513
  if ((qctrl.flags & 4U) == 0U) {
#line 2514
    ciptr->set_value = & ctrl_cx2341x_set;
  } else {

  }
#line 2516
  strncpy((char *)(& (hdw->mpeg_ctrl_info + (unsigned long )idx)->desc), (char const   *)(& qctrl.name),
          32UL);
#line 2518
  (hdw->mpeg_ctrl_info + (unsigned long )idx)->desc[31] = 0;
#line 2519
  ciptr->default_value = qctrl.default_value;
#line 2520
  switch (qctrl.type) {
  default: ;
  case 1U: 
#line 2523
  ciptr->type = 0;
#line 2524
  ciptr->def.type_int.min_value = (long )qctrl.minimum;
#line 2525
  ciptr->def.type_int.max_value = (long )qctrl.maximum;
#line 2526
  goto ldv_53248;
  case 2U: 
#line 2528
  ciptr->type = 3;
#line 2529
  goto ldv_53248;
  case 3U: 
#line 2531
  ciptr->type = 1;
#line 2532
  ciptr->def.type_enum.value_names = cx2341x_ctrl_get_menu((struct cx2341x_mpeg_params  const  *)(& hdw->enc_ctl_state),
                                                           (u32 )ciptr->v4l_id);
#line 2535
  cnt1 = 0U;
#line 2535
  goto ldv_53252;
  ldv_53251: 
#line 2537
  cnt1 = cnt1 + 1U;
  ldv_53252: ;
#line 2535
  if ((unsigned long )*(ciptr->def.type_enum.value_names + (unsigned long )cnt1) != (unsigned long )((char const   */* const  */)0)) {
#line 2538
    goto ldv_53251;
  } else {

  }
#line 2538
  ciptr->def.type_enum.count = cnt1;
#line 2539
  goto ldv_53248;
  }
  ldv_53248: 
#line 2541
  cptr->info = (struct pvr2_ctl_info  const  *)ciptr;
#line 2500
  idx = idx + 1U;
  ldv_53255: ;
#line 2500
  if (idx <= 25U) {
#line 2502
    goto ldv_53254;
  } else {

  }
#line 2545
  tmp___2 = pvr2_std_get_usable();
#line 2545
  valid_std_mask = (int )tmp___2;
#line 2546
  idx = 0U;
#line 2546
  goto ldv_53259;
  ldv_53258: ;
#line 2547
  if (((valid_std_mask >> (int )idx) & 1) == 0) {
#line 2547
    goto ldv_53257;
  } else {

  }
#line 2548
  cnt1 = pvr2_std_id_to_str((char *)(& hdw->std_mask_names) + (unsigned long )idx,
                            15U, (v4l2_std_id )(1 << (int )idx));
#line 2552
  hdw->std_mask_names[idx][cnt1] = 0;
  ldv_53257: 
#line 2546
  idx = idx + 1U;
  ldv_53259: ;
#line 2546
  if (idx <= 31U) {
#line 2548
    goto ldv_53258;
  } else {

  }
#line 2554
  cptr = pvr2_hdw_get_ctrl_by_id(hdw, 3U);
#line 2555
  if ((unsigned long )cptr != (unsigned long )((struct pvr2_ctrl *)0)) {
#line 2556
    memcpy((void *)(& hdw->std_info_avail), (void const   *)cptr->info, 144UL);
#line 2558
    cptr->info = (struct pvr2_ctl_info  const  *)(& hdw->std_info_avail);
#line 2559
    hdw->std_info_avail.def.type_bitmask.bit_names = (char const   **)(& hdw->std_mask_ptrs);
#line 2561
    hdw->std_info_avail.def.type_bitmask.valid_bits = (unsigned int )valid_std_mask;
  } else {

  }
#line 2564
  cptr = pvr2_hdw_get_ctrl_by_id(hdw, 2U);
#line 2565
  if ((unsigned long )cptr != (unsigned long )((struct pvr2_ctrl *)0)) {
#line 2566
    memcpy((void *)(& hdw->std_info_cur), (void const   *)cptr->info, 144UL);
#line 2568
    cptr->info = (struct pvr2_ctl_info  const  *)(& hdw->std_info_cur);
#line 2569
    hdw->std_info_cur.def.type_bitmask.bit_names = (char const   **)(& hdw->std_mask_ptrs);
#line 2571
    hdw->std_info_cur.def.type_bitmask.valid_bits = (unsigned int )valid_std_mask;
  } else {

  }
#line 2574
  cptr = pvr2_hdw_get_ctrl_by_id(hdw, 19U);
#line 2575
  if ((unsigned long )cptr != (unsigned long )((struct pvr2_ctrl *)0)) {
#line 2576
    memcpy((void *)(& hdw->std_info_detect), (void const   *)cptr->info, 144UL);
#line 2578
    cptr->info = (struct pvr2_ctl_info  const  *)(& hdw->std_info_detect);
#line 2579
    hdw->std_info_detect.def.type_bitmask.bit_names = (char const   **)(& hdw->std_mask_ptrs);
#line 2581
    hdw->std_info_detect.def.type_bitmask.valid_bits = (unsigned int )valid_std_mask;
  } else {

  }
#line 2585
  hdw->cropcap_stale = 1;
#line 2586
  hdw->eeprom_addr = -1;
#line 2587
  hdw->unit_number = -1;
#line 2588
  hdw->v4l_minor_number_video = -1;
#line 2589
  hdw->v4l_minor_number_vbi = -1;
#line 2590
  hdw->v4l_minor_number_radio = -1;
#line 2591
  tmp___3 = kmalloc(64UL, 208U);
#line 2591
  hdw->ctl_write_buffer = (unsigned char *)tmp___3;
#line 2592
  if ((unsigned long )hdw->ctl_write_buffer == (unsigned long )((unsigned char *)0U)) {
#line 2592
    goto fail;
  } else {

  }
#line 2593
  tmp___4 = kmalloc(64UL, 208U);
#line 2593
  hdw->ctl_read_buffer = (unsigned char *)tmp___4;
#line 2594
  if ((unsigned long )hdw->ctl_read_buffer == (unsigned long )((unsigned char *)0U)) {
#line 2594
    goto fail;
  } else {

  }
#line 2595
  hdw->ctl_write_urb = usb_alloc_urb(0, 208U);
#line 2596
  if ((unsigned long )hdw->ctl_write_urb == (unsigned long )((struct urb *)0)) {
#line 2596
    goto fail;
  } else {

  }
#line 2597
  hdw->ctl_read_urb = usb_alloc_urb(0, 208U);
#line 2598
  if ((unsigned long )hdw->ctl_read_urb == (unsigned long )((struct urb *)0)) {
#line 2598
    goto fail;
  } else {

  }
#line 2600
  tmp___5 = v4l2_device_register(& intf->dev, & hdw->v4l2_dev);
#line 2600
  if (tmp___5 != 0) {
#line 2601
    if ((pvrusb2_debug & 2) != 0) {
#line 2601
      printk("\016pvrusb2: Error registering with v4l core, giving up\n");
    } else {

    }
#line 2603
    goto fail;
  } else {

  }
#line 2605
  ldv_mutex_lock_240(& pvr2_unit_mtx);
#line 2607
  idx = 0U;
#line 2607
  goto ldv_53264;
  ldv_53263: ;
#line 2608
  if ((unsigned long )unit_pointers[idx] != (unsigned long )((struct pvr2_hdw *)0)) {
#line 2608
    goto ldv_53261;
  } else {

  }
#line 2609
  hdw->unit_number = (int )idx;
#line 2610
  unit_pointers[idx] = hdw;
#line 2611
  goto ldv_53262;
  ldv_53261: 
#line 2607
  idx = idx + 1U;
  ldv_53264: ;
#line 2607
  if (idx <= 19U) {
#line 2609
    goto ldv_53263;
  } else {

  }
  ldv_53262: 
#line 2614
  ldv_mutex_unlock_241(& pvr2_unit_mtx);
#line 2616
  cnt1 = 0U;
#line 2617
  tmp___6 = scnprintf((char *)(& hdw->name) + (unsigned long )cnt1, 32UL - (unsigned long )cnt1,
                      "pvrusb2");
#line 2617
  cnt2 = (unsigned int )tmp___6;
#line 2618
  cnt1 = cnt1 + cnt2;
#line 2619
  if (hdw->unit_number >= 0) {
#line 2620
    tmp___7 = scnprintf((char *)(& hdw->name) + (unsigned long )cnt1, 32UL - (unsigned long )cnt1,
                        "_%c", hdw->unit_number + 97);
#line 2620
    cnt2 = (unsigned int )tmp___7;
#line 2622
    cnt1 = cnt1 + cnt2;
  } else {

  }
#line 2624
  if (cnt1 > 31U) {
#line 2624
    cnt1 = 31U;
  } else {

  }
#line 2625
  hdw->name[cnt1] = 0;
#line 2627
  __lock_name = "\"%s\"hdw->name";
#line 2627
  tmp___8 = __alloc_workqueue_key("%s", 131082U, 1, & __key___0, __lock_name, (char *)(& hdw->name));
#line 2627
  hdw->workqueue = tmp___8;
#line 2628
  __init_work(& hdw->workpoll, 0);
#line 2628
  __constr_expr_0.counter = 137438953408L;
#line 2628
  hdw->workpoll.data = __constr_expr_0;
#line 2628
  lockdep_init_map(& hdw->workpoll.lockdep_map, "(&hdw->workpoll)", & __key___1, 0);
#line 2628
  INIT_LIST_HEAD(& hdw->workpoll.entry);
#line 2628
  hdw->workpoll.func = & pvr2_hdw_worker_poll;
#line 2630
  if ((pvrusb2_debug & 32) != 0) {
#line 2630
    printk("\016pvrusb2: Driver unit number is %d, name is %s\n", hdw->unit_number,
           (char *)(& hdw->name));
  } else {

  }
#line 2633
  hdw->tuner_type = 4294967295U;
#line 2634
  hdw->flag_ok = 1;
#line 2636
  hdw->usb_intf = intf;
#line 2637
  hdw->usb_dev = usb_dev;
#line 2639
  usb_make_path(hdw->usb_dev, (char *)(& hdw->bus_info), 32UL);
#line 2641
  ifnum = ((hdw->usb_intf)->cur_altsetting)->desc.bInterfaceNumber;
#line 2642
  usb_set_interface(hdw->usb_dev, (int )ifnum, 0);
#line 2644
  __mutex_init(& hdw->ctl_lock_mutex, "&hdw->ctl_lock_mutex", & __key___2);
#line 2645
  __mutex_init(& hdw->big_lock_mutex, "&hdw->big_lock_mutex", & __key___3);
#line 2647
  return (hdw);
  fail: ;
#line 2649
  if ((unsigned long )hdw != (unsigned long )((struct pvr2_hdw *)0)) {
#line 2650
    ldv_del_timer_sync_242(& hdw->quiescent_timer);
#line 2651
    ldv_del_timer_sync_243(& hdw->decoder_stabilization_timer);
#line 2652
    ldv_del_timer_sync_244(& hdw->encoder_run_timer);
#line 2653
    ldv_del_timer_sync_245(& hdw->encoder_wait_timer);
#line 2654
    if ((unsigned long )hdw->workqueue != (unsigned long )((struct workqueue_struct *)0)) {
#line 2655
      ldv_flush_workqueue_246(hdw->workqueue);
#line 2656
      ldv_destroy_workqueue_247(hdw->workqueue);
#line 2657
      hdw->workqueue = (struct workqueue_struct *)0;
    } else {

    }
#line 2659
    usb_free_urb(hdw->ctl_read_urb);
#line 2660
    usb_free_urb(hdw->ctl_write_urb);
#line 2661
    kfree((void const   *)hdw->ctl_read_buffer);
#line 2662
    kfree((void const   *)hdw->ctl_write_buffer);
#line 2663
    kfree((void const   *)hdw->controls);
#line 2664
    kfree((void const   *)hdw->mpeg_ctrl_info);
#line 2665
    kfree((void const   *)hdw);
  } else {

  }
#line 2667
  return ((struct pvr2_hdw *)0);
}
}
#line 2673 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_hdw_remove_usb_stuff(struct pvr2_hdw *hdw ) 
{ 


  {
#line 2675
  if (hdw->flag_disconnected != 0) {
#line 2675
    return;
  } else {

  }
#line 2676
  if ((pvrusb2_debug & 32) != 0) {
#line 2676
    printk("\016pvrusb2: pvr2_hdw_remove_usb_stuff: hdw=%p\n", hdw);
  } else {

  }
#line 2677
  if ((unsigned long )hdw->ctl_read_urb != (unsigned long )((struct urb *)0)) {
#line 2678
    usb_kill_urb(hdw->ctl_read_urb);
#line 2679
    usb_free_urb(hdw->ctl_read_urb);
#line 2680
    hdw->ctl_read_urb = (struct urb *)0;
  } else {

  }
#line 2682
  if ((unsigned long )hdw->ctl_write_urb != (unsigned long )((struct urb *)0)) {
#line 2683
    usb_kill_urb(hdw->ctl_write_urb);
#line 2684
    usb_free_urb(hdw->ctl_write_urb);
#line 2685
    hdw->ctl_write_urb = (struct urb *)0;
  } else {

  }
#line 2687
  if ((unsigned long )hdw->ctl_read_buffer != (unsigned long )((unsigned char *)0U)) {
#line 2688
    kfree((void const   *)hdw->ctl_read_buffer);
#line 2689
    hdw->ctl_read_buffer = (unsigned char *)0U;
  } else {

  }
#line 2691
  if ((unsigned long )hdw->ctl_write_buffer != (unsigned long )((unsigned char *)0U)) {
#line 2692
    kfree((void const   *)hdw->ctl_write_buffer);
#line 2693
    hdw->ctl_write_buffer = (unsigned char *)0U;
  } else {

  }
#line 2695
  hdw->flag_disconnected = 1;
#line 2699
  v4l2_device_disconnect(& hdw->v4l2_dev);
#line 2700
  hdw->usb_dev = (struct usb_device *)0;
#line 2701
  hdw->usb_intf = (struct usb_interface *)0;
#line 2702
  pvr2_hdw_render_useless(hdw);
#line 2703
  return;
}
}
#line 2705 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
void pvr2_hdw_set_v4l2_dev(struct pvr2_hdw *hdw , struct video_device *vdev ) 
{ 


  {
#line 2707
  vdev->v4l2_dev = & hdw->v4l2_dev;
#line 2708
  return;
}
}
#line 2711 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
void pvr2_hdw_destroy(struct pvr2_hdw *hdw ) 
{ 


  {
#line 2713
  if ((unsigned long )hdw == (unsigned long )((struct pvr2_hdw *)0)) {
#line 2713
    return;
  } else {

  }
#line 2714
  if ((pvrusb2_debug & 32) != 0) {
#line 2714
    printk("\016pvrusb2: pvr2_hdw_destroy: hdw=%p\n", hdw);
  } else {

  }
#line 2715
  if ((unsigned long )hdw->workqueue != (unsigned long )((struct workqueue_struct *)0)) {
#line 2716
    ldv_flush_workqueue_248(hdw->workqueue);
#line 2717
    ldv_destroy_workqueue_249(hdw->workqueue);
#line 2718
    hdw->workqueue = (struct workqueue_struct *)0;
  } else {

  }
#line 2720
  ldv_del_timer_sync_250(& hdw->quiescent_timer);
#line 2721
  ldv_del_timer_sync_251(& hdw->decoder_stabilization_timer);
#line 2722
  ldv_del_timer_sync_252(& hdw->encoder_run_timer);
#line 2723
  ldv_del_timer_sync_253(& hdw->encoder_wait_timer);
#line 2724
  if ((unsigned long )hdw->fw_buffer != (unsigned long )((char *)0)) {
#line 2725
    kfree((void const   *)hdw->fw_buffer);
#line 2726
    hdw->fw_buffer = (char *)0;
  } else {

  }
#line 2728
  if ((unsigned long )hdw->vid_stream != (unsigned long )((struct pvr2_stream *)0)) {
#line 2729
    pvr2_stream_destroy(hdw->vid_stream);
#line 2730
    hdw->vid_stream = (struct pvr2_stream *)0;
  } else {

  }
#line 2732
  pvr2_i2c_core_done(hdw);
#line 2733
  v4l2_device_unregister(& hdw->v4l2_dev);
#line 2734
  pvr2_hdw_remove_usb_stuff(hdw);
#line 2735
  ldv_mutex_lock_254(& pvr2_unit_mtx);
#line 2737
  if ((hdw->unit_number >= 0 && hdw->unit_number <= 19) && (unsigned long )unit_pointers[hdw->unit_number] == (unsigned long )hdw) {
#line 2740
    unit_pointers[hdw->unit_number] = (struct pvr2_hdw *)0;
  } else {

  }
#line 2743
  ldv_mutex_unlock_255(& pvr2_unit_mtx);
#line 2744
  kfree((void const   *)hdw->controls);
#line 2745
  kfree((void const   *)hdw->mpeg_ctrl_info);
#line 2746
  kfree((void const   *)hdw);
#line 2747
  return;
}
}
#line 2750 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_dev_ok(struct pvr2_hdw *hdw ) 
{ 


  {
#line 2752
  return ((unsigned long )hdw != (unsigned long )((struct pvr2_hdw *)0) && hdw->flag_ok != 0);
}
}
#line 2757 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
void pvr2_hdw_disconnect(struct pvr2_hdw *hdw ) 
{ 


  {
#line 2759
  if ((pvrusb2_debug & 32) != 0) {
#line 2759
    printk("\016pvrusb2: pvr2_hdw_disconnect(hdw=%p)\n", hdw);
  } else {

  }
#line 2760
  ldv_mutex_lock_256(& hdw->big_lock_mutex);
#line 2760
  hdw->big_lock_held = 1;
#line 2761
  ldv_mutex_lock_257(& hdw->ctl_lock_mutex);
#line 2761
  hdw->ctl_lock_held = 1;
#line 2762
  pvr2_hdw_remove_usb_stuff(hdw);
#line 2763
  hdw->ctl_lock_held = 0;
#line 2763
  ldv_mutex_unlock_258(& hdw->ctl_lock_mutex);
#line 2764
  hdw->big_lock_held = 0;
#line 2764
  ldv_mutex_unlock_259(& hdw->big_lock_mutex);
#line 2765
  return;
}
}
#line 2769 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
unsigned int pvr2_hdw_get_ctrl_count(struct pvr2_hdw *hdw ) 
{ 


  {
#line 2771
  return (hdw->control_cnt);
}
}
#line 2776 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
struct pvr2_ctrl *pvr2_hdw_get_ctrl_by_index(struct pvr2_hdw *hdw , unsigned int idx ) 
{ 


  {
#line 2779
  if (hdw->control_cnt <= idx) {
#line 2779
    return ((struct pvr2_ctrl *)0);
  } else {

  }
#line 2780
  return (hdw->controls + (unsigned long )idx);
}
}
#line 2785 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
struct pvr2_ctrl *pvr2_hdw_get_ctrl_by_id(struct pvr2_hdw *hdw , unsigned int ctl_id ) 
{ 
  struct pvr2_ctrl *cptr ;
  unsigned int idx ;
  int i ;

  {
#line 2793
  idx = 0U;
#line 2793
  goto ldv_53303;
  ldv_53302: 
#line 2794
  cptr = hdw->controls + (unsigned long )idx;
#line 2795
  i = (cptr->info)->internal_id;
#line 2796
  if (i != 0 && (unsigned int )i == ctl_id) {
#line 2796
    return (cptr);
  } else {

  }
#line 2793
  idx = idx + 1U;
  ldv_53303: ;
#line 2793
  if (hdw->control_cnt > idx) {
#line 2795
    goto ldv_53302;
  } else {

  }

#line 2798
  return ((struct pvr2_ctrl *)0);
}
}
#line 2803 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
struct pvr2_ctrl *pvr2_hdw_get_ctrl_v4l(struct pvr2_hdw *hdw , unsigned int ctl_id ) 
{ 
  struct pvr2_ctrl *cptr ;
  unsigned int idx ;
  int i ;

  {
#line 2810
  idx = 0U;
#line 2810
  goto ldv_53313;
  ldv_53312: 
#line 2811
  cptr = hdw->controls + (unsigned long )idx;
#line 2812
  i = (cptr->info)->v4l_id;
#line 2813
  if (i != 0 && (unsigned int )i == ctl_id) {
#line 2813
    return (cptr);
  } else {

  }
#line 2810
  idx = idx + 1U;
  ldv_53313: ;
#line 2810
  if (hdw->control_cnt > idx) {
#line 2812
    goto ldv_53312;
  } else {

  }

#line 2815
  return ((struct pvr2_ctrl *)0);
}
}
#line 2821 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
struct pvr2_ctrl *pvr2_hdw_get_ctrl_nextv4l(struct pvr2_hdw *hdw , unsigned int ctl_id ) 
{ 
  struct pvr2_ctrl *cptr ;
  struct pvr2_ctrl *cp2 ;
  unsigned int idx ;
  int i ;

  {
#line 2829
  cp2 = (struct pvr2_ctrl *)0;
#line 2830
  idx = 0U;
#line 2830
  goto ldv_53325;
  ldv_53324: 
#line 2831
  cptr = hdw->controls + (unsigned long )idx;
#line 2832
  i = (cptr->info)->v4l_id;
#line 2833
  if (i == 0) {
#line 2833
    goto ldv_53323;
  } else {

  }
#line 2834
  if ((unsigned int )i <= ctl_id) {
#line 2834
    goto ldv_53323;
  } else {

  }
#line 2835
  if ((unsigned long )cp2 != (unsigned long )((struct pvr2_ctrl *)0) && (int )(cp2->info)->v4l_id < i) {
#line 2835
    goto ldv_53323;
  } else {

  }
#line 2836
  cp2 = cptr;
  ldv_53323: 
#line 2830
  idx = idx + 1U;
  ldv_53325: ;
#line 2830
  if (hdw->control_cnt > idx) {
#line 2832
    goto ldv_53324;
  } else {

  }

#line 2838
  return (cp2);
#line 2839
  return ((struct pvr2_ctrl *)0);
}
}
#line 2843 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static char const   *get_ctrl_typename(enum pvr2_ctl_type tp ) 
{ 


  {
#line 2845
  switch ((unsigned int )tp) {
  case 0U: ;
#line 2846
  return ("integer");
  case 1U: ;
#line 2847
  return ("enum");
  case 3U: ;
#line 2848
  return ("boolean");
  case 2U: ;
#line 2849
  return ("bitmask");
  }
#line 2851
  return ("");
}
}
#line 2855 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_subdev_set_control(struct pvr2_hdw *hdw , int id , char const   *name ,
                                    int val ) 
{ 
  struct v4l2_control ctrl ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 2859
  if ((pvrusb2_debug & 65536) != 0) {
#line 2859
    printk("\016pvrusb2: subdev v4l2 %s=%d\n", name, val);
  } else {

  }
#line 2860
  memset((void *)(& ctrl), 0, 8UL);
#line 2861
  ctrl.id = (__u32 )id;
#line 2862
  ctrl.value = val;
#line 2863
  __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 2863
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 2863
  goto ldv_53347;
  ldv_53346: ;
#line 2863
  if ((unsigned long )(__sd->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->core)->s_ctrl != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                          struct v4l2_control * ))0)) {
#line 2863
    (*(((__sd->ops)->core)->s_ctrl))(__sd, & ctrl);
  } else {

  }
#line 2863
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 2863
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_53347: ;
#line 2863
  if ((unsigned long )(& __sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 2865
    goto ldv_53346;
  } else {

  }

#line 2871
  return;
}
}
#line 2871 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static v4l2_std_id pvr2_hdw_get_detected_std(struct pvr2_hdw *hdw ) 
{ 
  v4l2_std_id std ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 2874
  std = hdw->std_mask_avail;
#line 2875
  __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 2875
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 2875
  goto ldv_53359;
  ldv_53358: ;
#line 2875
  if ((unsigned long )(__sd->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->video)->querystd != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                               v4l2_std_id * ))0)) {
#line 2875
    (*(((__sd->ops)->video)->querystd))(__sd, & std);
  } else {

  }
#line 2875
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 2875
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_53359: ;
#line 2875
  if ((unsigned long )(& __sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 2877
    goto ldv_53358;
  } else {

  }

#line 2877
  return (std);
}
}
#line 2882 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_subdev_update(struct pvr2_hdw *hdw ) 
{ 
  struct v4l2_subdev *sd ;
  unsigned int id ;
  void (*fp)(struct pvr2_hdw * , struct v4l2_subdev * ) ;
  struct tuner_setup setup ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct v4l2_subdev *__sd___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  v4l2_std_id vs ;
  struct v4l2_subdev *__sd___1 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;
  struct v4l2_tuner vt ;
  struct v4l2_subdev *__sd___2 ;
  struct list_head  const  *__mptr___5 ;
  struct list_head  const  *__mptr___6 ;
  unsigned long fv ;
  struct v4l2_frequency freq ;
  struct v4l2_subdev *__sd___3 ;
  struct list_head  const  *__mptr___7 ;
  struct list_head  const  *__mptr___8 ;
  struct v4l2_subdev_format format ;
  struct v4l2_subdev *__sd___4 ;
  struct list_head  const  *__mptr___9 ;
  struct list_head  const  *__mptr___10 ;
  u32 val ;
  struct v4l2_subdev *__sd___5 ;
  struct list_head  const  *__mptr___11 ;
  struct list_head  const  *__mptr___12 ;
  struct list_head  const  *__mptr___13 ;
  struct list_head  const  *__mptr___14 ;

  {
#line 2888
  if ((pvrusb2_debug & 65536) != 0) {
#line 2888
    printk("\016pvrusb2: subdev update...\n");
  } else {

  }
#line 2890
  if (hdw->tuner_updated != 0 || hdw->force_dirty != 0) {
#line 2892
    if ((pvrusb2_debug & 65536) != 0) {
#line 2892
      printk("\016pvrusb2: subdev tuner set_type(%d)\n", hdw->tuner_type);
    } else {

    }
#line 2894
    if ((int )hdw->tuner_type >= 0) {
#line 2895
      memset((void *)(& setup), 0, 32UL);
#line 2896
      setup.addr = 255U;
#line 2897
      setup.type = hdw->tuner_type;
#line 2898
      setup.mode_mask = 6U;
#line 2899
      __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 2899
      __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 2899
      goto ldv_53374;
      ldv_53373: ;
#line 2899
      if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->s_type_addr != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                      struct tuner_setup * ))0)) {
#line 2899
        (*(((__sd->ops)->tuner)->s_type_addr))(__sd, & setup);
      } else {

      }
#line 2899
      __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 2899
      __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
      ldv_53374: ;
#line 2899
      if ((unsigned long )(& __sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 2901
        goto ldv_53373;
      } else {

      }

    } else {

    }
  } else {

  }
#line 2904
  if ((hdw->input_dirty != 0 || hdw->std_dirty != 0) || hdw->force_dirty != 0) {
#line 2905
    if ((pvrusb2_debug & 65536) != 0) {
#line 2905
      printk("\016pvrusb2: subdev v4l2 set_standard\n");
    } else {

    }
#line 2906
    if (hdw->input_val == 4) {
#line 2907
      __mptr___1 = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 2907
      __sd___0 = (struct v4l2_subdev *)__mptr___1 + 0xffffffffffffff88UL;
#line 2907
      goto ldv_53382;
      ldv_53381: ;
#line 2907
      if ((unsigned long )(__sd___0->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd___0->ops)->tuner)->s_radio != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ))0)) {
#line 2907
        (*(((__sd___0->ops)->tuner)->s_radio))(__sd___0);
      } else {

      }
#line 2907
      __mptr___2 = (struct list_head  const  *)__sd___0->list.next;
#line 2907
      __sd___0 = (struct v4l2_subdev *)__mptr___2 + 0xffffffffffffff88UL;
      ldv_53382: ;
#line 2907
      if ((unsigned long )(& __sd___0->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 2909
        goto ldv_53381;
      } else {

      }

    } else {
#line 2911
      vs = hdw->std_mask_cur;
#line 2912
      __mptr___3 = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 2912
      __sd___1 = (struct v4l2_subdev *)__mptr___3 + 0xffffffffffffff88UL;
#line 2912
      goto ldv_53391;
      ldv_53390: ;
#line 2912
      if ((unsigned long )(__sd___1->ops)->video != (unsigned long )((struct v4l2_subdev_video_ops  const  */* const  */)0) && (unsigned long )((__sd___1->ops)->video)->s_std != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                        v4l2_std_id  ))0)) {
#line 2912
        (*(((__sd___1->ops)->video)->s_std))(__sd___1, vs);
      } else {

      }
#line 2912
      __mptr___4 = (struct list_head  const  *)__sd___1->list.next;
#line 2912
      __sd___1 = (struct v4l2_subdev *)__mptr___4 + 0xffffffffffffff88UL;
      ldv_53391: ;
#line 2912
      if ((unsigned long )(& __sd___1->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 2914
        goto ldv_53390;
      } else {

      }
#line 2914
      pvr2_hdw_cx25840_vbi_hack(hdw);
    }
#line 2916
    hdw->tuner_signal_stale = 1;
#line 2917
    hdw->cropcap_stale = 1;
  } else {

  }
#line 2920
  if (hdw->brightness_dirty != 0 || hdw->force_dirty != 0) {
#line 2920
    pvr2_subdev_set_control(hdw, 9963776, "brightness", hdw->brightness_val);
  } else {

  }
#line 2921
  if (hdw->contrast_dirty != 0 || hdw->force_dirty != 0) {
#line 2921
    pvr2_subdev_set_control(hdw, 9963777, "contrast", hdw->contrast_val);
  } else {

  }
#line 2922
  if (hdw->saturation_dirty != 0 || hdw->force_dirty != 0) {
#line 2922
    pvr2_subdev_set_control(hdw, 9963778, "saturation", hdw->saturation_val);
  } else {

  }
#line 2923
  if (hdw->hue_dirty != 0 || hdw->force_dirty != 0) {
#line 2923
    pvr2_subdev_set_control(hdw, 9963779, "hue", hdw->hue_val);
  } else {

  }
#line 2924
  if (hdw->mute_dirty != 0 || hdw->force_dirty != 0) {
#line 2924
    pvr2_subdev_set_control(hdw, 9963785, "mute", hdw->mute_val);
  } else {

  }
#line 2925
  if (hdw->volume_dirty != 0 || hdw->force_dirty != 0) {
#line 2925
    pvr2_subdev_set_control(hdw, 9963781, "volume", hdw->volume_val);
  } else {

  }
#line 2926
  if (hdw->balance_dirty != 0 || hdw->force_dirty != 0) {
#line 2926
    pvr2_subdev_set_control(hdw, 9963782, "balance", hdw->balance_val);
  } else {

  }
#line 2927
  if (hdw->bass_dirty != 0 || hdw->force_dirty != 0) {
#line 2927
    pvr2_subdev_set_control(hdw, 9963783, "bass", hdw->bass_val);
  } else {

  }
#line 2928
  if (hdw->treble_dirty != 0 || hdw->force_dirty != 0) {
#line 2928
    pvr2_subdev_set_control(hdw, 9963784, "treble", hdw->treble_val);
  } else {

  }
#line 2930
  if ((hdw->input_dirty != 0 || hdw->audiomode_dirty != 0) || hdw->force_dirty != 0) {
#line 2932
    memset((void *)(& vt), 0, 84UL);
#line 2933
    vt.type = hdw->input_val == 4 ? 1U : 2U;
#line 2935
    vt.audmode = (__u32 )hdw->audiomode_val;
#line 2936
    __mptr___5 = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 2936
    __sd___2 = (struct v4l2_subdev *)__mptr___5 + 0xffffffffffffff88UL;
#line 2936
    goto ldv_53400;
    ldv_53399: ;
#line 2936
    if ((unsigned long )(__sd___2->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd___2->ops)->tuner)->s_tuner != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                        struct v4l2_tuner  const  * ))0)) {
#line 2936
      (*(((__sd___2->ops)->tuner)->s_tuner))(__sd___2, (struct v4l2_tuner  const  *)(& vt));
    } else {

    }
#line 2936
    __mptr___6 = (struct list_head  const  *)__sd___2->list.next;
#line 2936
    __sd___2 = (struct v4l2_subdev *)__mptr___6 + 0xffffffffffffff88UL;
    ldv_53400: ;
#line 2936
    if ((unsigned long )(& __sd___2->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 2938
      goto ldv_53399;
    } else {

    }

  } else {

  }
#line 2939
  if (hdw->freqDirty != 0 || hdw->force_dirty != 0) {
#line 2942
    fv = pvr2_hdw_get_cur_freq(hdw);
#line 2943
    if ((pvrusb2_debug & 65536) != 0) {
#line 2943
      printk("\016pvrusb2: subdev v4l2 set_freq(%lu)\n", fv);
    } else {

    }
#line 2944
    if (hdw->tuner_signal_stale != 0) {
#line 2944
      pvr2_hdw_status_poll(hdw);
    } else {

    }
#line 2945
    memset((void *)(& freq), 0, 44UL);
#line 2946
    if ((int )hdw->tuner_signal_info.capability & 1) {
#line 2948
      freq.frequency = (__u32 )((fv * 2UL) / 125UL);
    } else {
#line 2950
      freq.frequency = (__u32 )(fv / 62500UL);
    }
#line 2954
    if (hdw->input_val == 4) {
#line 2955
      freq.type = 1U;
    } else {
#line 2957
      freq.type = 2U;
    }
#line 2959
    freq.tuner = 0U;
#line 2960
    __mptr___7 = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 2960
    __sd___3 = (struct v4l2_subdev *)__mptr___7 + 0xffffffffffffff88UL;
#line 2960
    goto ldv_53410;
    ldv_53409: ;
#line 2960
    if ((unsigned long )(__sd___3->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd___3->ops)->tuner)->s_frequency != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                            struct v4l2_frequency  const  * ))0)) {
#line 2960
      (*(((__sd___3->ops)->tuner)->s_frequency))(__sd___3, (struct v4l2_frequency  const  *)(& freq));
    } else {

    }
#line 2960
    __mptr___8 = (struct list_head  const  *)__sd___3->list.next;
#line 2960
    __sd___3 = (struct v4l2_subdev *)__mptr___8 + 0xffffffffffffff88UL;
    ldv_53410: ;
#line 2960
    if ((unsigned long )(& __sd___3->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 2962
      goto ldv_53409;
    } else {

    }

  } else {

  }
#line 2964
  if ((hdw->res_hor_dirty != 0 || hdw->res_ver_dirty != 0) || hdw->force_dirty != 0) {
#line 2965
    format.which = 1U;
#line 2965
    format.pad = 0U;
#line 2965
    format.format.width = 0U;
#line 2965
    format.format.height = 0U;
#line 2965
    format.format.code = 0U;
#line 2965
    format.format.field = 0U;
#line 2965
    format.format.colorspace = 0U;
#line 2965
    format.format.ycbcr_enc = (unsigned short)0;
#line 2965
    format.format.quantization = (unsigned short)0;
#line 2965
    format.format.xfer_func = (unsigned short)0;
#line 2965
    format.format.reserved[0] = (unsigned short)0;
#line 2965
    format.format.reserved[1] = (unsigned short)0;
#line 2965
    format.format.reserved[2] = (unsigned short)0;
#line 2965
    format.format.reserved[3] = (unsigned short)0;
#line 2965
    format.format.reserved[4] = (unsigned short)0;
#line 2965
    format.format.reserved[5] = (unsigned short)0;
#line 2965
    format.format.reserved[6] = (unsigned short)0;
#line 2965
    format.format.reserved[7] = (unsigned short)0;
#line 2965
    format.format.reserved[8] = (unsigned short)0;
#line 2965
    format.format.reserved[9] = (unsigned short)0;
#line 2965
    format.format.reserved[10] = (unsigned short)0;
#line 2965
    format.reserved[0] = 0U;
#line 2965
    format.reserved[1] = 0U;
#line 2965
    format.reserved[2] = 0U;
#line 2965
    format.reserved[3] = 0U;
#line 2965
    format.reserved[4] = 0U;
#line 2965
    format.reserved[5] = 0U;
#line 2965
    format.reserved[6] = 0U;
#line 2965
    format.reserved[7] = 0U;
#line 2969
    format.format.width = (__u32 )hdw->res_hor_val;
#line 2970
    format.format.height = (__u32 )hdw->res_ver_val;
#line 2971
    format.format.code = 1U;
#line 2972
    if ((pvrusb2_debug & 65536) != 0) {
#line 2972
      printk("\016pvrusb2: subdev v4l2 set_size(%dx%d)\n", format.format.width, format.format.height);
    } else {

    }
#line 2974
    __mptr___9 = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 2974
    __sd___4 = (struct v4l2_subdev *)__mptr___9 + 0xffffffffffffff88UL;
#line 2974
    goto ldv_53419;
    ldv_53418: ;
#line 2974
    if ((unsigned long )(__sd___4->ops)->pad != (unsigned long )((struct v4l2_subdev_pad_ops  const  */* const  */)0) && (unsigned long )((__sd___4->ops)->pad)->set_fmt != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                  struct v4l2_subdev_pad_config * ,
                                                                                                                                                                                                                  struct v4l2_subdev_format * ))0)) {
#line 2974
      (*(((__sd___4->ops)->pad)->set_fmt))(__sd___4, (struct v4l2_subdev_pad_config *)0,
                                           & format);
    } else {

    }
#line 2974
    __mptr___10 = (struct list_head  const  *)__sd___4->list.next;
#line 2974
    __sd___4 = (struct v4l2_subdev *)__mptr___10 + 0xffffffffffffff88UL;
    ldv_53419: ;
#line 2974
    if ((unsigned long )(& __sd___4->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 2976
      goto ldv_53418;
    } else {

    }

  } else {

  }
#line 2978
  if (hdw->srate_dirty != 0 || hdw->force_dirty != 0) {
#line 2980
    if ((pvrusb2_debug & 65536) != 0) {
#line 2980
      printk("\016pvrusb2: subdev v4l2 set_audio %d\n", hdw->srate_val);
    } else {

    }
#line 2982
    switch (hdw->srate_val) {
    default: ;
    case 1: 
#line 2985
    val = 48000U;
#line 2986
    goto ldv_53424;
    case 0: 
#line 2988
    val = 44100U;
#line 2989
    goto ldv_53424;
    case 2: 
#line 2991
    val = 32000U;
#line 2992
    goto ldv_53424;
    }
    ldv_53424: 
#line 2994
    __mptr___11 = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 2994
    __sd___5 = (struct v4l2_subdev *)__mptr___11 + 0xffffffffffffff88UL;
#line 2994
    goto ldv_53433;
    ldv_53432: ;
#line 2994
    if ((unsigned long )(__sd___5->ops)->audio != (unsigned long )((struct v4l2_subdev_audio_ops  const  */* const  */)0) && (unsigned long )((__sd___5->ops)->audio)->s_clock_freq != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                             u32  ))0)) {
#line 2994
      (*(((__sd___5->ops)->audio)->s_clock_freq))(__sd___5, val);
    } else {

    }
#line 2994
    __mptr___12 = (struct list_head  const  *)__sd___5->list.next;
#line 2994
    __sd___5 = (struct v4l2_subdev *)__mptr___12 + 0xffffffffffffff88UL;
    ldv_53433: ;
#line 2994
    if ((unsigned long )(& __sd___5->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 2996
      goto ldv_53432;
    } else {

    }

  } else {

  }
#line 3001
  __mptr___13 = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 3001
  sd = (struct v4l2_subdev *)__mptr___13 + 0xffffffffffffff88UL;
#line 3001
  goto ldv_53443;
  ldv_53442: 
#line 3002
  id = sd->grp_id;
#line 3003
  if (id > 6U) {
#line 3003
    goto ldv_53441;
  } else {

  }
#line 3004
  fp = pvr2_module_update_functions[id];
#line 3005
  if ((unsigned long )fp == (unsigned long )((void (*)(struct pvr2_hdw * , struct v4l2_subdev * ))0)) {
#line 3005
    goto ldv_53441;
  } else {

  }
#line 3006
  (*fp)(hdw, sd);
  ldv_53441: 
#line 3001
  __mptr___14 = (struct list_head  const  *)sd->list.next;
#line 3001
  sd = (struct v4l2_subdev *)__mptr___14 + 0xffffffffffffff88UL;
  ldv_53443: ;
#line 3001
  if ((unsigned long )(& sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 3003
    goto ldv_53442;
  } else {

  }

#line 3009
  if (hdw->tuner_signal_stale != 0 || hdw->cropcap_stale != 0) {
#line 3010
    pvr2_hdw_status_poll(hdw);
  } else {

  }
#line 3011
  return;
}
}
#line 3018 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_hdw_commit_setup(struct pvr2_hdw *hdw ) 
{ 
  unsigned int idx ;
  struct pvr2_ctrl *cptr ;
  int value ;
  int commit_flag ;
  char buf[100U] ;
  unsigned int bcnt ;
  unsigned int ccnt ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 3023
  commit_flag = hdw->force_dirty;
#line 3027
  idx = 0U;
#line 3027
  goto ldv_53457;
  ldv_53456: 
#line 3028
  cptr = hdw->controls + (unsigned long )idx;
#line 3029
  if ((unsigned long )(cptr->info)->is_dirty == (unsigned long )((int (*)(struct pvr2_ctrl * ))0)) {
#line 3029
    goto ldv_53455;
  } else {

  }
#line 3030
  tmp = (*((cptr->info)->is_dirty))(cptr);
#line 3030
  if (tmp == 0) {
#line 3030
    goto ldv_53455;
  } else {

  }
#line 3031
  commit_flag = 1;
#line 3033
  if ((pvrusb2_debug & 128) == 0) {
#line 3033
    goto ldv_53455;
  } else {

  }
#line 3034
  tmp___0 = scnprintf((char *)(& buf), 100UL, "\"%s\" <-- ", (cptr->info)->name);
#line 3034
  bcnt = (unsigned int )tmp___0;
#line 3036
  value = 0;
#line 3037
  (*((cptr->info)->get_value))(cptr, & value);
#line 3038
  pvr2_ctrl_value_to_sym_internal(cptr, -1, value, (char *)(& buf) + (unsigned long )bcnt,
                                  100U - bcnt, & ccnt);
#line 3041
  bcnt = bcnt + ccnt;
#line 3042
  tmp___1 = get_ctrl_typename((cptr->info)->type);
#line 3042
  tmp___2 = scnprintf((char *)(& buf) + (unsigned long )bcnt, 100UL - (unsigned long )bcnt,
                      " <%s>", tmp___1);
#line 3042
  bcnt = (unsigned int )tmp___2 + bcnt;
#line 3044
  if ((pvrusb2_debug & 128) != 0) {
#line 3044
    printk("\016pvrusb2: /*--TRACE_COMMIT--*/ %.*s\n", bcnt, (char *)(& buf));
  } else {

  }
  ldv_53455: 
#line 3027
  idx = idx + 1U;
  ldv_53457: ;
#line 3027
  if (hdw->control_cnt > idx) {
#line 3029
    goto ldv_53456;
  } else {

  }

#line 3049
  if (commit_flag == 0) {
#line 3051
    return (0);
  } else {

  }
#line 3054
  hdw->state_pipeline_config = 0;
#line 3055
  trace_stbit("state_pipeline_config", hdw->state_pipeline_config);
#line 3056
  pvr2_hdw_state_sched(hdw);
#line 3058
  return (1);
}
}
#line 3067 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_hdw_commit_execute(struct pvr2_hdw *hdw ) 
{ 
  unsigned int idx ;
  struct pvr2_ctrl *cptr ;
  int disruptive_change ;
  int nvres ;
  int gop_size ;
  struct v4l2_ext_controls cs ;
  struct v4l2_ext_control c1 ;
  int _min1 ;
  int _min2 ;
  int nvres___0 ;
  int _min1___0 ;
  int _min2___0 ;
  struct v4l2_ext_controls cs___0 ;
  struct v4l2_ext_control c1___0 ;
  u32 b ;
  int tmp ;

  {
#line 3073
  if ((hdw->input_dirty != 0 && hdw->state_pathway_ok != 0) && (hdw->input_val == 1 ? 2 : 1) != hdw->pathway_state) {
#line 3078
    hdw->state_pathway_ok = 0;
#line 3079
    trace_stbit("state_pathway_ok", hdw->state_pathway_ok);
  } else {

  }
#line 3081
  if (hdw->state_pathway_ok == 0) {
#line 3083
    return (0);
  } else {

  }
#line 3088
  if (hdw->std_dirty != 0) {
#line 3091
    if ((hdw->std_mask_cur & 63744ULL) != 0ULL) {
#line 3092
      nvres = 480;
#line 3093
      gop_size = 15;
    } else {
#line 3095
      nvres = 576;
#line 3096
      gop_size = 12;
    }
#line 3100
    if (hdw->res_ver_val != nvres) {
#line 3101
      hdw->res_ver_val = nvres;
#line 3102
      hdw->res_ver_dirty = 1;
    } else {

    }
#line 3106
    if ((int )hdw->enc_ctl_state.video_gop_size != gop_size) {
#line 3109
      memset((void *)(& cs), 0, 32UL);
#line 3110
      memset((void *)(& c1), 0, 20UL);
#line 3111
      cs.controls = & c1;
#line 3112
      cs.count = 1U;
#line 3113
      c1.id = 10029515U;
#line 3114
      c1.__annonCompField78.value = gop_size;
#line 3115
      cx2341x_ext_ctrls(& hdw->enc_ctl_state, 0, & cs, 3223344712U);
    } else {

    }
  } else {

  }
#line 3126
  if (hdw->res_hor_dirty != 0 && hdw->cropw_val < hdw->res_hor_val) {
#line 3127
    hdw->cropw_val = hdw->res_hor_val;
#line 3128
    hdw->cropw_dirty = 1;
  } else
#line 3129
  if (hdw->cropw_dirty != 0) {
#line 3130
    hdw->res_hor_dirty = 1;
#line 3131
    _min1 = 720;
#line 3131
    _min2 = hdw->cropw_val;
#line 3131
    hdw->res_hor_val = _min1 < _min2 ? _min1 : _min2;
  } else {

  }
#line 3133
  if (hdw->res_ver_dirty != 0 && hdw->croph_val < hdw->res_ver_val) {
#line 3134
    hdw->croph_val = hdw->res_ver_val;
#line 3135
    hdw->croph_dirty = 1;
  } else
#line 3136
  if (hdw->croph_dirty != 0) {
#line 3137
    nvres___0 = (hdw->std_mask_cur & 63744ULL) != 0ULL ? 480 : 576;
#line 3138
    hdw->res_ver_dirty = 1;
#line 3139
    _min1___0 = nvres___0;
#line 3139
    _min2___0 = hdw->croph_val;
#line 3139
    hdw->res_ver_val = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
  } else {

  }
#line 3146
  disruptive_change = (((((((hdw->std_dirty != 0 || hdw->enc_unsafe_stale != 0) || hdw->srate_dirty != 0) || hdw->res_ver_dirty != 0) || hdw->res_hor_dirty != 0) || hdw->cropw_dirty != 0) || hdw->croph_dirty != 0) || hdw->input_dirty != 0) || (unsigned int )hdw->active_stream_type != (unsigned int )hdw->desired_stream_type;
#line 3156
  if (disruptive_change != 0 && hdw->state_pipeline_idle == 0) {
#line 3160
    hdw->state_pipeline_pause = 1;
#line 3161
    return (0);
  } else {

  }
#line 3164
  if (hdw->srate_dirty != 0) {
#line 3171
    memset((void *)(& cs___0), 0, 32UL);
#line 3172
    memset((void *)(& c1___0), 0, 20UL);
#line 3173
    cs___0.controls = & c1___0;
#line 3174
    cs___0.count = 1U;
#line 3175
    c1___0.id = 10029412U;
#line 3176
    c1___0.__annonCompField78.value = hdw->srate_val;
#line 3177
    cx2341x_ext_ctrls(& hdw->enc_ctl_state, 0, & cs___0, 3223344712U);
  } else {

  }
#line 3180
  if ((unsigned int )hdw->active_stream_type != (unsigned int )hdw->desired_stream_type) {
#line 3182
    hdw->active_stream_type = hdw->desired_stream_type;
  } else {

  }
#line 3185
  if ((unsigned int )((unsigned char )(hdw->hdw_desc)->signal_routing_scheme) == 1U) {
#line 3189
    pvr2_hdw_gpio_get_out(hdw, & b);
#line 3190
    if (hdw->input_val == 4) {
#line 3192
      pvr2_hdw_gpio_chg_out(hdw, 2048U, 4294967295U);
    } else {
#line 3195
      pvr2_hdw_gpio_chg_out(hdw, 2048U, 0U);
    }
  } else {

  }
#line 3200
  pvr2_subdev_update(hdw);
#line 3202
  hdw->tuner_updated = 0;
#line 3203
  hdw->force_dirty = 0;
#line 3204
  idx = 0U;
#line 3204
  goto ldv_53481;
  ldv_53480: 
#line 3205
  cptr = hdw->controls + (unsigned long )idx;
#line 3206
  if ((unsigned long )(cptr->info)->clear_dirty == (unsigned long )((void (*)(struct pvr2_ctrl * ))0)) {
#line 3206
    goto ldv_53479;
  } else {

  }
#line 3207
  (*((cptr->info)->clear_dirty))(cptr);
  ldv_53479: 
#line 3204
  idx = idx + 1U;
  ldv_53481: ;
#line 3204
  if (hdw->control_cnt > idx) {
#line 3206
    goto ldv_53480;
  } else {

  }

#line 3210
  if (hdw->pathway_state == 1 && hdw->state_encoder_run != 0) {
#line 3215
    tmp = pvr2_encoder_adjust(hdw);
#line 3215
    if (tmp < 0) {
#line 3215
      return (1);
    } else {

    }
  } else {

  }
#line 3218
  hdw->state_pipeline_config = 1;
#line 3222
  trace_stbit("state_pipeline_config", hdw->state_pipeline_config);
#line 3223
  return (1);
}
}
#line 3227 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_commit_ctl(struct pvr2_hdw *hdw ) 
{ 
  int fl ;
  int tmp ;

  {
#line 3230
  ldv_mutex_lock_260(& hdw->big_lock_mutex);
#line 3230
  hdw->big_lock_held = 1;
#line 3231
  fl = pvr2_hdw_commit_setup(hdw);
#line 3232
  hdw->big_lock_held = 0;
#line 3232
  ldv_mutex_unlock_261(& hdw->big_lock_mutex);
#line 3233
  if (fl == 0) {
#line 3233
    return (0);
  } else {

  }
#line 3234
  tmp = pvr2_hdw_wait(hdw, 0);
#line 3234
  return (tmp);
}
}
#line 3238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_hdw_worker_poll(struct work_struct *work ) 
{ 
  int fl ;
  struct pvr2_hdw *hdw ;
  struct work_struct  const  *__mptr ;

  {
#line 3240
  fl = 0;
#line 3241
  __mptr = (struct work_struct  const  *)work;
#line 3241
  hdw = (struct pvr2_hdw *)__mptr + 0xffffffffffffff20UL;
#line 3242
  ldv_mutex_lock_262(& hdw->big_lock_mutex);
#line 3242
  hdw->big_lock_held = 1;
#line 3243
  fl = pvr2_hdw_state_eval(hdw);
#line 3244
  hdw->big_lock_held = 0;
#line 3244
  ldv_mutex_unlock_263(& hdw->big_lock_mutex);
#line 3245
  if (fl != 0 && (unsigned long )hdw->state_func != (unsigned long )((void (*)(void * ))0)) {
#line 3246
    (*(hdw->state_func))(hdw->state_data);
  } else {

  }
#line 3247
  return;
}
}
#line 3251 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_hdw_wait(struct pvr2_hdw *hdw , int state ) 
{ 
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp ;

  {
#line 3253
  __ret = 0;
#line 3253
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c",
                3256, 0);
#line 3253
  if (hdw->state_stale != 0 || (state != 0 && hdw->master_state == (unsigned int )state)) {
#line 3253
    __ret___0 = 0L;
#line 3253
    INIT_LIST_HEAD(& __wait.task_list);
#line 3253
    __wait.flags = 0U;
    ldv_53504: 
#line 3253
    tmp = prepare_to_wait_event(& hdw->state_wait_data, & __wait, 1);
#line 3253
    __int = tmp;
#line 3253
    if (hdw->state_stale == 0 && (state == 0 || hdw->master_state != (unsigned int )state)) {
#line 3253
      goto ldv_53503;
    } else {

    }
#line 3253
    if (__int != 0L) {
#line 3253
      __ret___0 = __int;
#line 3253
      goto ldv_53503;
    } else {

    }
#line 3253
    schedule();
#line 3253
    goto ldv_53504;
    ldv_53503: 
#line 3253
    finish_wait(& hdw->state_wait_data, & __wait);
#line 3253
    __ret = (int )__ret___0;
  } else {

  }
#line 3253
  return (__ret);
}
}
#line 3261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
char const   *pvr2_hdw_get_driver_name(struct pvr2_hdw *hdw ) 
{ 


  {
#line 3263
  return ((char const   *)(& hdw->name));
}
}
#line 3267 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
char const   *pvr2_hdw_get_desc(struct pvr2_hdw *hdw ) 
{ 


  {
#line 3269
  return ((char const   *)(hdw->hdw_desc)->description);
}
}
#line 3273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
char const   *pvr2_hdw_get_type(struct pvr2_hdw *hdw ) 
{ 


  {
#line 3275
  return ((char const   *)(hdw->hdw_desc)->shortname);
}
}
#line 3279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_is_hsm(struct pvr2_hdw *hdw ) 
{ 
  int result ;

  {
#line 3282
  ldv_mutex_lock_264(& hdw->ctl_lock_mutex);
#line 3282
  hdw->ctl_lock_held = 1;
#line 3283
  hdw->cmd_buffer[0] = 11U;
#line 3284
  result = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), 1U, (void *)(& hdw->cmd_buffer),
                             1U);
#line 3287
  if (result < 0) {
#line 3287
    goto ldv_53520;
  } else {

  }
#line 3288
  result = (unsigned int )hdw->cmd_buffer[0] != 0U;
  ldv_53520: 
#line 3289
  hdw->ctl_lock_held = 0;
#line 3289
  ldv_mutex_unlock_265(& hdw->ctl_lock_mutex);
#line 3290
  return (result);
}
}
#line 3295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
void pvr2_hdw_execute_tuner_poll(struct pvr2_hdw *hdw ) 
{ 


  {
#line 3297
  ldv_mutex_lock_266(& hdw->big_lock_mutex);
#line 3297
  hdw->big_lock_held = 1;
#line 3298
  pvr2_hdw_status_poll(hdw);
#line 3299
  hdw->big_lock_held = 0;
#line 3299
  ldv_mutex_unlock_267(& hdw->big_lock_mutex);
#line 3300
  return;
}
}
#line 3303 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_hdw_check_cropcap(struct pvr2_hdw *hdw ) 
{ 


  {
#line 3305
  if (hdw->cropcap_stale == 0) {
#line 3306
    return (0);
  } else {

  }
#line 3308
  pvr2_hdw_status_poll(hdw);
#line 3309
  if (hdw->cropcap_stale != 0) {
#line 3310
    return (-5);
  } else {

  }
#line 3312
  return (0);
}
}
#line 3317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_get_cropcap(struct pvr2_hdw *hdw , struct v4l2_cropcap *pp ) 
{ 
  int stat ;

  {
#line 3319
  stat = 0;
#line 3320
  ldv_mutex_lock_268(& hdw->big_lock_mutex);
#line 3320
  hdw->big_lock_held = 1;
#line 3321
  stat = pvr2_hdw_check_cropcap(hdw);
#line 3322
  if (stat == 0) {
#line 3323
    memcpy((void *)pp, (void const   *)(& hdw->cropcap_info), 44UL);
  } else {

  }
#line 3325
  hdw->big_lock_held = 0;
#line 3325
  ldv_mutex_unlock_269(& hdw->big_lock_mutex);
#line 3326
  return (stat);
}
}
#line 3331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_get_tuner_status(struct pvr2_hdw *hdw , struct v4l2_tuner *vtp ) 
{ 


  {
#line 3333
  ldv_mutex_lock_270(& hdw->big_lock_mutex);
#line 3333
  hdw->big_lock_held = 1;
#line 3334
  if (hdw->tuner_signal_stale != 0) {
#line 3335
    pvr2_hdw_status_poll(hdw);
  } else {

  }
#line 3337
  memcpy((void *)vtp, (void const   *)(& hdw->tuner_signal_info), 84UL);
#line 3338
  hdw->big_lock_held = 0;
#line 3338
  ldv_mutex_unlock_271(& hdw->big_lock_mutex);
#line 3339
  return (0);
}
}
#line 3344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
struct pvr2_stream *pvr2_hdw_get_video_stream(struct pvr2_hdw *hp ) 
{ 


  {
#line 3346
  return (hp->vid_stream);
}
}
#line 3350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
void pvr2_hdw_trigger_module_log(struct pvr2_hdw *hdw ) 
{ 
  int nr ;
  int tmp ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 3352
  tmp = pvr2_hdw_get_unit_number(hdw);
#line 3352
  nr = tmp;
#line 3353
  ldv_mutex_lock_272(& hdw->big_lock_mutex);
#line 3353
  hdw->big_lock_held = 1;
#line 3355
  printk("\016pvrusb2: =================  START STATUS CARD #%d  =================\n",
         nr);
#line 3356
  __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 3356
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 3356
  goto ldv_53549;
  ldv_53548: ;
#line 3356
  if ((unsigned long )(__sd->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->core)->log_status != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ))0)) {
#line 3356
    (*(((__sd->ops)->core)->log_status))(__sd);
  } else {

  }
#line 3356
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 3356
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_53549: ;
#line 3356
  if ((unsigned long )(& __sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 3358
    goto ldv_53548;
  } else {

  }

#line 3357
  if (pvrusb2_debug & 1) {
#line 3357
    printk("\016pvrusb2: cx2341x config:\n");
  } else {

  }
#line 3358
  cx2341x_log_status((struct cx2341x_mpeg_params  const  *)(& hdw->enc_ctl_state),
                     "pvrusb2");
#line 3359
  pvr2_hdw_state_log_state(hdw);
#line 3360
  printk("\016pvrusb2: ==================  END STATUS CARD #%d  ==================\n",
         nr);
#line 3362
  hdw->big_lock_held = 0;
#line 3362
  ldv_mutex_unlock_273(& hdw->big_lock_mutex);
#line 3363
  return;
}
}
#line 3369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static u8 *pvr2_full_eeprom_fetch(struct pvr2_hdw *hdw ) 
{ 
  struct i2c_msg msg[2U] ;
  u8 *eeprom ;
  u8 iadd[2U] ;
  u8 addr ;
  u16 eepromSize ;
  unsigned int offs ;
  int ret ;
  int mode16 ;
  unsigned int pcnt ;
  unsigned int tcnt ;
  void *tmp ;

  {
#line 3378
  mode16 = 0;
#line 3380
  tmp = kmalloc(8192UL, 208U);
#line 3380
  eeprom = (u8 *)tmp;
#line 3381
  if ((unsigned long )eeprom == (unsigned long )((u8 *)0U)) {
#line 3382
    if ((pvrusb2_debug & 2) != 0) {
#line 3382
      printk("\016pvrusb2: Failed to allocate memory required to read eeprom\n");
    } else {

    }
#line 3385
    return ((u8 *)0U);
  } else {

  }
#line 3388
  if ((pvrusb2_debug & 1024) != 0) {
#line 3388
    printk("\016pvrusb2: Value for eeprom addr from controller was 0x%x\n", hdw->eeprom_addr);
  } else {

  }
#line 3390
  addr = (u8 )hdw->eeprom_addr;
#line 3394
  if ((int )((signed char )addr) < 0) {
#line 3394
    addr = (u8 )((int )addr >> 1);
  } else {

  }
#line 3399
  mode16 = (int )addr & 1;
#line 3400
  eepromSize = mode16 != 0 ? 8192U : 256U;
#line 3401
  if ((pvrusb2_debug & 1024) != 0) {
#line 3401
    printk("\016pvrusb2: Examining %d byte eeprom at location 0x%x using %d bit addressing\n",
           (int )eepromSize, (int )addr, mode16 != 0 ? 16 : 8);
  } else {

  }
#line 3405
  msg[0].addr = (__u16 )addr;
#line 3406
  msg[0].flags = 0U;
#line 3407
  msg[0].len = mode16 != 0 ? 2U : 1U;
#line 3408
  msg[0].buf = (__u8 *)(& iadd);
#line 3409
  msg[1].addr = (__u16 )addr;
#line 3410
  msg[1].flags = 1U;
#line 3416
  memset((void *)eeprom, 0, 8192UL);
#line 3417
  tcnt = 0U;
#line 3417
  goto ldv_53567;
  ldv_53566: 
#line 3418
  pcnt = 16U;
#line 3419
  if (pcnt + tcnt > 8192U) {
#line 3419
    pcnt = 8192U - tcnt;
  } else {

  }
#line 3420
  offs = ((unsigned int )eepromSize + tcnt) + 4294959104U;
#line 3421
  if (mode16 != 0) {
#line 3422
    iadd[0] = (u8 )(offs >> 8);
#line 3423
    iadd[1] = (u8 )offs;
  } else {
#line 3425
    iadd[0] = (u8 )offs;
  }
#line 3427
  msg[1].len = (__u16 )pcnt;
#line 3428
  msg[1].buf = eeprom + (unsigned long )tcnt;
#line 3429
  ret = i2c_transfer(& hdw->i2c_adap, (struct i2c_msg *)(& msg), 2);
#line 3429
  if (ret != 2) {
#line 3431
    if ((pvrusb2_debug & 2) != 0) {
#line 3431
      printk("\016pvrusb2: eeprom fetch set offs err=%d\n", ret);
    } else {

    }
#line 3433
    kfree((void const   *)eeprom);
#line 3434
    return ((u8 *)0U);
  } else {

  }
#line 3417
  tcnt = tcnt + pcnt;
  ldv_53567: ;
#line 3417
  if (tcnt <= 8191U) {
#line 3419
    goto ldv_53566;
  } else {

  }

#line 3437
  return (eeprom);
}
}
#line 3441 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
void pvr2_hdw_cpufw_set_enabled(struct pvr2_hdw *hdw , int mode , int enable_flag ) 
{ 
  int ret ;
  u16 address ;
  unsigned int pipe ;
  void *tmp ;
  unsigned int tmp___0 ;
  u8 *tmp___1 ;

  {
#line 3448
  ldv_mutex_lock_274(& hdw->big_lock_mutex);
#line 3448
  hdw->big_lock_held = 1;
#line 3449
  if (((unsigned long )hdw->fw_buffer != (unsigned long )((char *)0)) ^ (enable_flag == 0)) {
#line 3449
    goto ldv_53577;
  } else {

  }
#line 3451
  if (enable_flag == 0) {
#line 3452
    if ((pvrusb2_debug & 32768) != 0) {
#line 3452
      printk("\016pvrusb2: Cleaning up after CPU firmware fetch\n");
    } else {

    }
#line 3454
    kfree((void const   *)hdw->fw_buffer);
#line 3455
    hdw->fw_buffer = (char *)0;
#line 3456
    hdw->fw_size = 0U;
#line 3457
    if (hdw->fw_cpu_flag != 0) {
#line 3460
      pvr2_hdw_cpureset_assert(hdw, 0);
    } else {

    }
#line 3462
    goto ldv_53577;
  } else {

  }
#line 3465
  hdw->fw_cpu_flag = mode != 2;
#line 3466
  if (hdw->fw_cpu_flag != 0) {
#line 3467
    hdw->fw_size = mode == 1 ? 16384U : 8192U;
#line 3468
    if ((pvrusb2_debug & 32768) != 0) {
#line 3468
      printk("\016pvrusb2: Preparing to suck out CPU firmware (size=%u)\n", hdw->fw_size);
    } else {

    }
#line 3471
    tmp = kzalloc((size_t )hdw->fw_size, 208U);
#line 3471
    hdw->fw_buffer = (char *)tmp;
#line 3472
    if ((unsigned long )hdw->fw_buffer == (unsigned long )((char *)0)) {
#line 3473
      hdw->fw_size = 0U;
#line 3474
      goto ldv_53577;
    } else {

    }
#line 3478
    pvr2_hdw_cpureset_assert(hdw, 1);
#line 3483
    if ((pvrusb2_debug & 32768) != 0) {
#line 3483
      printk("\016pvrusb2: Grabbing CPU firmware\n");
    } else {

    }
#line 3485
    tmp___0 = __create_pipe(hdw->usb_dev, 0U);
#line 3485
    pipe = tmp___0 | 2147483776U;
#line 3486
    address = 0U;
#line 3486
    goto ldv_53580;
    ldv_53579: 
#line 3488
    ret = usb_control_msg(hdw->usb_dev, pipe, 160, 192, (int )address, 0, (void *)hdw->fw_buffer + (unsigned long )address,
                          2048, 250);
#line 3493
    if (ret < 0) {
#line 3493
      goto ldv_53578;
    } else {

    }
#line 3487
    address = (unsigned int )address + 2048U;
    ldv_53580: ;
#line 3486
    if ((unsigned int )address < hdw->fw_size) {
#line 3488
      goto ldv_53579;
    } else {

    }
    ldv_53578: ;
#line 3496
    if ((pvrusb2_debug & 32768) != 0) {
#line 3496
      printk("\016pvrusb2: Done grabbing CPU firmware\n");
    } else {

    }
  } else {
#line 3499
    if ((pvrusb2_debug & 32768) != 0) {
#line 3499
      printk("\016pvrusb2: Sucking down EEPROM contents\n");
    } else {

    }
#line 3501
    tmp___1 = pvr2_full_eeprom_fetch(hdw);
#line 3501
    hdw->fw_buffer = (char *)tmp___1;
#line 3502
    if ((unsigned long )hdw->fw_buffer == (unsigned long )((char *)0)) {
#line 3503
      if ((pvrusb2_debug & 32768) != 0) {
#line 3503
        printk("\016pvrusb2: EEPROM content suck failed.\n");
      } else {

      }
#line 3505
      goto ldv_53577;
    } else {

    }
#line 3507
    hdw->fw_size = 8192U;
#line 3508
    if ((pvrusb2_debug & 32768) != 0) {
#line 3508
      printk("\016pvrusb2: Done sucking down EEPROM contents\n");
    } else {

    }
  }
  ldv_53577: 
#line 3512
  hdw->big_lock_held = 0;
#line 3512
  ldv_mutex_unlock_275(& hdw->big_lock_mutex);
#line 3513
  return;
}
}
#line 3517 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_cpufw_get_enabled(struct pvr2_hdw *hdw ) 
{ 


  {
#line 3519
  return ((unsigned long )hdw->fw_buffer != (unsigned long )((char *)0));
}
}
#line 3523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_cpufw_get(struct pvr2_hdw *hdw , unsigned int offs , char *buf , unsigned int cnt ) 
{ 
  int ret ;

  {
#line 3526
  ret = -22;
#line 3527
  ldv_mutex_lock_276(& hdw->big_lock_mutex);
#line 3527
  hdw->big_lock_held = 1;
#line 3528
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 3528
    goto ldv_53591;
  } else {

  }
#line 3529
  if (cnt == 0U) {
#line 3529
    goto ldv_53591;
  } else {

  }
#line 3531
  if ((unsigned long )hdw->fw_buffer == (unsigned long )((char *)0)) {
#line 3532
    ret = -5;
#line 3533
    goto ldv_53591;
  } else {

  }
#line 3536
  if (hdw->fw_size <= offs) {
#line 3537
    if ((pvrusb2_debug & 32768) != 0) {
#line 3537
      printk("\016pvrusb2: Read firmware data offs=%d EOF\n", offs);
    } else {

    }
#line 3540
    ret = 0;
#line 3541
    goto ldv_53591;
  } else {

  }
#line 3544
  if (offs + cnt > hdw->fw_size) {
#line 3544
    cnt = hdw->fw_size - offs;
  } else {

  }
#line 3546
  memcpy((void *)buf, (void const   *)hdw->fw_buffer + (unsigned long )offs, (size_t )cnt);
#line 3548
  if ((pvrusb2_debug & 32768) != 0) {
#line 3548
    printk("\016pvrusb2: Read firmware data offs=%d cnt=%d\n", offs, cnt);
  } else {

  }
#line 3551
  ret = (int )cnt;
  ldv_53591: 
#line 3552
  hdw->big_lock_held = 0;
#line 3552
  ldv_mutex_unlock_277(& hdw->big_lock_mutex);
#line 3554
  return (ret);
}
}
#line 3558 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_v4l_get_minor_number(struct pvr2_hdw *hdw , enum pvr2_v4l_type index ) 
{ 


  {
#line 3561
  switch ((unsigned int )index) {
  case 0U: ;
#line 3562
  return (hdw->v4l_minor_number_video);
  case 1U: ;
#line 3563
  return (hdw->v4l_minor_number_vbi);
  case 2U: ;
#line 3564
  return (hdw->v4l_minor_number_radio);
  default: ;
#line 3565
  return (-1);
  }
}
}
#line 3571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
void pvr2_hdw_v4l_store_minor_number(struct pvr2_hdw *hdw , enum pvr2_v4l_type index ,
                                     int v ) 
{ 


  {
#line 3574
  switch ((unsigned int )index) {
  case 0U: 
#line 3575
  hdw->v4l_minor_number_video = v;
#line 3575
  goto ldv_53606;
  case 1U: 
#line 3576
  hdw->v4l_minor_number_vbi = v;
#line 3576
  goto ldv_53606;
  case 2U: 
#line 3577
  hdw->v4l_minor_number_radio = v;
#line 3577
  goto ldv_53606;
  default: ;
#line 3578
  goto ldv_53606;
  }
  ldv_53606: ;
#line 3581
  return;
}
}
#line 3583 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_ctl_write_complete(struct urb *urb ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 3585
  hdw = (struct pvr2_hdw *)urb->context;
#line 3586
  hdw->ctl_write_pend_flag = 0;
#line 3587
  if (hdw->ctl_read_pend_flag != 0) {
#line 3587
    return;
  } else {

  }
#line 3588
  complete(& hdw->ctl_done);
#line 3589
  return;
}
}
#line 3592 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_ctl_read_complete(struct urb *urb ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 3594
  hdw = (struct pvr2_hdw *)urb->context;
#line 3595
  hdw->ctl_read_pend_flag = 0;
#line 3596
  if (hdw->ctl_write_pend_flag != 0) {
#line 3596
    return;
  } else {

  }
#line 3597
  complete(& hdw->ctl_done);
#line 3598
  return;
}
}
#line 3601 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_ctl_timeout(unsigned long data ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 3603
  hdw = (struct pvr2_hdw *)data;
#line 3604
  if (hdw->ctl_write_pend_flag != 0 || hdw->ctl_read_pend_flag != 0) {
#line 3605
    hdw->ctl_timeout_flag = 1;
#line 3606
    if (hdw->ctl_write_pend_flag != 0) {
#line 3607
      usb_unlink_urb(hdw->ctl_write_urb);
    } else {

    }
#line 3608
    if (hdw->ctl_read_pend_flag != 0) {
#line 3609
      usb_unlink_urb(hdw->ctl_read_urb);
    } else {

    }
  } else {

  }
#line 3611
  return;
}
}
#line 3618 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_send_request_ex(struct pvr2_hdw *hdw , unsigned int timeout , int probe_fl ,
                                void *write_data , unsigned int write_len , void *read_data ,
                                unsigned int read_len ) 
{ 
  unsigned int idx ;
  int status ;
  struct timer_list timer ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 3624
  status = 0;
#line 3626
  if (hdw->ctl_lock_held == 0) {
#line 3627
    if ((pvrusb2_debug & 2) != 0) {
#line 3627
      printk("\016pvrusb2: Attempted to execute control transfer without lock!!\n");
    } else {

    }
#line 3630
    return (-35);
  } else {

  }
#line 3632
  if (hdw->flag_ok == 0 && probe_fl == 0) {
#line 3633
    if ((pvrusb2_debug & 2) != 0) {
#line 3633
      printk("\016pvrusb2: Attempted to execute control transfer when device not ok\n");
    } else {

    }
#line 3636
    return (-5);
  } else {

  }
#line 3638
  if ((unsigned long )hdw->ctl_read_urb == (unsigned long )((struct urb *)0) || (unsigned long )hdw->ctl_write_urb == (unsigned long )((struct urb *)0)) {
#line 3639
    if (probe_fl == 0) {
#line 3640
      if ((pvrusb2_debug & 2) != 0) {
#line 3640
        printk("\016pvrusb2: Attempted to execute control transfer when USB is disconnected\n");
      } else {

      }
    } else {

    }
#line 3644
    return (-25);
  } else {

  }
#line 3648
  if ((unsigned long )write_data == (unsigned long )((void *)0)) {
#line 3648
    write_len = 0U;
  } else {

  }
#line 3649
  if ((unsigned long )read_data == (unsigned long )((void *)0)) {
#line 3649
    read_len = 0U;
  } else {

  }
#line 3650
  if (write_len > 64U) {
#line 3651
    if ((pvrusb2_debug & 2) != 0) {
#line 3651
      printk("\016pvrusb2: Attempted to execute %d byte control-write transfer (limit=%d)\n",
             write_len, 64);
    } else {

    }
#line 3656
    return (-22);
  } else {

  }
#line 3658
  if (read_len > 64U) {
#line 3659
    if ((pvrusb2_debug & 2) != 0) {
#line 3659
      printk("\016pvrusb2: Attempted to execute %d byte control-read transfer (limit=%d)\n",
             write_len, 64);
    } else {

    }
#line 3664
    return (-22);
  } else {

  }
#line 3666
  if (write_len == 0U && read_len == 0U) {
#line 3667
    if ((pvrusb2_debug & 2) != 0) {
#line 3667
      printk("\016pvrusb2: Attempted to execute null control transfer?\n");
    } else {

    }
#line 3670
    return (-22);
  } else {

  }
#line 3674
  hdw->cmd_debug_state = 1;
#line 3675
  if (write_len != 0U) {
#line 3676
    hdw->cmd_debug_code = *((unsigned char *)write_data);
  } else {
#line 3678
    hdw->cmd_debug_code = 0U;
  }
#line 3680
  hdw->cmd_debug_write_len = write_len;
#line 3681
  hdw->cmd_debug_read_len = read_len;
#line 3684
  init_completion(& hdw->ctl_done);
#line 3685
  hdw->ctl_timeout_flag = 0;
#line 3686
  hdw->ctl_write_pend_flag = 0;
#line 3687
  hdw->ctl_read_pend_flag = 0;
#line 3688
  reg_timer_2(& timer, & pvr2_ctl_timeout, (unsigned long )hdw);
#line 3689
  timer.expires = (unsigned long )timeout + (unsigned long )jiffies;
#line 3691
  if (write_len != 0U) {
#line 3692
    hdw->cmd_debug_state = 2;
#line 3694
    idx = 0U;
#line 3694
    goto ldv_53635;
    ldv_53634: 
#line 3695
    *(hdw->ctl_write_buffer + (unsigned long )idx) = *((unsigned char *)write_data + (unsigned long )idx);
#line 3694
    idx = idx + 1U;
    ldv_53635: ;
#line 3694
    if (idx < write_len) {
#line 3696
      goto ldv_53634;
    } else {

    }
#line 3699
    tmp = __create_pipe(hdw->usb_dev, 1U);
#line 3699
    usb_fill_bulk_urb(hdw->ctl_write_urb, hdw->usb_dev, tmp | 3221225472U, (void *)hdw->ctl_write_buffer,
                      (int )write_len, & pvr2_ctl_write_complete, (void *)hdw);
#line 3707
    (hdw->ctl_write_urb)->actual_length = 0U;
#line 3708
    hdw->ctl_write_pend_flag = 1;
#line 3709
    status = usb_submit_urb(hdw->ctl_write_urb, 208U);
#line 3710
    if (status < 0) {
#line 3711
      if ((pvrusb2_debug & 2) != 0) {
#line 3711
        printk("\016pvrusb2: Failed to submit write-control URB status=%d\n", status);
      } else {

      }
#line 3714
      hdw->ctl_write_pend_flag = 0;
#line 3715
      goto done;
    } else {

    }
  } else {

  }
#line 3719
  if (read_len != 0U) {
#line 3720
    hdw->cmd_debug_state = 3;
#line 3721
    memset((void *)hdw->ctl_read_buffer, 67, (size_t )read_len);
#line 3723
    tmp___0 = __create_pipe(hdw->usb_dev, 129U);
#line 3723
    usb_fill_bulk_urb(hdw->ctl_read_urb, hdw->usb_dev, tmp___0 | 3221225600U, (void *)hdw->ctl_read_buffer,
                      (int )read_len, & pvr2_ctl_read_complete, (void *)hdw);
#line 3731
    (hdw->ctl_read_urb)->actual_length = 0U;
#line 3732
    hdw->ctl_read_pend_flag = 1;
#line 3733
    status = usb_submit_urb(hdw->ctl_read_urb, 208U);
#line 3734
    if (status < 0) {
#line 3735
      if ((pvrusb2_debug & 2) != 0) {
#line 3735
        printk("\016pvrusb2: Failed to submit read-control URB status=%d\n", status);
      } else {

      }
#line 3738
      hdw->ctl_read_pend_flag = 0;
#line 3739
      goto done;
    } else {

    }
  } else {

  }
#line 3744
  add_timer(& timer);
#line 3747
  hdw->cmd_debug_state = 4;
#line 3748
  goto ldv_53639;
  ldv_53638: 
#line 3749
  wait_for_completion(& hdw->ctl_done);
  ldv_53639: ;
#line 3748
  if (hdw->ctl_write_pend_flag != 0 || hdw->ctl_read_pend_flag != 0) {
#line 3750
    goto ldv_53638;
  } else {

  }
#line 3751
  hdw->cmd_debug_state = 5;
#line 3754
  ldv_del_timer_sync_278(& timer);
#line 3756
  hdw->cmd_debug_state = 6;
#line 3757
  status = 0;
#line 3759
  if (hdw->ctl_timeout_flag != 0) {
#line 3760
    status = -110;
#line 3761
    if (probe_fl == 0) {
#line 3762
      if ((pvrusb2_debug & 2) != 0) {
#line 3762
        printk("\016pvrusb2: Timed out control-write\n");
      } else {

      }
    } else {

    }
#line 3765
    goto done;
  } else {

  }
#line 3768
  if (write_len != 0U) {
#line 3770
    if ((((hdw->ctl_write_urb)->status != 0 && (hdw->ctl_write_urb)->status != -2) && (hdw->ctl_write_urb)->status != -108) && (hdw->ctl_write_urb)->status != -104) {
#line 3776
      status = (hdw->ctl_write_urb)->status;
#line 3777
      if (probe_fl == 0) {
#line 3778
        if ((pvrusb2_debug & 2) != 0) {
#line 3778
          printk("\016pvrusb2: control-write URB failure, status=%d\n", status);
        } else {

        }
      } else {

      }
#line 3783
      goto done;
    } else {

    }
#line 3785
    if ((hdw->ctl_write_urb)->actual_length < write_len) {
#line 3787
      status = -5;
#line 3788
      if (probe_fl == 0) {
#line 3789
        if ((pvrusb2_debug & 2) != 0) {
#line 3789
          printk("\016pvrusb2: control-write URB short, expected=%d got=%d\n", write_len,
                 (hdw->ctl_write_urb)->actual_length);
        } else {

        }
      } else {

      }
#line 3795
      goto done;
    } else {

    }
  } else {

  }
#line 3798
  if (read_len != 0U) {
#line 3800
    if ((((hdw->ctl_read_urb)->status != 0 && (hdw->ctl_read_urb)->status != -2) && (hdw->ctl_read_urb)->status != -108) && (hdw->ctl_read_urb)->status != -104) {
#line 3806
      status = (hdw->ctl_read_urb)->status;
#line 3807
      if (probe_fl == 0) {
#line 3808
        if ((pvrusb2_debug & 2) != 0) {
#line 3808
          printk("\016pvrusb2: control-read URB failure, status=%d\n", status);
        } else {

        }
      } else {

      }
#line 3813
      goto done;
    } else {

    }
#line 3815
    if ((hdw->ctl_read_urb)->actual_length < read_len) {
#line 3817
      status = -5;
#line 3818
      if (probe_fl == 0) {
#line 3819
        if ((pvrusb2_debug & 2) != 0) {
#line 3819
          printk("\016pvrusb2: control-read URB short, expected=%d got=%d\n", read_len,
                 (hdw->ctl_read_urb)->actual_length);
        } else {

        }
      } else {

      }
#line 3825
      goto done;
    } else {

    }
#line 3828
    idx = 0U;
#line 3828
    goto ldv_53642;
    ldv_53641: 
#line 3829
    *((unsigned char *)read_data + (unsigned long )idx) = *(hdw->ctl_read_buffer + (unsigned long )idx);
#line 3828
    idx = idx + 1U;
    ldv_53642: ;
#line 3828
    if (idx < read_len) {
#line 3830
      goto ldv_53641;
    } else {

    }

  } else {

  }
  done: 
#line 3836
  hdw->cmd_debug_state = 0;
#line 3837
  if (status < 0 && probe_fl == 0) {
#line 3838
    pvr2_hdw_render_useless(hdw);
  } else {

  }
#line 3840
  return (status);
}
}
#line 3844 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_send_request(struct pvr2_hdw *hdw , void *write_data , unsigned int write_len ,
                      void *read_data , unsigned int read_len ) 
{ 
  int tmp ;

  {
#line 3848
  tmp = pvr2_send_request_ex(hdw, 1000U, 0, write_data, write_len, read_data, read_len);
#line 3848
  return (tmp);
}
}
#line 3854 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_issue_simple_cmd(struct pvr2_hdw *hdw , u32 cmdcode ) 
{ 
  int ret ;
  unsigned int cnt ;
  unsigned int args ;
  unsigned int idx ;
  unsigned int ccnt ;
  unsigned int bcnt ;
  char tbuf[50U] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 3857
  cnt = 1U;
#line 3858
  args = 0U;
#line 3859
  ldv_mutex_lock_279(& hdw->ctl_lock_mutex);
#line 3859
  hdw->ctl_lock_held = 1;
#line 3860
  hdw->cmd_buffer[0] = (unsigned char )cmdcode;
#line 3861
  args = (cmdcode >> 8) & 255U;
#line 3862
  args = 2U < args ? 2U : args;
#line 3863
  if (args != 0U) {
#line 3864
    cnt = cnt + args;
#line 3865
    hdw->cmd_buffer[1] = (unsigned char )(cmdcode >> 16);
#line 3866
    if (args > 1U) {
#line 3867
      hdw->cmd_buffer[2] = (unsigned char )(cmdcode >> 24);
    } else {

    }
  } else {

  }
#line 3870
  if ((pvrusb2_debug & 32) != 0) {
#line 3874
    cmdcode = cmdcode & 255U;
#line 3875
    bcnt = 0U;
#line 3876
    tmp = scnprintf((char *)(& tbuf) + (unsigned long )bcnt, 50UL - (unsigned long )bcnt,
                    "Sending FX2 command 0x%x", cmdcode);
#line 3876
    ccnt = (unsigned int )tmp;
#line 3879
    bcnt = bcnt + ccnt;
#line 3880
    idx = 0U;
#line 3880
    goto ldv_53666;
    ldv_53665: ;
#line 3881
    if ((u32 )pvr2_fx2cmd_desc[idx].id == cmdcode) {
#line 3882
      tmp___0 = scnprintf((char *)(& tbuf) + (unsigned long )bcnt, 50UL - (unsigned long )bcnt,
                          " \"%s\"", pvr2_fx2cmd_desc[idx].desc);
#line 3882
      ccnt = (unsigned int )tmp___0;
#line 3886
      bcnt = bcnt + ccnt;
#line 3887
      goto ldv_53664;
    } else {

    }
#line 3880
    idx = idx + 1U;
    ldv_53666: ;
#line 3880
    if (idx <= 24U) {
#line 3882
      goto ldv_53665;
    } else {

    }
    ldv_53664: ;
#line 3890
    if (args != 0U) {
#line 3891
      tmp___1 = scnprintf((char *)(& tbuf) + (unsigned long )bcnt, 50UL - (unsigned long )bcnt,
                          " (%u", (int )hdw->cmd_buffer[1]);
#line 3891
      ccnt = (unsigned int )tmp___1;
#line 3894
      bcnt = bcnt + ccnt;
#line 3895
      if (args > 1U) {
#line 3896
        tmp___2 = scnprintf((char *)(& tbuf) + (unsigned long )bcnt, 50UL - (unsigned long )bcnt,
                            ",%u", (int )hdw->cmd_buffer[2]);
#line 3896
        ccnt = (unsigned int )tmp___2;
#line 3899
        bcnt = bcnt + ccnt;
      } else {

      }
#line 3901
      tmp___3 = scnprintf((char *)(& tbuf) + (unsigned long )bcnt, 50UL - (unsigned long )bcnt,
                          ")");
#line 3901
      ccnt = (unsigned int )tmp___3;
#line 3904
      bcnt = bcnt + ccnt;
    } else {

    }
#line 3906
    if ((pvrusb2_debug & 32) != 0) {
#line 3906
      printk("\016pvrusb2: %.*s\n", bcnt, (char *)(& tbuf));
    } else {

    }
  } else {

  }
#line 3908
  ret = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), cnt, (void *)0, 0U);
#line 3909
  hdw->ctl_lock_held = 0;
#line 3909
  ldv_mutex_unlock_280(& hdw->ctl_lock_mutex);
#line 3910
  return (ret);
}
}
#line 3914 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_write_register(struct pvr2_hdw *hdw , u16 reg , u32 data ) 
{ 
  int ret ;

  {
#line 3918
  ldv_mutex_lock_281(& hdw->ctl_lock_mutex);
#line 3918
  hdw->ctl_lock_held = 1;
#line 3920
  hdw->cmd_buffer[0] = 4U;
#line 3921
  hdw->cmd_buffer[1] = (unsigned char )data;
#line 3921
  hdw->cmd_buffer[2] = (unsigned char )(data >> 8);
#line 3921
  hdw->cmd_buffer[3] = (unsigned char )(data >> 16);
#line 3921
  hdw->cmd_buffer[4] = (unsigned char )(data >> 24);
#line 3922
  hdw->cmd_buffer[5] = 0U;
#line 3923
  hdw->cmd_buffer[6] = (unsigned char )((int )reg >> 8);
#line 3924
  hdw->cmd_buffer[7] = (unsigned char )reg;
#line 3927
  ret = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), 8U, (void *)(& hdw->cmd_buffer),
                          0U);
#line 3929
  hdw->ctl_lock_held = 0;
#line 3929
  ldv_mutex_unlock_282(& hdw->ctl_lock_mutex);
#line 3931
  return (ret);
}
}
#line 3935 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_read_register(struct pvr2_hdw *hdw , u16 reg , u32 *data ) 
{ 
  int ret ;
  int tmp ;

  {
#line 3937
  ret = 0;
#line 3939
  ldv_mutex_lock_283(& hdw->ctl_lock_mutex);
#line 3939
  hdw->ctl_lock_held = 1;
#line 3941
  hdw->cmd_buffer[0] = 5U;
#line 3942
  hdw->cmd_buffer[1] = 0U;
#line 3943
  hdw->cmd_buffer[2] = 0U;
#line 3944
  hdw->cmd_buffer[3] = 0U;
#line 3945
  hdw->cmd_buffer[4] = 0U;
#line 3946
  hdw->cmd_buffer[5] = 0U;
#line 3947
  hdw->cmd_buffer[6] = (unsigned char )((int )reg >> 8);
#line 3948
  hdw->cmd_buffer[7] = (unsigned char )reg;
#line 3950
  tmp = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), 8U, (void *)(& hdw->cmd_buffer),
                          4U);
#line 3950
  ret = tmp | ret;
#line 3951
  *data = ((((unsigned int )hdw->cmd_buffer[3] << 24) | ((unsigned int )hdw->cmd_buffer[2] << 16)) | ((unsigned int )hdw->cmd_buffer[1] << 8)) | (unsigned int )hdw->cmd_buffer[0];
#line 3953
  hdw->ctl_lock_held = 0;
#line 3953
  ldv_mutex_unlock_284(& hdw->ctl_lock_mutex);
#line 3955
  return (ret);
}
}
#line 3959 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
void pvr2_hdw_render_useless(struct pvr2_hdw *hdw ) 
{ 


  {
#line 3961
  if (hdw->flag_ok == 0) {
#line 3961
    return;
  } else {

  }
#line 3962
  if ((pvrusb2_debug & 2) != 0) {
#line 3962
    printk("\016pvrusb2: Device being rendered inoperable\n");
  } else {

  }
#line 3964
  if ((unsigned long )hdw->vid_stream != (unsigned long )((struct pvr2_stream *)0)) {
#line 3965
    pvr2_stream_setup(hdw->vid_stream, (struct usb_device *)0, 0, 0U);
  } else {

  }
#line 3967
  hdw->flag_ok = 0;
#line 3968
  trace_stbit("flag_ok", hdw->flag_ok);
#line 3969
  pvr2_hdw_state_sched(hdw);
#line 3970
  return;
}
}
#line 3973 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
void pvr2_hdw_device_reset(struct pvr2_hdw *hdw ) 
{ 
  int ret ;

  {
#line 3976
  if ((pvrusb2_debug & 32) != 0) {
#line 3976
    printk("\016pvrusb2: Performing a device reset...\n");
  } else {

  }
#line 3977
  ret = ldv_usb_lock_device_for_reset_285(hdw->usb_dev, (struct usb_interface  const  *)0);
#line 3978
  if (ret == 0) {
#line 3979
    ret = usb_reset_device(hdw->usb_dev);
#line 3980
    ldv___ldv_usb_unlock_device_286(hdw->usb_dev);
  } else
#line 3982
  if ((pvrusb2_debug & 2) != 0) {
#line 3982
    printk("\016pvrusb2: Failed to lock USB device ret=%d\n", ret);
  } else {

  }
#line 3985
  if (init_pause_msec != 0) {
#line 3986
    if (pvrusb2_debug & 1) {
#line 3986
      printk("\016pvrusb2: Waiting %u msec for hardware to settle\n", init_pause_msec);
    } else {

    }
#line 3989
    msleep((unsigned int )init_pause_msec);
  } else {

  }
#line 3991
  return;
}
}
#line 3995 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
void pvr2_hdw_cpureset_assert(struct pvr2_hdw *hdw , int val ) 
{ 
  char *da ;
  unsigned int pipe ;
  int ret ;
  void *tmp ;
  unsigned int tmp___0 ;

  {
#line 4001
  if ((unsigned long )hdw->usb_dev == (unsigned long )((struct usb_device *)0)) {
#line 4001
    return;
  } else {

  }
#line 4003
  tmp = kmalloc(16UL, 208U);
#line 4003
  da = (char *)tmp;
#line 4005
  if ((unsigned long )da == (unsigned long )((char *)0)) {
#line 4006
    if ((pvrusb2_debug & 2) != 0) {
#line 4006
      printk("\016pvrusb2: Unable to allocate memory to control CPU reset\n");
    } else {

    }
#line 4008
    return;
  } else {

  }
#line 4011
  if ((pvrusb2_debug & 32) != 0) {
#line 4011
    printk("\016pvrusb2: cpureset_assert(%d)\n", val);
  } else {

  }
#line 4013
  *da = val != 0;
#line 4017
  tmp___0 = __create_pipe(hdw->usb_dev, 0U);
#line 4017
  pipe = tmp___0 | 2147483648U;
#line 4018
  ret = usb_control_msg(hdw->usb_dev, pipe, 160, 64, 58880, 0, (void *)da, 1, 250);
#line 4019
  if (ret < 0) {
#line 4020
    if ((pvrusb2_debug & 2) != 0) {
#line 4020
      printk("\016pvrusb2: cpureset_assert(%d) error=%d\n", val, ret);
    } else {

    }
#line 4022
    pvr2_hdw_render_useless(hdw);
  } else {

  }
#line 4025
  kfree((void const   *)da);
#line 4026
  return;
}
}
#line 4029 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_cmd_deep_reset(struct pvr2_hdw *hdw ) 
{ 
  int tmp ;

  {
#line 4031
  tmp = pvr2_issue_simple_cmd(hdw, 221U);
#line 4031
  return (tmp);
}
}
#line 4035 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_cmd_powerup(struct pvr2_hdw *hdw ) 
{ 
  int tmp ;

  {
#line 4037
  tmp = pvr2_issue_simple_cmd(hdw, 222U);
#line 4037
  return (tmp);
}
}
#line 4042 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_cmd_decoder_reset(struct pvr2_hdw *hdw ) 
{ 
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 4044
  if ((pvrusb2_debug & 32) != 0) {
#line 4044
    printk("\016pvrusb2: Requesting decoder reset\n");
  } else {

  }
#line 4046
  if (hdw->decoder_client_id != 0U) {
#line 4047
    __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 4047
    __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 4047
    goto ldv_53708;
    ldv_53707: ;
#line 4047
    if (((hdw->decoder_client_id == 0U || __sd->grp_id == hdw->decoder_client_id) && (unsigned long )(__sd->ops)->core != (unsigned long )((struct v4l2_subdev_core_ops  const  */* const  */)0)) && (unsigned long )((__sd->ops)->core)->reset != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                                                                                                         u32  ))0)) {
#line 4047
      (*(((__sd->ops)->core)->reset))(__sd, 0U);
    } else {

    }
#line 4047
    __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 4047
    __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
    ldv_53708: ;
#line 4047
    if ((unsigned long )(& __sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 4049
      goto ldv_53707;
    } else {

    }
#line 4049
    pvr2_hdw_cx25840_vbi_hack(hdw);
#line 4050
    return (0);
  } else {

  }
#line 4052
  if ((pvrusb2_debug & 32) != 0) {
#line 4052
    printk("\016pvrusb2: Unable to reset decoder: nothing attached\n");
  } else {

  }
#line 4054
  return (-25);
}
}
#line 4058 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_hdw_cmd_hcw_demod_reset(struct pvr2_hdw *hdw , int onoff ) 
{ 
  int tmp ;

  {
#line 4060
  hdw->flag_ok = 1;
#line 4061
  tmp = pvr2_issue_simple_cmd(hdw, onoff != 0 ? 66032U : 496U);
#line 4061
  return (tmp);
}
}
#line 4068 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_hdw_cmd_onair_fe_power_ctrl(struct pvr2_hdw *hdw , int onoff ) 
{ 
  int tmp ;

  {
#line 4070
  hdw->flag_ok = 1;
#line 4071
  tmp = pvr2_issue_simple_cmd(hdw, onoff != 0 ? 162U : 163U);
#line 4071
  return (tmp);
}
}
#line 4077 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_hdw_cmd_onair_digital_path_ctrl(struct pvr2_hdw *hdw , int onoff ) 
{ 
  int tmp ;

  {
#line 4080
  tmp = pvr2_issue_simple_cmd(hdw, onoff != 0 ? 160U : 161U);
#line 4080
  return (tmp);
}
}
#line 4086 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_hdw_cmd_modeswitch(struct pvr2_hdw *hdw , int digitalFl ) 
{ 
  int cmode ;

  {
#line 4091
  cmode = digitalFl != 0 ? 2 : 1;
#line 4092
  if (hdw->pathway_state == cmode) {
#line 4094
    return;
  } else {

  }
#line 4097
  switch ((int )(hdw->hdw_desc)->digital_control_scheme) {
  case 1: 
#line 4099
  pvr2_hdw_cmd_hcw_demod_reset(hdw, digitalFl);
#line 4100
  if (cmode == 1) {
#line 4105
    pvr2_hdw_cmd_decoder_reset(hdw);
  } else {

  }
#line 4107
  goto ldv_53728;
  case 2: 
#line 4112
  pvr2_hdw_cmd_onair_fe_power_ctrl(hdw, digitalFl);
#line 4113
  goto ldv_53728;
  default: ;
#line 4114
  goto ldv_53728;
  }
  ldv_53728: 
#line 4117
  pvr2_hdw_untrip_unlocked(hdw);
#line 4118
  hdw->pathway_state = cmode;
#line 4119
  return;
}
}
#line 4122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_led_ctrl_hauppauge(struct pvr2_hdw *hdw , int onoff ) 
{ 


  {
#line 4130
  if (onoff != 0) {
#line 4131
    pvr2_hdw_gpio_chg_dir(hdw, 4294967295U, 1153U);
  } else {
#line 4133
    pvr2_hdw_gpio_chg_dir(hdw, 4294967295U, 1025U);
  }
#line 4135
  pvr2_hdw_gpio_chg_out(hdw, 4294967295U, 0U);
#line 4136
  return;
}
}
#line 4141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static led_method_func led_methods[2U]  = {      0,      & pvr2_led_ctrl_hauppauge};
#line 4147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_led_ctrl(struct pvr2_hdw *hdw , int onoff ) 
{ 
  unsigned int scheme_id ;
  void (*fp)(struct pvr2_hdw * , int  ) ;

  {
#line 4152
  if ((onoff != 0) ^ (hdw->led_on == 0)) {
#line 4152
    return;
  } else {

  }
#line 4154
  hdw->led_on = onoff != 0;
#line 4156
  scheme_id = (unsigned int )(hdw->hdw_desc)->led_scheme;
#line 4157
  if (scheme_id <= 1U) {
#line 4158
    fp = led_methods[scheme_id];
  } else {
#line 4160
    fp = (void (*)(struct pvr2_hdw * , int  ))0;
  }
#line 4163
  if ((unsigned long )fp != (unsigned long )((void (*)(struct pvr2_hdw * , int  ))0)) {
#line 4163
    (*fp)(hdw, onoff);
  } else {

  }
#line 4164
  return;
}
}
#line 4168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_hdw_cmd_usbstream(struct pvr2_hdw *hdw , int runFl ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4174
  if (hdw->pathway_state == 1) {
#line 4175
    tmp = pvr2_issue_simple_cmd(hdw, runFl != 0 ? 54U : 55U);
#line 4175
    return (tmp);
  } else {

  }
#line 4182
  if (hdw->pathway_state != 2) {
#line 4184
    return (-22);
  } else {

  }
#line 4191
  switch ((int )(hdw->hdw_desc)->digital_control_scheme) {
  case 1: 
#line 4193
  tmp___0 = pvr2_issue_simple_cmd(hdw, runFl != 0 ? 241U : 242U);
#line 4193
  return (tmp___0);
  case 2: 
#line 4198
  ret = pvr2_issue_simple_cmd(hdw, runFl != 0 ? 54U : 55U);
#line 4202
  if (ret != 0) {
#line 4202
    return (ret);
  } else {

  }
#line 4203
  tmp___1 = pvr2_hdw_cmd_onair_digital_path_ctrl(hdw, runFl);
#line 4203
  return (tmp___1);
  default: ;
#line 4205
  return (-22);
  }
}
}
#line 4211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int state_eval_pathway_ok(struct pvr2_hdw *hdw ) 
{ 


  {
#line 4213
  if (hdw->state_pathway_ok != 0) {
#line 4215
    return (0);
  } else {

  }
#line 4217
  if (hdw->state_pipeline_idle == 0) {
#line 4219
    return (0);
  } else {

  }
#line 4221
  pvr2_hdw_cmd_modeswitch(hdw, hdw->input_val == 1);
#line 4222
  hdw->state_pathway_ok = 1;
#line 4223
  trace_stbit("state_pathway_ok", hdw->state_pathway_ok);
#line 4224
  return (1);
}
}
#line 4229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int state_eval_encoder_ok(struct pvr2_hdw *hdw ) 
{ 
  int tmp ;

  {
#line 4231
  if (hdw->state_encoder_ok != 0) {
#line 4231
    return (0);
  } else {

  }
#line 4232
  if (hdw->flag_tripped != 0) {
#line 4232
    return (0);
  } else {

  }
#line 4233
  if (hdw->state_encoder_run != 0) {
#line 4233
    return (0);
  } else {

  }
#line 4234
  if (hdw->state_encoder_config != 0) {
#line 4234
    return (0);
  } else {

  }
#line 4235
  if (hdw->state_decoder_run != 0) {
#line 4235
    return (0);
  } else {

  }
#line 4236
  if (hdw->state_usbstream_run != 0) {
#line 4236
    return (0);
  } else {

  }
#line 4237
  if (hdw->pathway_state == 2) {
#line 4238
    if ((unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) == 0U) {
#line 4238
      return (0);
    } else {

    }
  } else
#line 4239
  if (hdw->pathway_state != 1) {
#line 4240
    return (0);
  } else {

  }
#line 4243
  tmp = pvr2_upload_firmware2(hdw);
#line 4243
  if (tmp < 0) {
#line 4244
    hdw->flag_tripped = 1;
#line 4245
    trace_stbit("flag_tripped", hdw->flag_tripped);
#line 4246
    return (1);
  } else {

  }
#line 4248
  hdw->state_encoder_ok = 1;
#line 4249
  trace_stbit("state_encoder_ok", hdw->state_encoder_ok);
#line 4250
  return (1);
}
}
#line 4255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int state_eval_encoder_config(struct pvr2_hdw *hdw ) 
{ 
  int tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 4257
  if (hdw->state_encoder_config != 0) {
#line 4258
    if (hdw->state_encoder_ok != 0) {
#line 4259
      if (hdw->state_pipeline_req != 0 && hdw->state_pipeline_pause == 0) {
#line 4260
        return (0);
      } else {

      }
    } else {

    }
#line 4262
    hdw->state_encoder_config = 0;
#line 4263
    hdw->state_encoder_waitok = 0;
#line 4264
    trace_stbit("state_encoder_waitok", hdw->state_encoder_waitok);
#line 4266
    ldv_del_timer_sync_287(& hdw->encoder_wait_timer);
  } else {
#line 4268
    if ((((((hdw->state_pathway_ok == 0 || hdw->pathway_state != 1) || hdw->state_encoder_ok == 0) || hdw->state_pipeline_idle == 0) || hdw->state_pipeline_pause != 0) || hdw->state_pipeline_req == 0) || hdw->state_pipeline_config == 0) {
#line 4278
      tmp = timer_pending((struct timer_list  const  *)(& hdw->encoder_wait_timer));
#line 4278
      if (tmp != 0) {
#line 4279
        ldv_del_timer_sync_288(& hdw->encoder_wait_timer);
      } else {

      }
#line 4281
      if (hdw->state_encoder_waitok != 0) {
#line 4285
        hdw->state_encoder_waitok = 0;
#line 4286
        trace_stbit("state_encoder_waitok", hdw->state_encoder_waitok);
#line 4288
        return (1);
      } else {

      }
#line 4290
      return (0);
    } else {

    }
#line 4292
    if (hdw->state_encoder_waitok == 0) {
#line 4293
      tmp___1 = timer_pending((struct timer_list  const  *)(& hdw->encoder_wait_timer));
#line 4293
      if (tmp___1 == 0) {
#line 4300
        if (hdw->state_encoder_waitok == 0) {
#line 4301
          tmp___0 = msecs_to_jiffies(50U);
#line 4301
          hdw->encoder_wait_timer.expires = tmp___0 + (unsigned long )jiffies;
#line 4304
          add_timer(& hdw->encoder_wait_timer);
        } else {

        }
      } else {

      }
#line 4310
      return (0);
    } else {

    }
#line 4312
    pvr2_encoder_configure(hdw);
#line 4313
    if (hdw->state_encoder_ok != 0) {
#line 4313
      hdw->state_encoder_config = 1;
    } else {

    }
  }
#line 4315
  trace_stbit("state_encoder_config", hdw->state_encoder_config);
#line 4316
  return (1);
}
}
#line 4321 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int state_check_disable_encoder_run(struct pvr2_hdw *hdw ) 
{ 


  {
#line 4323
  if (hdw->state_encoder_ok == 0) {
#line 4325
    return (1);
  } else {

  }
#line 4327
  if (hdw->state_pathway_ok == 0) {
#line 4330
    return (1);
  } else {

  }
#line 4333
  switch (hdw->pathway_state) {
  case 1: ;
#line 4335
  if (hdw->state_decoder_run == 0) {
#line 4339
    return (1);
  } else {

  }
#line 4341
  goto ldv_53768;
  case 2: ;
#line 4343
  if (hdw->state_encoder_runok != 0) {
#line 4351
    return (1);
  } else {

  }
#line 4353
  goto ldv_53768;
  default: ;
#line 4356
  return (1);
  }
  ldv_53768: ;
#line 4361
  return (0);
}
}
#line 4366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int state_check_enable_encoder_run(struct pvr2_hdw *hdw ) 
{ 


  {
#line 4368
  if (hdw->state_encoder_ok == 0) {
#line 4370
    return (0);
  } else {

  }
#line 4372
  if (hdw->state_pathway_ok == 0) {
#line 4375
    return (0);
  } else {

  }
#line 4378
  switch (hdw->pathway_state) {
  case 1: ;
#line 4380
  if (hdw->state_decoder_run != 0 && hdw->state_decoder_ready != 0) {
#line 4383
    return (1);
  } else {

  }
#line 4385
  goto ldv_53775;
  case 2: ;
#line 4387
  if ((unsigned int )((unsigned char )(hdw->hdw_desc)->digital_control_scheme) == 2U && hdw->state_encoder_runok == 0) {
#line 4398
    return (1);
  } else {

  }
#line 4400
  goto ldv_53775;
  default: ;
#line 4403
  goto ldv_53775;
  }
  ldv_53775: ;
#line 4407
  return (0);
}
}
#line 4412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int state_eval_encoder_run(struct pvr2_hdw *hdw ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 4414
  if (hdw->state_encoder_run != 0) {
#line 4415
    tmp = state_check_disable_encoder_run(hdw);
#line 4415
    if (tmp == 0) {
#line 4415
      return (0);
    } else {

    }
#line 4416
    if (hdw->state_encoder_ok != 0) {
#line 4417
      ldv_del_timer_sync_289(& hdw->encoder_run_timer);
#line 4418
      tmp___0 = pvr2_encoder_stop(hdw);
#line 4418
      if (tmp___0 < 0) {
#line 4418
        return (1);
      } else {

      }
    } else {

    }
#line 4420
    hdw->state_encoder_run = 0;
  } else {
#line 4422
    tmp___1 = state_check_enable_encoder_run(hdw);
#line 4422
    if (tmp___1 == 0) {
#line 4422
      return (0);
    } else {

    }
#line 4423
    tmp___2 = pvr2_encoder_start(hdw);
#line 4423
    if (tmp___2 < 0) {
#line 4423
      return (1);
    } else {

    }
#line 4424
    hdw->state_encoder_run = 1;
#line 4425
    if (hdw->state_encoder_runok == 0) {
#line 4426
      tmp___3 = msecs_to_jiffies(250U);
#line 4426
      hdw->encoder_run_timer.expires = tmp___3 + (unsigned long )jiffies;
#line 4428
      add_timer(& hdw->encoder_run_timer);
    } else {

    }
  }
#line 4431
  trace_stbit("state_encoder_run", hdw->state_encoder_run);
#line 4432
  return (1);
}
}
#line 4437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_hdw_quiescent_timeout(unsigned long data ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 4439
  hdw = (struct pvr2_hdw *)data;
#line 4440
  hdw->state_decoder_quiescent = 1;
#line 4441
  trace_stbit("state_decoder_quiescent", hdw->state_decoder_quiescent);
#line 4442
  hdw->state_stale = 1;
#line 4443
  queue_work(hdw->workqueue, & hdw->workpoll);
#line 4444
  return;
}
}
#line 4448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_hdw_decoder_stabilization_timeout(unsigned long data ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 4450
  hdw = (struct pvr2_hdw *)data;
#line 4451
  hdw->state_decoder_ready = 1;
#line 4452
  trace_stbit("state_decoder_ready", hdw->state_decoder_ready);
#line 4453
  hdw->state_stale = 1;
#line 4454
  queue_work(hdw->workqueue, & hdw->workpoll);
#line 4455
  return;
}
}
#line 4459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_hdw_encoder_wait_timeout(unsigned long data ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 4461
  hdw = (struct pvr2_hdw *)data;
#line 4462
  hdw->state_encoder_waitok = 1;
#line 4463
  trace_stbit("state_encoder_waitok", hdw->state_encoder_waitok);
#line 4464
  hdw->state_stale = 1;
#line 4465
  queue_work(hdw->workqueue, & hdw->workpoll);
#line 4466
  return;
}
}
#line 4470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_hdw_encoder_run_timeout(unsigned long data ) 
{ 
  struct pvr2_hdw *hdw ;

  {
#line 4472
  hdw = (struct pvr2_hdw *)data;
#line 4473
  if (hdw->state_encoder_runok == 0) {
#line 4474
    hdw->state_encoder_runok = 1;
#line 4475
    trace_stbit("state_encoder_runok", hdw->state_encoder_runok);
#line 4476
    hdw->state_stale = 1;
#line 4477
    queue_work(hdw->workqueue, & hdw->workpoll);
  } else {

  }
#line 4479
  return;
}
}
#line 4483 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int state_eval_decoder_run(struct pvr2_hdw *hdw ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 4485
  if (hdw->state_decoder_run != 0) {
#line 4486
    if (hdw->state_encoder_ok != 0) {
#line 4487
      if ((hdw->state_pipeline_req != 0 && hdw->state_pipeline_pause == 0) && hdw->state_pathway_ok != 0) {
#line 4489
        return (0);
      } else {

      }
    } else {

    }
#line 4491
    if (hdw->flag_decoder_missed == 0) {
#line 4492
      pvr2_decoder_enable(hdw, 0);
    } else {

    }
#line 4494
    hdw->state_decoder_quiescent = 0;
#line 4495
    hdw->state_decoder_run = 0;
#line 4497
    ldv_del_timer_sync_290(& hdw->quiescent_timer);
#line 4501
    ldv_del_timer_sync_291(& hdw->decoder_stabilization_timer);
#line 4502
    hdw->state_decoder_ready = 0;
  } else {
#line 4504
    if (hdw->state_decoder_quiescent == 0) {
#line 4505
      tmp___0 = timer_pending((struct timer_list  const  *)(& hdw->quiescent_timer));
#line 4505
      if (tmp___0 == 0) {
#line 4516
        if (hdw->state_decoder_quiescent == 0) {
#line 4517
          tmp = msecs_to_jiffies(50U);
#line 4517
          hdw->quiescent_timer.expires = tmp + (unsigned long )jiffies;
#line 4520
          add_timer(& hdw->quiescent_timer);
        } else {

        }
      } else {

      }
#line 4526
      return (0);
    } else {

    }
#line 4528
    if ((((((hdw->state_pathway_ok == 0 || hdw->pathway_state != 1) || hdw->state_pipeline_req == 0) || hdw->state_pipeline_pause != 0) || hdw->state_pipeline_config == 0) || hdw->state_encoder_config == 0) || hdw->state_encoder_ok == 0) {
#line 4534
      return (0);
    } else {

    }
#line 4535
    ldv_del_timer_sync_292(& hdw->quiescent_timer);
#line 4536
    if (hdw->flag_decoder_missed != 0) {
#line 4536
      return (0);
    } else {

    }
#line 4537
    tmp___1 = pvr2_decoder_enable(hdw, 1);
#line 4537
    if (tmp___1 < 0) {
#line 4537
      return (0);
    } else {

    }
#line 4538
    hdw->state_decoder_quiescent = 0;
#line 4539
    hdw->state_decoder_ready = 0;
#line 4540
    hdw->state_decoder_run = 1;
#line 4541
    if (hdw->decoder_client_id == 3U) {
#line 4542
      tmp___2 = msecs_to_jiffies(300U);
#line 4542
      hdw->decoder_stabilization_timer.expires = tmp___2 + (unsigned long )jiffies;
#line 4545
      add_timer(& hdw->decoder_stabilization_timer);
    } else {
#line 4547
      hdw->state_decoder_ready = 1;
    }
  }
#line 4550
  trace_stbit("state_decoder_quiescent", hdw->state_decoder_quiescent);
#line 4551
  trace_stbit("state_decoder_run", hdw->state_decoder_run);
#line 4552
  trace_stbit("state_decoder_ready", hdw->state_decoder_ready);
#line 4553
  return (1);
}
}
#line 4558 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int state_eval_usbstream_run(struct pvr2_hdw *hdw ) 
{ 
  int fl ;
  int tmp ;

  {
#line 4560
  if (hdw->state_usbstream_run != 0) {
#line 4561
    fl = 1;
#line 4562
    if (hdw->pathway_state == 1) {
#line 4563
      fl = hdw->state_encoder_ok != 0 && hdw->state_encoder_run != 0;
    } else
#line 4565
    if (hdw->pathway_state == 2 && (unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) != 0U) {
#line 4567
      fl = hdw->state_encoder_ok;
    } else {

    }
#line 4569
    if (((fl != 0 && hdw->state_pipeline_req != 0) && hdw->state_pipeline_pause == 0) && hdw->state_pathway_ok != 0) {
#line 4573
      return (0);
    } else {

    }
#line 4575
    pvr2_hdw_cmd_usbstream(hdw, 0);
#line 4576
    hdw->state_usbstream_run = 0;
  } else {
#line 4578
    if ((hdw->state_pipeline_req == 0 || hdw->state_pipeline_pause != 0) || hdw->state_pathway_ok == 0) {
#line 4580
      return (0);
    } else {

    }
#line 4581
    if (hdw->pathway_state == 1) {
#line 4582
      if (hdw->state_encoder_ok == 0 || hdw->state_encoder_run == 0) {
#line 4583
        return (0);
      } else {

      }
    } else
#line 4584
    if (hdw->pathway_state == 2 && (unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) != 0U) {
#line 4586
      if (hdw->state_encoder_ok == 0) {
#line 4586
        return (0);
      } else {

      }
#line 4587
      if (hdw->state_encoder_run != 0) {
#line 4587
        return (0);
      } else {

      }
#line 4588
      if ((unsigned int )((unsigned char )(hdw->hdw_desc)->digital_control_scheme) == 2U) {
#line 4595
        if (hdw->state_encoder_runok == 0) {
#line 4595
          return (0);
        } else {

        }
      } else {

      }
    } else {

    }
#line 4598
    tmp = pvr2_hdw_cmd_usbstream(hdw, 1);
#line 4598
    if (tmp < 0) {
#line 4598
      return (0);
    } else {

    }
#line 4599
    hdw->state_usbstream_run = 1;
  }
#line 4601
  trace_stbit("state_usbstream_run", hdw->state_usbstream_run);
#line 4602
  return (1);
}
}
#line 4607 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int state_eval_pipeline_config(struct pvr2_hdw *hdw ) 
{ 


  {
#line 4609
  if (hdw->state_pipeline_config != 0 || hdw->state_pipeline_pause != 0) {
#line 4610
    return (0);
  } else {

  }
#line 4611
  pvr2_hdw_commit_execute(hdw);
#line 4612
  return (1);
}
}
#line 4619 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int state_update_pipeline_state(struct pvr2_hdw *hdw ) 
{ 
  unsigned int st ;
  int updatedFl ;

  {
#line 4622
  updatedFl = 0;
#line 4624
  st = (unsigned int )(((hdw->state_encoder_run == 0 && hdw->state_decoder_run == 0) && hdw->state_usbstream_run == 0) && hdw->state_decoder_quiescent != 0);
#line 4628
  if ((st == 0U) ^ (hdw->state_pipeline_idle == 0)) {
#line 4629
    hdw->state_pipeline_idle = (int )st;
#line 4630
    updatedFl = 1;
  } else {

  }
#line 4632
  if (hdw->state_pipeline_idle != 0 && hdw->state_pipeline_pause != 0) {
#line 4633
    hdw->state_pipeline_pause = 0;
#line 4634
    updatedFl = 1;
  } else {

  }
#line 4636
  return (updatedFl);
}
}
#line 4643 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static state_eval_func eval_funcs[7U]  = {      & state_eval_pathway_ok,      & state_eval_pipeline_config,      & state_eval_encoder_ok,      & state_eval_encoder_config, 
        & state_eval_decoder_run,      & state_eval_encoder_run,      & state_eval_usbstream_run};
#line 4655 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_hdw_state_update(struct pvr2_hdw *hdw ) 
{ 
  unsigned int i ;
  int state_updated ;
  int check_flag ;
  int tmp ;

  {
#line 4658
  state_updated = 0;
#line 4661
  if (hdw->state_stale == 0) {
#line 4661
    return (0);
  } else {

  }
#line 4662
  if (hdw->fw1_state != 4 || hdw->flag_ok == 0) {
#line 4664
    hdw->state_stale = 0;
#line 4665
    return (1);
  } else {

  }
  ldv_53826: 
#line 4675
  check_flag = 0;
#line 4676
  state_update_pipeline_state(hdw);
#line 4678
  i = 0U;
#line 4678
  goto ldv_53824;
  ldv_53823: 
#line 4679
  tmp = (*(eval_funcs[i]))(hdw);
#line 4679
  if (tmp != 0) {
#line 4680
    check_flag = 1;
#line 4681
    state_updated = 1;
#line 4682
    state_update_pipeline_state(hdw);
  } else {

  }
#line 4678
  i = i + 1U;
  ldv_53824: ;
#line 4678
  if (i <= 6U && hdw->flag_ok != 0) {
#line 4680
    goto ldv_53823;
  } else {

  }

#line 4685
  if (check_flag != 0 && hdw->flag_ok != 0) {
#line 4687
    goto ldv_53826;
  } else {

  }
#line 4686
  hdw->state_stale = 0;
#line 4687
  trace_stbit("state_stale", hdw->state_stale);
#line 4688
  return (state_updated);
}
}
#line 4692 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static unsigned int print_input_mask(unsigned int msk , char *buf , unsigned int acnt ) 
{ 
  unsigned int idx ;
  unsigned int ccnt ;
  unsigned int tcnt ;
  int tmp ;

  {
#line 4696
  tcnt = 0U;
#line 4697
  idx = 0U;
#line 4697
  goto ldv_53840;
  ldv_53839: ;
#line 4698
  if (((unsigned int )(1 << (int )idx) & msk) == 0U) {
#line 4698
    goto ldv_53838;
  } else {

  }
#line 4699
  tmp = scnprintf(buf + (unsigned long )tcnt, (size_t )(acnt - tcnt), "%s%s", tcnt != 0U ? (char *)", " : (char *)"",
                  control_values_input[idx]);
#line 4699
  ccnt = (unsigned int )tmp;
#line 4704
  tcnt = tcnt + ccnt;
  ldv_53838: 
#line 4697
  idx = idx + 1U;
  ldv_53840: ;
#line 4697
  if (idx <= 4U) {
#line 4699
    goto ldv_53839;
  } else {

  }

#line 4706
  return (tcnt);
}
}
#line 4710 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static char const   *pvr2_pathway_state_name(int id ) 
{ 


  {
#line 4712
  switch (id) {
  case 1: ;
#line 4713
  return ("analog");
  case 2: ;
#line 4714
  return ("digital");
  default: ;
#line 4715
  return ("unknown");
  }
}
}
#line 4720 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static unsigned int pvr2_hdw_report_unlocked(struct pvr2_hdw *hdw , int which , char *buf ,
                                             unsigned int acnt ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  unsigned int tcnt ;
  unsigned int ccnt ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  struct pvr2_stream_stats stats ;
  int tmp___9 ;
  unsigned int id ;
  int tmp___10 ;

  {
#line 4723
  switch (which) {
  case 0: 
#line 4725
  tmp = pvr2_pathway_state_name(hdw->pathway_state);
#line 4725
  tmp___0 = scnprintf(buf, (size_t )acnt, "driver:%s%s%s%s%s <mode=%s>", hdw->flag_ok != 0 ? (char *)" <ok>" : (char *)" <fail>",
                      hdw->flag_init_ok != 0 ? (char *)" <init>" : (char *)" <uninitialized>",
                      hdw->flag_disconnected != 0 ? (char *)" <disconnected>" : (char *)" <connected>",
                      hdw->flag_tripped != 0 ? (char *)" <tripped>" : (char *)"",
                      hdw->flag_decoder_missed != 0 ? (char *)" <no decoder>" : (char *)"",
                      tmp);
#line 4725
  return ((unsigned int )tmp___0);
  case 1: 
#line 4737
  tmp___1 = scnprintf(buf, (size_t )acnt, "pipeline:%s%s%s%s", hdw->state_pipeline_idle != 0 ? (char *)" <idle>" : (char *)"",
                      hdw->state_pipeline_config != 0 ? (char *)" <configok>" : (char *)" <stale>",
                      hdw->state_pipeline_req != 0 ? (char *)" <req>" : (char *)"",
                      hdw->state_pipeline_pause != 0 ? (char *)" <pause>" : (char *)"");
#line 4737
  return ((unsigned int )tmp___1);
  case 2: 
#line 4746
  tmp___2 = scnprintf(buf, (size_t )acnt, "worker:%s%s%s%s%s%s%s", hdw->state_decoder_run != 0 ? (hdw->state_decoder_ready != 0 ? (char *)"<decode:run>" : (char *)" <decode:start>") : (hdw->state_decoder_quiescent != 0 ? (char *)"" : (char *)" <decode:stop>"),
                      hdw->state_decoder_quiescent != 0 ? (char *)" <decode:quiescent>" : (char *)"",
                      hdw->state_encoder_ok != 0 ? (char *)"" : (char *)" <encode:init>",
                      hdw->state_encoder_run != 0 ? (hdw->state_encoder_runok != 0 ? (char *)" <encode:run>" : (char *)" <encode:firstrun>") : (hdw->state_encoder_runok != 0 ? (char *)" <encode:stop>" : (char *)" <encode:virgin>"),
                      hdw->state_encoder_config == 0 ? (hdw->state_encoder_waitok != 0 ? (char *)"" : (char *)" <encode:waitok>") : (char *)" <encode:configok>",
                      hdw->state_usbstream_run != 0 ? (char *)" <usb:run>" : (char *)" <usb:stop>",
                      hdw->state_pathway_ok != 0 ? (char *)" <pathway:ok>" : (char *)"");
#line 4746
  return ((unsigned int )tmp___2);
  case 3: 
#line 4774
  tmp___3 = pvr2_get_state_name(hdw->master_state);
#line 4774
  tmp___4 = scnprintf(buf, (size_t )acnt, "state: %s", tmp___3);
#line 4774
  return ((unsigned int )tmp___4);
  case 4: 
#line 4779
  tcnt = 0U;
#line 4782
  tmp___5 = scnprintf(buf, (size_t )acnt, "Hardware supported inputs: ");
#line 4782
  ccnt = (unsigned int )tmp___5;
#line 4785
  tcnt = tcnt + ccnt;
#line 4786
  tmp___6 = print_input_mask(hdw->input_avail_mask, buf + (unsigned long )tcnt, acnt - tcnt);
#line 4786
  tcnt = tmp___6 + tcnt;
#line 4789
  if (hdw->input_avail_mask != hdw->input_allowed_mask) {
#line 4790
    tmp___7 = scnprintf(buf + (unsigned long )tcnt, (size_t )(acnt - tcnt), "; allowed inputs: ");
#line 4790
    ccnt = (unsigned int )tmp___7;
#line 4793
    tcnt = tcnt + ccnt;
#line 4794
    tmp___8 = print_input_mask(hdw->input_allowed_mask, buf + (unsigned long )tcnt,
                               acnt - tcnt);
#line 4794
    tcnt = tmp___8 + tcnt;
  } else {

  }
#line 4798
  return (tcnt);
  case 5: ;
#line 4802
  if ((unsigned long )hdw->vid_stream == (unsigned long )((struct pvr2_stream *)0)) {
#line 4802
    goto ldv_53863;
  } else {

  }
#line 4803
  pvr2_stream_get_stats(hdw->vid_stream, & stats, 0);
#line 4806
  tmp___9 = scnprintf(buf, (size_t )acnt, "Bytes streamed=%u URBs: queued=%u idle=%u ready=%u processed=%u failed=%u",
                      stats.bytes_processed, stats.buffers_in_queue, stats.buffers_in_idle,
                      stats.buffers_in_ready, stats.buffers_processed, stats.buffers_failed);
#line 4806
  return ((unsigned int )tmp___9);
  case 6: 
#line 4819
  id = hdw->ir_scheme_active;
#line 4820
  tmp___10 = scnprintf(buf, (size_t )acnt, "ir scheme: id=%d %s", id, id <= 4U ? ir_scheme_names[id] : "?");
#line 4820
  return ((unsigned int )tmp___10);
  default: ;
#line 4824
  goto ldv_53863;
  }
  ldv_53863: ;
#line 4826
  return (0U);
}
}
#line 4833 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static unsigned int pvr2_hdw_report_clients(struct pvr2_hdw *hdw , char *buf , unsigned int acnt ) 
{ 
  struct v4l2_subdev *sd ;
  unsigned int tcnt ;
  unsigned int ccnt ;
  struct i2c_client *client ;
  char const   *p ;
  unsigned int id ;
  int tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct list_head  const  *__mptr___0 ;

  {
#line 4837
  tcnt = 0U;
#line 4843
  tmp = scnprintf(buf, (size_t )acnt, "Associated v4l2-subdev drivers and I2C clients:\n");
#line 4843
  ccnt = (unsigned int )tmp;
#line 4844
  tcnt = tcnt + ccnt;
#line 4845
  __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 4845
  sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 4845
  goto ldv_53887;
  ldv_53886: 
#line 4846
  id = sd->grp_id;
#line 4847
  p = (char const   *)0;
#line 4848
  if (id <= 7U) {
#line 4848
    p = module_names[id];
  } else {

  }
#line 4849
  if ((unsigned long )p != (unsigned long )((char const   *)0)) {
#line 4850
    tmp___0 = scnprintf(buf + (unsigned long )tcnt, (size_t )(acnt - tcnt), "  %s:",
                        p);
#line 4850
    ccnt = (unsigned int )tmp___0;
#line 4851
    tcnt = tcnt + ccnt;
  } else {
#line 4853
    tmp___1 = scnprintf(buf + (unsigned long )tcnt, (size_t )(acnt - tcnt), "  (unknown id=%u):",
                        id);
#line 4853
    ccnt = (unsigned int )tmp___1;
#line 4855
    tcnt = tcnt + ccnt;
  }
#line 4857
  tmp___2 = v4l2_get_subdevdata((struct v4l2_subdev  const  *)sd);
#line 4857
  client = (struct i2c_client *)tmp___2;
#line 4858
  if ((unsigned long )client != (unsigned long )((struct i2c_client *)0)) {
#line 4859
    tmp___3 = scnprintf(buf + (unsigned long )tcnt, (size_t )(acnt - tcnt), " %s @ %02x\n",
                        (char *)(& client->name), (int )client->addr);
#line 4859
    ccnt = (unsigned int )tmp___3;
#line 4862
    tcnt = tcnt + ccnt;
  } else {
#line 4864
    tmp___4 = scnprintf(buf + (unsigned long )tcnt, (size_t )(acnt - tcnt), " no i2c client\n");
#line 4864
    ccnt = (unsigned int )tmp___4;
#line 4866
    tcnt = tcnt + ccnt;
  }
#line 4845
  __mptr___0 = (struct list_head  const  *)sd->list.next;
#line 4845
  sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_53887: ;
#line 4845
  if ((unsigned long )(& sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 4847
    goto ldv_53886;
  } else {

  }

#line 4869
  return (tcnt);
}
}
#line 4873 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
unsigned int pvr2_hdw_state_report(struct pvr2_hdw *hdw , char *buf , unsigned int acnt ) 
{ 
  unsigned int bcnt ;
  unsigned int ccnt ;
  unsigned int idx ;

  {
#line 4877
  bcnt = 0U;
#line 4878
  ldv_mutex_lock_293(& hdw->big_lock_mutex);
#line 4878
  hdw->big_lock_held = 1;
#line 4879
  idx = 0U;
  ldv_53898: 
#line 4880
  ccnt = pvr2_hdw_report_unlocked(hdw, (int )idx, buf, acnt);
#line 4881
  if (ccnt == 0U) {
#line 4881
    goto ldv_53897;
  } else {

  }
#line 4882
  bcnt = bcnt + ccnt;
#line 4882
  acnt = acnt - ccnt;
#line 4882
  buf = buf + (unsigned long )ccnt;
#line 4883
  if (acnt == 0U) {
#line 4883
    goto ldv_53897;
  } else {

  }
#line 4884
  *buf = 10;
#line 4884
  ccnt = 1U;
#line 4885
  bcnt = bcnt + ccnt;
#line 4885
  acnt = acnt - ccnt;
#line 4885
  buf = buf + (unsigned long )ccnt;
#line 4879
  idx = idx + 1U;
#line 4886
  goto ldv_53898;
  ldv_53897: 
#line 4887
  ccnt = pvr2_hdw_report_clients(hdw, buf, acnt);
#line 4888
  bcnt = bcnt + ccnt;
#line 4888
  acnt = acnt - ccnt;
#line 4888
  buf = buf + (unsigned long )ccnt;
#line 4889
  hdw->big_lock_held = 0;
#line 4889
  ldv_mutex_unlock_294(& hdw->big_lock_mutex);
#line 4890
  return (bcnt);
}
}
#line 4894 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_hdw_state_log_state(struct pvr2_hdw *hdw ) 
{ 
  char buf[256U] ;
  unsigned int idx ;
  unsigned int ccnt ;
  unsigned int lcnt ;
  unsigned int ucnt ;

  {
#line 4900
  idx = 0U;
  ldv_53908: 
#line 4901
  ccnt = pvr2_hdw_report_unlocked(hdw, (int )idx, (char *)(& buf), 256U);
#line 4902
  if (ccnt == 0U) {
#line 4902
    goto ldv_53907;
  } else {

  }
#line 4903
  printk("\016%s %.*s\n", (char *)(& hdw->name), ccnt, (char *)(& buf));
#line 4900
  idx = idx + 1U;
#line 4904
  goto ldv_53908;
  ldv_53907: 
#line 4905
  ccnt = pvr2_hdw_report_clients(hdw, (char *)(& buf), 256U);
#line 4906
  ucnt = 0U;
#line 4907
  goto ldv_53913;
  ldv_53912: 
#line 4908
  lcnt = 0U;
#line 4909
  goto ldv_53910;
  ldv_53909: 
#line 4910
  lcnt = lcnt + 1U;
  ldv_53910: ;
#line 4909
  if (lcnt + ucnt < ccnt && (int )((signed char )buf[lcnt + ucnt]) != 10) {
#line 4911
    goto ldv_53909;
  } else {

  }
#line 4912
  printk("\016%s %.*s\n", (char *)(& hdw->name), lcnt, (char *)(& buf) + (unsigned long )ucnt);
#line 4913
  ucnt = (lcnt + ucnt) + 1U;
  ldv_53913: ;
#line 4907
  if (ucnt < ccnt) {
#line 4909
    goto ldv_53912;
  } else {

  }

#line 4914
  return;
}
}
#line 4920 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_hdw_state_eval(struct pvr2_hdw *hdw ) 
{ 
  unsigned int st ;
  int state_updated ;
  int callback_flag ;
  int analog_mode ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 4923
  state_updated = 0;
#line 4924
  callback_flag = 0;
#line 4927
  if ((pvrusb2_debug & 512) != 0) {
#line 4927
    printk("\016pvrusb2: Drive state check START\n");
  } else {

  }
#line 4929
  if ((pvrusb2_debug & 512) != 0) {
#line 4930
    pvr2_hdw_state_log_state(hdw);
  } else {

  }
#line 4934
  state_updated = pvr2_hdw_state_update(hdw);
#line 4936
  analog_mode = hdw->pathway_state != 2;
#line 4939
  if (hdw->flag_ok == 0) {
#line 4940
    st = 1U;
  } else
#line 4941
  if (hdw->fw1_state != 4) {
#line 4942
    st = 2U;
  } else
#line 4943
  if ((analog_mode != 0 || (unsigned int )*((unsigned char *)hdw->hdw_desc + 87UL) != 0U) && hdw->state_encoder_ok == 0) {
#line 4946
    st = 3U;
  } else
#line 4947
  if (hdw->flag_tripped != 0 || (analog_mode != 0 && hdw->flag_decoder_missed != 0)) {
#line 4949
    st = 4U;
  } else
#line 4950
  if (hdw->state_usbstream_run != 0 && (analog_mode == 0 || (hdw->state_encoder_run != 0 && hdw->state_decoder_run != 0))) {
#line 4953
    st = 6U;
  } else {
#line 4955
    st = 5U;
  }
#line 4957
  if (hdw->master_state != st) {
#line 4958
    if ((pvrusb2_debug & 256) != 0) {
#line 4958
      tmp = pvr2_get_state_name(st);
#line 4958
      tmp___0 = pvr2_get_state_name(hdw->master_state);
#line 4958
      printk("\016pvrusb2: Device state change from %s to %s\n", tmp___0, tmp);
    } else {

    }
#line 4962
    pvr2_led_ctrl(hdw, st == 6U);
#line 4963
    hdw->master_state = st;
#line 4964
    state_updated = 1;
#line 4965
    callback_flag = 1;
  } else {

  }
#line 4967
  if (state_updated != 0) {
#line 4969
    __wake_up(& hdw->state_wait_data, 3U, 1, (void *)0);
  } else {

  }
#line 4972
  if ((pvrusb2_debug & 512) != 0) {
#line 4973
    pvr2_hdw_state_log_state(hdw);
  } else {

  }
#line 4975
  if ((pvrusb2_debug & 512) != 0) {
#line 4975
    printk("\016pvrusb2: Drive state check DONE callback=%d\n", callback_flag);
  } else {

  }
#line 4978
  return (callback_flag);
}
}
#line 4983 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static void pvr2_hdw_state_sched(struct pvr2_hdw *hdw ) 
{ 


  {
#line 4985
  if (hdw->state_stale != 0) {
#line 4985
    return;
  } else {

  }
#line 4986
  hdw->state_stale = 1;
#line 4987
  trace_stbit("state_stale", hdw->state_stale);
#line 4988
  queue_work(hdw->workqueue, & hdw->workpoll);
#line 4989
  return;
}
}
#line 4992 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_gpio_get_dir(struct pvr2_hdw *hdw , u32 *dp ) 
{ 
  int tmp ;

  {
#line 4994
  tmp = pvr2_read_register(hdw, 36896, dp);
#line 4994
  return (tmp);
}
}
#line 4998 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_gpio_get_out(struct pvr2_hdw *hdw , u32 *dp ) 
{ 
  int tmp ;

  {
#line 5000
  tmp = pvr2_read_register(hdw, 36876, dp);
#line 5000
  return (tmp);
}
}
#line 5004 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_gpio_get_in(struct pvr2_hdw *hdw , u32 *dp ) 
{ 
  int tmp ;

  {
#line 5006
  tmp = pvr2_read_register(hdw, 36872, dp);
#line 5006
  return (tmp);
}
}
#line 5010 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_gpio_chg_dir(struct pvr2_hdw *hdw , u32 msk , u32 val ) 
{ 
  u32 cval ;
  u32 nval ;
  int ret ;
  int tmp ;

  {
#line 5014
  if (msk != 4294967295U) {
#line 5015
    ret = pvr2_read_register(hdw, 36896, & cval);
#line 5016
    if (ret != 0) {
#line 5016
      return (ret);
    } else {

    }
#line 5017
    nval = (~ msk & cval) | (val & msk);
#line 5018
    if ((pvrusb2_debug & 134217728) != 0) {
#line 5018
      printk("\016pvrusb2: GPIO direction changing 0x%x:0x%x from 0x%x to 0x%x\n",
             msk, val, cval, nval);
    } else {

    }
  } else {
#line 5023
    nval = val;
#line 5024
    if ((pvrusb2_debug & 134217728) != 0) {
#line 5024
      printk("\016pvrusb2: GPIO direction changing to 0x%x\n", nval);
    } else {

    }
  }
#line 5027
  tmp = pvr2_write_register(hdw, 36896, nval);
#line 5027
  return (tmp);
}
}
#line 5031 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_gpio_chg_out(struct pvr2_hdw *hdw , u32 msk , u32 val ) 
{ 
  u32 cval ;
  u32 nval ;
  int ret ;
  int tmp ;

  {
#line 5035
  if (msk != 4294967295U) {
#line 5036
    ret = pvr2_read_register(hdw, 36876, & cval);
#line 5037
    if (ret != 0) {
#line 5037
      return (ret);
    } else {

    }
#line 5038
    nval = (~ msk & cval) | (val & msk);
#line 5039
    if ((pvrusb2_debug & 134217728) != 0) {
#line 5039
      printk("\016pvrusb2: GPIO output changing 0x%x:0x%x from 0x%x to 0x%x\n", msk,
             val, cval, nval);
    } else {

    }
  } else {
#line 5043
    nval = val;
#line 5044
    if ((pvrusb2_debug & 134217728) != 0) {
#line 5044
      printk("\016pvrusb2: GPIO output changing to 0x%x\n", nval);
    } else {

    }
  }
#line 5047
  tmp = pvr2_write_register(hdw, 36876, nval);
#line 5047
  return (tmp);
}
}
#line 5051 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
void pvr2_hdw_status_poll(struct pvr2_hdw *hdw ) 
{ 
  struct v4l2_tuner *vtp ;
  struct v4l2_subdev *__sd ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 5053
  vtp = & hdw->tuner_signal_info;
#line 5054
  memset((void *)vtp, 0, 84UL);
#line 5055
  vtp->type = hdw->input_val == 4 ? 1U : 2U;
#line 5057
  hdw->tuner_signal_stale = 0;
#line 5062
  __mptr = (struct list_head  const  *)hdw->v4l2_dev.subdevs.next;
#line 5062
  __sd = (struct v4l2_subdev *)__mptr + 0xffffffffffffff88UL;
#line 5062
  goto ldv_53963;
  ldv_53962: ;
#line 5062
  if ((unsigned long )(__sd->ops)->tuner != (unsigned long )((struct v4l2_subdev_tuner_ops  const  */* const  */)0) && (unsigned long )((__sd->ops)->tuner)->g_tuner != (unsigned long )((int (*/* const  */)(struct v4l2_subdev * ,
                                                                                                                                                                                                              struct v4l2_tuner * ))0)) {
#line 5062
    (*(((__sd->ops)->tuner)->g_tuner))(__sd, vtp);
  } else {

  }
#line 5062
  __mptr___0 = (struct list_head  const  *)__sd->list.next;
#line 5062
  __sd = (struct v4l2_subdev *)__mptr___0 + 0xffffffffffffff88UL;
  ldv_53963: ;
#line 5062
  if ((unsigned long )(& __sd->list) != (unsigned long )(& hdw->v4l2_dev.subdevs)) {
#line 5064
    goto ldv_53962;
  } else {

  }

#line 5063
  if ((pvrusb2_debug & 65536) != 0) {
#line 5063
    printk("\016pvrusb2: subdev status poll type=%u strength=%u audio=0x%x cap=0x%x low=%u hi=%u\n",
           vtp->type, vtp->signal, vtp->rxsubchans, vtp->capability, vtp->rangelow,
           vtp->rangehigh);
  } else {

  }
#line 5072
  hdw->cropcap_stale = 0;
#line 5073
  return;
}
}
#line 5076 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
unsigned int pvr2_hdw_get_input_available(struct pvr2_hdw *hdw ) 
{ 


  {
#line 5078
  return (hdw->input_avail_mask);
}
}
#line 5082 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
unsigned int pvr2_hdw_get_input_allowed(struct pvr2_hdw *hdw ) 
{ 


  {
#line 5084
  return (hdw->input_allowed_mask);
}
}
#line 5088 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_hdw_set_input(struct pvr2_hdw *hdw , int v ) 
{ 


  {
#line 5090
  if (hdw->input_val != v) {
#line 5091
    hdw->input_val = v;
#line 5092
    hdw->input_dirty = 1;
  } else {

  }
#line 5098
  if (hdw->input_val == 4) {
#line 5099
    hdw->freqSelector = 0U;
#line 5100
    hdw->freqDirty = 1;
  } else
#line 5101
  if (hdw->input_val == 0 || hdw->input_val == 1) {
#line 5103
    hdw->freqSelector = 1U;
#line 5104
    hdw->freqDirty = 1;
  } else {

  }
#line 5106
  return (0);
}
}
#line 5110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
int pvr2_hdw_set_input_allowed(struct pvr2_hdw *hdw , unsigned int change_mask , unsigned int change_val ) 
{ 
  int ret ;
  unsigned int nv ;
  unsigned int m ;
  unsigned int idx ;

  {
#line 5114
  ret = 0;
#line 5116
  ldv_mutex_lock_295(& hdw->big_lock_mutex);
#line 5116
  hdw->big_lock_held = 1;
#line 5118
  nv = hdw->input_allowed_mask & ~ change_mask;
#line 5119
  nv = (change_val & change_mask) | nv;
#line 5120
  nv = hdw->input_avail_mask & nv;
#line 5121
  if (nv == 0U) {
#line 5123
    ret = -1;
#line 5124
    goto ldv_53984;
  } else {

  }
#line 5126
  hdw->input_allowed_mask = nv;
#line 5127
  if (((unsigned int )(1 << hdw->input_val) & hdw->input_allowed_mask) != 0U) {
#line 5130
    goto ldv_53984;
  } else {

  }
#line 5134
  if (hdw->input_allowed_mask == 0U) {
#line 5136
    goto ldv_53984;
  } else {

  }
#line 5138
  m = hdw->input_allowed_mask;
#line 5139
  idx = 0U;
#line 5139
  goto ldv_53988;
  ldv_53987: ;
#line 5140
  if (((unsigned int )(1 << (int )idx) & m) == 0U) {
#line 5140
    goto ldv_53985;
  } else {

  }
#line 5141
  pvr2_hdw_set_input(hdw, (int )idx);
#line 5142
  goto ldv_53986;
  ldv_53985: 
#line 5139
  idx = idx + 1U;
  ldv_53988: ;
#line 5139
  if (idx <= 31U) {
#line 5141
    goto ldv_53987;
  } else {

  }
  ldv_53986: ;
  ldv_53984: 
#line 5145
  hdw->big_lock_held = 0;
#line 5145
  ldv_mutex_unlock_296(& hdw->big_lock_mutex);
#line 5146
  return (ret);
}
}
#line 5151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c"
static int pvr2_hdw_get_eeprom_addr(struct pvr2_hdw *hdw ) 
{ 
  int result ;

  {
#line 5154
  ldv_mutex_lock_297(& hdw->ctl_lock_mutex);
#line 5154
  hdw->ctl_lock_held = 1;
#line 5155
  hdw->cmd_buffer[0] = 235U;
#line 5156
  result = pvr2_send_request(hdw, (void *)(& hdw->cmd_buffer), 1U, (void *)(& hdw->cmd_buffer),
                             1U);
#line 5159
  if (result < 0) {
#line 5159
    goto ldv_53993;
  } else {

  }
#line 5160
  result = (int )hdw->cmd_buffer[0];
  ldv_53993: 
#line 5161
  hdw->ctl_lock_held = 0;
#line 5161
  ldv_mutex_unlock_298(& hdw->ctl_lock_mutex);
#line 5162
  return (result);
}
}
#line 327 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void activate_suitable_timer_6(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 328
  if (ldv_timer_6_0 == 0 || ldv_timer_6_0 == 2) {
#line 329
    ldv_timer_list_6_0 = timer;
#line 330
    ldv_timer_list_6_0->data = data;
#line 331
    ldv_timer_6_0 = 1;
#line 332
    return;
  } else {

  }
#line 334
  if (ldv_timer_6_1 == 0 || ldv_timer_6_1 == 2) {
#line 335
    ldv_timer_list_6_1 = timer;
#line 336
    ldv_timer_list_6_1->data = data;
#line 337
    ldv_timer_6_1 = 1;
#line 338
    return;
  } else {

  }
#line 340
  if (ldv_timer_6_2 == 0 || ldv_timer_6_2 == 2) {
#line 341
    ldv_timer_list_6_2 = timer;
#line 342
    ldv_timer_list_6_2->data = data;
#line 343
    ldv_timer_6_2 = 1;
#line 344
    return;
  } else {

  }
#line 346
  if (ldv_timer_6_3 == 0 || ldv_timer_6_3 == 2) {
#line 347
    ldv_timer_list_6_3 = timer;
#line 348
    ldv_timer_list_6_3->data = data;
#line 349
    ldv_timer_6_3 = 1;
#line 350
    return;
  } else {

  }
#line 352
  return;
}
}
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void call_and_disable_work_1(struct work_struct *work ) 
{ 


  {
#line 359
  if ((ldv_work_1_0 == 2 || ldv_work_1_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_0) {
#line 361
    pvr2_hdw_worker_poll(work);
#line 362
    ldv_work_1_0 = 1;
#line 363
    return;
  } else {

  }
#line 365
  if ((ldv_work_1_1 == 2 || ldv_work_1_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_1) {
#line 367
    pvr2_hdw_worker_poll(work);
#line 368
    ldv_work_1_1 = 1;
#line 369
    return;
  } else {

  }
#line 371
  if ((ldv_work_1_2 == 2 || ldv_work_1_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_2) {
#line 373
    pvr2_hdw_worker_poll(work);
#line 374
    ldv_work_1_2 = 1;
#line 375
    return;
  } else {

  }
#line 377
  if ((ldv_work_1_3 == 2 || ldv_work_1_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_3) {
#line 379
    pvr2_hdw_worker_poll(work);
#line 380
    ldv_work_1_3 = 1;
#line 381
    return;
  } else {

  }
#line 383
  return;
}
}
#line 386 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_timer_5(int state , struct timer_list *timer ) 
{ 


  {
#line 387
  LDV_IN_INTERRUPT = 2;
#line 388
  pvr2_hdw_encoder_run_timeout(timer->data);
#line 389
  LDV_IN_INTERRUPT = 1;
#line 390
  return;
}
}
#line 393 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void choose_timer_5(void) 
{ 
  int tmp ;

  {
#line 394
  tmp = __VERIFIER_nondet_int();
#line 394
  switch (tmp) {
  case 0: ;
#line 396
  if (ldv_timer_5_0 == 1) {
#line 397
    ldv_timer_5_0 = 2;
#line 398
    ldv_timer_5(ldv_timer_5_0, ldv_timer_list_5_0);
  } else {

  }
#line 401
  goto ldv_54011;
  case 1: ;
#line 403
  if (ldv_timer_5_1 == 1) {
#line 404
    ldv_timer_5_1 = 2;
#line 405
    ldv_timer_5(ldv_timer_5_1, ldv_timer_list_5_1);
  } else {

  }
#line 408
  goto ldv_54011;
  case 2: ;
#line 410
  if (ldv_timer_5_2 == 1) {
#line 411
    ldv_timer_5_2 = 2;
#line 412
    ldv_timer_5(ldv_timer_5_2, ldv_timer_list_5_2);
  } else {

  }
#line 415
  goto ldv_54011;
  case 3: ;
#line 417
  if (ldv_timer_5_3 == 1) {
#line 418
    ldv_timer_5_3 = 2;
#line 419
    ldv_timer_5(ldv_timer_5_3, ldv_timer_list_5_3);
  } else {

  }
#line 422
  goto ldv_54011;
  default: 
#line 423
  ldv_stop();
  }
  ldv_54011: ;
#line 425
  return;
}
}
#line 429 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void activate_pending_timer_2(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 430
  if ((unsigned long )ldv_timer_list_2_0 == (unsigned long )timer) {
#line 431
    if (ldv_timer_2_0 == 2 || pending_flag != 0) {
#line 432
      ldv_timer_list_2_0 = timer;
#line 433
      ldv_timer_list_2_0->data = data;
#line 434
      ldv_timer_2_0 = 1;
    } else {

    }
#line 436
    return;
  } else {

  }
#line 439
  if ((unsigned long )ldv_timer_list_2_1 == (unsigned long )timer) {
#line 440
    if (ldv_timer_2_1 == 2 || pending_flag != 0) {
#line 441
      ldv_timer_list_2_1 = timer;
#line 442
      ldv_timer_list_2_1->data = data;
#line 443
      ldv_timer_2_1 = 1;
    } else {

    }
#line 445
    return;
  } else {

  }
#line 448
  if ((unsigned long )ldv_timer_list_2_2 == (unsigned long )timer) {
#line 449
    if (ldv_timer_2_2 == 2 || pending_flag != 0) {
#line 450
      ldv_timer_list_2_2 = timer;
#line 451
      ldv_timer_list_2_2->data = data;
#line 452
      ldv_timer_2_2 = 1;
    } else {

    }
#line 454
    return;
  } else {

  }
#line 457
  if ((unsigned long )ldv_timer_list_2_3 == (unsigned long )timer) {
#line 458
    if (ldv_timer_2_3 == 2 || pending_flag != 0) {
#line 459
      ldv_timer_list_2_3 = timer;
#line 460
      ldv_timer_list_2_3->data = data;
#line 461
      ldv_timer_2_3 = 1;
    } else {

    }
#line 463
    return;
  } else {

  }
#line 465
  activate_suitable_timer_2(timer, data);
#line 466
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 470
  if ((unsigned long )ldv_timer_list_4_0 == (unsigned long )timer) {
#line 471
    if (ldv_timer_4_0 == 2 || pending_flag != 0) {
#line 472
      ldv_timer_list_4_0 = timer;
#line 473
      ldv_timer_list_4_0->data = data;
#line 474
      ldv_timer_4_0 = 1;
    } else {

    }
#line 476
    return;
  } else {

  }
#line 479
  if ((unsigned long )ldv_timer_list_4_1 == (unsigned long )timer) {
#line 480
    if (ldv_timer_4_1 == 2 || pending_flag != 0) {
#line 481
      ldv_timer_list_4_1 = timer;
#line 482
      ldv_timer_list_4_1->data = data;
#line 483
      ldv_timer_4_1 = 1;
    } else {

    }
#line 485
    return;
  } else {

  }
#line 488
  if ((unsigned long )ldv_timer_list_4_2 == (unsigned long )timer) {
#line 489
    if (ldv_timer_4_2 == 2 || pending_flag != 0) {
#line 490
      ldv_timer_list_4_2 = timer;
#line 491
      ldv_timer_list_4_2->data = data;
#line 492
      ldv_timer_4_2 = 1;
    } else {

    }
#line 494
    return;
  } else {

  }
#line 497
  if ((unsigned long )ldv_timer_list_4_3 == (unsigned long )timer) {
#line 498
    if (ldv_timer_4_3 == 2 || pending_flag != 0) {
#line 499
      ldv_timer_list_4_3 = timer;
#line 500
      ldv_timer_list_4_3->data = data;
#line 501
      ldv_timer_4_3 = 1;
    } else {

    }
#line 503
    return;
  } else {

  }
#line 505
  activate_suitable_timer_4(timer, data);
#line 506
  return;
}
}
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void timer_init_4(void) 
{ 


  {
#line 510
  ldv_timer_4_0 = 0;
#line 511
  ldv_timer_4_1 = 0;
#line 512
  ldv_timer_4_2 = 0;
#line 513
  ldv_timer_4_3 = 0;
#line 514
  return;
}
}
#line 517 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void activate_work_1(struct work_struct *work , int state ) 
{ 


  {
#line 518
  if (ldv_work_1_0 == 0) {
#line 519
    ldv_work_struct_1_0 = work;
#line 520
    ldv_work_1_0 = state;
#line 521
    return;
  } else {

  }
#line 524
  if (ldv_work_1_1 == 0) {
#line 525
    ldv_work_struct_1_1 = work;
#line 526
    ldv_work_1_1 = state;
#line 527
    return;
  } else {

  }
#line 530
  if (ldv_work_1_2 == 0) {
#line 531
    ldv_work_struct_1_2 = work;
#line 532
    ldv_work_1_2 = state;
#line 533
    return;
  } else {

  }
#line 536
  if (ldv_work_1_3 == 0) {
#line 537
    ldv_work_struct_1_3 = work;
#line 538
    ldv_work_1_3 = state;
#line 539
    return;
  } else {

  }
#line 541
  return;
}
}
#line 544 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void timer_init_2(void) 
{ 


  {
#line 545
  ldv_timer_2_0 = 0;
#line 546
  ldv_timer_2_1 = 0;
#line 547
  ldv_timer_2_2 = 0;
#line 548
  ldv_timer_2_3 = 0;
#line 549
  return;
}
}
#line 552 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void disable_suitable_timer_3(struct timer_list *timer ) 
{ 


  {
#line 553
  if (ldv_timer_3_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_3_0) {
#line 554
    ldv_timer_3_0 = 0;
#line 555
    return;
  } else {

  }
#line 557
  if (ldv_timer_3_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_3_1) {
#line 558
    ldv_timer_3_1 = 0;
#line 559
    return;
  } else {

  }
#line 561
  if (ldv_timer_3_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_3_2) {
#line 562
    ldv_timer_3_2 = 0;
#line 563
    return;
  } else {

  }
#line 565
  if (ldv_timer_3_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_3_3) {
#line 566
    ldv_timer_3_3 = 0;
#line 567
    return;
  } else {

  }
#line 569
  return;
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void activate_suitable_timer_3(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 574
  if (ldv_timer_3_0 == 0 || ldv_timer_3_0 == 2) {
#line 575
    ldv_timer_list_3_0 = timer;
#line 576
    ldv_timer_list_3_0->data = data;
#line 577
    ldv_timer_3_0 = 1;
#line 578
    return;
  } else {

  }
#line 580
  if (ldv_timer_3_1 == 0 || ldv_timer_3_1 == 2) {
#line 581
    ldv_timer_list_3_1 = timer;
#line 582
    ldv_timer_list_3_1->data = data;
#line 583
    ldv_timer_3_1 = 1;
#line 584
    return;
  } else {

  }
#line 586
  if (ldv_timer_3_2 == 0 || ldv_timer_3_2 == 2) {
#line 587
    ldv_timer_list_3_2 = timer;
#line 588
    ldv_timer_list_3_2->data = data;
#line 589
    ldv_timer_3_2 = 1;
#line 590
    return;
  } else {

  }
#line 592
  if (ldv_timer_3_3 == 0 || ldv_timer_3_3 == 2) {
#line 593
    ldv_timer_list_3_3 = timer;
#line 594
    ldv_timer_list_3_3->data = data;
#line 595
    ldv_timer_3_3 = 1;
#line 596
    return;
  } else {

  }
#line 598
  return;
}
}
#line 602 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void timer_init_6(void) 
{ 


  {
#line 603
  ldv_timer_6_0 = 0;
#line 604
  ldv_timer_6_1 = 0;
#line 605
  ldv_timer_6_2 = 0;
#line 606
  ldv_timer_6_3 = 0;
#line 607
  return;
}
}
#line 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void disable_work_1(struct work_struct *work ) 
{ 


  {
#line 612
  if ((ldv_work_1_0 == 3 || ldv_work_1_0 == 2) && (unsigned long )ldv_work_struct_1_0 == (unsigned long )work) {
#line 614
    ldv_work_1_0 = 1;
  } else {

  }
#line 616
  if ((ldv_work_1_1 == 3 || ldv_work_1_1 == 2) && (unsigned long )ldv_work_struct_1_1 == (unsigned long )work) {
#line 618
    ldv_work_1_1 = 1;
  } else {

  }
#line 620
  if ((ldv_work_1_2 == 3 || ldv_work_1_2 == 2) && (unsigned long )ldv_work_struct_1_2 == (unsigned long )work) {
#line 622
    ldv_work_1_2 = 1;
  } else {

  }
#line 624
  if ((ldv_work_1_3 == 3 || ldv_work_1_3 == 2) && (unsigned long )ldv_work_struct_1_3 == (unsigned long )work) {
#line 626
    ldv_work_1_3 = 1;
  } else {

  }
#line 627
  return;
}
}
#line 631 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void timer_init_5(void) 
{ 


  {
#line 632
  ldv_timer_5_0 = 0;
#line 633
  ldv_timer_5_1 = 0;
#line 634
  ldv_timer_5_2 = 0;
#line 635
  ldv_timer_5_3 = 0;
#line 636
  return;
}
}
#line 639 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void work_init_1(void) 
{ 


  {
#line 640
  ldv_work_1_0 = 0;
#line 641
  ldv_work_1_1 = 0;
#line 642
  ldv_work_1_2 = 0;
#line 643
  ldv_work_1_3 = 0;
#line 644
  return;
}
}
#line 647 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void disable_suitable_timer_2(struct timer_list *timer ) 
{ 


  {
#line 648
  if (ldv_timer_2_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_2_0) {
#line 649
    ldv_timer_2_0 = 0;
#line 650
    return;
  } else {

  }
#line 652
  if (ldv_timer_2_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_2_1) {
#line 653
    ldv_timer_2_1 = 0;
#line 654
    return;
  } else {

  }
#line 656
  if (ldv_timer_2_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_2_2) {
#line 657
    ldv_timer_2_2 = 0;
#line 658
    return;
  } else {

  }
#line 660
  if (ldv_timer_2_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_2_3) {
#line 661
    ldv_timer_2_3 = 0;
#line 662
    return;
  } else {

  }
#line 664
  return;
}
}
#line 668 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int reg_timer_3(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 669
  if ((unsigned long )function == (unsigned long )(& pvr2_hdw_decoder_stabilization_timeout)) {
#line 670
    activate_suitable_timer_3(timer, data);
  } else {

  }
#line 671
  return (0);
}
}
#line 675 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void disable_suitable_timer_6(struct timer_list *timer ) 
{ 


  {
#line 676
  if (ldv_timer_6_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_0) {
#line 677
    ldv_timer_6_0 = 0;
#line 678
    return;
  } else {

  }
#line 680
  if (ldv_timer_6_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_1) {
#line 681
    ldv_timer_6_1 = 0;
#line 682
    return;
  } else {

  }
#line 684
  if (ldv_timer_6_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_2) {
#line 685
    ldv_timer_6_2 = 0;
#line 686
    return;
  } else {

  }
#line 688
  if (ldv_timer_6_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_3) {
#line 689
    ldv_timer_6_3 = 0;
#line 690
    return;
  } else {

  }
#line 692
  return;
}
}
#line 696 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void disable_suitable_timer_5(struct timer_list *timer ) 
{ 


  {
#line 697
  if (ldv_timer_5_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_0) {
#line 698
    ldv_timer_5_0 = 0;
#line 699
    return;
  } else {

  }
#line 701
  if (ldv_timer_5_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_1) {
#line 702
    ldv_timer_5_1 = 0;
#line 703
    return;
  } else {

  }
#line 705
  if (ldv_timer_5_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_2) {
#line 706
    ldv_timer_5_2 = 0;
#line 707
    return;
  } else {

  }
#line 709
  if (ldv_timer_5_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_3) {
#line 710
    ldv_timer_5_3 = 0;
#line 711
    return;
  } else {

  }
#line 713
  return;
}
}
#line 717 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void activate_pending_timer_6(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 718
  if ((unsigned long )ldv_timer_list_6_0 == (unsigned long )timer) {
#line 719
    if (ldv_timer_6_0 == 2 || pending_flag != 0) {
#line 720
      ldv_timer_list_6_0 = timer;
#line 721
      ldv_timer_list_6_0->data = data;
#line 722
      ldv_timer_6_0 = 1;
    } else {

    }
#line 724
    return;
  } else {

  }
#line 727
  if ((unsigned long )ldv_timer_list_6_1 == (unsigned long )timer) {
#line 728
    if (ldv_timer_6_1 == 2 || pending_flag != 0) {
#line 729
      ldv_timer_list_6_1 = timer;
#line 730
      ldv_timer_list_6_1->data = data;
#line 731
      ldv_timer_6_1 = 1;
    } else {

    }
#line 733
    return;
  } else {

  }
#line 736
  if ((unsigned long )ldv_timer_list_6_2 == (unsigned long )timer) {
#line 737
    if (ldv_timer_6_2 == 2 || pending_flag != 0) {
#line 738
      ldv_timer_list_6_2 = timer;
#line 739
      ldv_timer_list_6_2->data = data;
#line 740
      ldv_timer_6_2 = 1;
    } else {

    }
#line 742
    return;
  } else {

  }
#line 745
  if ((unsigned long )ldv_timer_list_6_3 == (unsigned long )timer) {
#line 746
    if (ldv_timer_6_3 == 2 || pending_flag != 0) {
#line 747
      ldv_timer_list_6_3 = timer;
#line 748
      ldv_timer_list_6_3->data = data;
#line 749
      ldv_timer_6_3 = 1;
    } else {

    }
#line 751
    return;
  } else {

  }
#line 753
  activate_suitable_timer_6(timer, data);
#line 754
  return;
}
}
#line 757 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void activate_suitable_timer_4(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 758
  if (ldv_timer_4_0 == 0 || ldv_timer_4_0 == 2) {
#line 759
    ldv_timer_list_4_0 = timer;
#line 760
    ldv_timer_list_4_0->data = data;
#line 761
    ldv_timer_4_0 = 1;
#line 762
    return;
  } else {

  }
#line 764
  if (ldv_timer_4_1 == 0 || ldv_timer_4_1 == 2) {
#line 765
    ldv_timer_list_4_1 = timer;
#line 766
    ldv_timer_list_4_1->data = data;
#line 767
    ldv_timer_4_1 = 1;
#line 768
    return;
  } else {

  }
#line 770
  if (ldv_timer_4_2 == 0 || ldv_timer_4_2 == 2) {
#line 771
    ldv_timer_list_4_2 = timer;
#line 772
    ldv_timer_list_4_2->data = data;
#line 773
    ldv_timer_4_2 = 1;
#line 774
    return;
  } else {

  }
#line 776
  if (ldv_timer_4_3 == 0 || ldv_timer_4_3 == 2) {
#line 777
    ldv_timer_list_4_3 = timer;
#line 778
    ldv_timer_list_4_3->data = data;
#line 779
    ldv_timer_4_3 = 1;
#line 780
    return;
  } else {

  }
#line 782
  return;
}
}
#line 786 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_timer_2(int state , struct timer_list *timer ) 
{ 


  {
#line 787
  LDV_IN_INTERRUPT = 2;
#line 788
  pvr2_hdw_quiescent_timeout(timer->data);
#line 789
  LDV_IN_INTERRUPT = 1;
#line 790
  return;
}
}
#line 793 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void choose_timer_2(void) 
{ 
  int tmp ;

  {
#line 794
  tmp = __VERIFIER_nondet_int();
#line 794
  switch (tmp) {
  case 0: ;
#line 796
  if (ldv_timer_2_0 == 1) {
#line 797
    ldv_timer_2_0 = 2;
#line 798
    ldv_timer_2(ldv_timer_2_0, ldv_timer_list_2_0);
  } else {

  }
#line 801
  goto ldv_54087;
  case 1: ;
#line 803
  if (ldv_timer_2_1 == 1) {
#line 804
    ldv_timer_2_1 = 2;
#line 805
    ldv_timer_2(ldv_timer_2_1, ldv_timer_list_2_1);
  } else {

  }
#line 808
  goto ldv_54087;
  case 2: ;
#line 810
  if (ldv_timer_2_2 == 1) {
#line 811
    ldv_timer_2_2 = 2;
#line 812
    ldv_timer_2(ldv_timer_2_2, ldv_timer_list_2_2);
  } else {

  }
#line 815
  goto ldv_54087;
  case 3: ;
#line 817
  if (ldv_timer_2_3 == 1) {
#line 818
    ldv_timer_2_3 = 2;
#line 819
    ldv_timer_2(ldv_timer_2_3, ldv_timer_list_2_3);
  } else {

  }
#line 822
  goto ldv_54087;
  default: 
#line 823
  ldv_stop();
  }
  ldv_54087: ;
#line 825
  return;
}
}
#line 829 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int reg_timer_2(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 830
  if ((unsigned long )function == (unsigned long )(& pvr2_hdw_quiescent_timeout)) {
#line 831
    activate_suitable_timer_2(timer, data);
  } else {

  }
#line 832
  return (0);
}
}
#line 836 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void choose_timer_3(void) 
{ 
  int tmp ;

  {
#line 837
  tmp = __VERIFIER_nondet_int();
#line 837
  switch (tmp) {
  case 0: ;
#line 839
  if (ldv_timer_3_0 == 1) {
#line 840
    ldv_timer_3_0 = 2;
#line 841
    ldv_timer_3(ldv_timer_3_0, ldv_timer_list_3_0);
  } else {

  }
#line 844
  goto ldv_54102;
  case 1: ;
#line 846
  if (ldv_timer_3_1 == 1) {
#line 847
    ldv_timer_3_1 = 2;
#line 848
    ldv_timer_3(ldv_timer_3_1, ldv_timer_list_3_1);
  } else {

  }
#line 851
  goto ldv_54102;
  case 2: ;
#line 853
  if (ldv_timer_3_2 == 1) {
#line 854
    ldv_timer_3_2 = 2;
#line 855
    ldv_timer_3(ldv_timer_3_2, ldv_timer_list_3_2);
  } else {

  }
#line 858
  goto ldv_54102;
  case 3: ;
#line 860
  if (ldv_timer_3_3 == 1) {
#line 861
    ldv_timer_3_3 = 2;
#line 862
    ldv_timer_3(ldv_timer_3_3, ldv_timer_list_3_3);
  } else {

  }
#line 865
  goto ldv_54102;
  default: 
#line 866
  ldv_stop();
  }
  ldv_54102: ;
#line 868
  return;
}
}
#line 872 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void call_and_disable_all_1(int state ) 
{ 


  {
#line 874
  if (ldv_work_1_0 == state) {
#line 875
    call_and_disable_work_1(ldv_work_struct_1_0);
  } else {

  }
#line 876
  if (ldv_work_1_1 == state) {
#line 877
    call_and_disable_work_1(ldv_work_struct_1_1);
  } else {

  }
#line 878
  if (ldv_work_1_2 == state) {
#line 879
    call_and_disable_work_1(ldv_work_struct_1_2);
  } else {

  }
#line 880
  if (ldv_work_1_3 == state) {
#line 881
    call_and_disable_work_1(ldv_work_struct_1_3);
  } else {

  }
#line 882
  return;
}
}
#line 885 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void choose_timer_6(void) 
{ 
  int tmp ;

  {
#line 886
  tmp = __VERIFIER_nondet_int();
#line 886
  switch (tmp) {
  case 0: ;
#line 888
  if (ldv_timer_6_0 == 1) {
#line 889
    ldv_timer_6_0 = 2;
#line 890
    ldv_timer_6(ldv_timer_6_0, ldv_timer_list_6_0);
  } else {

  }
#line 893
  goto ldv_54114;
  case 1: ;
#line 895
  if (ldv_timer_6_1 == 1) {
#line 896
    ldv_timer_6_1 = 2;
#line 897
    ldv_timer_6(ldv_timer_6_1, ldv_timer_list_6_1);
  } else {

  }
#line 900
  goto ldv_54114;
  case 2: ;
#line 902
  if (ldv_timer_6_2 == 1) {
#line 903
    ldv_timer_6_2 = 2;
#line 904
    ldv_timer_6(ldv_timer_6_2, ldv_timer_list_6_2);
  } else {

  }
#line 907
  goto ldv_54114;
  case 3: ;
#line 909
  if (ldv_timer_6_3 == 1) {
#line 910
    ldv_timer_6_3 = 2;
#line 911
    ldv_timer_6(ldv_timer_6_3, ldv_timer_list_6_3);
  } else {

  }
#line 914
  goto ldv_54114;
  default: 
#line 915
  ldv_stop();
  }
  ldv_54114: ;
#line 917
  return;
}
}
#line 921 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void timer_init_3(void) 
{ 


  {
#line 922
  ldv_timer_3_0 = 0;
#line 923
  ldv_timer_3_1 = 0;
#line 924
  ldv_timer_3_2 = 0;
#line 925
  ldv_timer_3_3 = 0;
#line 926
  return;
}
}
#line 929 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int reg_timer_6(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 930
  if ((unsigned long )function == (unsigned long )(& pvr2_ctl_timeout)) {
#line 931
    activate_suitable_timer_6(timer, data);
  } else {

  }
#line 932
  return (0);
}
}
#line 936 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_timer_6(int state , struct timer_list *timer ) 
{ 


  {
#line 937
  LDV_IN_INTERRUPT = 2;
#line 938
  pvr2_ctl_timeout(timer->data);
#line 939
  LDV_IN_INTERRUPT = 1;
#line 940
  return;
}
}
#line 943 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void choose_timer_4(void) 
{ 
  int tmp ;

  {
#line 944
  tmp = __VERIFIER_nondet_int();
#line 944
  switch (tmp) {
  case 0: ;
#line 946
  if (ldv_timer_4_0 == 1) {
#line 947
    ldv_timer_4_0 = 2;
#line 948
    ldv_timer_4(ldv_timer_4_0, ldv_timer_list_4_0);
  } else {

  }
#line 951
  goto ldv_54136;
  case 1: ;
#line 953
  if (ldv_timer_4_1 == 1) {
#line 954
    ldv_timer_4_1 = 2;
#line 955
    ldv_timer_4(ldv_timer_4_1, ldv_timer_list_4_1);
  } else {

  }
#line 958
  goto ldv_54136;
  case 2: ;
#line 960
  if (ldv_timer_4_2 == 1) {
#line 961
    ldv_timer_4_2 = 2;
#line 962
    ldv_timer_4(ldv_timer_4_2, ldv_timer_list_4_2);
  } else {

  }
#line 965
  goto ldv_54136;
  case 3: ;
#line 967
  if (ldv_timer_4_3 == 1) {
#line 968
    ldv_timer_4_3 = 2;
#line 969
    ldv_timer_4(ldv_timer_4_3, ldv_timer_list_4_3);
  } else {

  }
#line 972
  goto ldv_54136;
  default: 
#line 973
  ldv_stop();
  }
  ldv_54136: ;
#line 975
  return;
}
}
#line 979 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void disable_suitable_timer_4(struct timer_list *timer ) 
{ 


  {
#line 980
  if (ldv_timer_4_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_0) {
#line 981
    ldv_timer_4_0 = 0;
#line 982
    return;
  } else {

  }
#line 984
  if (ldv_timer_4_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_1) {
#line 985
    ldv_timer_4_1 = 0;
#line 986
    return;
  } else {

  }
#line 988
  if (ldv_timer_4_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_2) {
#line 989
    ldv_timer_4_2 = 0;
#line 990
    return;
  } else {

  }
#line 992
  if (ldv_timer_4_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_3) {
#line 993
    ldv_timer_4_3 = 0;
#line 994
    return;
  } else {

  }
#line 996
  return;
}
}
#line 1000 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int reg_timer_4(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 1001
  if ((unsigned long )function == (unsigned long )(& pvr2_hdw_encoder_wait_timeout)) {
#line 1002
    activate_suitable_timer_4(timer, data);
  } else {

  }
#line 1003
  return (0);
}
}
#line 1007 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void invoke_work_1(void) 
{ 
  int tmp ;

  {
#line 1009
  tmp = __VERIFIER_nondet_int();
#line 1009
  switch (tmp) {
  case 0: ;
#line 1011
  if (ldv_work_1_0 == 2 || ldv_work_1_0 == 3) {
#line 1012
    ldv_work_1_0 = 4;
#line 1013
    pvr2_hdw_worker_poll(ldv_work_struct_1_0);
#line 1014
    ldv_work_1_0 = 1;
  } else {

  }
#line 1017
  goto ldv_54156;
  case 1: ;
#line 1019
  if (ldv_work_1_1 == 2 || ldv_work_1_1 == 3) {
#line 1020
    ldv_work_1_1 = 4;
#line 1021
    pvr2_hdw_worker_poll(ldv_work_struct_1_0);
#line 1022
    ldv_work_1_1 = 1;
  } else {

  }
#line 1025
  goto ldv_54156;
  case 2: ;
#line 1027
  if (ldv_work_1_2 == 2 || ldv_work_1_2 == 3) {
#line 1028
    ldv_work_1_2 = 4;
#line 1029
    pvr2_hdw_worker_poll(ldv_work_struct_1_0);
#line 1030
    ldv_work_1_2 = 1;
  } else {

  }
#line 1033
  goto ldv_54156;
  case 3: ;
#line 1035
  if (ldv_work_1_3 == 2 || ldv_work_1_3 == 3) {
#line 1036
    ldv_work_1_3 = 4;
#line 1037
    pvr2_hdw_worker_poll(ldv_work_struct_1_0);
#line 1038
    ldv_work_1_3 = 1;
  } else {

  }
#line 1041
  goto ldv_54156;
  default: 
#line 1042
  ldv_stop();
  }
  ldv_54156: ;
#line 1044
  return;
}
}
#line 1048 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void activate_pending_timer_3(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 1049
  if ((unsigned long )ldv_timer_list_3_0 == (unsigned long )timer) {
#line 1050
    if (ldv_timer_3_0 == 2 || pending_flag != 0) {
#line 1051
      ldv_timer_list_3_0 = timer;
#line 1052
      ldv_timer_list_3_0->data = data;
#line 1053
      ldv_timer_3_0 = 1;
    } else {

    }
#line 1055
    return;
  } else {

  }
#line 1058
  if ((unsigned long )ldv_timer_list_3_1 == (unsigned long )timer) {
#line 1059
    if (ldv_timer_3_1 == 2 || pending_flag != 0) {
#line 1060
      ldv_timer_list_3_1 = timer;
#line 1061
      ldv_timer_list_3_1->data = data;
#line 1062
      ldv_timer_3_1 = 1;
    } else {

    }
#line 1064
    return;
  } else {

  }
#line 1067
  if ((unsigned long )ldv_timer_list_3_2 == (unsigned long )timer) {
#line 1068
    if (ldv_timer_3_2 == 2 || pending_flag != 0) {
#line 1069
      ldv_timer_list_3_2 = timer;
#line 1070
      ldv_timer_list_3_2->data = data;
#line 1071
      ldv_timer_3_2 = 1;
    } else {

    }
#line 1073
    return;
  } else {

  }
#line 1076
  if ((unsigned long )ldv_timer_list_3_3 == (unsigned long )timer) {
#line 1077
    if (ldv_timer_3_3 == 2 || pending_flag != 0) {
#line 1078
      ldv_timer_list_3_3 = timer;
#line 1079
      ldv_timer_list_3_3->data = data;
#line 1080
      ldv_timer_3_3 = 1;
    } else {

    }
#line 1082
    return;
  } else {

  }
#line 1084
  activate_suitable_timer_3(timer, data);
#line 1085
  return;
}
}
#line 1088 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void activate_pending_timer_5(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 1089
  if ((unsigned long )ldv_timer_list_5_0 == (unsigned long )timer) {
#line 1090
    if (ldv_timer_5_0 == 2 || pending_flag != 0) {
#line 1091
      ldv_timer_list_5_0 = timer;
#line 1092
      ldv_timer_list_5_0->data = data;
#line 1093
      ldv_timer_5_0 = 1;
    } else {

    }
#line 1095
    return;
  } else {

  }
#line 1098
  if ((unsigned long )ldv_timer_list_5_1 == (unsigned long )timer) {
#line 1099
    if (ldv_timer_5_1 == 2 || pending_flag != 0) {
#line 1100
      ldv_timer_list_5_1 = timer;
#line 1101
      ldv_timer_list_5_1->data = data;
#line 1102
      ldv_timer_5_1 = 1;
    } else {

    }
#line 1104
    return;
  } else {

  }
#line 1107
  if ((unsigned long )ldv_timer_list_5_2 == (unsigned long )timer) {
#line 1108
    if (ldv_timer_5_2 == 2 || pending_flag != 0) {
#line 1109
      ldv_timer_list_5_2 = timer;
#line 1110
      ldv_timer_list_5_2->data = data;
#line 1111
      ldv_timer_5_2 = 1;
    } else {

    }
#line 1113
    return;
  } else {

  }
#line 1116
  if ((unsigned long )ldv_timer_list_5_3 == (unsigned long )timer) {
#line 1117
    if (ldv_timer_5_3 == 2 || pending_flag != 0) {
#line 1118
      ldv_timer_list_5_3 = timer;
#line 1119
      ldv_timer_list_5_3->data = data;
#line 1120
      ldv_timer_5_3 = 1;
    } else {

    }
#line 1122
    return;
  } else {

  }
#line 1124
  activate_suitable_timer_5(timer, data);
#line 1125
  return;
}
}
#line 1128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int reg_timer_5(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 1129
  if ((unsigned long )function == (unsigned long )(& pvr2_hdw_encoder_run_timeout)) {
#line 1130
    activate_suitable_timer_5(timer, data);
  } else {

  }
#line 1131
  return (0);
}
}
#line 1135 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_timer_4(int state , struct timer_list *timer ) 
{ 


  {
#line 1136
  LDV_IN_INTERRUPT = 2;
#line 1137
  pvr2_hdw_encoder_wait_timeout(timer->data);
#line 1138
  LDV_IN_INTERRUPT = 1;
#line 1139
  return;
}
}
#line 1142 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void activate_suitable_timer_5(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 1143
  if (ldv_timer_5_0 == 0 || ldv_timer_5_0 == 2) {
#line 1144
    ldv_timer_list_5_0 = timer;
#line 1145
    ldv_timer_list_5_0->data = data;
#line 1146
    ldv_timer_5_0 = 1;
#line 1147
    return;
  } else {

  }
#line 1149
  if (ldv_timer_5_1 == 0 || ldv_timer_5_1 == 2) {
#line 1150
    ldv_timer_list_5_1 = timer;
#line 1151
    ldv_timer_list_5_1->data = data;
#line 1152
    ldv_timer_5_1 = 1;
#line 1153
    return;
  } else {

  }
#line 1155
  if (ldv_timer_5_2 == 0 || ldv_timer_5_2 == 2) {
#line 1156
    ldv_timer_list_5_2 = timer;
#line 1157
    ldv_timer_list_5_2->data = data;
#line 1158
    ldv_timer_5_2 = 1;
#line 1159
    return;
  } else {

  }
#line 1161
  if (ldv_timer_5_3 == 0 || ldv_timer_5_3 == 2) {
#line 1162
    ldv_timer_list_5_3 = timer;
#line 1163
    ldv_timer_list_5_3->data = data;
#line 1164
    ldv_timer_5_3 = 1;
#line 1165
    return;
  } else {

  }
#line 1167
  return;
}
}
#line 1171 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void activate_suitable_timer_2(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 1172
  if (ldv_timer_2_0 == 0 || ldv_timer_2_0 == 2) {
#line 1173
    ldv_timer_list_2_0 = timer;
#line 1174
    ldv_timer_list_2_0->data = data;
#line 1175
    ldv_timer_2_0 = 1;
#line 1176
    return;
  } else {

  }
#line 1178
  if (ldv_timer_2_1 == 0 || ldv_timer_2_1 == 2) {
#line 1179
    ldv_timer_list_2_1 = timer;
#line 1180
    ldv_timer_list_2_1->data = data;
#line 1181
    ldv_timer_2_1 = 1;
#line 1182
    return;
  } else {

  }
#line 1184
  if (ldv_timer_2_2 == 0 || ldv_timer_2_2 == 2) {
#line 1185
    ldv_timer_list_2_2 = timer;
#line 1186
    ldv_timer_list_2_2->data = data;
#line 1187
    ldv_timer_2_2 = 1;
#line 1188
    return;
  } else {

  }
#line 1190
  if (ldv_timer_2_3 == 0 || ldv_timer_2_3 == 2) {
#line 1191
    ldv_timer_list_2_3 = timer;
#line 1192
    ldv_timer_list_2_3->data = data;
#line 1193
    ldv_timer_2_3 = 1;
#line 1194
    return;
  } else {

  }
#line 1196
  return;
}
}
#line 1200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_timer_3(int state , struct timer_list *timer ) 
{ 


  {
#line 1201
  LDV_IN_INTERRUPT = 2;
#line 1202
  pvr2_hdw_decoder_stabilization_timeout(timer->data);
#line 1203
  LDV_IN_INTERRUPT = 1;
#line 1204
  return;
}
}
#line 1230 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
bool ldv_queue_work_on_215(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 1234
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1234
  ldv_func_res = tmp;
#line 1236
  activate_work_1(ldv_func_arg3, 2);
#line 1238
  return (ldv_func_res);
}
}
#line 1241 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
bool ldv_queue_delayed_work_on_216(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 1245
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1245
  ldv_func_res = tmp;
#line 1247
  activate_work_1(& ldv_func_arg3->work, 2);
#line 1249
  return (ldv_func_res);
}
}
#line 1252 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
bool ldv_queue_work_on_217(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 1256
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1256
  ldv_func_res = tmp;
#line 1258
  activate_work_1(ldv_func_arg3, 2);
#line 1260
  return (ldv_func_res);
}
}
#line 1263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_flush_workqueue_218(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1266
  flush_workqueue(ldv_func_arg1);
#line 1268
  call_and_disable_all_1(2);
#line 1269
  return;
}
}
#line 1271 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
bool ldv_queue_delayed_work_on_219(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1275
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1275
  ldv_func_res = tmp;
#line 1277
  activate_work_1(& ldv_func_arg3->work, 2);
#line 1279
  return (ldv_func_res);
}
}
#line 1282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_220(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1285
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1287
  mutex_lock(ldv_func_arg1);
#line 1288
  return;
}
}
#line 1290 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_221(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1293
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1295
  mutex_unlock(ldv_func_arg1);
#line 1296
  return;
}
}
#line 1298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_222(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1301
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 1303
  mutex_unlock(ldv_func_arg1);
#line 1304
  return;
}
}
#line 1306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_223(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1309
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 1311
  mutex_lock(ldv_func_arg1);
#line 1312
  return;
}
}
#line 1314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_224(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1317
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1319
  mutex_lock(ldv_func_arg1);
#line 1320
  return;
}
}
#line 1322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_mutex_trylock_225(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1326
  tmp = mutex_trylock(ldv_func_arg1);
#line 1326
  ldv_func_res = tmp;
#line 1328
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1328
  return (tmp___0);
#line 1330
  return (ldv_func_res);
}
}
#line 1333 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_226(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1336
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1338
  mutex_unlock(ldv_func_arg1);
#line 1339
  return;
}
}
#line 1341 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_227(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1344
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 1346
  mutex_lock(ldv_func_arg1);
#line 1347
  return;
}
}
#line 1349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_228(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1352
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 1354
  mutex_unlock(ldv_func_arg1);
#line 1355
  return;
}
}
#line 1357 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_229(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
#line 1361
  tmp = del_timer_sync(ldv_func_arg1);
#line 1361
  ldv_func_res = tmp;
#line 1363
  disable_suitable_timer_2(ldv_func_arg1);
#line 1365
  return (ldv_func_res);
}
}
#line 1368 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_230(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1371
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1373
  mutex_lock(ldv_func_arg1);
#line 1374
  return;
}
}
#line 1376 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_231(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1379
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1381
  mutex_unlock(ldv_func_arg1);
#line 1382
  return;
}
}
#line 1384 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_232(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1387
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1389
  mutex_lock(ldv_func_arg1);
#line 1390
  return;
}
}
#line 1392 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_233(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1395
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1397
  mutex_unlock(ldv_func_arg1);
#line 1398
  return;
}
}
#line 1400 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_234(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1403
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1405
  mutex_lock(ldv_func_arg1);
#line 1406
  return;
}
}
#line 1408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_235(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1411
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1413
  mutex_unlock(ldv_func_arg1);
#line 1414
  return;
}
}
#line 1416 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_236(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1419
  ldv_mutex_lock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1421
  mutex_lock(ldv_func_arg1);
#line 1422
  return;
}
}
#line 1424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_237(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1427
  ldv_mutex_unlock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1429
  mutex_unlock(ldv_func_arg1);
#line 1430
  return;
}
}
#line 1432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_238(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1435
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1437
  mutex_lock(ldv_func_arg1);
#line 1438
  return;
}
}
#line 1440 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_239(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1443
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1445
  mutex_unlock(ldv_func_arg1);
#line 1446
  return;
}
}
#line 1448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_240(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1451
  ldv_mutex_lock_pvr2_unit_mtx(ldv_func_arg1);
#line 1453
  mutex_lock(ldv_func_arg1);
#line 1454
  return;
}
}
#line 1456 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_241(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1459
  ldv_mutex_unlock_pvr2_unit_mtx(ldv_func_arg1);
#line 1461
  mutex_unlock(ldv_func_arg1);
#line 1462
  return;
}
}
#line 1464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_242(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
#line 1468
  tmp = del_timer_sync(ldv_func_arg1);
#line 1468
  ldv_func_res = tmp;
#line 1470
  disable_suitable_timer_2(ldv_func_arg1);
#line 1472
  return (ldv_func_res);
}
}
#line 1475 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_243(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 1479
  tmp = del_timer_sync(ldv_func_arg1);
#line 1479
  ldv_func_res = tmp;
#line 1481
  disable_suitable_timer_2(ldv_func_arg1);
#line 1483
  return (ldv_func_res);
}
}
#line 1486 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_244(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 1490
  tmp = del_timer_sync(ldv_func_arg1);
#line 1490
  ldv_func_res = tmp;
#line 1492
  disable_suitable_timer_2(ldv_func_arg1);
#line 1494
  return (ldv_func_res);
}
}
#line 1497 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_245(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
#line 1501
  tmp = del_timer_sync(ldv_func_arg1);
#line 1501
  ldv_func_res = tmp;
#line 1503
  disable_suitable_timer_2(ldv_func_arg1);
#line 1505
  return (ldv_func_res);
}
}
#line 1508 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_flush_workqueue_246(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1511
  flush_workqueue(ldv_func_arg1);
#line 1513
  call_and_disable_all_1(2);
#line 1514
  return;
}
}
#line 1516 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_destroy_workqueue_247(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1519
  destroy_workqueue(ldv_func_arg1);
#line 1521
  call_and_disable_all_1(2);
#line 1522
  return;
}
}
#line 1524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_flush_workqueue_248(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1527
  flush_workqueue(ldv_func_arg1);
#line 1529
  call_and_disable_all_1(2);
#line 1530
  return;
}
}
#line 1532 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_destroy_workqueue_249(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1535
  destroy_workqueue(ldv_func_arg1);
#line 1537
  call_and_disable_all_1(2);
#line 1538
  return;
}
}
#line 1540 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_250(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
#line 1544
  tmp = del_timer_sync(ldv_func_arg1);
#line 1544
  ldv_func_res = tmp;
#line 1546
  disable_suitable_timer_2(ldv_func_arg1);
#line 1548
  return (ldv_func_res);
}
}
#line 1551 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_251(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
#line 1555
  tmp = del_timer_sync(ldv_func_arg1);
#line 1555
  ldv_func_res = tmp;
#line 1557
  disable_suitable_timer_2(ldv_func_arg1);
#line 1559
  return (ldv_func_res);
}
}
#line 1562 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_252(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;

  {
#line 1566
  tmp = del_timer_sync(ldv_func_arg1);
#line 1566
  ldv_func_res = tmp;
#line 1568
  disable_suitable_timer_2(ldv_func_arg1);
#line 1570
  return (ldv_func_res);
}
}
#line 1573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_253(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;

  {
#line 1577
  tmp = del_timer_sync(ldv_func_arg1);
#line 1577
  ldv_func_res = tmp;
#line 1579
  disable_suitable_timer_2(ldv_func_arg1);
#line 1581
  return (ldv_func_res);
}
}
#line 1584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_254(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1587
  ldv_mutex_lock_pvr2_unit_mtx(ldv_func_arg1);
#line 1589
  mutex_lock(ldv_func_arg1);
#line 1590
  return;
}
}
#line 1592 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_255(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1595
  ldv_mutex_unlock_pvr2_unit_mtx(ldv_func_arg1);
#line 1597
  mutex_unlock(ldv_func_arg1);
#line 1598
  return;
}
}
#line 1600 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_256(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1603
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1605
  mutex_lock(ldv_func_arg1);
#line 1606
  return;
}
}
#line 1608 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_257(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1611
  ldv_mutex_lock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1613
  mutex_lock(ldv_func_arg1);
#line 1614
  return;
}
}
#line 1616 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_258(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1619
  ldv_mutex_unlock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1621
  mutex_unlock(ldv_func_arg1);
#line 1622
  return;
}
}
#line 1624 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_259(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1627
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1629
  mutex_unlock(ldv_func_arg1);
#line 1630
  return;
}
}
#line 1632 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_260(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1635
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1637
  mutex_lock(ldv_func_arg1);
#line 1638
  return;
}
}
#line 1640 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_261(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1643
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1645
  mutex_unlock(ldv_func_arg1);
#line 1646
  return;
}
}
#line 1648 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_262(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1651
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1653
  mutex_lock(ldv_func_arg1);
#line 1654
  return;
}
}
#line 1656 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_263(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1659
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1661
  mutex_unlock(ldv_func_arg1);
#line 1662
  return;
}
}
#line 1664 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_264(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1667
  ldv_mutex_lock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1669
  mutex_lock(ldv_func_arg1);
#line 1670
  return;
}
}
#line 1672 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_265(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1675
  ldv_mutex_unlock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1677
  mutex_unlock(ldv_func_arg1);
#line 1678
  return;
}
}
#line 1680 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_266(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1683
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1685
  mutex_lock(ldv_func_arg1);
#line 1686
  return;
}
}
#line 1688 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_267(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1691
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1693
  mutex_unlock(ldv_func_arg1);
#line 1694
  return;
}
}
#line 1696 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_268(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1699
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1701
  mutex_lock(ldv_func_arg1);
#line 1702
  return;
}
}
#line 1704 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_269(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1707
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1709
  mutex_unlock(ldv_func_arg1);
#line 1710
  return;
}
}
#line 1712 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_270(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1715
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1717
  mutex_lock(ldv_func_arg1);
#line 1718
  return;
}
}
#line 1720 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_271(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1723
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1725
  mutex_unlock(ldv_func_arg1);
#line 1726
  return;
}
}
#line 1728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_272(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1731
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1733
  mutex_lock(ldv_func_arg1);
#line 1734
  return;
}
}
#line 1736 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_273(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1739
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1741
  mutex_unlock(ldv_func_arg1);
#line 1742
  return;
}
}
#line 1744 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_274(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1747
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1749
  mutex_lock(ldv_func_arg1);
#line 1750
  return;
}
}
#line 1752 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_275(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1755
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1757
  mutex_unlock(ldv_func_arg1);
#line 1758
  return;
}
}
#line 1760 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_276(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1763
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1765
  mutex_lock(ldv_func_arg1);
#line 1766
  return;
}
}
#line 1768 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_277(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1771
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1773
  mutex_unlock(ldv_func_arg1);
#line 1774
  return;
}
}
#line 1776 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_278(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
#line 1780
  tmp = del_timer_sync(ldv_func_arg1);
#line 1780
  ldv_func_res = tmp;
#line 1782
  disable_suitable_timer_2(ldv_func_arg1);
#line 1784
  return (ldv_func_res);
}
}
#line 1787 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_279(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1790
  ldv_mutex_lock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1792
  mutex_lock(ldv_func_arg1);
#line 1793
  return;
}
}
#line 1795 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_280(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1798
  ldv_mutex_unlock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1800
  mutex_unlock(ldv_func_arg1);
#line 1801
  return;
}
}
#line 1803 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_281(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1806
  ldv_mutex_lock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1808
  mutex_lock(ldv_func_arg1);
#line 1809
  return;
}
}
#line 1811 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_282(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1814
  ldv_mutex_unlock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1816
  mutex_unlock(ldv_func_arg1);
#line 1817
  return;
}
}
#line 1819 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_283(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1822
  ldv_mutex_lock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1824
  mutex_lock(ldv_func_arg1);
#line 1825
  return;
}
}
#line 1827 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_284(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1830
  ldv_mutex_unlock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1832
  mutex_unlock(ldv_func_arg1);
#line 1833
  return;
}
}
#line 1835 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_usb_lock_device_for_reset_285(struct usb_device *ldv_func_arg1 , struct usb_interface  const  *ldv_func_arg2 ) 
{ 
  int tmp ;

  {
#line 1838
  tmp = ldv_usb_lock_device_for_reset_usb_dev_of_pvr2_hdw();
#line 1838
  return (tmp);
}
}
#line 1841 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv___ldv_usb_unlock_device_286(struct usb_device *ldv_func_arg1 ) 
{ 


  {
#line 1844
  __ldv_usb_unlock_device(ldv_func_arg1);
#line 1846
  ldv_usb_unlock_device_usb_dev_of_pvr2_hdw();
#line 1847
  return;
}
}
#line 1849 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_287(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;

  {
#line 1853
  tmp = del_timer_sync(ldv_func_arg1);
#line 1853
  ldv_func_res = tmp;
#line 1855
  disable_suitable_timer_2(ldv_func_arg1);
#line 1857
  return (ldv_func_res);
}
}
#line 1860 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_288(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;

  {
#line 1864
  tmp = del_timer_sync(ldv_func_arg1);
#line 1864
  ldv_func_res = tmp;
#line 1866
  disable_suitable_timer_2(ldv_func_arg1);
#line 1868
  return (ldv_func_res);
}
}
#line 1871 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_289(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___16 ldv_func_res ;
  int tmp ;

  {
#line 1875
  tmp = del_timer_sync(ldv_func_arg1);
#line 1875
  ldv_func_res = tmp;
#line 1877
  disable_suitable_timer_2(ldv_func_arg1);
#line 1879
  return (ldv_func_res);
}
}
#line 1882 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_290(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___17 ldv_func_res ;
  int tmp ;

  {
#line 1886
  tmp = del_timer_sync(ldv_func_arg1);
#line 1886
  ldv_func_res = tmp;
#line 1888
  disable_suitable_timer_2(ldv_func_arg1);
#line 1890
  return (ldv_func_res);
}
}
#line 1893 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_291(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___18 ldv_func_res ;
  int tmp ;

  {
#line 1897
  tmp = del_timer_sync(ldv_func_arg1);
#line 1897
  ldv_func_res = tmp;
#line 1899
  disable_suitable_timer_2(ldv_func_arg1);
#line 1901
  return (ldv_func_res);
}
}
#line 1904 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
int ldv_del_timer_sync_292(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___19 ldv_func_res ;
  int tmp ;

  {
#line 1908
  tmp = del_timer_sync(ldv_func_arg1);
#line 1908
  ldv_func_res = tmp;
#line 1910
  disable_suitable_timer_2(ldv_func_arg1);
#line 1912
  return (ldv_func_res);
}
}
#line 1915 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_293(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1918
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1920
  mutex_lock(ldv_func_arg1);
#line 1921
  return;
}
}
#line 1923 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_294(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1926
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1928
  mutex_unlock(ldv_func_arg1);
#line 1929
  return;
}
}
#line 1931 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_295(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1934
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1936
  mutex_lock(ldv_func_arg1);
#line 1937
  return;
}
}
#line 1939 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_296(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1942
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1944
  mutex_unlock(ldv_func_arg1);
#line 1945
  return;
}
}
#line 1947 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_lock_297(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1950
  ldv_mutex_lock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1952
  mutex_lock(ldv_func_arg1);
#line 1953
  return;
}
}
#line 1955 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-hdw.o.c.prepared"
void ldv_mutex_unlock_298(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1958
  ldv_mutex_unlock_ctl_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 1960
  mutex_unlock(ldv_func_arg1);
#line 1961
  return;
}
}
#line 1 "<compiler builtins>"
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 248 "include/linux/kernel.h"
extern void __might_fault(char const   * , int  ) ;
#line 187 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 189
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_394(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_392(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_395(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_396(struct mutex *ldv_func_arg1 ) ;
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
void ldv_mutex_lock_391(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_393(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_397(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_386(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_388(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_387(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_390(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_389(struct workqueue_struct *ldv_func_arg1 ) ;
#line 652 "./arch/x86/include/asm/uaccess.h"
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 677
extern void __copy_to_user_overflow(void) ;
#line 728 "./arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 730
  tmp = __builtin_object_size(from, 0);
#line 730
  sz = (int )tmp;
#line 732
  __might_fault("./arch/x86/include/asm/uaccess.h", 732);
#line 735
  tmp___0 = ldv__builtin_expect((long )(sz < 0 || (unsigned long )sz >= n), 1L);
#line 735
  if (tmp___0 != 0L) {
#line 736
    n = _copy_to_user(to, from, (unsigned int )n);
  } else {
#line 740
    __copy_to_user_overflow();
  }
#line 742
  return (n);
}
}
#line 86 "include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 832 "include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 835
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 836
    return ((char const   *)dev->init_name);
  } else {

  }
#line 838
  tmp = kobject_name(& dev->kobj);
#line 838
  return (tmp);
}
}
#line 964
extern int device_move(struct device * , struct device * , enum dpm_order  ) ;
#line 73 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-context.h"
void pvr2_channel_init(struct pvr2_channel *cp , struct pvr2_context *mp ) ;
#line 74
void pvr2_channel_done(struct pvr2_channel *cp ) ;
#line 75
int pvr2_channel_limit_inputs(struct pvr2_channel *cp , unsigned int cmsk ) ;
#line 77
int pvr2_channel_claim_stream(struct pvr2_channel *cp , struct pvr2_context_stream *sp ) ;
#line 79
struct pvr2_ioread *pvr2_channel_create_mpeg_stream(struct pvr2_context_stream *sp ) ;
#line 42 "include/linux/poll.h"
__inline static void poll_wait(struct file *filp , wait_queue_head_t *wait_address ,
                               poll_table *p ) 
{ 


  {
#line 44
  if (((unsigned long )p != (unsigned long )((poll_table *)0) && (unsigned long )p->_qproc != (unsigned long )((void (*)(struct file * ,
                                                                                                                         wait_queue_head_t * ,
                                                                                                                         struct poll_table_struct * ))0)) && (unsigned long )wait_address != (unsigned long )((wait_queue_head_t *)0)) {
#line 45
    (*(p->_qproc))(filp, wait_address, p);
  } else {

  }
#line 46
  return;
}
}
#line 149 "include/media/v4l2-dev.h"
extern int __video_register_device(struct video_device * , int  , int  , int  , struct module * ) ;
#line 156 "include/media/v4l2-dev.h"
__inline static int video_register_device(struct video_device *vdev , int type , int nr ) 
{ 
  int tmp ;

  {
#line 159
  tmp = __video_register_device(vdev, type, nr, 1, (vdev->fops)->owner);
#line 159
  return (tmp);
}
}
#line 172
extern void video_unregister_device(struct video_device * ) ;
#line 217
extern struct video_device *video_devdata(struct file * ) ;
#line 226 "include/media/v4l2-dev.h"
__inline static char const   *video_device_node_name(struct video_device *vdev ) 
{ 
  char const   *tmp ;

  {
#line 228
  tmp = dev_name((struct device  const  *)(& vdev->dev));
#line 228
  return (tmp);
}
}
#line 53 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-io.h"
void pvr2_stream_set_callback(struct pvr2_stream *sp , void (*func)(void * ) , void *data ) ;
#line 34 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-ctrl.h"
int pvr2_ctrl_set_value(struct pvr2_ctrl *cptr , int val ) ;
#line 40
int pvr2_ctrl_get_value(struct pvr2_ctrl *cptr , int *valptr ) ;
#line 43
enum pvr2_ctl_type pvr2_ctrl_get_type(struct pvr2_ctrl *cptr ) ;
#line 46
int pvr2_ctrl_get_max(struct pvr2_ctrl *cptr ) ;
#line 49
int pvr2_ctrl_get_min(struct pvr2_ctrl *cptr ) ;
#line 52
int pvr2_ctrl_get_def(struct pvr2_ctrl *cptr , int *valptr ) ;
#line 55
int pvr2_ctrl_get_cnt(struct pvr2_ctrl *cptr ) ;
#line 61
char const   *pvr2_ctrl_get_name(struct pvr2_ctrl *cptr ) ;
#line 64
char const   *pvr2_ctrl_get_desc(struct pvr2_ctrl *cptr ) ;
#line 67
int pvr2_ctrl_get_valname(struct pvr2_ctrl *cptr , int val , char *bptr , unsigned int bmax ,
                          unsigned int *blen ) ;
#line 75
unsigned int pvr2_ctrl_get_v4lflags(struct pvr2_ctrl *cptr ) ;
#line 78
int pvr2_ctrl_get_v4lid(struct pvr2_ctrl *cptr ) ;
#line 28 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-ioread.h"
void pvr2_ioread_destroy(struct pvr2_ioread *cp ) ;
#line 30
struct pvr2_stream *pvr2_ioread_get_stream(struct pvr2_ioread *cp ) ;
#line 34
int pvr2_ioread_set_enabled(struct pvr2_ioread *cp , int fl ) ;
#line 35
int pvr2_ioread_read(struct pvr2_ioread *cp , void *buf , unsigned int cnt ) ;
#line 36
int pvr2_ioread_avail(struct pvr2_ioread *cp ) ;
#line 60 "include/media/v4l2-fh.h"
extern void v4l2_fh_init(struct v4l2_fh * , struct video_device * ) ;
#line 65
extern void v4l2_fh_add(struct v4l2_fh * ) ;
#line 78
extern void v4l2_fh_del(struct v4l2_fh * ) ;
#line 85
extern void v4l2_fh_exit(struct v4l2_fh * ) ;
#line 308 "include/media/v4l2-ioctl.h"
extern void v4l_printk_ioctl(char const   * , unsigned int  ) ;
#line 333
extern long video_ioctl2(struct file * , unsigned int  , unsigned long  ) ;
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int video_nr[20U]  = 
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int radio_nr[20U]  = 
#line 78
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int vbi_nr[20U]  = 
#line 81
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static struct v4l2_fmtdesc pvr_fmtdesc[1U]  = {      {0U, 1U, 1U, {'M', 'P', 'E', 'G', '1', '/', '2', '\000'}, 0U, {0U, 0U, 0U, 0U}}};
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static struct v4l2_format pvr_format[2U]  = {      {1U, {{720U, 576U, 0U, 4U, 0U, 32768U, 0U, 0U, 0U, 0U, 0U, 0U}}}, 
        {4U, {.vbi = {27000000U, 248U, 1443U, 1497715271U, {0, 0}, {0U, 0U}, 0U, {0U,
                                                                               0U}}}}};
#line 141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_querycap(struct file *file , void *priv , struct v4l2_capability *cap ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 143
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 144
  hdw = (fh->channel.mc_head)->hdw;
#line 146
  strlcpy((char *)(& cap->driver), "pvrusb2", 16UL);
#line 147
  tmp = pvr2_hdw_get_bus_info(hdw);
#line 147
  strlcpy((char *)(& cap->bus_info), tmp, 32UL);
#line 149
  tmp___0 = pvr2_hdw_get_desc(hdw);
#line 149
  strlcpy((char *)(& cap->card), tmp___0, 32UL);
#line 150
  cap->capabilities = 2164719617U;
#line 153
  switch ((fh->pdi)->devbase.vfl_type) {
  case 0: 
#line 155
  cap->device_caps = 131073U;
#line 156
  goto ldv_35179;
  case 2: 
#line 158
  cap->device_caps = 262144U;
#line 159
  goto ldv_35179;
  }
  ldv_35179: 
#line 161
  cap->device_caps = cap->device_caps | 16842752U;
#line 162
  return (0);
}
}
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_g_std(struct file *file , void *priv , v4l2_std_id *std ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int val ;
  int ret ;
  struct pvr2_ctrl *tmp ;

  {
#line 167
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 168
  hdw = (fh->channel.mc_head)->hdw;
#line 169
  val = 0;
#line 172
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 2U);
#line 172
  ret = pvr2_ctrl_get_value(tmp, & val);
#line 174
  *std = (v4l2_std_id )val;
#line 175
  return (ret);
}
}
#line 178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_s_std(struct file *file , void *priv , v4l2_std_id std ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct pvr2_ctrl *tmp ;
  int tmp___0 ;

  {
#line 180
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 181
  hdw = (fh->channel.mc_head)->hdw;
#line 183
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 2U);
#line 183
  tmp___0 = pvr2_ctrl_set_value(tmp, (int )std);
#line 183
  return (tmp___0);
}
}
#line 187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_querystd(struct file *file , void *priv , v4l2_std_id *std ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int val ;
  int ret ;
  struct pvr2_ctrl *tmp ;

  {
#line 189
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 190
  hdw = (fh->channel.mc_head)->hdw;
#line 191
  val = 0;
#line 194
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 19U);
#line 194
  ret = pvr2_ctrl_get_value(tmp, & val);
#line 196
  *std = (v4l2_std_id )val;
#line 197
  return (ret);
}
}
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_enum_input(struct file *file , void *priv , struct v4l2_input *vi ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct pvr2_ctrl *cptr ;
  struct v4l2_input tmp ;
  unsigned int cnt ;
  int val ;

  {
#line 202
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 203
  hdw = (fh->channel.mc_head)->hdw;
#line 209
  cptr = pvr2_hdw_get_ctrl_by_id(hdw, 4U);
#line 211
  memset((void *)(& tmp), 0, 80UL);
#line 212
  tmp.index = vi->index;
#line 213
  if (vi->index >= fh->input_cnt) {
#line 214
    return (-22);
  } else {

  }
#line 215
  val = (int )*(fh->input_map + (unsigned long )vi->index);
#line 216
  switch (val) {
  case 0: ;
  case 1: ;
  case 4: 
#line 220
  tmp.type = 1U;
#line 221
  goto ldv_35220;
  case 3: ;
  case 2: 
#line 224
  tmp.type = 2U;
#line 225
  goto ldv_35220;
  default: ;
#line 227
  return (-22);
  }
  ldv_35220: 
#line 230
  cnt = 0U;
#line 231
  pvr2_ctrl_get_valname(cptr, val, (char *)(& tmp.name), 31U, & cnt);
#line 233
  tmp.name[cnt] = 0U;
#line 244
  *vi = tmp;
#line 245
  return (0);
}
}
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_g_input(struct file *file , void *priv , unsigned int *i ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  unsigned int idx ;
  struct pvr2_ctrl *cptr ;
  int val ;
  int ret ;

  {
#line 250
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 251
  hdw = (fh->channel.mc_head)->hdw;
#line 257
  cptr = pvr2_hdw_get_ctrl_by_id(hdw, 4U);
#line 258
  val = 0;
#line 259
  ret = pvr2_ctrl_get_value(cptr, & val);
#line 260
  *i = 0U;
#line 261
  idx = 0U;
#line 261
  goto ldv_35237;
  ldv_35236: ;
#line 262
  if ((int )*(fh->input_map + (unsigned long )idx) == val) {
#line 263
    *i = idx;
#line 264
    goto ldv_35235;
  } else {

  }
#line 261
  idx = idx + 1U;
  ldv_35237: ;
#line 261
  if (fh->input_cnt > idx) {
#line 263
    goto ldv_35236;
  } else {

  }
  ldv_35235: ;
#line 267
  return (ret);
}
}
#line 270 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_s_input(struct file *file , void *priv , unsigned int inp ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct pvr2_ctrl *tmp ;
  int tmp___0 ;

  {
#line 272
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 273
  hdw = (fh->channel.mc_head)->hdw;
#line 275
  if (fh->input_cnt <= inp) {
#line 276
    return (-22);
  } else {

  }
#line 277
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 4U);
#line 277
  tmp___0 = pvr2_ctrl_set_value(tmp, (int )*(fh->input_map + (unsigned long )inp));
#line 277
  return (tmp___0);
}
}
#line 282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_enumaudio(struct file *file , void *priv , struct v4l2_audio *vin ) 
{ 


  {
#line 299
  if (vin->index != 0U) {
#line 300
    return (-22);
  } else {

  }
#line 301
  strncpy((char *)(& vin->name), "PVRUSB2 Audio", 14UL);
#line 302
  vin->capability = 1U;
#line 303
  return (0);
}
}
#line 306 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_g_audio(struct file *file , void *priv , struct v4l2_audio *vin ) 
{ 


  {
#line 309
  vin->index = 0U;
#line 310
  strncpy((char *)(& vin->name), "PVRUSB2 Audio", 14UL);
#line 311
  vin->capability = 1U;
#line 312
  return (0);
}
}
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_s_audio(struct file *file , void *priv , struct v4l2_audio  const  *vout ) 
{ 


  {
#line 317
  if ((unsigned int )vout->index != 0U) {
#line 318
    return (-22);
  } else {

  }
#line 319
  return (0);
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_g_tuner(struct file *file , void *priv , struct v4l2_tuner *vt ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int tmp ;

  {
#line 324
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 325
  hdw = (fh->channel.mc_head)->hdw;
#line 327
  if (vt->index != 0U) {
#line 328
    return (-22);
  } else {

  }
#line 330
  pvr2_hdw_execute_tuner_poll(hdw);
#line 331
  tmp = pvr2_hdw_get_tuner_status(hdw, vt);
#line 331
  return (tmp);
}
}
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_s_tuner(struct file *file , void *priv , struct v4l2_tuner  const  *vt ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct pvr2_ctrl *tmp ;
  int tmp___0 ;

  {
#line 336
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 337
  hdw = (fh->channel.mc_head)->hdw;
#line 339
  if ((unsigned int )vt->index != 0U) {
#line 340
    return (-22);
  } else {

  }
#line 342
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 5U);
#line 342
  tmp___0 = pvr2_ctrl_set_value(tmp, (int )vt->audmode);
#line 342
  return (tmp___0);
}
}
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_s_frequency(struct file *file , void *priv , struct v4l2_frequency  const  *vf ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  unsigned long fv ;
  struct v4l2_tuner vt ;
  int cur_input ;
  struct pvr2_ctrl *ctrlp ;
  int ret ;
  struct pvr2_ctrl *tmp ;
  int tmp___0 ;

  {
#line 349
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 350
  hdw = (fh->channel.mc_head)->hdw;
#line 357
  ret = pvr2_hdw_get_tuner_status(hdw, & vt);
#line 358
  if (ret != 0) {
#line 359
    return (ret);
  } else {

  }
#line 360
  ctrlp = pvr2_hdw_get_ctrl_by_id(hdw, 4U);
#line 361
  ret = pvr2_ctrl_get_value(ctrlp, & cur_input);
#line 362
  if (ret != 0) {
#line 363
    return (ret);
  } else {

  }
#line 364
  if ((unsigned int )vf->type == 1U) {
#line 365
    if (cur_input != 4) {
#line 366
      pvr2_ctrl_set_value(ctrlp, 4);
    } else {

    }
  } else
#line 368
  if (cur_input == 4) {
#line 369
    pvr2_ctrl_set_value(ctrlp, 0);
  } else {

  }
#line 371
  fv = (unsigned long )vf->frequency;
#line 372
  if ((int )vt.capability & 1) {
#line 373
    fv = (fv * 125UL) / 2UL;
  } else {
#line 375
    fv = fv * 62500UL;
  }
#line 376
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 6U);
#line 376
  tmp___0 = pvr2_ctrl_set_value(tmp, (int )fv);
#line 376
  return (tmp___0);
}
}
#line 380 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_g_frequency(struct file *file , void *priv , struct v4l2_frequency *vf ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int val ;
  int cur_input ;
  struct v4l2_tuner vt ;
  int ret ;
  struct pvr2_ctrl *tmp ;
  struct pvr2_ctrl *tmp___0 ;

  {
#line 382
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 383
  hdw = (fh->channel.mc_head)->hdw;
#line 384
  val = 0;
#line 389
  ret = pvr2_hdw_get_tuner_status(hdw, & vt);
#line 390
  if (ret != 0) {
#line 391
    return (ret);
  } else {

  }
#line 392
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 6U);
#line 392
  ret = pvr2_ctrl_get_value(tmp, & val);
#line 395
  if (ret != 0) {
#line 396
    return (ret);
  } else {

  }
#line 397
  tmp___0 = pvr2_hdw_get_ctrl_by_id(hdw, 4U);
#line 397
  pvr2_ctrl_get_value(tmp___0, & cur_input);
#line 400
  if (cur_input == 4) {
#line 401
    vf->type = 1U;
  } else {
#line 403
    vf->type = 2U;
  }
#line 404
  if ((int )vt.capability & 1) {
#line 405
    val = (val * 2) / 125;
  } else {
#line 407
    val = val / 62500;
  }
#line 408
  vf->frequency = (__u32 )val;
#line 409
  return (0);
}
}
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_enum_fmt_vid_cap(struct file *file , void *priv , struct v4l2_fmtdesc *fd ) 
{ 


  {
#line 415
  if (fd->index != 0U) {
#line 416
    return (-22);
  } else {

  }
#line 418
  memcpy((void *)fd, (void const   *)(& pvr_fmtdesc), 64UL);
#line 419
  return (0);
}
}
#line 422 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_g_fmt_vid_cap(struct file *file , void *priv , struct v4l2_format *vf ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int val ;
  struct pvr2_ctrl *tmp ;
  struct pvr2_ctrl *tmp___0 ;

  {
#line 424
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 425
  hdw = (fh->channel.mc_head)->hdw;
#line 428
  memcpy((void *)vf, (void const   *)(& pvr_format), 208UL);
#line 429
  val = 0;
#line 430
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 7U);
#line 430
  pvr2_ctrl_get_value(tmp, & val);
#line 433
  vf->fmt.pix.width = (__u32 )val;
#line 434
  val = 0;
#line 435
  tmp___0 = pvr2_hdw_get_ctrl_by_id(hdw, 8U);
#line 435
  pvr2_ctrl_get_value(tmp___0, & val);
#line 438
  vf->fmt.pix.height = (__u32 )val;
#line 439
  return (0);
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_try_fmt_vid_cap(struct file *file , void *priv , struct v4l2_format *vf ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int lmin ;
  int lmax ;
  int ldef ;
  struct pvr2_ctrl *hcp ;
  struct pvr2_ctrl *vcp ;
  int h ;
  int w ;

  {
#line 444
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 445
  hdw = (fh->channel.mc_head)->hdw;
#line 448
  h = (int )vf->fmt.pix.height;
#line 449
  w = (int )vf->fmt.pix.width;
#line 451
  hcp = pvr2_hdw_get_ctrl_by_id(hdw, 7U);
#line 452
  vcp = pvr2_hdw_get_ctrl_by_id(hdw, 8U);
#line 454
  lmin = pvr2_ctrl_get_min(hcp);
#line 455
  lmax = pvr2_ctrl_get_max(hcp);
#line 456
  pvr2_ctrl_get_def(hcp, & ldef);
#line 457
  if (w == -1) {
#line 458
    w = ldef;
  } else
#line 459
  if (w < lmin) {
#line 460
    w = lmin;
  } else
#line 461
  if (w > lmax) {
#line 462
    w = lmax;
  } else {

  }
#line 463
  lmin = pvr2_ctrl_get_min(vcp);
#line 464
  lmax = pvr2_ctrl_get_max(vcp);
#line 465
  pvr2_ctrl_get_def(vcp, & ldef);
#line 466
  if (h == -1) {
#line 467
    h = ldef;
  } else
#line 468
  if (h < lmin) {
#line 469
    h = lmin;
  } else
#line 470
  if (h > lmax) {
#line 471
    h = lmax;
  } else {

  }
#line 473
  memcpy((void *)vf, (void const   *)(& pvr_format), 208UL);
#line 475
  vf->fmt.pix.width = (__u32 )w;
#line 476
  vf->fmt.pix.height = (__u32 )h;
#line 477
  return (0);
}
}
#line 480 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_s_fmt_vid_cap(struct file *file , void *priv , struct v4l2_format *vf ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct pvr2_ctrl *hcp ;
  struct pvr2_ctrl *vcp ;
  int ret ;
  int tmp ;

  {
#line 482
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 483
  hdw = (fh->channel.mc_head)->hdw;
#line 485
  tmp = pvr2_try_fmt_vid_cap(file, (void *)fh, vf);
#line 485
  ret = tmp;
#line 487
  if (ret != 0) {
#line 488
    return (ret);
  } else {

  }
#line 489
  hcp = pvr2_hdw_get_ctrl_by_id(hdw, 7U);
#line 490
  vcp = pvr2_hdw_get_ctrl_by_id(hdw, 8U);
#line 491
  pvr2_ctrl_set_value(hcp, (int )vf->fmt.pix.width);
#line 492
  pvr2_ctrl_set_value(vcp, (int )vf->fmt.pix.height);
#line 493
  return (0);
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_streamon(struct file *file , void *priv , enum v4l2_buf_type i ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct pvr2_v4l2_dev *pdi ;
  int ret ;
  int tmp ;

  {
#line 498
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 499
  hdw = (fh->channel.mc_head)->hdw;
#line 500
  pdi = fh->pdi;
#line 503
  if ((unsigned long )(fh->pdi)->stream == (unsigned long )((struct pvr2_context_stream *)0)) {
#line 507
    return (-1);
  } else {

  }
#line 509
  ret = pvr2_hdw_set_stream_type(hdw, pdi->config);
#line 510
  if (ret < 0) {
#line 511
    return (ret);
  } else {

  }
#line 512
  tmp = pvr2_hdw_set_streaming(hdw, 1);
#line 512
  return (tmp);
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_streamoff(struct file *file , void *priv , enum v4l2_buf_type i ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int tmp ;

  {
#line 517
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 518
  hdw = (fh->channel.mc_head)->hdw;
#line 520
  if ((unsigned long )(fh->pdi)->stream == (unsigned long )((struct pvr2_context_stream *)0)) {
#line 524
    return (-1);
  } else {

  }
#line 526
  tmp = pvr2_hdw_set_streaming(hdw, 0);
#line 526
  return (tmp);
}
}
#line 529 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_queryctrl(struct file *file , void *priv , struct v4l2_queryctrl *vc ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct pvr2_ctrl *cptr ;
  int val ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  enum pvr2_ctl_type tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
#line 532
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 533
  hdw = (fh->channel.mc_head)->hdw;
#line 537
  if ((int )vc->id < 0) {
#line 538
    cptr = pvr2_hdw_get_ctrl_nextv4l(hdw, vc->id & 2147483647U);
#line 540
    if ((unsigned long )cptr != (unsigned long )((struct pvr2_ctrl *)0)) {
#line 541
      tmp = pvr2_ctrl_get_v4lid(cptr);
#line 541
      vc->id = (__u32 )tmp;
    } else {

    }
  } else {
#line 543
    cptr = pvr2_hdw_get_ctrl_v4l(hdw, vc->id);
  }
#line 545
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 546
    if ((pvrusb2_debug & 2097152) != 0) {
#line 546
      printk("\016pvrusb2: QUERYCTRL id=0x%x not implemented here\n", vc->id);
    } else {

    }
#line 549
    return (-22);
  } else {

  }
#line 552
  if ((pvrusb2_debug & 2097152) != 0) {
#line 552
    tmp___0 = pvr2_ctrl_get_desc(cptr);
#line 552
    tmp___1 = pvr2_ctrl_get_name(cptr);
#line 552
    printk("\016pvrusb2: QUERYCTRL id=0x%x mapping name=%s (%s)\n", vc->id, tmp___1,
           tmp___0);
  } else {

  }
#line 556
  tmp___2 = pvr2_ctrl_get_desc(cptr);
#line 556
  strlcpy((char *)(& vc->name), tmp___2, 32UL);
#line 557
  vc->flags = pvr2_ctrl_get_v4lflags(cptr);
#line 558
  pvr2_ctrl_get_def(cptr, & val);
#line 559
  vc->default_value = val;
#line 560
  tmp___3 = pvr2_ctrl_get_type(cptr);
#line 560
  switch ((unsigned int )tmp___3) {
  case 1U: 
#line 562
  vc->type = 3U;
#line 563
  vc->minimum = 0;
#line 564
  tmp___4 = pvr2_ctrl_get_cnt(cptr);
#line 564
  vc->maximum = tmp___4 + -1;
#line 565
  vc->step = 1;
#line 566
  goto ldv_35360;
  case 3U: 
#line 568
  vc->type = 2U;
#line 569
  vc->minimum = 0;
#line 570
  vc->maximum = 1;
#line 571
  vc->step = 1;
#line 572
  goto ldv_35360;
  case 0U: 
#line 574
  vc->type = 1U;
#line 575
  vc->minimum = pvr2_ctrl_get_min(cptr);
#line 576
  vc->maximum = pvr2_ctrl_get_max(cptr);
#line 577
  vc->step = 1;
#line 578
  goto ldv_35360;
  default: ;
#line 580
  if ((pvrusb2_debug & 2097152) != 0) {
#line 580
    tmp___5 = pvr2_ctrl_get_name(cptr);
#line 580
    printk("\016pvrusb2: QUERYCTRL id=0x%x name=%s not mappable\n", vc->id, tmp___5);
  } else {

  }
#line 583
  return (-22);
  }
  ldv_35360: ;
#line 585
  return (0);
}
}
#line 588 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_querymenu(struct file *file , void *priv , struct v4l2_querymenu *vm ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  unsigned int cnt ;
  int ret ;
  struct pvr2_ctrl *tmp ;

  {
#line 590
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 591
  hdw = (fh->channel.mc_head)->hdw;
#line 592
  cnt = 0U;
#line 595
  tmp = pvr2_hdw_get_ctrl_v4l(hdw, vm->id);
#line 595
  ret = pvr2_ctrl_get_valname(tmp, (int )vm->index, (char *)(& vm->__annonCompField79.name),
                              31U, & cnt);
#line 599
  vm->__annonCompField79.name[cnt] = 0U;
#line 600
  return (ret);
}
}
#line 603 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_g_ctrl(struct file *file , void *priv , struct v4l2_control *vc ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int val ;
  int ret ;
  struct pvr2_ctrl *tmp ;

  {
#line 605
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 606
  hdw = (fh->channel.mc_head)->hdw;
#line 607
  val = 0;
#line 610
  tmp = pvr2_hdw_get_ctrl_v4l(hdw, vc->id);
#line 610
  ret = pvr2_ctrl_get_value(tmp, & val);
#line 612
  vc->value = val;
#line 613
  return (ret);
}
}
#line 616 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_s_ctrl(struct file *file , void *priv , struct v4l2_control *vc ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct pvr2_ctrl *tmp ;
  int tmp___0 ;

  {
#line 618
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 619
  hdw = (fh->channel.mc_head)->hdw;
#line 621
  tmp = pvr2_hdw_get_ctrl_v4l(hdw, vc->id);
#line 621
  tmp___0 = pvr2_ctrl_set_value(tmp, vc->value);
#line 621
  return (tmp___0);
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_g_ext_ctrls(struct file *file , void *priv , struct v4l2_ext_controls *ctls ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct v4l2_ext_control *ctrl ;
  unsigned int idx ;
  int val ;
  int ret ;
  struct pvr2_ctrl *tmp ;

  {
#line 628
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 629
  hdw = (fh->channel.mc_head)->hdw;
#line 635
  ret = 0;
#line 636
  idx = 0U;
#line 636
  goto ldv_35401;
  ldv_35400: 
#line 637
  ctrl = ctls->controls + (unsigned long )idx;
#line 638
  tmp = pvr2_hdw_get_ctrl_v4l(hdw, ctrl->id);
#line 638
  ret = pvr2_ctrl_get_value(tmp, & val);
#line 640
  if (ret != 0) {
#line 641
    ctls->error_idx = idx;
#line 642
    return (ret);
  } else {

  }
#line 646
  ctrl->__annonCompField78.value64 = 0LL;
#line 647
  ctrl->__annonCompField78.value = val;
#line 636
  idx = idx + 1U;
  ldv_35401: ;
#line 636
  if (ctls->count > idx) {
#line 638
    goto ldv_35400;
  } else {

  }

#line 649
  return (0);
}
}
#line 652 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_s_ext_ctrls(struct file *file , void *priv , struct v4l2_ext_controls *ctls ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct v4l2_ext_control *ctrl ;
  unsigned int idx ;
  int ret ;
  struct pvr2_ctrl *tmp ;

  {
#line 655
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 656
  hdw = (fh->channel.mc_head)->hdw;
#line 661
  ret = 0;
#line 662
  idx = 0U;
#line 662
  goto ldv_35414;
  ldv_35413: 
#line 663
  ctrl = ctls->controls + (unsigned long )idx;
#line 664
  tmp = pvr2_hdw_get_ctrl_v4l(hdw, ctrl->id);
#line 664
  ret = pvr2_ctrl_set_value(tmp, ctrl->__annonCompField78.value);
#line 667
  if (ret != 0) {
#line 668
    ctls->error_idx = idx;
#line 669
    return (ret);
  } else {

  }
#line 662
  idx = idx + 1U;
  ldv_35414: ;
#line 662
  if (ctls->count > idx) {
#line 664
    goto ldv_35413;
  } else {

  }

#line 672
  return (0);
}
}
#line 675 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_try_ext_ctrls(struct file *file , void *priv , struct v4l2_ext_controls *ctls ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  struct v4l2_ext_control *ctrl ;
  struct pvr2_ctrl *pctl ;
  unsigned int idx ;

  {
#line 678
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 679
  hdw = (fh->channel.mc_head)->hdw;
#line 686
  idx = 0U;
#line 686
  goto ldv_35427;
  ldv_35426: 
#line 687
  ctrl = ctls->controls + (unsigned long )idx;
#line 688
  pctl = pvr2_hdw_get_ctrl_v4l(hdw, ctrl->id);
#line 689
  if ((unsigned long )pctl == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 690
    ctls->error_idx = idx;
#line 691
    return (-22);
  } else {

  }
#line 686
  idx = idx + 1U;
  ldv_35427: ;
#line 686
  if (ctls->count > idx) {
#line 688
    goto ldv_35426;
  } else {

  }

#line 694
  return (0);
}
}
#line 697 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_cropcap(struct file *file , void *priv , struct v4l2_cropcap *cap ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int ret ;

  {
#line 699
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 700
  hdw = (fh->channel.mc_head)->hdw;
#line 703
  if (cap->type != 1U) {
#line 704
    return (-22);
  } else {

  }
#line 705
  ret = pvr2_hdw_get_cropcap(hdw, cap);
#line 706
  cap->type = 1U;
#line 707
  return (ret);
}
}
#line 710 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_g_crop(struct file *file , void *priv , struct v4l2_crop *crop ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int val ;
  int ret ;
  struct pvr2_ctrl *tmp ;
  struct pvr2_ctrl *tmp___0 ;
  struct pvr2_ctrl *tmp___1 ;
  struct pvr2_ctrl *tmp___2 ;

  {
#line 712
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 713
  hdw = (fh->channel.mc_head)->hdw;
#line 714
  val = 0;
#line 717
  if (crop->type != 1U) {
#line 718
    return (-22);
  } else {

  }
#line 719
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 9U);
#line 719
  ret = pvr2_ctrl_get_value(tmp, & val);
#line 721
  if (ret != 0) {
#line 722
    return (-22);
  } else {

  }
#line 723
  crop->c.left = val;
#line 724
  tmp___0 = pvr2_hdw_get_ctrl_by_id(hdw, 10U);
#line 724
  ret = pvr2_ctrl_get_value(tmp___0, & val);
#line 726
  if (ret != 0) {
#line 727
    return (-22);
  } else {

  }
#line 728
  crop->c.top = val;
#line 729
  tmp___1 = pvr2_hdw_get_ctrl_by_id(hdw, 11U);
#line 729
  ret = pvr2_ctrl_get_value(tmp___1, & val);
#line 731
  if (ret != 0) {
#line 732
    return (-22);
  } else {

  }
#line 733
  crop->c.width = (__u32 )val;
#line 734
  tmp___2 = pvr2_hdw_get_ctrl_by_id(hdw, 12U);
#line 734
  ret = pvr2_ctrl_get_value(tmp___2, & val);
#line 736
  if (ret != 0) {
#line 737
    return (-22);
  } else {

  }
#line 738
  crop->c.height = (__u32 )val;
#line 739
  return (0);
}
}
#line 742 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_s_crop(struct file *file , void *priv , struct v4l2_crop  const  *crop ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  int ret ;
  struct pvr2_ctrl *tmp ;
  struct pvr2_ctrl *tmp___0 ;
  struct pvr2_ctrl *tmp___1 ;
  struct pvr2_ctrl *tmp___2 ;

  {
#line 744
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 745
  hdw = (fh->channel.mc_head)->hdw;
#line 748
  if ((unsigned int )crop->type != 1U) {
#line 749
    return (-22);
  } else {

  }
#line 750
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 9U);
#line 750
  ret = pvr2_ctrl_set_value(tmp, crop->c.left);
#line 753
  if (ret != 0) {
#line 754
    return (-22);
  } else {

  }
#line 755
  tmp___0 = pvr2_hdw_get_ctrl_by_id(hdw, 10U);
#line 755
  ret = pvr2_ctrl_set_value(tmp___0, crop->c.top);
#line 758
  if (ret != 0) {
#line 759
    return (-22);
  } else {

  }
#line 760
  tmp___1 = pvr2_hdw_get_ctrl_by_id(hdw, 11U);
#line 760
  ret = pvr2_ctrl_set_value(tmp___1, (int )crop->c.width);
#line 763
  if (ret != 0) {
#line 764
    return (-22);
  } else {

  }
#line 765
  tmp___2 = pvr2_hdw_get_ctrl_by_id(hdw, 12U);
#line 765
  ret = pvr2_ctrl_set_value(tmp___2, (int )crop->c.height);
#line 768
  if (ret != 0) {
#line 769
    return (-22);
  } else {

  }
#line 770
  return (0);
}
}
#line 773 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_log_status(struct file *file , void *priv ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;

  {
#line 775
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 776
  hdw = (fh->channel.mc_head)->hdw;
#line 778
  pvr2_hdw_trigger_module_log(hdw);
#line 779
  return (0);
}
}
#line 782 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static struct v4l2_ioctl_ops  const  pvr2_ioctl_ops  = 
#line 782
     {& pvr2_querycap, & pvr2_enum_fmt_vid_cap, 0, 0, 0, 0, 0, & pvr2_g_fmt_vid_cap,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & pvr2_s_fmt_vid_cap, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, & pvr2_try_fmt_vid_cap, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, & pvr2_streamon, & pvr2_streamoff, & pvr2_g_std, & pvr2_s_std, & pvr2_querystd,
    & pvr2_enum_input, & pvr2_g_input, & pvr2_s_input, 0, 0, 0, & pvr2_queryctrl,
    0, & pvr2_g_ctrl, & pvr2_s_ctrl, & pvr2_g_ext_ctrls, & pvr2_s_ext_ctrls, & pvr2_try_ext_ctrls,
    & pvr2_querymenu, & pvr2_enumaudio, & pvr2_g_audio, & pvr2_s_audio, 0, 0, 0, 0,
    0, & pvr2_cropcap, & pvr2_g_crop, & pvr2_s_crop, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, & pvr2_g_tuner, & pvr2_s_tuner, & pvr2_g_frequency, & pvr2_s_frequency, 0,
    0, & pvr2_log_status, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 816 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static void pvr2_v4l2_dev_destroy(struct pvr2_v4l2_dev *dip ) 
{ 
  struct pvr2_hdw *hdw ;
  enum pvr2_config cfg ;
  char msg[80U] ;
  unsigned int mcnt ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 818
  hdw = ((dip->v4lp)->channel.mc_head)->hdw;
#line 819
  cfg = dip->config;
#line 826
  tmp = pvr2_config_get_name(cfg);
#line 826
  tmp___0 = video_device_node_name(& dip->devbase);
#line 826
  tmp___1 = scnprintf((char *)(& msg), 79UL, "pvrusb2: unregistered device %s [%s]",
                      tmp___0, tmp);
#line 826
  mcnt = (unsigned int )tmp___1;
#line 830
  msg[mcnt] = 0;
#line 832
  pvr2_hdw_v4l_store_minor_number(hdw, dip->minor_type, -1);
#line 835
  dip->v4lp = (struct pvr2_v4l2 *)0;
#line 836
  dip->stream = (struct pvr2_context_stream *)0;
#line 840
  video_unregister_device(& dip->devbase);
#line 842
  printk("\016%s\n", (char *)(& msg));
#line 843
  return;
}
}
#line 847 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static void pvr2_v4l2_dev_disassociate_parent(struct pvr2_v4l2_dev *dip ) 
{ 


  {
#line 849
  if ((unsigned long )dip == (unsigned long )((struct pvr2_v4l2_dev *)0)) {
#line 849
    return;
  } else {

  }
#line 850
  if ((unsigned long )(dip->devbase.v4l2_dev)->dev == (unsigned long )((struct device *)0)) {
#line 850
    return;
  } else {

  }
#line 851
  (dip->devbase.v4l2_dev)->dev = (struct device *)0;
#line 852
  device_move(& dip->devbase.dev, (struct device *)0, 0);
#line 853
  return;
}
}
#line 856 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static void pvr2_v4l2_destroy_no_lock(struct pvr2_v4l2 *vp ) 
{ 


  {
#line 858
  if ((unsigned long )vp->dev_video != (unsigned long )((struct pvr2_v4l2_dev *)0)) {
#line 859
    pvr2_v4l2_dev_destroy(vp->dev_video);
#line 860
    vp->dev_video = (struct pvr2_v4l2_dev *)0;
  } else {

  }
#line 862
  if ((unsigned long )vp->dev_radio != (unsigned long )((struct pvr2_v4l2_dev *)0)) {
#line 863
    pvr2_v4l2_dev_destroy(vp->dev_radio);
#line 864
    vp->dev_radio = (struct pvr2_v4l2_dev *)0;
  } else {

  }
#line 867
  if ((pvrusb2_debug & 2048) != 0) {
#line 867
    printk("\016pvrusb2: Destroying pvr2_v4l2 id=%p\n", vp);
  } else {

  }
#line 868
  pvr2_channel_done(& vp->channel);
#line 869
  kfree((void const   *)vp);
#line 870
  return;
}
}
#line 873 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static void pvr2_video_device_release(struct video_device *vdev ) 
{ 
  struct pvr2_v4l2_dev *dev ;
  struct video_device  const  *__mptr ;

  {
#line 876
  __mptr = (struct video_device  const  *)vdev;
#line 876
  dev = (struct pvr2_v4l2_dev *)__mptr;
#line 877
  kfree((void const   *)dev);
#line 878
  return;
}
}
#line 881 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static void pvr2_v4l2_internal_check(struct pvr2_channel *chp ) 
{ 
  struct pvr2_v4l2 *vp ;
  struct pvr2_channel  const  *__mptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 884
  __mptr = (struct pvr2_channel  const  *)chp;
#line 884
  vp = (struct pvr2_v4l2 *)__mptr;
#line 885
  if ((vp->channel.mc_head)->disconnect_flag == 0) {
#line 885
    return;
  } else {

  }
#line 886
  pvr2_v4l2_dev_disassociate_parent(vp->dev_video);
#line 887
  pvr2_v4l2_dev_disassociate_parent(vp->dev_radio);
#line 888
  tmp = list_empty((struct list_head  const  *)(& (vp->dev_video)->devbase.fh_list));
#line 888
  if (tmp == 0) {
#line 890
    return;
  } else {
#line 888
    tmp___0 = list_empty((struct list_head  const  *)(& (vp->dev_radio)->devbase.fh_list));
#line 888
    if (tmp___0 == 0) {
#line 890
      return;
    } else {

    }
  }
#line 891
  pvr2_v4l2_destroy_no_lock(vp);
#line 892
  return;
}
}
#line 895 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static long pvr2_v4l2_ioctl(struct file *file , unsigned int cmd , unsigned long arg ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  struct pvr2_hdw *hdw ;
  long ret ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 899
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 900
  hdw = (fh->channel.mc_head)->hdw;
#line 901
  ret = -22L;
#line 903
  if ((pvrusb2_debug & 2097152) != 0) {
#line 904
    tmp = pvr2_hdw_get_driver_name(hdw);
#line 904
    v4l_printk_ioctl(tmp, cmd);
  } else {

  }
#line 906
  tmp___0 = pvr2_hdw_dev_ok(hdw);
#line 906
  if (tmp___0 == 0) {
#line 907
    if ((pvrusb2_debug & 2) != 0) {
#line 907
      printk("\016pvrusb2: ioctl failed - bad or no context\n");
    } else {

    }
#line 909
    return (-14L);
  } else {

  }
#line 912
  ret = video_ioctl2(file, cmd, arg);
#line 914
  pvr2_hdw_commit_ctl(hdw);
#line 916
  if (ret < 0L) {
#line 917
    if ((pvrusb2_debug & 2097152) != 0) {
#line 918
      if ((pvrusb2_debug & 2097152) != 0) {
#line 918
        printk("\016pvrusb2: pvr2_v4l2_do_ioctl failure, ret=%ld command was:\n",
               ret);
      } else {

      }
#line 921
      tmp___1 = pvr2_hdw_get_driver_name(hdw);
#line 921
      v4l_printk_ioctl(tmp___1, cmd);
    } else {

    }
  } else
#line 924
  if ((pvrusb2_debug & 2097152) != 0) {
#line 924
    printk("\016pvrusb2: pvr2_v4l2_do_ioctl complete, ret=%ld (0x%lx)\n", ret, ret);
  } else {

  }
#line 928
  return (ret);
}
}
#line 933 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_v4l2_release(struct file *file ) 
{ 
  struct pvr2_v4l2_fh *fhp ;
  struct pvr2_v4l2 *vp ;
  struct pvr2_hdw *hdw ;
  struct pvr2_stream *sp ;
  int tmp ;
  int tmp___0 ;

  {
#line 935
  fhp = (struct pvr2_v4l2_fh *)file->private_data;
#line 936
  vp = (fhp->pdi)->v4lp;
#line 937
  hdw = (fhp->channel.mc_head)->hdw;
#line 939
  if ((pvrusb2_debug & 4096) != 0) {
#line 939
    printk("\016pvrusb2: pvr2_v4l2_release\n");
  } else {

  }
#line 941
  if ((unsigned long )fhp->rhp != (unsigned long )((struct pvr2_ioread *)0)) {
#line 943
    pvr2_hdw_set_streaming(hdw, 0);
#line 944
    sp = pvr2_ioread_get_stream(fhp->rhp);
#line 945
    if ((unsigned long )sp != (unsigned long )((struct pvr2_stream *)0)) {
#line 945
      pvr2_stream_set_callback(sp, (void (*)(void * ))0, (void *)0);
    } else {

    }
#line 946
    pvr2_ioread_destroy(fhp->rhp);
#line 947
    fhp->rhp = (struct pvr2_ioread *)0;
  } else {

  }
#line 950
  v4l2_fh_del(& fhp->fh);
#line 951
  v4l2_fh_exit(& fhp->fh);
#line 952
  file->private_data = (void *)0;
#line 954
  pvr2_channel_done(& fhp->channel);
#line 955
  if ((pvrusb2_debug & 2048) != 0) {
#line 955
    printk("\016pvrusb2: Destroying pvr_v4l2_fh id=%p\n", fhp);
  } else {

  }
#line 957
  if ((unsigned long )fhp->input_map != (unsigned long )((unsigned char *)0U)) {
#line 958
    kfree((void const   *)fhp->input_map);
#line 959
    fhp->input_map = (unsigned char *)0U;
  } else {

  }
#line 961
  kfree((void const   *)fhp);
#line 962
  if ((vp->channel.mc_head)->disconnect_flag != 0) {
#line 962
    tmp = list_empty((struct list_head  const  *)(& (vp->dev_video)->devbase.fh_list));
#line 962
    if (tmp != 0) {
#line 962
      tmp___0 = list_empty((struct list_head  const  *)(& (vp->dev_radio)->devbase.fh_list));
#line 962
      if (tmp___0 != 0) {
#line 965
        pvr2_v4l2_destroy_no_lock(vp);
      } else {

      }
    } else {

    }
  } else {

  }
#line 967
  return (0);
}
}
#line 971 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_v4l2_open(struct file *file ) 
{ 
  struct pvr2_v4l2_dev *dip ;
  struct pvr2_v4l2_fh *fhp ;
  struct pvr2_v4l2 *vp ;
  struct pvr2_hdw *hdw ;
  unsigned int input_mask ;
  unsigned int input_cnt ;
  unsigned int idx ;
  int ret ;
  struct video_device  const  *__mptr ;
  struct video_device *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  struct lock_class_key __key ;
  unsigned int tmp___2 ;
  void *tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 977
  input_mask = 0U;
#line 979
  ret = 0;
#line 981
  tmp = video_devdata(file);
#line 981
  __mptr = (struct video_device  const  *)tmp;
#line 981
  dip = (struct pvr2_v4l2_dev *)__mptr;
#line 983
  vp = dip->v4lp;
#line 984
  hdw = vp->channel.hdw;
#line 986
  if ((pvrusb2_debug & 4096) != 0) {
#line 986
    printk("\016pvrusb2: pvr2_v4l2_open\n");
  } else {

  }
#line 988
  tmp___0 = pvr2_hdw_dev_ok(hdw);
#line 988
  if (tmp___0 == 0) {
#line 989
    if ((pvrusb2_debug & 4096) != 0) {
#line 989
      printk("\016pvrusb2: pvr2_v4l2_open: hardware not ready\n");
    } else {

    }
#line 991
    return (-5);
  } else {

  }
#line 994
  tmp___1 = kzalloc(368UL, 208U);
#line 994
  fhp = (struct pvr2_v4l2_fh *)tmp___1;
#line 995
  if ((unsigned long )fhp == (unsigned long )((struct pvr2_v4l2_fh *)0)) {
#line 996
    return (-12);
  } else {

  }
#line 999
  v4l2_fh_init(& fhp->fh, & dip->devbase);
#line 1000
  __init_waitqueue_head(& fhp->wait_data, "&fhp->wait_data", & __key);
#line 1001
  fhp->pdi = dip;
#line 1003
  if ((pvrusb2_debug & 2048) != 0) {
#line 1003
    printk("\016pvrusb2: Creating pvr_v4l2_fh id=%p\n", fhp);
  } else {

  }
#line 1004
  pvr2_channel_init(& fhp->channel, vp->channel.mc_head);
#line 1006
  if (dip->v4l_type == 2) {
#line 1009
    input_mask = 16U;
  } else {
#line 1013
    input_mask = 29U;
  }
#line 1018
  ret = pvr2_channel_limit_inputs(& fhp->channel, input_mask);
#line 1019
  if (ret != 0) {
#line 1020
    pvr2_channel_done(& fhp->channel);
#line 1021
    if ((pvrusb2_debug & 2048) != 0) {
#line 1021
      printk("\016pvrusb2: Destroying pvr_v4l2_fh id=%p (input mask error)\n", fhp);
    } else {

    }
#line 1025
    kfree((void const   *)fhp);
#line 1026
    return (ret);
  } else {

  }
#line 1029
  tmp___2 = pvr2_hdw_get_input_available(hdw);
#line 1029
  input_mask = tmp___2 & input_mask;
#line 1030
  input_cnt = 0U;
#line 1031
  idx = 0U;
#line 1031
  goto ldv_35516;
  ldv_35515: ;
#line 1032
  if (((unsigned int )(1 << (int )idx) & input_mask) != 0U) {
#line 1032
    input_cnt = input_cnt + 1U;
  } else {

  }
#line 1031
  idx = idx + 1U;
  ldv_35516: ;
#line 1031
  if (idx <= 31U) {
#line 1033
    goto ldv_35515;
  } else {

  }
#line 1034
  fhp->input_cnt = input_cnt;
#line 1035
  tmp___3 = kzalloc((size_t )input_cnt, 208U);
#line 1035
  fhp->input_map = (unsigned char *)tmp___3;
#line 1036
  if ((unsigned long )fhp->input_map == (unsigned long )((unsigned char *)0U)) {
#line 1037
    pvr2_channel_done(& fhp->channel);
#line 1038
    if ((pvrusb2_debug & 2048) != 0) {
#line 1038
      printk("\016pvrusb2: Destroying pvr_v4l2_fh id=%p (input map failure)\n", fhp);
    } else {

    }
#line 1041
    kfree((void const   *)fhp);
#line 1042
    return (-12);
  } else {

  }
#line 1044
  input_cnt = 0U;
#line 1045
  idx = 0U;
#line 1045
  goto ldv_35520;
  ldv_35519: ;
#line 1046
  if (((unsigned int )(1 << (int )idx) & input_mask) == 0U) {
#line 1046
    goto ldv_35518;
  } else {

  }
#line 1047
  tmp___4 = input_cnt;
#line 1047
  input_cnt = input_cnt + 1U;
#line 1047
  *(fhp->input_map + (unsigned long )tmp___4) = (unsigned char )idx;
  ldv_35518: 
#line 1045
  idx = idx + 1U;
  ldv_35520: ;
#line 1045
  if (idx <= 31U) {
#line 1047
    goto ldv_35519;
  } else {

  }
#line 1050
  fhp->file = file;
#line 1051
  file->private_data = (void *)fhp;
#line 1053
  fhp->fw_mode_flag = pvr2_hdw_cpufw_get_enabled(hdw);
#line 1054
  v4l2_fh_add(& fhp->fh);
#line 1056
  return (0);
}
}
#line 1060 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static void pvr2_v4l2_notify(struct pvr2_v4l2_fh *fhp ) 
{ 


  {
#line 1062
  __wake_up(& fhp->wait_data, 3U, 1, (void *)0);
#line 1063
  return;
}
}
#line 1065 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static int pvr2_v4l2_iosetup(struct pvr2_v4l2_fh *fh ) 
{ 
  int ret ;
  struct pvr2_stream *sp ;
  struct pvr2_hdw *hdw ;
  int tmp ;

  {
#line 1070
  if ((unsigned long )fh->rhp != (unsigned long )((struct pvr2_ioread *)0)) {
#line 1070
    return (0);
  } else {

  }
#line 1072
  if ((unsigned long )(fh->pdi)->stream == (unsigned long )((struct pvr2_context_stream *)0)) {
#line 1075
    return (-1);
  } else {

  }
#line 1080
  ret = pvr2_channel_claim_stream(& fh->channel, (fh->pdi)->stream);
#line 1080
  if (ret != 0) {
#line 1083
    return (ret);
  } else {

  }
#line 1086
  fh->rhp = pvr2_channel_create_mpeg_stream((fh->pdi)->stream);
#line 1087
  if ((unsigned long )fh->rhp == (unsigned long )((struct pvr2_ioread *)0)) {
#line 1088
    pvr2_channel_claim_stream(& fh->channel, (struct pvr2_context_stream *)0);
#line 1089
    return (-12);
  } else {

  }
#line 1092
  hdw = (fh->channel.mc_head)->hdw;
#line 1093
  sp = ((fh->pdi)->stream)->stream;
#line 1094
  pvr2_stream_set_callback(sp, (void (*)(void * ))(& pvr2_v4l2_notify), (void *)fh);
#line 1095
  pvr2_hdw_set_stream_type(hdw, (fh->pdi)->config);
#line 1096
  ret = pvr2_hdw_set_streaming(hdw, 1);
#line 1096
  if (ret < 0) {
#line 1096
    return (ret);
  } else {

  }
#line 1097
  tmp = pvr2_ioread_set_enabled(fh->rhp, 1);
#line 1097
  return (tmp);
}
}
#line 1101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static ssize_t pvr2_v4l2_read(struct file *file , char *buff , size_t count , loff_t *ppos ) 
{ 
  struct pvr2_v4l2_fh *fh ;
  int ret ;
  struct pvr2_hdw *hdw ;
  char *tbuf ;
  int c1 ;
  int c2 ;
  int tcnt ;
  unsigned int offs ;
  void *tmp ;
  unsigned long tmp___0 ;
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1104
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 1107
  if (fh->fw_mode_flag != 0) {
#line 1108
    hdw = (fh->channel.mc_head)->hdw;
#line 1111
    tcnt = 0;
#line 1112
    offs = (unsigned int )*ppos;
#line 1114
    tmp = kmalloc(4096UL, 208U);
#line 1114
    tbuf = (char *)tmp;
#line 1115
    if ((unsigned long )tbuf == (unsigned long )((char *)0)) {
#line 1115
      return (-12L);
    } else {

    }
#line 1117
    goto ldv_35547;
    ldv_35546: 
#line 1118
    c1 = (int )count;
#line 1119
    if ((unsigned int )c1 > 4096U) {
#line 1119
      c1 = 4096;
    } else {

    }
#line 1120
    c2 = pvr2_hdw_cpufw_get(hdw, offs, tbuf, (unsigned int )c1);
#line 1121
    if (c2 < 0) {
#line 1122
      tcnt = c2;
#line 1123
      goto ldv_35545;
    } else {

    }
#line 1125
    if (c2 == 0) {
#line 1125
      goto ldv_35545;
    } else {

    }
#line 1126
    tmp___0 = copy_to_user((void *)buff, (void const   *)tbuf, (unsigned long )c2);
#line 1126
    if (tmp___0 != 0UL) {
#line 1127
      tcnt = -14;
#line 1128
      goto ldv_35545;
    } else {

    }
#line 1130
    offs = offs + (unsigned int )c2;
#line 1131
    tcnt = tcnt + c2;
#line 1132
    buff = buff + (unsigned long )c2;
#line 1133
    count = count - (size_t )c2;
#line 1134
    *ppos = *ppos + (loff_t )c2;
    ldv_35547: ;
#line 1117
    if (count != 0UL) {
#line 1119
      goto ldv_35546;
    } else {

    }
    ldv_35545: 
#line 1136
    kfree((void const   *)tbuf);
#line 1137
    return ((ssize_t )tcnt);
  } else {

  }
#line 1140
  if ((unsigned long )fh->rhp == (unsigned long )((struct pvr2_ioread *)0)) {
#line 1141
    ret = pvr2_v4l2_iosetup(fh);
#line 1142
    if (ret != 0) {
#line 1143
      return ((ssize_t )ret);
    } else {

    }
  } else {

  }
  ldv_35558: 
#line 1148
  ret = pvr2_ioread_read(fh->rhp, (void *)buff, (unsigned int )count);
#line 1149
  if (ret >= 0) {
#line 1149
    goto ldv_35548;
  } else {

  }
#line 1150
  if (ret != -11) {
#line 1150
    goto ldv_35548;
  } else {

  }
#line 1151
  if ((file->f_flags & 2048U) != 0U) {
#line 1151
    goto ldv_35548;
  } else {

  }
#line 1153
  __ret = 0;
#line 1153
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c",
                1155, 0);
#line 1153
  tmp___3 = pvr2_ioread_avail(fh->rhp);
#line 1153
  if (tmp___3 < 0) {
#line 1153
    __ret___0 = 0L;
#line 1153
    INIT_LIST_HEAD(& __wait.task_list);
#line 1153
    __wait.flags = 0U;
    ldv_35555: 
#line 1153
    tmp___1 = prepare_to_wait_event(& fh->wait_data, & __wait, 1);
#line 1153
    __int = tmp___1;
#line 1153
    tmp___2 = pvr2_ioread_avail(fh->rhp);
#line 1153
    if (tmp___2 >= 0) {
#line 1153
      goto ldv_35554;
    } else {

    }
#line 1153
    if (__int != 0L) {
#line 1153
      __ret___0 = __int;
#line 1153
      goto ldv_35554;
    } else {

    }
#line 1153
    schedule();
#line 1153
    goto ldv_35555;
    ldv_35554: 
#line 1153
    finish_wait(& fh->wait_data, & __wait);
#line 1153
    __ret = (int )__ret___0;
  } else {

  }
#line 1153
  ret = __ret;
#line 1156
  if (ret < 0) {
#line 1156
    goto ldv_35548;
  } else {

  }
#line 1157
  goto ldv_35558;
  ldv_35548: ;
#line 1159
  return ((ssize_t )ret);
}
}
#line 1163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static unsigned int pvr2_v4l2_poll(struct file *file , poll_table *wait ) 
{ 
  unsigned int mask ;
  struct pvr2_v4l2_fh *fh ;
  int ret ;
  int tmp ;

  {
#line 1165
  mask = 0U;
#line 1166
  fh = (struct pvr2_v4l2_fh *)file->private_data;
#line 1169
  if (fh->fw_mode_flag != 0) {
#line 1170
    mask = mask | 65U;
#line 1171
    return (mask);
  } else {

  }
#line 1174
  if ((unsigned long )fh->rhp == (unsigned long )((struct pvr2_ioread *)0)) {
#line 1175
    ret = pvr2_v4l2_iosetup(fh);
#line 1176
    if (ret != 0) {
#line 1176
      return (8U);
    } else {

    }
  } else {

  }
#line 1179
  poll_wait(file, & fh->wait_data, wait);
#line 1181
  tmp = pvr2_ioread_avail(fh->rhp);
#line 1181
  if (tmp >= 0) {
#line 1182
    mask = mask | 65U;
  } else {

  }
#line 1185
  return (mask);
}
}
#line 1189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static struct v4l2_file_operations  const  vdev_fops  = 
#line 1189
     {& __this_module, & pvr2_v4l2_read, 0, & pvr2_v4l2_poll, & pvr2_v4l2_ioctl, 0,
    0, 0, & pvr2_v4l2_open, & pvr2_v4l2_release};
#line 1199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static struct video_device vdev_template  = 
#line 1199
     {{{0, 0}, 0, 0U, 0, 0U, 0U, 0UL, 0U, (unsigned short)0, (unsigned short)0, (unsigned short)0,
     (unsigned short)0, 0, 0, 0, 0, 0, 0, {{0U, 0U}}}, & vdev_fops, {0, 0, {0, {0,
                                                                                0},
                                                                            0, 0,
                                                                            0, 0,
                                                                            {{0}},
                                                                            {{{0L},
                                                                              {0,
                                                                               0},
                                                                              0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}},
                                                                             {{0,
                                                                               0},
                                                                              0UL,
                                                                              0, 0UL,
                                                                              0U,
                                                                              0, 0,
                                                                              0, {(char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0},
                                                                              {0,
                                                                               {0,
                                                                                0},
                                                                               0,
                                                                               0,
                                                                               0UL}},
                                                                             0, 0},
                                                                            (unsigned char)0,
                                                                            (unsigned char)0,
                                                                            (unsigned char)0,
                                                                            (unsigned char)0,
                                                                            (unsigned char)0},
                                                                     0, 0, {{0}, {{{{{0}},
                                                                                    0U,
                                                                                    0U,
                                                                                    0,
                                                                                    {0,
                                                                                     {0,
                                                                                      0},
                                                                                     0,
                                                                                     0,
                                                                                     0UL}}}},
                                                                            {0, 0},
                                                                            0, 0,
                                                                            {0, {0,
                                                                                 0},
                                                                             0, 0,
                                                                             0UL}},
                                                                     0, 0, 0, 0, {{0},
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  {{{{{0}},
                                                                                     0U,
                                                                                     0U,
                                                                                     0,
                                                                                     {0,
                                                                                      {0,
                                                                                       0},
                                                                                      0,
                                                                                      0,
                                                                                      0UL}}}},
                                                                                  {0,
                                                                                   0},
                                                                                  {0U,
                                                                                   {{{{{{0}},
                                                                                       0U,
                                                                                       0U,
                                                                                       0,
                                                                                       {0,
                                                                                        {0,
                                                                                         0},
                                                                                        0,
                                                                                        0,
                                                                                        0UL}}}},
                                                                                    {0,
                                                                                     0}}},
                                                                                  0,
                                                                                  (_Bool)0,
                                                                                  (_Bool)0,
                                                                                  {{0,
                                                                                    0},
                                                                                   0UL,
                                                                                   0,
                                                                                   0UL,
                                                                                   0U,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   {(char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0,
                                                                                    (char)0},
                                                                                   {0,
                                                                                    {0,
                                                                                     0},
                                                                                    0,
                                                                                    0,
                                                                                    0UL}},
                                                                                  0UL,
                                                                                  {{0L},
                                                                                   {0,
                                                                                    0},
                                                                                   0,
                                                                                   {0,
                                                                                    {0,
                                                                                     0},
                                                                                    0,
                                                                                    0,
                                                                                    0UL}},
                                                                                  {{{{{{0}},
                                                                                      0U,
                                                                                      0U,
                                                                                      0,
                                                                                      {0,
                                                                                       {0,
                                                                                        0},
                                                                                       0,
                                                                                       0,
                                                                                       0UL}}}},
                                                                                   {0,
                                                                                    0}},
                                                                                  0,
                                                                                  {0},
                                                                                  {0},
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  (unsigned char)0,
                                                                                  0,
                                                                                  0,
                                                                                  0,
                                                                                  0,
                                                                                  0UL,
                                                                                  0UL,
                                                                                  0UL,
                                                                                  0UL,
                                                                                  0,
                                                                                  0,
                                                                                  0},
                                                                     0, 0, 0, 0, 0ULL,
                                                                     0UL, 0, {0, 0},
                                                                     0, 0, {0, 0},
                                                                     0, 0, 0U, 0U,
                                                                     {{{{{0}}, 0U,
                                                                        0U, 0, {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}}}},
                                                                     {0, 0}, {0, {0,
                                                                                  0},
                                                                              {{0}}},
                                                                     0, 0, 0, 0, (_Bool)0,
                                                                     (_Bool)0}, 0,
    0, 0, 0, 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                    (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                    (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                    (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                    (char)0, (char)0, (char)0, (char)0}, 0, 0, 0, (unsigned short)0,
    0UL, 0, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 0ULL, 0, 0,
    {0UL, 0UL, 0UL}, {0UL, 0UL, 0UL}, 0};
#line 1204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
static void pvr2_v4l2_dev_init(struct pvr2_v4l2_dev *dip , struct pvr2_v4l2 *vp ,
                               int v4l_type ) 
{ 
  int mindevnum ;
  int unit_number ;
  struct pvr2_hdw *hdw ;
  int *nr_ptr ;
  int val ;
  struct pvr2_ctrl *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 1211
  nr_ptr = (int *)0;
#line 1212
  dip->v4lp = vp;
#line 1214
  hdw = (vp->channel.mc_head)->hdw;
#line 1215
  dip->v4l_type = v4l_type;
#line 1216
  switch (v4l_type) {
  case 0: 
#line 1218
  dip->stream = & (vp->channel.mc_head)->video_stream;
#line 1219
  dip->config = 1;
#line 1220
  dip->minor_type = 0;
#line 1221
  nr_ptr = (int *)(& video_nr);
#line 1222
  if ((unsigned long )dip->stream == (unsigned long )((struct pvr2_context_stream *)0)) {
#line 1223
    printk("\vpvrusb2: Failed to set up pvrusb2 v4l video dev due to missing stream instance\n");
#line 1226
    return;
  } else {

  }
#line 1228
  goto ldv_35578;
  case 1: 
#line 1230
  dip->config = 2;
#line 1231
  dip->minor_type = 1;
#line 1232
  nr_ptr = (int *)(& vbi_nr);
#line 1233
  goto ldv_35578;
  case 2: 
#line 1235
  dip->stream = & (vp->channel.mc_head)->video_stream;
#line 1236
  dip->config = 1;
#line 1237
  dip->minor_type = 2;
#line 1238
  nr_ptr = (int *)(& radio_nr);
#line 1239
  goto ldv_35578;
  default: 
#line 1242
  printk("\vpvrusb2: Failed to set up pvrusb2 v4l dev due to unrecognized config\n");
#line 1244
  return;
  }
  ldv_35578: 
#line 1247
  dip->devbase = vdev_template;
#line 1248
  dip->devbase.release = & pvr2_video_device_release;
#line 1249
  dip->devbase.ioctl_ops = & pvr2_ioctl_ops;
#line 1252
  tmp = pvr2_hdw_get_ctrl_by_id(hdw, 3U);
#line 1252
  pvr2_ctrl_get_value(tmp, & val);
#line 1255
  dip->devbase.tvnorms = (unsigned long long )val;
#line 1258
  mindevnum = -1;
#line 1259
  unit_number = pvr2_hdw_get_unit_number(hdw);
#line 1260
  if (((unsigned long )nr_ptr != (unsigned long )((int *)0) && unit_number >= 0) && unit_number <= 19) {
#line 1261
    mindevnum = *(nr_ptr + (unsigned long )unit_number);
  } else {

  }
#line 1263
  pvr2_hdw_set_v4l2_dev(hdw, & dip->devbase);
#line 1264
  tmp___0 = video_register_device(& dip->devbase, dip->v4l_type, mindevnum);
#line 1264
  if (tmp___0 < 0) {
#line 1264
    tmp___1 = video_register_device(& dip->devbase, dip->v4l_type, -1);
#line 1264
    if (tmp___1 < 0) {
#line 1268
      printk("\vpvrusb2: Failed to register pvrusb2 v4l device\n");
    } else {

    }
  } else {

  }
#line 1272
  tmp___2 = pvr2_config_get_name(dip->config);
#line 1272
  tmp___3 = video_device_node_name(& dip->devbase);
#line 1272
  printk("\016pvrusb2: registered device %s [%s]\n", tmp___3, tmp___2);
#line 1276
  pvr2_hdw_v4l_store_minor_number(hdw, dip->minor_type, dip->devbase.minor);
#line 1278
  return;
}
}
#line 1281 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.c"
struct pvr2_v4l2 *pvr2_v4l2_create(struct pvr2_context *mnp ) 
{ 
  struct pvr2_v4l2 *vp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 1285
  tmp = kzalloc(72UL, 208U);
#line 1285
  vp = (struct pvr2_v4l2 *)tmp;
#line 1286
  if ((unsigned long )vp == (unsigned long )((struct pvr2_v4l2 *)0)) {
#line 1286
    return (vp);
  } else {

  }
#line 1287
  pvr2_channel_init(& vp->channel, mnp);
#line 1288
  if ((pvrusb2_debug & 2048) != 0) {
#line 1288
    printk("\016pvrusb2: Creating pvr2_v4l2 id=%p\n", vp);
  } else {

  }
#line 1290
  vp->channel.check_func = & pvr2_v4l2_internal_check;
#line 1293
  tmp___0 = kzalloc(1864UL, 208U);
#line 1293
  vp->dev_video = (struct pvr2_v4l2_dev *)tmp___0;
#line 1294
  if ((unsigned long )vp->dev_video == (unsigned long )((struct pvr2_v4l2_dev *)0)) {
#line 1294
    goto fail;
  } else {

  }
#line 1295
  pvr2_v4l2_dev_init(vp->dev_video, vp, 0);
#line 1296
  tmp___2 = pvr2_hdw_get_input_available((vp->channel.mc_head)->hdw);
#line 1296
  if ((tmp___2 & 16U) != 0U) {
#line 1298
    tmp___1 = kzalloc(1864UL, 208U);
#line 1298
    vp->dev_radio = (struct pvr2_v4l2_dev *)tmp___1;
#line 1299
    if ((unsigned long )vp->dev_radio == (unsigned long )((struct pvr2_v4l2_dev *)0)) {
#line 1299
      goto fail;
    } else {

    }
#line 1300
    pvr2_v4l2_dev_init(vp->dev_radio, vp, 2);
  } else {

  }
#line 1303
  return (vp);
  fail: ;
#line 1305
  if ((pvrusb2_debug & 2048) != 0) {
#line 1305
    printk("\016pvrusb2: Failure creating pvr2_v4l2 id=%p\n", vp);
  } else {

  }
#line 1306
  pvr2_v4l2_destroy_no_lock(vp);
#line 1307
  return ((struct pvr2_v4l2 *)0);
}
}
#line 326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
int ldv_retval_1  ;
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
void ldv_initialize_v4l2_file_operations_12(void) 
{ 
  void *tmp ;

  {
#line 330
  tmp = __VERIFIER_nondet_pointer();
#line 330
  vdev_fops_group0 = (struct file *)tmp;
#line 331
  return;
}
}
#line 333 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
void ldv_initialize_v4l2_ioctl_ops_13(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 334
  tmp = ldv_init_zalloc(8UL);
#line 334
  pvr2_ioctl_ops_group4 = (struct v4l2_control *)tmp;
#line 335
  tmp___0 = ldv_init_zalloc(208UL);
#line 335
  pvr2_ioctl_ops_group3 = (struct v4l2_format *)tmp___0;
#line 336
  tmp___1 = ldv_init_zalloc(52UL);
#line 336
  pvr2_ioctl_ops_group1 = (struct v4l2_audio *)tmp___1;
#line 337
  tmp___2 = ldv_init_zalloc(32UL);
#line 337
  pvr2_ioctl_ops_group0 = (struct v4l2_ext_controls *)tmp___2;
#line 338
  tmp___3 = __VERIFIER_nondet_pointer();
#line 338
  pvr2_ioctl_ops_group2 = (struct file *)tmp___3;
#line 339
  return;
}
}
#line 341 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
void ldv_main_exported_13(void) 
{ 
  unsigned int *ldvarg19 ;
  void *tmp ;
  void *ldvarg22 ;
  void *tmp___0 ;
  void *ldvarg25 ;
  void *tmp___1 ;
  void *ldvarg17 ;
  void *tmp___2 ;
  struct v4l2_frequency *ldvarg21 ;
  void *tmp___3 ;
  struct v4l2_fmtdesc *ldvarg30 ;
  void *tmp___4 ;
  void *ldvarg15 ;
  void *tmp___5 ;
  void *ldvarg27 ;
  void *tmp___6 ;
  void *ldvarg26 ;
  void *tmp___7 ;
  struct v4l2_querymenu *ldvarg45 ;
  void *tmp___8 ;
  void *ldvarg9 ;
  void *tmp___9 ;
  void *ldvarg40 ;
  void *tmp___10 ;
  struct v4l2_input *ldvarg10 ;
  void *tmp___11 ;
  struct v4l2_crop *ldvarg36 ;
  void *tmp___12 ;
  void *ldvarg13 ;
  void *tmp___13 ;
  void *ldvarg8 ;
  void *tmp___14 ;
  void *ldvarg49 ;
  void *tmp___15 ;
  struct v4l2_audio *ldvarg3 ;
  void *tmp___16 ;
  v4l2_std_id ldvarg41 ;
  void *ldvarg31 ;
  void *tmp___17 ;
  void *ldvarg20 ;
  void *tmp___18 ;
  struct v4l2_tuner *ldvarg39 ;
  void *tmp___19 ;
  void *ldvarg47 ;
  void *tmp___20 ;
  void *ldvarg2 ;
  void *tmp___21 ;
  v4l2_std_id *ldvarg28 ;
  void *tmp___22 ;
  enum v4l2_buf_type ldvarg34 ;
  struct v4l2_frequency *ldvarg14 ;
  void *tmp___23 ;
  void *ldvarg4 ;
  void *tmp___24 ;
  struct v4l2_tuner *ldvarg48 ;
  void *tmp___25 ;
  void *ldvarg6 ;
  void *tmp___26 ;
  struct v4l2_capability *ldvarg16 ;
  void *tmp___27 ;
  void *ldvarg33 ;
  void *tmp___28 ;
  unsigned int ldvarg5 ;
  void *ldvarg38 ;
  void *tmp___29 ;
  enum v4l2_buf_type ldvarg0 ;
  void *ldvarg35 ;
  void *tmp___30 ;
  struct v4l2_cropcap *ldvarg24 ;
  void *tmp___31 ;
  void *ldvarg44 ;
  void *tmp___32 ;
  void *ldvarg29 ;
  void *tmp___33 ;
  void *ldvarg37 ;
  void *tmp___34 ;
  void *ldvarg1 ;
  void *tmp___35 ;
  void *ldvarg46 ;
  void *tmp___36 ;
  void *ldvarg50 ;
  void *tmp___37 ;
  v4l2_std_id *ldvarg12 ;
  void *tmp___38 ;
  void *ldvarg42 ;
  void *tmp___39 ;
  void *ldvarg43 ;
  void *tmp___40 ;
  void *ldvarg23 ;
  void *tmp___41 ;
  struct v4l2_crop *ldvarg7 ;
  void *tmp___42 ;
  struct v4l2_queryctrl *ldvarg32 ;
  void *tmp___43 ;
  void *ldvarg11 ;
  void *tmp___44 ;
  void *ldvarg18 ;
  void *tmp___45 ;
  int tmp___46 ;

  {
#line 342
  tmp = ldv_init_zalloc(4UL);
#line 342
  ldvarg19 = (unsigned int *)tmp;
#line 343
  tmp___0 = ldv_init_zalloc(1UL);
#line 343
  ldvarg22 = tmp___0;
#line 344
  tmp___1 = ldv_init_zalloc(1UL);
#line 344
  ldvarg25 = tmp___1;
#line 345
  tmp___2 = ldv_init_zalloc(1UL);
#line 345
  ldvarg17 = tmp___2;
#line 346
  tmp___3 = ldv_init_zalloc(44UL);
#line 346
  ldvarg21 = (struct v4l2_frequency *)tmp___3;
#line 347
  tmp___4 = ldv_init_zalloc(64UL);
#line 347
  ldvarg30 = (struct v4l2_fmtdesc *)tmp___4;
#line 348
  tmp___5 = ldv_init_zalloc(1UL);
#line 348
  ldvarg15 = tmp___5;
#line 349
  tmp___6 = ldv_init_zalloc(1UL);
#line 349
  ldvarg27 = tmp___6;
#line 350
  tmp___7 = ldv_init_zalloc(1UL);
#line 350
  ldvarg26 = tmp___7;
#line 351
  tmp___8 = ldv_init_zalloc(44UL);
#line 351
  ldvarg45 = (struct v4l2_querymenu *)tmp___8;
#line 352
  tmp___9 = ldv_init_zalloc(1UL);
#line 352
  ldvarg9 = tmp___9;
#line 353
  tmp___10 = ldv_init_zalloc(1UL);
#line 353
  ldvarg40 = tmp___10;
#line 354
  tmp___11 = ldv_init_zalloc(80UL);
#line 354
  ldvarg10 = (struct v4l2_input *)tmp___11;
#line 355
  tmp___12 = ldv_init_zalloc(20UL);
#line 355
  ldvarg36 = (struct v4l2_crop *)tmp___12;
#line 356
  tmp___13 = ldv_init_zalloc(1UL);
#line 356
  ldvarg13 = tmp___13;
#line 357
  tmp___14 = ldv_init_zalloc(1UL);
#line 357
  ldvarg8 = tmp___14;
#line 358
  tmp___15 = ldv_init_zalloc(1UL);
#line 358
  ldvarg49 = tmp___15;
#line 359
  tmp___16 = ldv_init_zalloc(52UL);
#line 359
  ldvarg3 = (struct v4l2_audio *)tmp___16;
#line 361
  tmp___17 = ldv_init_zalloc(1UL);
#line 361
  ldvarg31 = tmp___17;
#line 362
  tmp___18 = ldv_init_zalloc(1UL);
#line 362
  ldvarg20 = tmp___18;
#line 363
  tmp___19 = ldv_init_zalloc(84UL);
#line 363
  ldvarg39 = (struct v4l2_tuner *)tmp___19;
#line 364
  tmp___20 = ldv_init_zalloc(1UL);
#line 364
  ldvarg47 = tmp___20;
#line 365
  tmp___21 = ldv_init_zalloc(1UL);
#line 365
  ldvarg2 = tmp___21;
#line 366
  tmp___22 = ldv_init_zalloc(8UL);
#line 366
  ldvarg28 = (v4l2_std_id *)tmp___22;
#line 368
  tmp___23 = ldv_init_zalloc(44UL);
#line 368
  ldvarg14 = (struct v4l2_frequency *)tmp___23;
#line 369
  tmp___24 = ldv_init_zalloc(1UL);
#line 369
  ldvarg4 = tmp___24;
#line 370
  tmp___25 = ldv_init_zalloc(84UL);
#line 370
  ldvarg48 = (struct v4l2_tuner *)tmp___25;
#line 371
  tmp___26 = ldv_init_zalloc(1UL);
#line 371
  ldvarg6 = tmp___26;
#line 372
  tmp___27 = ldv_init_zalloc(104UL);
#line 372
  ldvarg16 = (struct v4l2_capability *)tmp___27;
#line 373
  tmp___28 = ldv_init_zalloc(1UL);
#line 373
  ldvarg33 = tmp___28;
#line 375
  tmp___29 = ldv_init_zalloc(1UL);
#line 375
  ldvarg38 = tmp___29;
#line 377
  tmp___30 = ldv_init_zalloc(1UL);
#line 377
  ldvarg35 = tmp___30;
#line 378
  tmp___31 = ldv_init_zalloc(44UL);
#line 378
  ldvarg24 = (struct v4l2_cropcap *)tmp___31;
#line 379
  tmp___32 = ldv_init_zalloc(1UL);
#line 379
  ldvarg44 = tmp___32;
#line 380
  tmp___33 = ldv_init_zalloc(1UL);
#line 380
  ldvarg29 = tmp___33;
#line 381
  tmp___34 = ldv_init_zalloc(1UL);
#line 381
  ldvarg37 = tmp___34;
#line 382
  tmp___35 = ldv_init_zalloc(1UL);
#line 382
  ldvarg1 = tmp___35;
#line 383
  tmp___36 = ldv_init_zalloc(1UL);
#line 383
  ldvarg46 = tmp___36;
#line 384
  tmp___37 = ldv_init_zalloc(1UL);
#line 384
  ldvarg50 = tmp___37;
#line 385
  tmp___38 = ldv_init_zalloc(8UL);
#line 385
  ldvarg12 = (v4l2_std_id *)tmp___38;
#line 386
  tmp___39 = ldv_init_zalloc(1UL);
#line 386
  ldvarg42 = tmp___39;
#line 387
  tmp___40 = ldv_init_zalloc(1UL);
#line 387
  ldvarg43 = tmp___40;
#line 388
  tmp___41 = ldv_init_zalloc(1UL);
#line 388
  ldvarg23 = tmp___41;
#line 389
  tmp___42 = ldv_init_zalloc(20UL);
#line 389
  ldvarg7 = (struct v4l2_crop *)tmp___42;
#line 390
  tmp___43 = ldv_init_zalloc(68UL);
#line 390
  ldvarg32 = (struct v4l2_queryctrl *)tmp___43;
#line 391
  tmp___44 = ldv_init_zalloc(1UL);
#line 391
  ldvarg11 = tmp___44;
#line 392
  tmp___45 = ldv_init_zalloc(1UL);
#line 392
  ldvarg18 = tmp___45;
#line 360
  ldv_memset((void *)(& ldvarg41), 0, 8UL);
#line 367
  ldv_memset((void *)(& ldvarg34), 0, 4UL);
#line 374
  ldv_memset((void *)(& ldvarg5), 0, 4UL);
#line 376
  ldv_memset((void *)(& ldvarg0), 0, 4UL);
#line 394
  tmp___46 = __VERIFIER_nondet_int();
#line 394
  switch (tmp___46) {
  case 0: ;
#line 397
  if (ldv_state_variable_13 == 1) {
#line 399
    pvr2_s_ctrl(pvr2_ioctl_ops_group2, ldvarg50, pvr2_ioctl_ops_group4);
#line 401
    ldv_state_variable_13 = 1;
  } else {

  }
#line 404
  goto ldv_35650;
  case 1: ;
#line 407
  if (ldv_state_variable_13 == 1) {
#line 409
    pvr2_g_tuner(pvr2_ioctl_ops_group2, ldvarg49, ldvarg48);
#line 411
    ldv_state_variable_13 = 1;
  } else {

  }
#line 414
  goto ldv_35650;
  case 2: ;
#line 417
  if (ldv_state_variable_13 == 1) {
#line 419
    pvr2_g_ext_ctrls(pvr2_ioctl_ops_group2, ldvarg47, pvr2_ioctl_ops_group0);
#line 421
    ldv_state_variable_13 = 1;
  } else {

  }
#line 424
  goto ldv_35650;
  case 3: ;
#line 427
  if (ldv_state_variable_13 == 1) {
#line 429
    pvr2_querymenu(pvr2_ioctl_ops_group2, ldvarg46, ldvarg45);
#line 431
    ldv_state_variable_13 = 1;
  } else {

  }
#line 434
  goto ldv_35650;
  case 4: ;
#line 437
  if (ldv_state_variable_13 == 1) {
#line 439
    pvr2_g_ctrl(pvr2_ioctl_ops_group2, ldvarg44, pvr2_ioctl_ops_group4);
#line 441
    ldv_state_variable_13 = 1;
  } else {

  }
#line 444
  goto ldv_35650;
  case 5: ;
#line 447
  if (ldv_state_variable_13 == 1) {
#line 449
    pvr2_try_fmt_vid_cap(pvr2_ioctl_ops_group2, ldvarg43, pvr2_ioctl_ops_group3);
#line 451
    ldv_state_variable_13 = 1;
  } else {

  }
#line 454
  goto ldv_35650;
  case 6: ;
#line 457
  if (ldv_state_variable_13 == 1) {
#line 459
    pvr2_s_std(pvr2_ioctl_ops_group2, ldvarg42, ldvarg41);
#line 461
    ldv_state_variable_13 = 1;
  } else {

  }
#line 464
  goto ldv_35650;
  case 7: ;
#line 467
  if (ldv_state_variable_13 == 1) {
#line 469
    pvr2_s_tuner(pvr2_ioctl_ops_group2, ldvarg40, (struct v4l2_tuner  const  *)ldvarg39);
#line 471
    ldv_state_variable_13 = 1;
  } else {

  }
#line 474
  goto ldv_35650;
  case 8: ;
#line 477
  if (ldv_state_variable_13 == 1) {
#line 479
    pvr2_log_status(pvr2_ioctl_ops_group2, ldvarg38);
#line 481
    ldv_state_variable_13 = 1;
  } else {

  }
#line 484
  goto ldv_35650;
  case 9: ;
#line 487
  if (ldv_state_variable_13 == 1) {
#line 489
    pvr2_g_crop(pvr2_ioctl_ops_group2, ldvarg37, ldvarg36);
#line 491
    ldv_state_variable_13 = 1;
  } else {

  }
#line 494
  goto ldv_35650;
  case 10: ;
#line 497
  if (ldv_state_variable_13 == 1) {
#line 499
    pvr2_streamoff(pvr2_ioctl_ops_group2, ldvarg35, ldvarg34);
#line 501
    ldv_state_variable_13 = 1;
  } else {

  }
#line 504
  goto ldv_35650;
  case 11: ;
#line 507
  if (ldv_state_variable_13 == 1) {
#line 509
    pvr2_queryctrl(pvr2_ioctl_ops_group2, ldvarg33, ldvarg32);
#line 511
    ldv_state_variable_13 = 1;
  } else {

  }
#line 514
  goto ldv_35650;
  case 12: ;
#line 517
  if (ldv_state_variable_13 == 1) {
#line 519
    pvr2_enum_fmt_vid_cap(pvr2_ioctl_ops_group2, ldvarg31, ldvarg30);
#line 521
    ldv_state_variable_13 = 1;
  } else {

  }
#line 524
  goto ldv_35650;
  case 13: ;
#line 527
  if (ldv_state_variable_13 == 1) {
#line 529
    pvr2_querystd(pvr2_ioctl_ops_group2, ldvarg29, ldvarg28);
#line 531
    ldv_state_variable_13 = 1;
  } else {

  }
#line 534
  goto ldv_35650;
  case 14: ;
#line 537
  if (ldv_state_variable_13 == 1) {
#line 539
    pvr2_try_ext_ctrls(pvr2_ioctl_ops_group2, ldvarg27, pvr2_ioctl_ops_group0);
#line 541
    ldv_state_variable_13 = 1;
  } else {

  }
#line 544
  goto ldv_35650;
  case 15: ;
#line 547
  if (ldv_state_variable_13 == 1) {
#line 549
    pvr2_s_fmt_vid_cap(pvr2_ioctl_ops_group2, ldvarg26, pvr2_ioctl_ops_group3);
#line 551
    ldv_state_variable_13 = 1;
  } else {

  }
#line 554
  goto ldv_35650;
  case 16: ;
#line 557
  if (ldv_state_variable_13 == 1) {
#line 559
    pvr2_cropcap(pvr2_ioctl_ops_group2, ldvarg25, ldvarg24);
#line 561
    ldv_state_variable_13 = 1;
  } else {

  }
#line 564
  goto ldv_35650;
  case 17: ;
#line 567
  if (ldv_state_variable_13 == 1) {
#line 569
    pvr2_g_fmt_vid_cap(pvr2_ioctl_ops_group2, ldvarg23, pvr2_ioctl_ops_group3);
#line 571
    ldv_state_variable_13 = 1;
  } else {

  }
#line 574
  goto ldv_35650;
  case 18: ;
#line 577
  if (ldv_state_variable_13 == 1) {
#line 579
    pvr2_g_frequency(pvr2_ioctl_ops_group2, ldvarg22, ldvarg21);
#line 581
    ldv_state_variable_13 = 1;
  } else {

  }
#line 584
  goto ldv_35650;
  case 19: ;
#line 587
  if (ldv_state_variable_13 == 1) {
#line 589
    pvr2_g_input(pvr2_ioctl_ops_group2, ldvarg20, ldvarg19);
#line 591
    ldv_state_variable_13 = 1;
  } else {

  }
#line 594
  goto ldv_35650;
  case 20: ;
#line 597
  if (ldv_state_variable_13 == 1) {
#line 599
    pvr2_g_audio(pvr2_ioctl_ops_group2, ldvarg18, pvr2_ioctl_ops_group1);
#line 601
    ldv_state_variable_13 = 1;
  } else {

  }
#line 604
  goto ldv_35650;
  case 21: ;
#line 607
  if (ldv_state_variable_13 == 1) {
#line 609
    pvr2_querycap(pvr2_ioctl_ops_group2, ldvarg17, ldvarg16);
#line 611
    ldv_state_variable_13 = 1;
  } else {

  }
#line 614
  goto ldv_35650;
  case 22: ;
#line 617
  if (ldv_state_variable_13 == 1) {
#line 619
    pvr2_s_frequency(pvr2_ioctl_ops_group2, ldvarg15, (struct v4l2_frequency  const  *)ldvarg14);
#line 621
    ldv_state_variable_13 = 1;
  } else {

  }
#line 624
  goto ldv_35650;
  case 23: ;
#line 627
  if (ldv_state_variable_13 == 1) {
#line 629
    pvr2_g_std(pvr2_ioctl_ops_group2, ldvarg13, ldvarg12);
#line 631
    ldv_state_variable_13 = 1;
  } else {

  }
#line 634
  goto ldv_35650;
  case 24: ;
#line 637
  if (ldv_state_variable_13 == 1) {
#line 639
    pvr2_enum_input(pvr2_ioctl_ops_group2, ldvarg11, ldvarg10);
#line 641
    ldv_state_variable_13 = 1;
  } else {

  }
#line 644
  goto ldv_35650;
  case 25: ;
#line 647
  if (ldv_state_variable_13 == 1) {
#line 649
    pvr2_s_ext_ctrls(pvr2_ioctl_ops_group2, ldvarg9, pvr2_ioctl_ops_group0);
#line 651
    ldv_state_variable_13 = 1;
  } else {

  }
#line 654
  goto ldv_35650;
  case 26: ;
#line 657
  if (ldv_state_variable_13 == 1) {
#line 659
    pvr2_s_crop(pvr2_ioctl_ops_group2, ldvarg8, (struct v4l2_crop  const  *)ldvarg7);
#line 661
    ldv_state_variable_13 = 1;
  } else {

  }
#line 664
  goto ldv_35650;
  case 27: ;
#line 667
  if (ldv_state_variable_13 == 1) {
#line 669
    pvr2_s_input(pvr2_ioctl_ops_group2, ldvarg6, ldvarg5);
#line 671
    ldv_state_variable_13 = 1;
  } else {

  }
#line 674
  goto ldv_35650;
  case 28: ;
#line 677
  if (ldv_state_variable_13 == 1) {
#line 679
    pvr2_s_audio(pvr2_ioctl_ops_group2, ldvarg4, (struct v4l2_audio  const  *)ldvarg3);
#line 681
    ldv_state_variable_13 = 1;
  } else {

  }
#line 684
  goto ldv_35650;
  case 29: ;
#line 687
  if (ldv_state_variable_13 == 1) {
#line 689
    pvr2_enumaudio(pvr2_ioctl_ops_group2, ldvarg2, pvr2_ioctl_ops_group1);
#line 691
    ldv_state_variable_13 = 1;
  } else {

  }
#line 694
  goto ldv_35650;
  case 30: ;
#line 697
  if (ldv_state_variable_13 == 1) {
#line 699
    pvr2_streamon(pvr2_ioctl_ops_group2, ldvarg1, ldvarg0);
#line 701
    ldv_state_variable_13 = 1;
  } else {

  }
#line 704
  goto ldv_35650;
  default: 
#line 705
  ldv_stop();
  }
  ldv_35650: ;
#line 709
  return;
}
}
#line 711 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
void ldv_main_exported_12(void) 
{ 
  unsigned int ldvarg52 ;
  char *ldvarg56 ;
  void *tmp ;
  size_t ldvarg55 ;
  struct poll_table_struct *ldvarg53 ;
  void *tmp___0 ;
  unsigned long ldvarg51 ;
  loff_t *ldvarg54 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 713
  tmp = ldv_init_zalloc(1UL);
#line 713
  ldvarg56 = (char *)tmp;
#line 715
  tmp___0 = ldv_init_zalloc(16UL);
#line 715
  ldvarg53 = (struct poll_table_struct *)tmp___0;
#line 717
  tmp___1 = ldv_init_zalloc(8UL);
#line 717
  ldvarg54 = (loff_t *)tmp___1;
#line 712
  ldv_memset((void *)(& ldvarg52), 0, 4UL);
#line 714
  ldv_memset((void *)(& ldvarg55), 0, 8UL);
#line 716
  ldv_memset((void *)(& ldvarg51), 0, 8UL);
#line 719
  tmp___2 = __VERIFIER_nondet_int();
#line 719
  switch (tmp___2) {
  case 0: ;
#line 722
  if (ldv_state_variable_12 == 1) {
#line 724
    ldv_retval_1 = pvr2_v4l2_open(vdev_fops_group0);
#line 726
    if (ldv_retval_1 == 0) {
#line 727
      ldv_state_variable_12 = 2;
#line 728
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 732
  goto ldv_35692;
  case 1: ;
#line 735
  if (ldv_state_variable_12 == 2) {
#line 737
    pvr2_v4l2_release(vdev_fops_group0);
#line 739
    ldv_state_variable_12 = 1;
#line 740
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 743
  goto ldv_35692;
  case 2: ;
#line 746
  if (ldv_state_variable_12 == 2) {
#line 748
    pvr2_v4l2_read(vdev_fops_group0, ldvarg56, ldvarg55, ldvarg54);
#line 750
    ldv_state_variable_12 = 2;
  } else {

  }
#line 753
  goto ldv_35692;
  case 3: ;
#line 756
  if (ldv_state_variable_12 == 1) {
#line 758
    pvr2_v4l2_poll(vdev_fops_group0, ldvarg53);
#line 760
    ldv_state_variable_12 = 1;
  } else {

  }
#line 763
  if (ldv_state_variable_12 == 2) {
#line 765
    pvr2_v4l2_poll(vdev_fops_group0, ldvarg53);
#line 767
    ldv_state_variable_12 = 2;
  } else {

  }
#line 770
  goto ldv_35692;
  case 4: ;
#line 773
  if (ldv_state_variable_12 == 1) {
#line 775
    pvr2_v4l2_ioctl(vdev_fops_group0, ldvarg52, ldvarg51);
#line 777
    ldv_state_variable_12 = 1;
  } else {

  }
#line 780
  if (ldv_state_variable_12 == 2) {
#line 782
    pvr2_v4l2_ioctl(vdev_fops_group0, ldvarg52, ldvarg51);
#line 784
    ldv_state_variable_12 = 2;
  } else {

  }
#line 787
  goto ldv_35692;
  default: 
#line 788
  ldv_stop();
  }
  ldv_35692: ;
#line 792
  return;
}
}
#line 817 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
bool ldv_queue_work_on_386(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 821
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 821
  ldv_func_res = tmp;
#line 823
  activate_work_1(ldv_func_arg3, 2);
#line 825
  return (ldv_func_res);
}
}
#line 828 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
bool ldv_queue_delayed_work_on_387(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 832
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 832
  ldv_func_res = tmp;
#line 834
  activate_work_1(& ldv_func_arg3->work, 2);
#line 836
  return (ldv_func_res);
}
}
#line 839 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
bool ldv_queue_work_on_388(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 843
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 843
  ldv_func_res = tmp;
#line 845
  activate_work_1(ldv_func_arg3, 2);
#line 847
  return (ldv_func_res);
}
}
#line 850 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
void ldv_flush_workqueue_389(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 853
  flush_workqueue(ldv_func_arg1);
#line 855
  call_and_disable_all_1(2);
#line 856
  return;
}
}
#line 858 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
bool ldv_queue_delayed_work_on_390(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 862
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 862
  ldv_func_res = tmp;
#line 864
  activate_work_1(& ldv_func_arg3->work, 2);
#line 866
  return (ldv_func_res);
}
}
#line 869 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
void ldv_mutex_lock_391(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 872
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 874
  mutex_lock(ldv_func_arg1);
#line 875
  return;
}
}
#line 877 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
void ldv_mutex_unlock_392(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 880
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 882
  mutex_unlock(ldv_func_arg1);
#line 883
  return;
}
}
#line 885 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
void ldv_mutex_lock_393(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 888
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 890
  mutex_lock(ldv_func_arg1);
#line 891
  return;
}
}
#line 893 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
int ldv_mutex_trylock_394(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 897
  tmp = mutex_trylock(ldv_func_arg1);
#line 897
  ldv_func_res = tmp;
#line 899
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 899
  return (tmp___0);
#line 901
  return (ldv_func_res);
}
}
#line 904 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
void ldv_mutex_unlock_395(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 907
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 909
  mutex_unlock(ldv_func_arg1);
#line 910
  return;
}
}
#line 912 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
void ldv_mutex_unlock_396(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 915
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 917
  mutex_unlock(ldv_func_arg1);
#line 918
  return;
}
}
#line 920 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-v4l2.o.c.prepared"
void ldv_mutex_lock_397(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 923
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 925
  mutex_lock(ldv_func_arg1);
#line 926
  return;
}
}
#line 394 "include/linux/kernel.h"
extern long simple_strtol(char const   * , char ** , unsigned int  ) ;
#line 63 "./arch/x86/include/asm/string_64.h"
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 64
extern size_t strlen(char const   * ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_422(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_420(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_423(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_424(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_427(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_429(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_431(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_433(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_435(struct mutex *ldv_func_arg1 ) ;
#line 213
void ldv_mutex_unlock_437(struct mutex *ldv_func_arg1 ) ;
#line 217
void ldv_mutex_unlock_439(struct mutex *ldv_func_arg1 ) ;
#line 221
void ldv_mutex_unlock_441(struct mutex *ldv_func_arg1 ) ;
#line 225
void ldv_mutex_unlock_443(struct mutex *ldv_func_arg1 ) ;
#line 229
void ldv_mutex_unlock_445(struct mutex *ldv_func_arg1 ) ;
#line 233
void ldv_mutex_unlock_447(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_lock_419(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_421(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_425(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_426(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_428(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_430(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_432(struct mutex *ldv_func_arg1 ) ;
#line 49
void ldv_mutex_lock_434(struct mutex *ldv_func_arg1 ) ;
#line 53
void ldv_mutex_lock_436(struct mutex *ldv_func_arg1 ) ;
#line 57
void ldv_mutex_lock_438(struct mutex *ldv_func_arg1 ) ;
#line 61
void ldv_mutex_lock_440(struct mutex *ldv_func_arg1 ) ;
#line 65
void ldv_mutex_lock_442(struct mutex *ldv_func_arg1 ) ;
#line 69
void ldv_mutex_lock_444(struct mutex *ldv_func_arg1 ) ;
#line 73
void ldv_mutex_lock_446(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_414(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_416(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_415(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_418(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_417(struct workqueue_struct *ldv_func_arg1 ) ;
#line 37 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-ctrl.h"
int pvr2_ctrl_set_mask_value(struct pvr2_ctrl *cptr , int mask , int val ) ;
#line 58
int pvr2_ctrl_get_mask(struct pvr2_ctrl *cptr ) ;
#line 71
int pvr2_ctrl_is_writable(struct pvr2_ctrl *cptr ) ;
#line 81
int pvr2_ctrl_has_custom_symbols(struct pvr2_ctrl *cptr ) ;
#line 84
int pvr2_ctrl_custom_value_to_sym(struct pvr2_ctrl *cptr , int mask , int val , char *buf ,
                                  unsigned int maxlen , unsigned int *len ) ;
#line 90
int pvr2_ctrl_custom_sym_to_value(struct pvr2_ctrl *cptr , char const   *buf , unsigned int len ,
                                  int *maskptr , int *valptr ) ;
#line 95
int pvr2_ctrl_value_to_sym(struct pvr2_ctrl *cptr , int mask , int val , char *buf ,
                           unsigned int maxlen , unsigned int *len ) ;
#line 101
int pvr2_ctrl_sym_to_value(struct pvr2_ctrl *cptr , char const   *ptr , unsigned int len ,
                           int *maskptr , int *valptr ) ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
static int pvr2_ctrl_range_check(struct pvr2_ctrl *cptr , int val ) 
{ 
  int tmp ;
  int lim ;

  {
#line 30
  if ((unsigned long )(cptr->info)->check_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                             int  ))0)) {
#line 31
    tmp = (*((cptr->info)->check_value))(cptr, val);
#line 31
    if (tmp == 0) {
#line 31
      return (-34);
    } else {

    }
  } else
#line 32
  if ((unsigned int )(cptr->info)->type == 1U) {
#line 33
    if (val < 0) {
#line 33
      return (-34);
    } else {

    }
#line 34
    if ((unsigned int )val >= (unsigned int )(cptr->info)->def.type_enum.count) {
#line 34
      return (-34);
    } else {

    }
  } else {
#line 37
    lim = (int )(cptr->info)->def.type_int.min_value;
#line 38
    if ((unsigned long )(cptr->info)->get_min_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                                 int * ))0)) {
#line 39
      (*((cptr->info)->get_min_value))(cptr, & lim);
    } else {

    }
#line 41
    if (val < lim) {
#line 41
      return (-34);
    } else {

    }
#line 42
    lim = (int )(cptr->info)->def.type_int.max_value;
#line 43
    if ((unsigned long )(cptr->info)->get_max_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                                 int * ))0)) {
#line 44
      (*((cptr->info)->get_max_value))(cptr, & lim);
    } else {

    }
#line 46
    if (val > lim) {
#line 46
      return (-34);
    } else {

    }
  }
#line 48
  return (0);
}
}
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
int pvr2_ctrl_set_value(struct pvr2_ctrl *cptr , int val ) 
{ 
  int tmp ;

  {
#line 55
  tmp = pvr2_ctrl_set_mask_value(cptr, -1, val);
#line 55
  return (tmp);
}
}
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
int pvr2_ctrl_set_mask_value(struct pvr2_ctrl *cptr , int mask , int val ) 
{ 
  int ret ;

  {
#line 62
  ret = 0;
#line 63
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 63
    return (-22);
  } else {

  }
#line 64
  ldv_mutex_lock_428(& (cptr->hdw)->big_lock_mutex);
#line 64
  (cptr->hdw)->big_lock_held = 1;
#line 65
  if ((unsigned long )(cptr->info)->set_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                           int  ,
                                                                           int  ))0)) {
#line 66
    if ((unsigned int )(cptr->info)->type == 2U) {
#line 67
      mask = (int )((unsigned int )(cptr->info)->def.type_bitmask.valid_bits & (unsigned int )mask);
    } else
#line 68
    if ((unsigned int )(cptr->info)->type == 0U || (unsigned int )(cptr->info)->type == 1U) {
#line 70
      ret = pvr2_ctrl_range_check(cptr, val);
#line 71
      if (ret < 0) {
#line 71
        goto ldv_51871;
      } else {

      }
    } else
#line 72
    if ((unsigned int )(cptr->info)->type != 3U) {
#line 73
      goto ldv_51871;
    } else {

    }
#line 75
    ret = (*((cptr->info)->set_value))(cptr, mask, val);
  } else {
#line 77
    ret = -1;
  }
  ldv_51871: 
#line 79
  (cptr->hdw)->big_lock_held = 0;
#line 79
  ldv_mutex_unlock_429(& (cptr->hdw)->big_lock_mutex);
#line 80
  return (ret);
}
}
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
int pvr2_ctrl_get_value(struct pvr2_ctrl *cptr , int *valptr ) 
{ 
  int ret ;

  {
#line 87
  ret = 0;
#line 88
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 88
    return (-22);
  } else {

  }
#line 89
  ldv_mutex_lock_430(& (cptr->hdw)->big_lock_mutex);
#line 89
  (cptr->hdw)->big_lock_held = 1;
#line 90
  ret = (*((cptr->info)->get_value))(cptr, valptr);
#line 91
  (cptr->hdw)->big_lock_held = 0;
#line 91
  ldv_mutex_unlock_431(& (cptr->hdw)->big_lock_mutex);
#line 92
  return (ret);
}
}
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
enum pvr2_ctl_type pvr2_ctrl_get_type(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 99
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 99
    return (0);
  } else {

  }
#line 100
  return ((enum pvr2_ctl_type )(cptr->info)->type);
}
}
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
int pvr2_ctrl_get_max(struct pvr2_ctrl *cptr ) 
{ 
  int ret ;

  {
#line 107
  ret = 0;
#line 108
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 108
    return (0);
  } else {

  }
#line 109
  ldv_mutex_lock_432(& (cptr->hdw)->big_lock_mutex);
#line 109
  (cptr->hdw)->big_lock_held = 1;
#line 110
  if ((unsigned long )(cptr->info)->get_max_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                               int * ))0)) {
#line 111
    (*((cptr->info)->get_max_value))(cptr, & ret);
  } else
#line 112
  if ((unsigned int )(cptr->info)->type == 0U) {
#line 113
    ret = (int )(cptr->info)->def.type_int.max_value;
  } else {

  }
#line 115
  (cptr->hdw)->big_lock_held = 0;
#line 115
  ldv_mutex_unlock_433(& (cptr->hdw)->big_lock_mutex);
#line 116
  return (ret);
}
}
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
int pvr2_ctrl_get_min(struct pvr2_ctrl *cptr ) 
{ 
  int ret ;

  {
#line 123
  ret = 0;
#line 124
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 124
    return (0);
  } else {

  }
#line 125
  ldv_mutex_lock_434(& (cptr->hdw)->big_lock_mutex);
#line 125
  (cptr->hdw)->big_lock_held = 1;
#line 126
  if ((unsigned long )(cptr->info)->get_min_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                               int * ))0)) {
#line 127
    (*((cptr->info)->get_min_value))(cptr, & ret);
  } else
#line 128
  if ((unsigned int )(cptr->info)->type == 0U) {
#line 129
    ret = (int )(cptr->info)->def.type_int.min_value;
  } else {

  }
#line 131
  (cptr->hdw)->big_lock_held = 0;
#line 131
  ldv_mutex_unlock_435(& (cptr->hdw)->big_lock_mutex);
#line 132
  return (ret);
}
}
#line 137 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
int pvr2_ctrl_get_def(struct pvr2_ctrl *cptr , int *valptr ) 
{ 
  int ret ;

  {
#line 139
  ret = 0;
#line 140
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 140
    return (-22);
  } else {

  }
#line 141
  ldv_mutex_lock_436(& (cptr->hdw)->big_lock_mutex);
#line 141
  (cptr->hdw)->big_lock_held = 1;
#line 142
  if ((unsigned long )(cptr->info)->get_def_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                               int * ))0)) {
#line 143
    ret = (*((cptr->info)->get_def_value))(cptr, valptr);
  } else {
#line 145
    *valptr = (cptr->info)->default_value;
  }
#line 147
  (cptr->hdw)->big_lock_held = 0;
#line 147
  ldv_mutex_unlock_437(& (cptr->hdw)->big_lock_mutex);
#line 148
  return (ret);
}
}
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
int pvr2_ctrl_get_cnt(struct pvr2_ctrl *cptr ) 
{ 
  int ret ;

  {
#line 155
  ret = 0;
#line 156
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 156
    return (0);
  } else {

  }
#line 157
  ldv_mutex_lock_438(& (cptr->hdw)->big_lock_mutex);
#line 157
  (cptr->hdw)->big_lock_held = 1;
#line 158
  if ((unsigned int )(cptr->info)->type == 1U) {
#line 159
    ret = (int )(cptr->info)->def.type_enum.count;
  } else {

  }
#line 161
  (cptr->hdw)->big_lock_held = 0;
#line 161
  ldv_mutex_unlock_439(& (cptr->hdw)->big_lock_mutex);
#line 162
  return (ret);
}
}
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
int pvr2_ctrl_get_mask(struct pvr2_ctrl *cptr ) 
{ 
  int ret ;

  {
#line 169
  ret = 0;
#line 170
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 170
    return (0);
  } else {

  }
#line 171
  ldv_mutex_lock_440(& (cptr->hdw)->big_lock_mutex);
#line 171
  (cptr->hdw)->big_lock_held = 1;
#line 172
  if ((unsigned int )(cptr->info)->type == 2U) {
#line 173
    ret = (int )(cptr->info)->def.type_bitmask.valid_bits;
  } else {

  }
#line 175
  (cptr->hdw)->big_lock_held = 0;
#line 175
  ldv_mutex_unlock_441(& (cptr->hdw)->big_lock_mutex);
#line 176
  return (ret);
}
}
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
char const   *pvr2_ctrl_get_name(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 183
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 183
    return ((char const   *)0);
  } else {

  }
#line 184
  return ((char const   *)(cptr->info)->name);
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
char const   *pvr2_ctrl_get_desc(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 191
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 191
    return ((char const   *)0);
  } else {

  }
#line 192
  return ((char const   *)(cptr->info)->desc);
}
}
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
int pvr2_ctrl_get_valname(struct pvr2_ctrl *cptr , int val , char *bptr , unsigned int bmax ,
                          unsigned int *blen ) 
{ 
  int ret ;
  char const   * const  *names ;
  int tmp ;
  int tmp___0 ;
  char const   **names___0 ;
  unsigned int idx ;
  int msk ;
  int tmp___1 ;

  {
#line 201
  ret = -22;
#line 202
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 202
    return (0);
  } else {

  }
#line 203
  *blen = 0U;
#line 204
  ldv_mutex_lock_442(& (cptr->hdw)->big_lock_mutex);
#line 204
  (cptr->hdw)->big_lock_held = 1;
#line 205
  if ((unsigned int )(cptr->info)->type == 1U) {
#line 207
    names = (cptr->info)->def.type_enum.value_names;
#line 208
    tmp___0 = pvr2_ctrl_range_check(cptr, val);
#line 208
    if (tmp___0 == 0) {
#line 209
      if ((unsigned long )*(names + (unsigned long )val) != (unsigned long )((char const   */* const  */)0)) {
#line 210
        tmp = scnprintf(bptr, (size_t )bmax, "%s", *(names + (unsigned long )val));
#line 210
        *blen = (unsigned int )tmp;
      } else {
#line 214
        *blen = 0U;
      }
#line 216
      ret = 0;
    } else {

    }
  } else
#line 218
  if ((unsigned int )(cptr->info)->type == 2U) {
#line 222
    names___0 = (cptr->info)->def.type_bitmask.bit_names;
#line 223
    val = (int )((unsigned int )(cptr->info)->def.type_bitmask.valid_bits & (unsigned int )val);
#line 224
    idx = 0U;
#line 224
    msk = 1;
#line 224
    goto ldv_51921;
    ldv_51920: ;
#line 225
    if ((val & msk) != 0) {
#line 226
      tmp___1 = scnprintf(bptr, (size_t )bmax, "%s", *(names___0 + (unsigned long )idx));
#line 226
      *blen = (unsigned int )tmp___1;
#line 228
      ret = 0;
#line 229
      goto ldv_51919;
    } else {

    }
#line 224
    idx = idx + 1U;
#line 224
    msk = msk << 1;
    ldv_51921: ;
#line 224
    if (val != 0) {
#line 226
      goto ldv_51920;
    } else {

    }
    ldv_51919: ;
  } else {

  }
#line 233
  (cptr->hdw)->big_lock_held = 0;
#line 233
  ldv_mutex_unlock_443(& (cptr->hdw)->big_lock_mutex);
#line 234
  return (ret);
}
}
#line 239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
int pvr2_ctrl_get_v4lid(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 241
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 241
    return (0);
  } else {

  }
#line 242
  return ((int )(cptr->info)->v4l_id);
}
}
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
unsigned int pvr2_ctrl_get_v4lflags(struct pvr2_ctrl *cptr ) 
{ 
  unsigned int flags ;

  {
#line 248
  flags = 0U;
#line 250
  if ((unsigned long )(cptr->info)->get_v4lflags != (unsigned long )((unsigned int (*)(struct pvr2_ctrl * ))0)) {
#line 251
    flags = (*((cptr->info)->get_v4lflags))(cptr);
  } else {

  }
#line 254
  if ((unsigned long )(cptr->info)->set_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                           int  ,
                                                                           int  ))0)) {
#line 255
    flags = flags & 4294967291U;
  } else {
#line 257
    flags = flags | 4U;
  }
#line 260
  return (flags);
}
}
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
int pvr2_ctrl_is_writable(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 267
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 267
    return (0);
  } else {

  }
#line 268
  return ((unsigned long )(cptr->info)->set_value != (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                               int  ,
                                                                               int  ))0));
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
int pvr2_ctrl_has_custom_symbols(struct pvr2_ctrl *cptr ) 
{ 


  {
#line 275
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 275
    return (0);
  } else {

  }
#line 276
  if ((unsigned long )(cptr->info)->val_to_sym == (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                            int  ,
                                                                            int  ,
                                                                            char * ,
                                                                            unsigned int  ,
                                                                            unsigned int * ))0)) {
#line 276
    return (0);
  } else {

  }
#line 277
  if ((unsigned long )(cptr->info)->sym_to_val == (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                            char const   * ,
                                                                            unsigned int  ,
                                                                            int * ,
                                                                            int * ))0)) {
#line 277
    return (0);
  } else {

  }
#line 278
  return (1);
}
}
#line 283 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
int pvr2_ctrl_custom_value_to_sym(struct pvr2_ctrl *cptr , int mask , int val , char *buf ,
                                  unsigned int maxlen , unsigned int *len ) 
{ 
  int tmp ;

  {
#line 288
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 288
    return (-22);
  } else {

  }
#line 289
  if ((unsigned long )(cptr->info)->val_to_sym == (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                            int  ,
                                                                            int  ,
                                                                            char * ,
                                                                            unsigned int  ,
                                                                            unsigned int * ))0)) {
#line 289
    return (-22);
  } else {

  }
#line 290
  tmp = (*((cptr->info)->val_to_sym))(cptr, mask, val, buf, maxlen, len);
#line 290
  return (tmp);
}
}
#line 295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
int pvr2_ctrl_custom_sym_to_value(struct pvr2_ctrl *cptr , char const   *buf , unsigned int len ,
                                  int *maskptr , int *valptr ) 
{ 
  int tmp ;

  {
#line 299
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 299
    return (-22);
  } else {

  }
#line 300
  if ((unsigned long )(cptr->info)->sym_to_val == (unsigned long )((int (*)(struct pvr2_ctrl * ,
                                                                            char const   * ,
                                                                            unsigned int  ,
                                                                            int * ,
                                                                            int * ))0)) {
#line 300
    return (-22);
  } else {

  }
#line 301
  tmp = (*((cptr->info)->sym_to_val))(cptr, buf, len, maskptr, valptr);
#line 301
  return (tmp);
}
}
#line 305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
static unsigned int gen_bitmask_string(int msk , int val , int msk_only , char const   **names ,
                                       char *ptr , unsigned int len ) 
{ 
  unsigned int idx ;
  long sm ;
  long um ;
  int spcFl ;
  unsigned int uc ;
  unsigned int cnt ;
  char const   *idStr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 315
  spcFl = 0;
#line 316
  uc = 0U;
#line 317
  um = 0L;
#line 318
  idx = 0U;
#line 318
  sm = 1L;
#line 318
  goto ldv_51966;
  ldv_51965: ;
#line 319
  if (((long )msk & sm) != 0L) {
#line 320
    msk = ~ ((int )sm) & msk;
#line 321
    idStr = *(names + (unsigned long )idx);
#line 322
    if ((unsigned long )idStr != (unsigned long )((char const   *)0)) {
#line 323
      tmp = scnprintf(ptr, (size_t )len, "%s%s%s", spcFl != 0 ? (char *)" " : (char *)"",
                      msk_only == 0 ? (((long )val & sm) != 0L ? (char *)"+" : (char *)"-") : (char *)"",
                      idStr);
#line 323
      cnt = (unsigned int )tmp;
#line 328
      ptr = ptr + (unsigned long )cnt;
#line 328
      len = len - cnt;
#line 328
      uc = uc + cnt;
#line 329
      spcFl = 1;
    } else {
#line 331
      um = um | sm;
    }
  } else {

  }
#line 318
  idx = idx + 1U;
#line 318
  sm = sm << 1;
  ldv_51966: ;
#line 318
  if (msk != 0) {
#line 320
    goto ldv_51965;
  } else {

  }

#line 335
  if (um != 0L) {
#line 336
    if (msk_only != 0) {
#line 337
      tmp___0 = scnprintf(ptr, (size_t )len, "%s0x%lx", spcFl != 0 ? (char *)" " : (char *)"",
                          um);
#line 337
      cnt = (unsigned int )tmp___0;
#line 340
      ptr = ptr + (unsigned long )cnt;
#line 340
      len = len - cnt;
#line 340
      uc = uc + cnt;
#line 341
      spcFl = 1;
    } else
#line 342
    if (((long )val & um) != 0L) {
#line 343
      tmp___1 = scnprintf(ptr, (size_t )len, "%s+0x%lx", spcFl != 0 ? (char *)" " : (char *)"",
                          (long )val & um);
#line 343
      cnt = (unsigned int )tmp___1;
#line 346
      ptr = ptr + (unsigned long )cnt;
#line 346
      len = len - cnt;
#line 346
      uc = uc + cnt;
#line 347
      spcFl = 1;
    } else
#line 348
    if (((long )(~ val) & um) != 0L) {
#line 349
      tmp___2 = scnprintf(ptr, (size_t )len, "%s+0x%lx", spcFl != 0 ? (char *)" " : (char *)"",
                          (long )(~ val) & um);
#line 349
      cnt = (unsigned int )tmp___2;
#line 352
      ptr = ptr + (unsigned long )cnt;
#line 352
      len = len - cnt;
#line 352
      uc = uc + cnt;
#line 353
      spcFl = 1;
    } else {

    }
  } else {

  }
#line 356
  return (uc);
}
}
#line 360 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
static char const   *boolNames[4U]  = {      "false",      "true",      "no",      "yes"};
#line 368 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
static int parse_token(char const   *ptr , unsigned int len , int *valptr , char const   * const  *names ,
                       unsigned int namecnt ) 
{ 
  char buf[33U] ;
  unsigned int slen ;
  unsigned int idx ;
  int negfl ;
  char *p2 ;
  size_t tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 377
  *valptr = 0;
#line 378
  if ((unsigned long )names == (unsigned long )((char const   * const  *)0)) {
#line 378
    namecnt = 0U;
  } else {

  }
#line 379
  idx = 0U;
#line 379
  goto ldv_51983;
  ldv_51982: ;
#line 380
  if ((unsigned long )*(names + (unsigned long )idx) == (unsigned long )((char const   */* const  */)0)) {
#line 380
    goto ldv_51981;
  } else {

  }
#line 381
  tmp = strlen(*(names + (unsigned long )idx));
#line 381
  slen = (unsigned int )tmp;
#line 382
  if (slen != len) {
#line 382
    goto ldv_51981;
  } else {

  }
#line 383
  tmp___0 = memcmp((void const   *)*(names + (unsigned long )idx), (void const   *)ptr,
                   (size_t )slen);
#line 383
  if (tmp___0 != 0) {
#line 383
    goto ldv_51981;
  } else {

  }
#line 384
  *valptr = (int )idx;
#line 385
  return (0);
  ldv_51981: 
#line 379
  idx = idx + 1U;
  ldv_51983: ;
#line 379
  if (idx < namecnt) {
#line 381
    goto ldv_51982;
  } else {

  }
#line 387
  negfl = 0;
#line 388
  if ((int )((signed char )*ptr) == 45 || (int )((signed char )*ptr) == 43) {
#line 389
    negfl = (int )((signed char )*ptr) == 45;
#line 390
    ptr = ptr + 1;
#line 390
    len = len - 1U;
  } else {

  }
#line 392
  if (len > 32U) {
#line 392
    return (-22);
  } else {

  }
#line 393
  memcpy((void *)(& buf), (void const   *)ptr, (size_t )len);
#line 394
  buf[len] = 0;
#line 395
  tmp___1 = simple_strtol((char const   *)(& buf), & p2, 0U);
#line 395
  *valptr = (int )tmp___1;
#line 396
  if (negfl != 0) {
#line 396
    *valptr = - *valptr;
  } else {

  }
#line 397
  if ((int )((signed char )*p2) != 0) {
#line 397
    return (-22);
  } else {

  }
#line 398
  return (1);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
static int parse_mtoken(char const   *ptr , unsigned int len , int *valptr , char const   **names ,
                        int valid_bits ) 
{ 
  char buf[33U] ;
  unsigned int slen ;
  unsigned int idx ;
  char *p2 ;
  int msk ;
  size_t tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 411
  *valptr = 0;
#line 412
  idx = 0U;
#line 412
  msk = 1;
#line 412
  goto ldv_51999;
  ldv_51998: ;
#line 413
  if ((msk & valid_bits) == 0) {
#line 413
    goto ldv_51997;
  } else {

  }
#line 414
  valid_bits = ~ msk & valid_bits;
#line 415
  if ((unsigned long )*(names + (unsigned long )idx) == (unsigned long )((char const   *)0)) {
#line 415
    goto ldv_51997;
  } else {

  }
#line 416
  tmp = strlen(*(names + (unsigned long )idx));
#line 416
  slen = (unsigned int )tmp;
#line 417
  if (slen != len) {
#line 417
    goto ldv_51997;
  } else {

  }
#line 418
  tmp___0 = memcmp((void const   *)*(names + (unsigned long )idx), (void const   *)ptr,
                   (size_t )slen);
#line 418
  if (tmp___0 != 0) {
#line 418
    goto ldv_51997;
  } else {

  }
#line 419
  *valptr = msk;
#line 420
  return (0);
  ldv_51997: 
#line 412
  idx = idx + 1U;
#line 412
  msk = msk << 1;
  ldv_51999: ;
#line 412
  if (valid_bits != 0) {
#line 414
    goto ldv_51998;
  } else {

  }

#line 422
  if (len > 32U) {
#line 422
    return (-22);
  } else {

  }
#line 423
  memcpy((void *)(& buf), (void const   *)ptr, (size_t )len);
#line 424
  buf[len] = 0;
#line 425
  tmp___1 = simple_strtol((char const   *)(& buf), & p2, 0U);
#line 425
  *valptr = (int )tmp___1;
#line 426
  if ((int )((signed char )*p2) != 0) {
#line 426
    return (-22);
  } else {

  }
#line 427
  return (0);
}
}
#line 431 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
static int parse_tlist(char const   *ptr , unsigned int len , int *maskptr , int *valptr ,
                       char const   **names , int valid_bits ) 
{ 
  unsigned int cnt ;
  int mask ;
  int val ;
  int kv ;
  int mode ;
  int ret ;
  int tmp ;

  {
#line 437
  mask = 0;
#line 438
  val = 0;
#line 439
  ret = 0;
#line 440
  goto ldv_52028;
  ldv_52027: 
#line 441
  cnt = 0U;
#line 442
  goto ldv_52016;
  ldv_52015: 
#line 444
  cnt = cnt + 1U;
  ldv_52016: ;
#line 442
  if (cnt < len && ((int )((signed char )*(ptr + (unsigned long )cnt)) <= 32 || (int )((signed char )*(ptr + (unsigned long )cnt)) == 127)) {
#line 446
    goto ldv_52015;
  } else {

  }
#line 445
  ptr = ptr + (unsigned long )cnt;
#line 446
  len = len - cnt;
#line 447
  mode = 0;
#line 448
  if ((int )((signed char )*ptr) == 45 || (int )((signed char )*ptr) == 43) {
#line 449
    mode = (int )((signed char )*ptr) == 45 ? -1 : 1;
#line 450
    ptr = ptr + 1;
#line 451
    len = len - 1U;
  } else {

  }
#line 453
  cnt = 0U;
#line 454
  goto ldv_52020;
  ldv_52019: ;
#line 455
  if ((int )((signed char )*(ptr + (unsigned long )cnt)) <= 32) {
#line 455
    goto ldv_52018;
  } else {

  }
#line 456
  if ((int )((signed char )*(ptr + (unsigned long )cnt)) == 127) {
#line 456
    goto ldv_52018;
  } else {

  }
#line 457
  cnt = cnt + 1U;
  ldv_52020: ;
#line 454
  if (cnt < len) {
#line 456
    goto ldv_52019;
  } else {

  }
  ldv_52018: ;
#line 459
  if (cnt == 0U) {
#line 459
    goto ldv_52021;
  } else {

  }
#line 460
  tmp = parse_mtoken(ptr, cnt, & kv, names, valid_bits);
#line 460
  if (tmp != 0) {
#line 461
    ret = -22;
#line 462
    goto ldv_52021;
  } else {

  }
#line 464
  ptr = ptr + (unsigned long )cnt;
#line 465
  len = len - cnt;
#line 466
  switch (mode) {
  case 0: 
#line 468
  mask = valid_bits;
#line 469
  val = val | kv;
#line 470
  goto ldv_52023;
  case -1: 
#line 472
  mask = mask | kv;
#line 473
  val = ~ kv & val;
#line 474
  goto ldv_52023;
  case 1: 
#line 476
  mask = mask | kv;
#line 477
  val = val | kv;
#line 478
  goto ldv_52023;
  default: ;
#line 480
  goto ldv_52023;
  }
  ldv_52023: ;
  ldv_52028: ;
#line 440
  if (len != 0U) {
#line 442
    goto ldv_52027;
  } else {

  }
  ldv_52021: 
#line 483
  *maskptr = mask;
#line 484
  *valptr = val;
#line 485
  return (ret);
}
}
#line 490 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
int pvr2_ctrl_sym_to_value(struct pvr2_ctrl *cptr , char const   *ptr , unsigned int len ,
                           int *maskptr , int *valptr ) 
{ 
  int ret ;
  unsigned int cnt ;

  {
#line 494
  ret = -22;
#line 497
  *maskptr = 0;
#line 498
  *valptr = 0;
#line 500
  cnt = 0U;
#line 501
  goto ldv_52039;
  ldv_52038: 
#line 501
  cnt = cnt + 1U;
  ldv_52039: ;
#line 501
  if (cnt < len && ((int )((signed char )*(ptr + (unsigned long )cnt)) <= 32 || (int )((signed char )*(ptr + (unsigned long )cnt)) == 127)) {
#line 503
    goto ldv_52038;
  } else {

  }
#line 502
  len = len - cnt;
#line 502
  ptr = ptr + (unsigned long )cnt;
#line 503
  cnt = 0U;
#line 504
  goto ldv_52042;
  ldv_52041: 
#line 505
  cnt = cnt + 1U;
  ldv_52042: ;
#line 504
  if (cnt < len && ((int )((signed char )*(ptr + (unsigned long )((len - cnt) - 1U))) <= 32 || (int )((signed char )*(ptr + (unsigned long )((len - cnt) - 1U))) == 127)) {
#line 507
    goto ldv_52041;
  } else {

  }
#line 506
  len = len - cnt;
#line 508
  if (len == 0U) {
#line 508
    return (-22);
  } else {

  }
#line 510
  ldv_mutex_lock_444(& (cptr->hdw)->big_lock_mutex);
#line 510
  (cptr->hdw)->big_lock_held = 1;
#line 511
  if ((unsigned int )(cptr->info)->type == 0U) {
#line 512
    ret = parse_token(ptr, len, valptr, (char const   * const  *)0, 0U);
#line 513
    if (ret >= 0) {
#line 514
      ret = pvr2_ctrl_range_check(cptr, *valptr);
    } else {

    }
#line 516
    *maskptr = -1;
  } else
#line 517
  if ((unsigned int )(cptr->info)->type == 3U) {
#line 518
    ret = parse_token(ptr, len, valptr, (char const   * const  *)(& boolNames), 4U);
#line 520
    if (ret == 1) {
#line 521
      *valptr = *valptr != 0;
    } else
#line 522
    if (ret == 0) {
#line 523
      *valptr = *valptr & 1;
    } else {

    }
#line 525
    *maskptr = 1;
  } else
#line 526
  if ((unsigned int )(cptr->info)->type == 1U) {
#line 527
    ret = parse_token(ptr, len, valptr, (cptr->info)->def.type_enum.value_names, (cptr->info)->def.type_enum.count);
#line 531
    if (ret >= 0) {
#line 532
      ret = pvr2_ctrl_range_check(cptr, *valptr);
    } else {

    }
#line 534
    *maskptr = -1;
  } else
#line 535
  if ((unsigned int )(cptr->info)->type == 2U) {
#line 536
    ret = parse_tlist(ptr, len, maskptr, valptr, (cptr->info)->def.type_bitmask.bit_names,
                      (int )(cptr->info)->def.type_bitmask.valid_bits);
  } else {

  }
#line 541
  (cptr->hdw)->big_lock_held = 0;
#line 541
  ldv_mutex_unlock_445(& (cptr->hdw)->big_lock_mutex);
#line 542
  return (ret);
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
int pvr2_ctrl_value_to_sym_internal(struct pvr2_ctrl *cptr , int mask , int val ,
                                    char *buf , unsigned int maxlen , unsigned int *len ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  char const   * const  *names ;
  int tmp___1 ;

  {
#line 552
  ret = -22;
#line 554
  *len = 0U;
#line 555
  if ((unsigned int )(cptr->info)->type == 0U) {
#line 556
    tmp = scnprintf(buf, (size_t )maxlen, "%d", val);
#line 556
    *len = (unsigned int )tmp;
#line 557
    ret = 0;
  } else
#line 558
  if ((unsigned int )(cptr->info)->type == 3U) {
#line 559
    tmp___0 = scnprintf(buf, (size_t )maxlen, "%s", val != 0 ? (char *)"true" : (char *)"false");
#line 559
    *len = (unsigned int )tmp___0;
#line 560
    ret = 0;
  } else
#line 561
  if ((unsigned int )(cptr->info)->type == 1U) {
#line 563
    names = (cptr->info)->def.type_enum.value_names;
#line 564
    if (val >= 0 && (unsigned int )val < (unsigned int )(cptr->info)->def.type_enum.count) {
#line 566
      if ((unsigned long )*(names + (unsigned long )val) != (unsigned long )((char const   */* const  */)0)) {
#line 567
        tmp___1 = scnprintf(buf, (size_t )maxlen, "%s", *(names + (unsigned long )val));
#line 567
        *len = (unsigned int )tmp___1;
      } else {
#line 571
        *len = 0U;
      }
#line 573
      ret = 0;
    } else {

    }
  } else
#line 575
  if ((unsigned int )(cptr->info)->type == 2U) {
#line 576
    *len = gen_bitmask_string((int )((unsigned int )(val & mask) & (unsigned int )(cptr->info)->def.type_bitmask.valid_bits),
                              -1, 1, (cptr->info)->def.type_bitmask.bit_names, buf,
                              maxlen);
  } else {

  }
#line 582
  return (ret);
}
}
#line 587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.c"
int pvr2_ctrl_value_to_sym(struct pvr2_ctrl *cptr , int mask , int val , char *buf ,
                           unsigned int maxlen , unsigned int *len ) 
{ 
  int ret ;

  {
#line 593
  ldv_mutex_lock_446(& (cptr->hdw)->big_lock_mutex);
#line 593
  (cptr->hdw)->big_lock_held = 1;
#line 594
  ret = pvr2_ctrl_value_to_sym_internal(cptr, mask, val, buf, maxlen, len);
#line 596
  (cptr->hdw)->big_lock_held = 0;
#line 596
  ldv_mutex_unlock_447(& (cptr->hdw)->big_lock_mutex);
#line 597
  return (ret);
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
bool ldv_queue_work_on_414(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 354
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 354
  ldv_func_res = tmp;
#line 356
  activate_work_1(ldv_func_arg3, 2);
#line 358
  return (ldv_func_res);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
bool ldv_queue_delayed_work_on_415(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 365
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 365
  ldv_func_res = tmp;
#line 367
  activate_work_1(& ldv_func_arg3->work, 2);
#line 369
  return (ldv_func_res);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
bool ldv_queue_work_on_416(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 376
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 376
  ldv_func_res = tmp;
#line 378
  activate_work_1(ldv_func_arg3, 2);
#line 380
  return (ldv_func_res);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_flush_workqueue_417(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 386
  flush_workqueue(ldv_func_arg1);
#line 388
  call_and_disable_all_1(2);
#line 389
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
bool ldv_queue_delayed_work_on_418(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 395
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 395
  ldv_func_res = tmp;
#line 397
  activate_work_1(& ldv_func_arg3->work, 2);
#line 399
  return (ldv_func_res);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_lock_419(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 405
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 407
  mutex_lock(ldv_func_arg1);
#line 408
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_unlock_420(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 413
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 415
  mutex_unlock(ldv_func_arg1);
#line 416
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_lock_421(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 421
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 423
  mutex_lock(ldv_func_arg1);
#line 424
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
int ldv_mutex_trylock_422(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 430
  tmp = mutex_trylock(ldv_func_arg1);
#line 430
  ldv_func_res = tmp;
#line 432
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 432
  return (tmp___0);
#line 434
  return (ldv_func_res);
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_unlock_423(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 440
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 442
  mutex_unlock(ldv_func_arg1);
#line 443
  return;
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_unlock_424(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 448
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 450
  mutex_unlock(ldv_func_arg1);
#line 451
  return;
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_lock_425(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 456
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 458
  mutex_lock(ldv_func_arg1);
#line 459
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_lock_426(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 464
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 466
  mutex_lock(ldv_func_arg1);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_unlock_427(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 472
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 474
  mutex_unlock(ldv_func_arg1);
#line 475
  return;
}
}
#line 477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_lock_428(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 480
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 482
  mutex_lock(ldv_func_arg1);
#line 483
  return;
}
}
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_unlock_429(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 488
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 490
  mutex_unlock(ldv_func_arg1);
#line 491
  return;
}
}
#line 493 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_lock_430(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 496
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 498
  mutex_lock(ldv_func_arg1);
#line 499
  return;
}
}
#line 501 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_unlock_431(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 504
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 506
  mutex_unlock(ldv_func_arg1);
#line 507
  return;
}
}
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_lock_432(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 512
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 514
  mutex_lock(ldv_func_arg1);
#line 515
  return;
}
}
#line 517 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_unlock_433(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 520
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 522
  mutex_unlock(ldv_func_arg1);
#line 523
  return;
}
}
#line 525 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_lock_434(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 528
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 530
  mutex_lock(ldv_func_arg1);
#line 531
  return;
}
}
#line 533 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_unlock_435(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 536
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 538
  mutex_unlock(ldv_func_arg1);
#line 539
  return;
}
}
#line 541 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_lock_436(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 544
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 546
  mutex_lock(ldv_func_arg1);
#line 547
  return;
}
}
#line 549 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_unlock_437(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 552
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 554
  mutex_unlock(ldv_func_arg1);
#line 555
  return;
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_lock_438(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 560
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 562
  mutex_lock(ldv_func_arg1);
#line 563
  return;
}
}
#line 565 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_unlock_439(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 568
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 570
  mutex_unlock(ldv_func_arg1);
#line 571
  return;
}
}
#line 573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_lock_440(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 576
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 578
  mutex_lock(ldv_func_arg1);
#line 579
  return;
}
}
#line 581 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_unlock_441(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 584
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 586
  mutex_unlock(ldv_func_arg1);
#line 587
  return;
}
}
#line 589 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_lock_442(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 592
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 594
  mutex_lock(ldv_func_arg1);
#line 595
  return;
}
}
#line 597 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_unlock_443(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 600
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 602
  mutex_unlock(ldv_func_arg1);
#line 603
  return;
}
}
#line 605 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_lock_444(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 608
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 610
  mutex_lock(ldv_func_arg1);
#line 611
  return;
}
}
#line 613 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_unlock_445(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 616
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 618
  mutex_unlock(ldv_func_arg1);
#line 619
  return;
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_lock_446(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 624
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 626
  mutex_lock(ldv_func_arg1);
#line 627
  return;
}
}
#line 629 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ctrl.o.c.prepared"
void ldv_mutex_unlock_447(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 632
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(ldv_func_arg1);
#line 634
  mutex_unlock(ldv_func_arg1);
#line 635
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_486(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_488(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_487(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_490(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_489(struct workqueue_struct *ldv_func_arg1 ) ;
#line 43 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-std.h"
struct v4l2_standard *pvr2_std_create_enum(unsigned int *countptr , v4l2_std_id id ) ;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-std.c"
static struct std_name  const  std_groups[4U]  = {      {"PAL", 4095ULL}, 
        {"NTSC", 61440ULL}, 
        {"SECAM", 16711680ULL}, 
        {"ATSC", 50331648ULL}};
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-std.c"
static struct std_name  const  std_items[20U]  = 
#line 92
  {      {"B", 65537ULL}, 
        {"B1", 2ULL}, 
        {"D", 131104ULL}, 
        {"D1", 64ULL}, 
        {"G", 262148ULL}, 
        {"H", 524296ULL}, 
        {"I", 16ULL}, 
        {"K", 1048704ULL}, 
        {"K1", 2097152ULL}, 
        {"L", 4194304ULL}, 
        {"LC", 8388608ULL}, 
        {"M", 4352ULL}, 
        {"Mj", 8192ULL}, 
        {"443", 16384ULL}, 
        {"Mk", 32768ULL}, 
        {"N", 512ULL}, 
        {"Nc", 1024ULL}, 
        {"60", 2048ULL}, 
        {"8VSB", 16777216ULL}, 
        {"16VSB", 33554432ULL}};
#line 118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-std.c"
static struct std_name  const  *find_std_name(struct std_name  const  *arrPtr , unsigned int arrSize ,
                                              char const   *bufPtr , unsigned int bufSize ) 
{ 
  unsigned int idx ;
  struct std_name  const  *p ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 125
  idx = 0U;
#line 125
  goto ldv_19820;
  ldv_19819: 
#line 126
  p = arrPtr + (unsigned long )idx;
#line 127
  tmp = strlen(p->name);
#line 127
  if (tmp != (size_t )bufSize) {
#line 127
    goto ldv_19818;
  } else {

  }
#line 128
  tmp___0 = memcmp((void const   *)bufPtr, (void const   *)p->name, (size_t )bufSize);
#line 128
  if (tmp___0 == 0) {
#line 128
    return (p);
  } else {

  }
  ldv_19818: 
#line 125
  idx = idx + 1U;
  ldv_19820: ;
#line 125
  if (idx < arrSize) {
#line 127
    goto ldv_19819;
  } else {

  }

#line 130
  return ((struct std_name  const  *)0);
}
}
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-std.c"
int pvr2_std_str_to_id(v4l2_std_id *idPtr , char const   *bufPtr , unsigned int bufSize ) 
{ 
  v4l2_std_id id ;
  v4l2_std_id cmsk ;
  v4l2_std_id t ;
  int mMode ;
  unsigned int cnt ;
  char ch ;
  struct std_name  const  *sp ;

  {
#line 137
  id = 0ULL;
#line 138
  cmsk = 0ULL;
#line 140
  mMode = 0;
#line 145
  goto ldv_19839;
  ldv_19845: ;
#line 146
  if (mMode == 0) {
#line 147
    cnt = 0U;
#line 148
    goto ldv_19835;
    ldv_19834: 
#line 148
    cnt = cnt + 1U;
    ldv_19835: ;
#line 148
    if (cnt < bufSize && (int )((signed char )*(bufPtr + (unsigned long )cnt)) != 45) {
#line 150
      goto ldv_19834;
    } else {

    }

#line 149
    if (cnt >= bufSize) {
#line 149
      return (0);
    } else {

    }
#line 150
    sp = find_std_name((struct std_name  const  *)(& std_groups), 4U, bufPtr, cnt);
#line 152
    if ((unsigned long )sp == (unsigned long )((struct std_name  const  *)0)) {
#line 152
      return (0);
    } else {

    }
#line 153
    cnt = cnt + 1U;
#line 154
    bufPtr = bufPtr + (unsigned long )cnt;
#line 155
    bufSize = bufSize - cnt;
#line 156
    mMode = 1;
#line 157
    cmsk = sp->id;
#line 158
    goto ldv_19839;
  } else {

  }
#line 160
  cnt = 0U;
#line 161
  goto ldv_19842;
  ldv_19841: 
#line 162
  ch = *(bufPtr + (unsigned long )cnt);
#line 163
  if ((int )((signed char )ch) == 59) {
#line 164
    mMode = 0;
#line 165
    goto ldv_19840;
  } else {

  }
#line 167
  if ((int )((signed char )ch) == 47) {
#line 167
    goto ldv_19840;
  } else {

  }
#line 168
  cnt = cnt + 1U;
  ldv_19842: ;
#line 161
  if (cnt < bufSize) {
#line 163
    goto ldv_19841;
  } else {

  }
  ldv_19840: 
#line 170
  sp = find_std_name((struct std_name  const  *)(& std_items), 20U, bufPtr, cnt);
#line 172
  if ((unsigned long )sp == (unsigned long )((struct std_name  const  *)0)) {
#line 172
    return (0);
  } else {

  }
#line 173
  t = (unsigned long long )sp->id & cmsk;
#line 174
  if (t == 0ULL) {
#line 174
    return (0);
  } else {

  }
#line 175
  id = id | t;
#line 176
  if (cnt < bufSize) {
#line 176
    cnt = cnt + 1U;
  } else {

  }
#line 177
  bufPtr = bufPtr + (unsigned long )cnt;
#line 178
  bufSize = bufSize - cnt;
  ldv_19839: ;
#line 145
  if (bufSize != 0U) {
#line 147
    goto ldv_19845;
  } else {

  }

#line 181
  if ((unsigned long )idPtr != (unsigned long )((v4l2_std_id *)0ULL)) {
#line 181
    *idPtr = id;
  } else {

  }
#line 182
  return (1);
}
}
#line 186 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-std.c"
unsigned int pvr2_std_id_to_str(char *bufPtr , unsigned int bufSize , v4l2_std_id id ) 
{ 
  unsigned int idx1 ;
  unsigned int idx2 ;
  struct std_name  const  *ip ;
  struct std_name  const  *gp ;
  int gfl ;
  int cfl ;
  unsigned int c1 ;
  unsigned int c2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 193
  cfl = 0;
#line 194
  c1 = 0U;
#line 195
  idx1 = 0U;
#line 195
  goto ldv_19869;
  ldv_19868: 
#line 196
  gp = (struct std_name  const  *)(& std_groups) + (unsigned long )idx1;
#line 197
  gfl = 0;
#line 198
  idx2 = 0U;
#line 198
  goto ldv_19866;
  ldv_19865: 
#line 199
  ip = (struct std_name  const  *)(& std_items) + (unsigned long )idx2;
#line 200
  if ((((unsigned long long )gp->id & (unsigned long long )ip->id) & id) == 0ULL) {
#line 200
    goto ldv_19864;
  } else {

  }
#line 201
  if (gfl == 0) {
#line 202
    if (cfl != 0) {
#line 203
      tmp = scnprintf(bufPtr, (size_t )bufSize, ";");
#line 203
      c2 = (unsigned int )tmp;
#line 204
      c1 = c1 + c2;
#line 205
      bufSize = bufSize - c2;
#line 206
      bufPtr = bufPtr + (unsigned long )c2;
    } else {

    }
#line 208
    cfl = 1;
#line 209
    tmp___0 = scnprintf(bufPtr, (size_t )bufSize, "%s-", gp->name);
#line 209
    c2 = (unsigned int )tmp___0;
#line 211
    gfl = 1;
  } else {
#line 213
    tmp___1 = scnprintf(bufPtr, (size_t )bufSize, "/");
#line 213
    c2 = (unsigned int )tmp___1;
  }
#line 215
  c1 = c1 + c2;
#line 216
  bufSize = bufSize - c2;
#line 217
  bufPtr = bufPtr + (unsigned long )c2;
#line 218
  tmp___2 = scnprintf(bufPtr, (size_t )bufSize, ip->name);
#line 218
  c2 = (unsigned int )tmp___2;
#line 220
  c1 = c1 + c2;
#line 221
  bufSize = bufSize - c2;
#line 222
  bufPtr = bufPtr + (unsigned long )c2;
  ldv_19864: 
#line 198
  idx2 = idx2 + 1U;
  ldv_19866: ;
#line 198
  if (idx2 <= 19U) {
#line 200
    goto ldv_19865;
  } else {

  }
#line 195
  idx1 = idx1 + 1U;
  ldv_19869: ;
#line 195
  if (idx1 <= 3U) {
#line 197
    goto ldv_19868;
  } else {

  }

#line 225
  return (c1);
}
}
#line 231 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-std.c"
static struct v4l2_standard generic_standards[4U]  = {      {0U, 16713471ULL, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
      {1U, 25U}, 625U, {0U, 0U, 0U, 0U}}, 
        {0U, 45312ULL, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
      {1001U, 30000U}, 525U, {0U, 0U, 0U, 0U}}, 
        {0U, 2048ULL, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
      {1001U, 30000U}, 525U, {0U, 0U, 0U, 0U}}, 
        {0U, 16384ULL, {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                     (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
      {1001U, 30000U}, 525U, {0U, 0U, 0U, 0U}}};
#line 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-std.c"
static struct v4l2_standard *match_std(v4l2_std_id id ) 
{ 
  unsigned int idx ;

  {
#line 284
  idx = 0U;
#line 284
  goto ldv_19879;
  ldv_19878: ;
#line 285
  if ((generic_standards[idx].id & id) != 0ULL) {
#line 286
    return ((struct v4l2_standard *)(& generic_standards) + (unsigned long )idx);
  } else {

  }
#line 284
  idx = idx + 1U;
  ldv_19879: ;
#line 284
  if (idx <= 3U) {
#line 286
    goto ldv_19878;
  } else {

  }

#line 289
  return ((struct v4l2_standard *)0);
}
}
#line 292 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-std.c"
static int pvr2_std_fill(struct v4l2_standard *std , v4l2_std_id id ) 
{ 
  struct v4l2_standard *template ;
  int idx ;
  unsigned int bcnt ;

  {
#line 297
  template = match_std(id);
#line 298
  if ((unsigned long )template == (unsigned long )((struct v4l2_standard *)0)) {
#line 298
    return (0);
  } else {

  }
#line 299
  idx = (int )std->index;
#line 300
  memcpy((void *)std, (void const   *)template, 72UL);
#line 301
  std->index = (__u32 )idx;
#line 302
  std->id = id;
#line 303
  bcnt = pvr2_std_id_to_str((char *)(& std->name), 23U, id);
#line 304
  std->name[bcnt] = 0U;
#line 305
  if ((pvrusb2_debug & 16) != 0) {
#line 305
    printk("\016pvrusb2: Set up standard idx=%u name=%s\n", std->index, (__u8 *)(& std->name));
  } else {

  }
#line 307
  return (1);
}
}
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-std.c"
static v4l2_std_id std_mixes[4U]  = {      5ULL,      160ULL,      327680ULL,      1179648ULL};
#line 319 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-std.c"
struct v4l2_standard *pvr2_std_create_enum(unsigned int *countptr , v4l2_std_id id ) 
{ 
  unsigned int std_cnt ;
  unsigned int idx ;
  unsigned int bcnt ;
  unsigned int idx2 ;
  v4l2_std_id idmsk ;
  v4l2_std_id cmsk ;
  v4l2_std_id fmsk ;
  struct v4l2_standard *stddefs ;
  char buf[100U] ;
  struct v4l2_standard *tmp ;
  char buf___0[100U] ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 322
  std_cnt = 0U;
#line 327
  if ((pvrusb2_debug & 16) != 0) {
#line 329
    bcnt = pvr2_std_id_to_str((char *)(& buf), 100U, id);
#line 330
    if ((pvrusb2_debug & 16) != 0) {
#line 330
      printk("\016pvrusb2: Mapping standards mask=0x%x (%.*s)\n", (int )id, bcnt,
             (char *)(& buf));
    } else {

    }
  } else {

  }
#line 335
  *countptr = 0U;
#line 336
  std_cnt = 0U;
#line 337
  fmsk = 0ULL;
#line 338
  idmsk = 1ULL;
#line 338
  cmsk = id;
#line 338
  goto ldv_19904;
  ldv_19903: ;
#line 339
  if ((idmsk & cmsk) == 0ULL) {
#line 339
    goto ldv_19902;
  } else {

  }
#line 340
  cmsk = ~ idmsk & cmsk;
#line 341
  tmp = match_std(idmsk);
#line 341
  if ((unsigned long )tmp != (unsigned long )((struct v4l2_standard *)0)) {
#line 342
    std_cnt = std_cnt + 1U;
#line 343
    goto ldv_19902;
  } else {

  }
#line 345
  fmsk = fmsk | idmsk;
  ldv_19902: 
#line 338
  idmsk = idmsk << 1;
  ldv_19904: ;
#line 338
  if (cmsk != 0ULL) {
#line 340
    goto ldv_19903;
  } else {

  }
#line 348
  idx2 = 0U;
#line 348
  goto ldv_19909;
  ldv_19908: ;
#line 349
  if ((std_mixes[idx2] & id) == std_mixes[idx2]) {
#line 349
    std_cnt = std_cnt + 1U;
  } else {

  }
#line 348
  idx2 = idx2 + 1U;
  ldv_19909: ;
#line 348
  if (idx2 <= 3U) {
#line 350
    goto ldv_19908;
  } else {

  }
#line 353
  fmsk = fmsk & 0xfffffffffcffffffULL;
#line 355
  if (fmsk != 0ULL) {
#line 357
    bcnt = pvr2_std_id_to_str((char *)(& buf___0), 100U, fmsk);
#line 358
    if ((pvrusb2_debug & 2) != 0) {
#line 358
      printk("\016pvrusb2: WARNING: Failed to classify the following standard(s): %.*s\n",
             bcnt, (char *)(& buf___0));
    } else {

    }
  } else {

  }
#line 365
  if ((pvrusb2_debug & 16) != 0) {
#line 365
    printk("\016pvrusb2: Setting up %u unique standard(s)\n", std_cnt);
  } else {

  }
#line 367
  if (std_cnt == 0U) {
#line 367
    return ((struct v4l2_standard *)0);
  } else {

  }
#line 369
  tmp___0 = kzalloc((unsigned long )std_cnt * 72UL, 208U);
#line 369
  stddefs = (struct v4l2_standard *)tmp___0;
#line 371
  if ((unsigned long )stddefs == (unsigned long )((struct v4l2_standard *)0)) {
#line 372
    return ((struct v4l2_standard *)0);
  } else {

  }
#line 374
  idx = 0U;
#line 374
  goto ldv_19913;
  ldv_19912: 
#line 375
  (stddefs + (unsigned long )idx)->index = idx;
#line 374
  idx = idx + 1U;
  ldv_19913: ;
#line 374
  if (idx < std_cnt) {
#line 376
    goto ldv_19912;
  } else {

  }
#line 377
  idx = 0U;
#line 380
  idx2 = 0U;
#line 380
  goto ldv_19919;
  ldv_19918: ;
#line 382
  if ((std_mixes[idx2] & id) == 0ULL) {
#line 382
    goto ldv_19917;
  } else {

  }
#line 383
  tmp___1 = pvr2_std_fill(stddefs + (unsigned long )idx, std_mixes[idx2]);
#line 383
  if (tmp___1 != 0) {
#line 383
    idx = idx + 1U;
  } else {

  }
  ldv_19917: 
#line 381
  idx2 = idx2 + 1U;
  ldv_19919: ;
#line 380
  if (idx2 <= 3U && idx < std_cnt) {
#line 382
    goto ldv_19918;
  } else {

  }
#line 386
  idmsk = 1ULL;
#line 386
  cmsk = id;
#line 386
  goto ldv_19923;
  ldv_19922: ;
#line 387
  if ((idmsk & cmsk) == 0ULL) {
#line 387
    goto ldv_19921;
  } else {

  }
#line 388
  cmsk = ~ idmsk & cmsk;
#line 389
  tmp___2 = pvr2_std_fill(stddefs + (unsigned long )idx, idmsk);
#line 389
  if (tmp___2 == 0) {
#line 389
    goto ldv_19921;
  } else {

  }
#line 390
  idx = idx + 1U;
  ldv_19921: 
#line 386
  idmsk = idmsk << 1;
  ldv_19923: ;
#line 386
  if (cmsk != 0ULL && idx < std_cnt) {
#line 388
    goto ldv_19922;
  } else {

  }
#line 393
  *countptr = std_cnt;
#line 394
  return (stddefs);
}
}
#line 397 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-std.c"
v4l2_std_id pvr2_std_get_usable(void) 
{ 


  {
#line 399
  return (67108863ULL);
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-std.o.c.prepared"
bool ldv_queue_work_on_486(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 354
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 354
  ldv_func_res = tmp;
#line 356
  activate_work_1(ldv_func_arg3, 2);
#line 358
  return (ldv_func_res);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-std.o.c.prepared"
bool ldv_queue_delayed_work_on_487(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 365
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 365
  ldv_func_res = tmp;
#line 367
  activate_work_1(& ldv_func_arg3->work, 2);
#line 369
  return (ldv_func_res);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-std.o.c.prepared"
bool ldv_queue_work_on_488(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 376
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 376
  ldv_func_res = tmp;
#line 378
  activate_work_1(ldv_func_arg3, 2);
#line 380
  return (ldv_func_res);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-std.o.c.prepared"
void ldv_flush_workqueue_489(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 386
  flush_workqueue(ldv_func_arg1);
#line 388
  call_and_disable_all_1(2);
#line 389
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-std.o.c.prepared"
bool ldv_queue_delayed_work_on_490(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 395
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 395
  ldv_func_res = tmp;
#line 397
  activate_work_1(& ldv_func_arg3->work, 2);
#line 399
  return (ldv_func_res);
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_508(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_506(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_509(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_510(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_513(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_mutex_lock_505(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_507(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_511(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_512(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_500(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_502(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_501(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_504(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_503(struct workqueue_struct *ldv_func_arg1 ) ;
#line 196 "include/linux/module.h"
extern void *__symbol_get(char const   * ) ;
#line 492
extern void __symbol_put(char const   * ) ;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_device_client_desc  const  pvr2_cli_29xxx[4U]  = {      {3U, 0}, 
        {1U, 0}, 
        {4U, 0}, 
        {7U, 0}};
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static char const   *pvr2_fw1_names_29xxx[1U]  = {      "v4l-pvrusb2-29xxx-01.fw"};
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_device_desc  const  pvr2_device_29xxx  = 
#line 62
     {"WinTV PVR USB2 Model 29xxx", "29xxx", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_29xxx),
                                                     4U}, {(char const   **)(& pvr2_fw1_names_29xxx),
                                                           1U}, 0, 0ULL, 0, 0U, 1U,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, 4U, 1U, 1U, 1U, 1U, (unsigned char)0, (unsigned char)0};
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_device_client_desc  const  pvr2_cli_24xxx[4U]  = {      {2U, 0}, 
        {4U, 0}, 
        {6U, 0}, 
        {7U, 0}};
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static char const   *pvr2_fw1_names_24xxx[1U]  = {      "v4l-pvrusb2-24xxx-01.fw"};
#line 96 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_device_desc  const  pvr2_device_24xxx  = 
#line 96
     {"WinTV PVR USB2 Model 24xxx", "24xxx", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_24xxx),
                                                     4U}, {(char const   **)(& pvr2_fw1_names_24xxx),
                                                           1U}, 0, 0ULL, 0, 0U, 1U,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, 1U,
    1U, 1U, 1U, 1U, 1U, 1U, (unsigned char)0, (unsigned char)0};
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_device_client_desc  const  pvr2_cli_gotview_2[3U]  = {      {2U, 0}, 
        {4U, 0}, 
        {7U, 0}};
#line 126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_device_desc  const  pvr2_device_gotview_2  = 
#line 126
     {"Gotview USB 2.0 DVD 2", "gv2", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_gotview_2),
                                              3U}, {0, 0U}, 0, 0ULL, 38, 1U, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    1U, (unsigned char)0, (unsigned char)0, 1U, 1U, 1U, 1U, (unsigned char)0, (unsigned char)0};
#line 147 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_device_desc  const  pvr2_device_gotview_2d  = 
#line 147
     {"Gotview USB 2.0 DVD Deluxe", "gv2d", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_gotview_2),
                                                    3U}, {0, 0U}, 0, 0ULL, 38, 1U,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U,
    1U, 1U, (unsigned char)0, (unsigned char)0};
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_device_client_desc  const  pvr2_cli_av400[1U]  = {      {2U, 0}};
#line 169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_device_desc  const  pvr2_device_av400  = 
#line 169
     {"Terratec Grabster AV400", "av400", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_av400),
                                                  1U}, {0, 0U}, 0, 0ULL, 0, 3U, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, 1U, 1U, (unsigned char)0,
    1U};
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct lgdt330x_config pvr2_lgdt3303_config  =    {14U, 2, 0, 0, 0, 1};
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static int pvr2_lgdt3303_attach(struct pvr2_dvb_adapter *adap ) 
{ 
  void *__r ;
  struct dvb_frontend *(*__a)(struct lgdt330x_config  const  * , struct i2c_adapter * ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct lgdt330x_config  const  * , struct i2c_adapter * ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;

  {
#line 196
  __r = (void *)0;
#line 196
  tmp___2 = __symbol_get("lgdt330x_attach");
#line 196
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct lgdt330x_config  const  * ,
                                                       struct i2c_adapter * ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct lgdt330x_config  const  * ,
                                                                                                                                     struct i2c_adapter * ))0);
#line 196
  if (tmp___1) {

  } else {
#line 196
    __request_module(1, "symbol:lgdt330x_attach");
#line 196
    tmp___0 = __symbol_get("lgdt330x_attach");
#line 196
    tmp___1 = (struct dvb_frontend *(*)(struct lgdt330x_config  const  * , struct i2c_adapter * ))tmp___0;
  }
#line 196
  __a = tmp___1;
#line 196
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct lgdt330x_config  const  * ,
                                                                        struct i2c_adapter * ))0)) {
#line 196
    tmp___3 = (*__a)((struct lgdt330x_config  const  *)(& pvr2_lgdt3303_config), & (adap->channel.hdw)->i2c_adap);
#line 196
    __r = (void *)tmp___3;
#line 196
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 196
      __symbol_put("lgdt330x_attach");
    } else {

    }
  } else {
#line 196
    printk("\vDVB: Unable to find symbol lgdt330x_attach()\n");
  }
#line 196
  adap->fe = (struct dvb_frontend *)__r;
#line 198
  if ((unsigned long )adap->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 199
    return (0);
  } else {

  }
#line 201
  return (-5);
}
}
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static int pvr2_lgh06xf_attach(struct pvr2_dvb_adapter *adap ) 
{ 
  void *__r ;
  struct dvb_frontend *(*__a)(struct dvb_frontend * , struct i2c_adapter * , u8  ,
                              unsigned int  ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct dvb_frontend * , struct i2c_adapter * , u8  ,
                                  unsigned int  ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;

  {
#line 206
  __r = (void *)0;
#line 206
  tmp___2 = __symbol_get("simple_tuner_attach");
#line 206
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                                       u8  , unsigned int  ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                    struct i2c_adapter * ,
                                                                                                                                    u8  ,
                                                                                                                                    unsigned int  ))0);
#line 206
  if (tmp___1) {

  } else {
#line 206
    __request_module(1, "symbol:simple_tuner_attach");
#line 206
    tmp___0 = __symbol_get("simple_tuner_attach");
#line 206
    tmp___1 = (struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                        u8  , unsigned int  ))tmp___0;
  }
#line 206
  __a = tmp___1;
#line 206
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                        struct i2c_adapter * ,
                                                                        u8  , unsigned int  ))0)) {
#line 206
    tmp___3 = (*__a)(adap->fe, & (adap->channel.hdw)->i2c_adap, 97, 64U);
#line 206
    __r = (void *)tmp___3;
#line 206
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 206
      __symbol_put("simple_tuner_attach");
    } else {

    }
  } else {
#line 206
    printk("\vDVB: Unable to find symbol simple_tuner_attach()\n");
  }
#line 210
  return (0);
}
}
#line 213 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_dvb_props  const  pvr2_onair_creator_fe_props  =    {& pvr2_lgdt3303_attach, & pvr2_lgh06xf_attach};
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_device_client_desc  const  pvr2_cli_onair_creator[3U]  = {      {3U, 0}, 
        {5U, 0}, 
        {4U, 0}};
#line 225 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_device_desc  const  pvr2_device_onair_creator  = 
#line 225
     {"OnAir Creator Hybrid USB tuner", "oac", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_onair_creator),
                                                       3U}, {0, 0U}, & pvr2_onair_creator_fe_props,
    4096ULL, 64, 2U, (unsigned char)0, 2U, (unsigned char)0, 1U, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    1U, 1U, 1U, (unsigned char)0, (unsigned char)0};
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct lgdt330x_config pvr2_lgdt3302_config  =    {14U, 1, 0, 0, 0, 0};
#line 254 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static int pvr2_lgdt3302_attach(struct pvr2_dvb_adapter *adap ) 
{ 
  void *__r ;
  struct dvb_frontend *(*__a)(struct lgdt330x_config  const  * , struct i2c_adapter * ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct lgdt330x_config  const  * , struct i2c_adapter * ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;

  {
#line 256
  __r = (void *)0;
#line 256
  tmp___2 = __symbol_get("lgdt330x_attach");
#line 256
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct lgdt330x_config  const  * ,
                                                       struct i2c_adapter * ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct lgdt330x_config  const  * ,
                                                                                                                                     struct i2c_adapter * ))0);
#line 256
  if (tmp___1) {

  } else {
#line 256
    __request_module(1, "symbol:lgdt330x_attach");
#line 256
    tmp___0 = __symbol_get("lgdt330x_attach");
#line 256
    tmp___1 = (struct dvb_frontend *(*)(struct lgdt330x_config  const  * , struct i2c_adapter * ))tmp___0;
  }
#line 256
  __a = tmp___1;
#line 256
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct lgdt330x_config  const  * ,
                                                                        struct i2c_adapter * ))0)) {
#line 256
    tmp___3 = (*__a)((struct lgdt330x_config  const  *)(& pvr2_lgdt3302_config), & (adap->channel.hdw)->i2c_adap);
#line 256
    __r = (void *)tmp___3;
#line 256
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 256
      __symbol_put("lgdt330x_attach");
    } else {

    }
  } else {
#line 256
    printk("\vDVB: Unable to find symbol lgdt330x_attach()\n");
  }
#line 256
  adap->fe = (struct dvb_frontend *)__r;
#line 258
  if ((unsigned long )adap->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 259
    return (0);
  } else {

  }
#line 261
  return (-5);
}
}
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static int pvr2_fcv1236d_attach(struct pvr2_dvb_adapter *adap ) 
{ 
  void *__r ;
  struct dvb_frontend *(*__a)(struct dvb_frontend * , struct i2c_adapter * , u8  ,
                              unsigned int  ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct dvb_frontend * , struct i2c_adapter * , u8  ,
                                  unsigned int  ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;

  {
#line 266
  __r = (void *)0;
#line 266
  tmp___2 = __symbol_get("simple_tuner_attach");
#line 266
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                                       u8  , unsigned int  ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                    struct i2c_adapter * ,
                                                                                                                                    u8  ,
                                                                                                                                    unsigned int  ))0);
#line 266
  if (tmp___1) {

  } else {
#line 266
    __request_module(1, "symbol:simple_tuner_attach");
#line 266
    tmp___0 = __symbol_get("simple_tuner_attach");
#line 266
    tmp___1 = (struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                        u8  , unsigned int  ))tmp___0;
  }
#line 266
  __a = tmp___1;
#line 266
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                        struct i2c_adapter * ,
                                                                        u8  , unsigned int  ))0)) {
#line 266
    tmp___3 = (*__a)(adap->fe, & (adap->channel.hdw)->i2c_adap, 97, 42U);
#line 266
    __r = (void *)tmp___3;
#line 266
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 266
      __symbol_put("simple_tuner_attach");
    } else {

    }
  } else {
#line 266
    printk("\vDVB: Unable to find symbol simple_tuner_attach()\n");
  }
#line 270
  return (0);
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_dvb_props  const  pvr2_onair_usb2_fe_props  =    {& pvr2_lgdt3302_attach, & pvr2_fcv1236d_attach};
#line 279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_device_client_desc  const  pvr2_cli_onair_usb2[3U]  = {      {3U, 0}, 
        {5U, 0}, 
        {4U, 0}};
#line 285 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_device_desc  const  pvr2_device_onair_usb2  = 
#line 285
     {"OnAir USB2 Hybrid USB tuner", "oa2", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_onair_usb2),
                                                    3U}, {0, 0U}, & pvr2_onair_usb2_fe_props,
    4096ULL, 42, 2U, (unsigned char)0, 2U, (unsigned char)0, 1U, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    1U, 1U, 1U, (unsigned char)0, (unsigned char)0};
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct tda10048_config hauppauge_tda10048_config  = 
#line 309
     {8U, 0U, 50U, 1U, 3300U, 3800U, 4300U, 16000U, 1U, (_Bool)0, (_Bool)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0};
#line 321 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct tda829x_config tda829x_no_probe  =    {0, 1U, (unsigned char)0, 0};
#line 325 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct tda18271_std_map hauppauge_tda18271_dvbt_std_map  = 
#line 325
     {{(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {(unsigned short)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {(unsigned short)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {(unsigned short)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0},
    {3300U, 3U, 4U, (unsigned char)0, 1U, 55U}, {3800U, 3U, 5U, (unsigned char)0,
                                                 1U, 55U}, {4300U, 3U, 6U, (unsigned char)0,
                                                            1U, 55U}, {(unsigned short)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}};
#line 334 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct tda18271_config hauppauge_tda18271_dvb_config  = 
#line 334
     {& hauppauge_tda18271_dvbt_std_map, 0, 1, 1, 0, (unsigned char)0, (unsigned char)0,
    0U};
#line 340 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static int pvr2_tda10048_attach(struct pvr2_dvb_adapter *adap ) 
{ 
  void *__r ;
  struct dvb_frontend *(*__a)(struct tda10048_config  const  * , struct i2c_adapter * ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct tda10048_config  const  * , struct i2c_adapter * ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;

  {
#line 342
  __r = (void *)0;
#line 342
  tmp___2 = __symbol_get("tda10048_attach");
#line 342
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct tda10048_config  const  * ,
                                                       struct i2c_adapter * ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct tda10048_config  const  * ,
                                                                                                                                     struct i2c_adapter * ))0);
#line 342
  if (tmp___1) {

  } else {
#line 342
    __request_module(1, "symbol:tda10048_attach");
#line 342
    tmp___0 = __symbol_get("tda10048_attach");
#line 342
    tmp___1 = (struct dvb_frontend *(*)(struct tda10048_config  const  * , struct i2c_adapter * ))tmp___0;
  }
#line 342
  __a = tmp___1;
#line 342
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct tda10048_config  const  * ,
                                                                        struct i2c_adapter * ))0)) {
#line 342
    tmp___3 = (*__a)((struct tda10048_config  const  *)(& hauppauge_tda10048_config),
                     & (adap->channel.hdw)->i2c_adap);
#line 342
    __r = (void *)tmp___3;
#line 342
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 342
      __symbol_put("tda10048_attach");
    } else {

    }
  } else {
#line 342
    printk("\vDVB: Unable to find symbol tda10048_attach()\n");
  }
#line 342
  adap->fe = (struct dvb_frontend *)__r;
#line 344
  if ((unsigned long )adap->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 345
    return (0);
  } else {

  }
#line 347
  return (-5);
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static int pvr2_73xxx_tda18271_8295_attach(struct pvr2_dvb_adapter *adap ) 
{ 
  void *__r ;
  struct dvb_frontend *(*__a)(struct dvb_frontend * , struct i2c_adapter * , u8  ,
                              struct tda829x_config * ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct dvb_frontend * , struct i2c_adapter * , u8  ,
                                  struct tda829x_config * ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;
  void *__r___0 ;
  struct dvb_frontend *(*__a___0)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                  struct tda18271_config * ) ;
  void *tmp___5 ;
  struct dvb_frontend *(*tmp___6)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                  struct tda18271_config * ) ;
  void *tmp___7 ;
  struct dvb_frontend *tmp___8 ;

  {
#line 352
  __r = (void *)0;
#line 352
  tmp___2 = __symbol_get("tda829x_attach");
#line 352
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                                       u8  , struct tda829x_config * ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                              struct i2c_adapter * ,
                                                                                                                                              u8  ,
                                                                                                                                              struct tda829x_config * ))0);
#line 352
  if (tmp___1) {

  } else {
#line 352
    __request_module(1, "symbol:tda829x_attach");
#line 352
    tmp___0 = __symbol_get("tda829x_attach");
#line 352
    tmp___1 = (struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                        u8  , struct tda829x_config * ))tmp___0;
  }
#line 352
  __a = tmp___1;
#line 352
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                        struct i2c_adapter * ,
                                                                        u8  , struct tda829x_config * ))0)) {
#line 352
    tmp___3 = (*__a)(adap->fe, & (adap->channel.hdw)->i2c_adap, 66, & tda829x_no_probe);
#line 352
    __r = (void *)tmp___3;
#line 352
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 352
      __symbol_put("tda829x_attach");
    } else {

    }
  } else {
#line 352
    printk("\vDVB: Unable to find symbol tda829x_attach()\n");
  }
#line 355
  __r___0 = (void *)0;
#line 355
  tmp___7 = __symbol_get("tda18271_attach");
#line 355
  tmp___6 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * , u8  ,
                                                       struct i2c_adapter * , struct tda18271_config * ))tmp___7) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                                                u8  ,
                                                                                                                                                                struct i2c_adapter * ,
                                                                                                                                                                struct tda18271_config * ))0);
#line 355
  if (tmp___6) {

  } else {
#line 355
    __request_module(1, "symbol:tda18271_attach");
#line 355
    tmp___5 = __symbol_get("tda18271_attach");
#line 355
    tmp___6 = (struct dvb_frontend *(*)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                        struct tda18271_config * ))tmp___5;
  }
#line 355
  __a___0 = tmp___6;
#line 355
  if ((unsigned long )__a___0 != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                            u8  ,
                                                                            struct i2c_adapter * ,
                                                                            struct tda18271_config * ))0)) {
#line 355
    tmp___8 = (*__a___0)(adap->fe, 96, & (adap->channel.hdw)->i2c_adap, & hauppauge_tda18271_dvb_config);
#line 355
    __r___0 = (void *)tmp___8;
#line 355
    if ((unsigned long )__r___0 == (unsigned long )((void *)0)) {
#line 355
      __symbol_put("tda18271_attach");
    } else {

    }
  } else {
#line 355
    printk("\vDVB: Unable to find symbol tda18271_attach()\n");
  }
#line 359
  return (0);
}
}
#line 362 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_dvb_props  const  pvr2_73xxx_dvb_props  =    {& pvr2_tda10048_attach, & pvr2_73xxx_tda18271_8295_attach};
#line 368 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_device_client_desc  const  pvr2_cli_73xxx[2U]  = {      {2U, 0}, 
        {4U, (unsigned char *)"B"}};
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static char const   *pvr2_fw1_names_73xxx[1U]  = {      "v4l-pvrusb2-73xxx-01.fw"};
#line 379 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_device_desc  const  pvr2_device_73xxx  = 
#line 379
     {"WinTV HVR-1900 Model 73xxx", "73xxx", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_73xxx),
                                                     2U}, {(char const   **)(& pvr2_fw1_names_73xxx),
                                                           1U}, & pvr2_73xxx_dvb_props,
    0ULL, 0, 0U, 1U, 1U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0,
    1U, (unsigned char)0, 2U, (unsigned char)0, 1U, 1U, 1U, 1U, (unsigned char)0};
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct s5h1409_config pvr2_s5h1409_config  = 
#line 407
     {25U, 0U, 0U, 4000U, 1U, 1U, (unsigned short)0, (unsigned char)0};
#line 416 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct s5h1411_config pvr2_s5h1411_config  =    {0U, 0U, (unsigned short)0, 4000U, 44000U, 1U, 1U};
#line 425 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct tda18271_std_map hauppauge_tda18271_std_map  = 
#line 425
     {{(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {(unsigned short)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {(unsigned short)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0, (unsigned char)0,
                                                               (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {5380U, 3U, 3U, (unsigned char)0,
                                                               6U, 55U}, {(unsigned short)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}, {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                         (unsigned char)0, (unsigned char)0}, {4000U, 3U, 0U, (unsigned char)0,
                                                               6U, 55U}, {(unsigned short)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0},
    {(unsigned short)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
     (unsigned char)0}};
#line 432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct tda18271_config hauppauge_tda18271_config  = 
#line 432
     {& hauppauge_tda18271_std_map, 0, 1, 1, 0, (unsigned char)0, (unsigned char)0,
    0U};
#line 438 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static int pvr2_s5h1409_attach(struct pvr2_dvb_adapter *adap ) 
{ 
  void *__r ;
  struct dvb_frontend *(*__a)(struct s5h1409_config  const  * , struct i2c_adapter * ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct s5h1409_config  const  * , struct i2c_adapter * ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;

  {
#line 440
  __r = (void *)0;
#line 440
  tmp___2 = __symbol_get("s5h1409_attach");
#line 440
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct s5h1409_config  const  * ,
                                                       struct i2c_adapter * ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct s5h1409_config  const  * ,
                                                                                                                                     struct i2c_adapter * ))0);
#line 440
  if (tmp___1) {

  } else {
#line 440
    __request_module(1, "symbol:s5h1409_attach");
#line 440
    tmp___0 = __symbol_get("s5h1409_attach");
#line 440
    tmp___1 = (struct dvb_frontend *(*)(struct s5h1409_config  const  * , struct i2c_adapter * ))tmp___0;
  }
#line 440
  __a = tmp___1;
#line 440
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct s5h1409_config  const  * ,
                                                                        struct i2c_adapter * ))0)) {
#line 440
    tmp___3 = (*__a)((struct s5h1409_config  const  *)(& pvr2_s5h1409_config), & (adap->channel.hdw)->i2c_adap);
#line 440
    __r = (void *)tmp___3;
#line 440
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 440
      __symbol_put("s5h1409_attach");
    } else {

    }
  } else {
#line 440
    printk("\vDVB: Unable to find symbol s5h1409_attach()\n");
  }
#line 440
  adap->fe = (struct dvb_frontend *)__r;
#line 442
  if ((unsigned long )adap->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 443
    return (0);
  } else {

  }
#line 445
  return (-5);
}
}
#line 448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static int pvr2_s5h1411_attach(struct pvr2_dvb_adapter *adap ) 
{ 
  void *__r ;
  struct dvb_frontend *(*__a)(struct s5h1411_config  const  * , struct i2c_adapter * ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct s5h1411_config  const  * , struct i2c_adapter * ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;

  {
#line 450
  __r = (void *)0;
#line 450
  tmp___2 = __symbol_get("s5h1411_attach");
#line 450
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct s5h1411_config  const  * ,
                                                       struct i2c_adapter * ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct s5h1411_config  const  * ,
                                                                                                                                     struct i2c_adapter * ))0);
#line 450
  if (tmp___1) {

  } else {
#line 450
    __request_module(1, "symbol:s5h1411_attach");
#line 450
    tmp___0 = __symbol_get("s5h1411_attach");
#line 450
    tmp___1 = (struct dvb_frontend *(*)(struct s5h1411_config  const  * , struct i2c_adapter * ))tmp___0;
  }
#line 450
  __a = tmp___1;
#line 450
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct s5h1411_config  const  * ,
                                                                        struct i2c_adapter * ))0)) {
#line 450
    tmp___3 = (*__a)((struct s5h1411_config  const  *)(& pvr2_s5h1411_config), & (adap->channel.hdw)->i2c_adap);
#line 450
    __r = (void *)tmp___3;
#line 450
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 450
      __symbol_put("s5h1411_attach");
    } else {

    }
  } else {
#line 450
    printk("\vDVB: Unable to find symbol s5h1411_attach()\n");
  }
#line 450
  adap->fe = (struct dvb_frontend *)__r;
#line 452
  if ((unsigned long )adap->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 453
    return (0);
  } else {

  }
#line 455
  return (-5);
}
}
#line 458 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static int pvr2_tda18271_8295_attach(struct pvr2_dvb_adapter *adap ) 
{ 
  void *__r ;
  struct dvb_frontend *(*__a)(struct dvb_frontend * , struct i2c_adapter * , u8  ,
                              struct tda829x_config * ) ;
  void *tmp___0 ;
  struct dvb_frontend *(*tmp___1)(struct dvb_frontend * , struct i2c_adapter * , u8  ,
                                  struct tda829x_config * ) ;
  void *tmp___2 ;
  struct dvb_frontend *tmp___3 ;
  void *__r___0 ;
  struct dvb_frontend *(*__a___0)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                  struct tda18271_config * ) ;
  void *tmp___5 ;
  struct dvb_frontend *(*tmp___6)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                  struct tda18271_config * ) ;
  void *tmp___7 ;
  struct dvb_frontend *tmp___8 ;

  {
#line 460
  __r = (void *)0;
#line 460
  tmp___2 = __symbol_get("tda829x_attach");
#line 460
  tmp___1 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                                       u8  , struct tda829x_config * ))tmp___2) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                              struct i2c_adapter * ,
                                                                                                                                              u8  ,
                                                                                                                                              struct tda829x_config * ))0);
#line 460
  if (tmp___1) {

  } else {
#line 460
    __request_module(1, "symbol:tda829x_attach");
#line 460
    tmp___0 = __symbol_get("tda829x_attach");
#line 460
    tmp___1 = (struct dvb_frontend *(*)(struct dvb_frontend * , struct i2c_adapter * ,
                                        u8  , struct tda829x_config * ))tmp___0;
  }
#line 460
  __a = tmp___1;
#line 460
  if ((unsigned long )__a != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                        struct i2c_adapter * ,
                                                                        u8  , struct tda829x_config * ))0)) {
#line 460
    tmp___3 = (*__a)(adap->fe, & (adap->channel.hdw)->i2c_adap, 66, & tda829x_no_probe);
#line 460
    __r = (void *)tmp___3;
#line 460
    if ((unsigned long )__r == (unsigned long )((void *)0)) {
#line 460
      __symbol_put("tda829x_attach");
    } else {

    }
  } else {
#line 460
    printk("\vDVB: Unable to find symbol tda829x_attach()\n");
  }
#line 463
  __r___0 = (void *)0;
#line 463
  tmp___7 = __symbol_get("tda18271_attach");
#line 463
  tmp___6 = (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * , u8  ,
                                                       struct i2c_adapter * , struct tda18271_config * ))tmp___7) != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                                                                                                                u8  ,
                                                                                                                                                                struct i2c_adapter * ,
                                                                                                                                                                struct tda18271_config * ))0);
#line 463
  if (tmp___6) {

  } else {
#line 463
    __request_module(1, "symbol:tda18271_attach");
#line 463
    tmp___5 = __symbol_get("tda18271_attach");
#line 463
    tmp___6 = (struct dvb_frontend *(*)(struct dvb_frontend * , u8  , struct i2c_adapter * ,
                                        struct tda18271_config * ))tmp___5;
  }
#line 463
  __a___0 = tmp___6;
#line 463
  if ((unsigned long )__a___0 != (unsigned long )((struct dvb_frontend *(*)(struct dvb_frontend * ,
                                                                            u8  ,
                                                                            struct i2c_adapter * ,
                                                                            struct tda18271_config * ))0)) {
#line 463
    tmp___8 = (*__a___0)(adap->fe, 96, & (adap->channel.hdw)->i2c_adap, & hauppauge_tda18271_config);
#line 463
    __r___0 = (void *)tmp___8;
#line 463
    if ((unsigned long )__r___0 == (unsigned long )((void *)0)) {
#line 463
      __symbol_put("tda18271_attach");
    } else {

    }
  } else {
#line 463
    printk("\vDVB: Unable to find symbol tda18271_attach()\n");
  }
#line 467
  return (0);
}
}
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_dvb_props  const  pvr2_750xx_dvb_props  =    {& pvr2_s5h1409_attach, & pvr2_tda18271_8295_attach};
#line 475 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_dvb_props  const  pvr2_751xx_dvb_props  =    {& pvr2_s5h1411_attach, & pvr2_tda18271_8295_attach};
#line 482 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static char const   *pvr2_fw1_names_75xxx[1U]  = {      "v4l-pvrusb2-73xxx-01.fw"};
#line 486 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_device_desc  const  pvr2_device_750xx  = 
#line 486
     {"WinTV HVR-1950 Model 750xx", "750xx", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_73xxx),
                                                     2U}, {(char const   **)(& pvr2_fw1_names_75xxx),
                                                           1U}, & pvr2_750xx_dvb_props,
    4096ULL, 0, 0U, 1U, 1U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0,
    1U, (unsigned char)0, 2U, (unsigned char)0, 1U, 1U, 1U, 1U, (unsigned char)0};
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
static struct pvr2_device_desc  const  pvr2_device_751xx  = 
#line 509
     {"WinTV HVR-1950 Model 751xx", "751xx", {0, 0U}, {(struct pvr2_device_client_desc  const  *)(& pvr2_cli_73xxx),
                                                     2U}, {(char const   **)(& pvr2_fw1_names_75xxx),
                                                           1U}, & pvr2_751xx_dvb_props,
    4096ULL, 0, 0U, 1U, 1U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0,
    1U, (unsigned char)0, 2U, (unsigned char)0, 1U, 1U, 1U, 1U, (unsigned char)0};
#line 536 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
struct usb_device_id pvr2_device_table[12U]  = 
#line 536
  {      {3U, 8256U, 10496U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_29xxx)}, 
        {3U, 8256U, 10576U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_29xxx)}, 
        {3U, 8256U, 9216U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_24xxx)}, 
        {3U, 4452U, 1570U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_gotview_2)}, 
        {3U, 4452U, 1538U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_gotview_2d)}, 
        {3U, 4538U, 4099U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_onair_creator)}, 
        {3U, 4538U, 4097U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_onair_usb2)}, 
        {3U, 8256U, 29440U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_73xxx)}, 
        {3U, 8256U, 29952U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_750xx)}, 
        {3U, 8256U, 29953U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_751xx)}, 
        {3U, 3277U, 57U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned long )(& pvr2_device_av400)}};
#line 562 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.c"
struct usb_device_id  const  __mod_usb__pvr2_device_table_device_table[12U]  ;
#line 327 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_initialize_pvr2_dvb_props_10(void) 
{ 
  void *tmp ;

  {
#line 328
  tmp = ldv_init_zalloc(2584UL);
#line 328
  pvr2_onair_usb2_fe_props_group0 = (struct pvr2_dvb_adapter *)tmp;
#line 329
  return;
}
}
#line 331 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_initialize_pvr2_dvb_props_9(void) 
{ 
  void *tmp ;

  {
#line 332
  tmp = ldv_init_zalloc(2584UL);
#line 332
  pvr2_73xxx_dvb_props_group0 = (struct pvr2_dvb_adapter *)tmp;
#line 333
  return;
}
}
#line 335 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_initialize_pvr2_dvb_props_7(void) 
{ 
  void *tmp ;

  {
#line 336
  tmp = ldv_init_zalloc(2584UL);
#line 336
  pvr2_751xx_dvb_props_group0 = (struct pvr2_dvb_adapter *)tmp;
#line 337
  return;
}
}
#line 339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_initialize_pvr2_dvb_props_11(void) 
{ 
  void *tmp ;

  {
#line 340
  tmp = ldv_init_zalloc(2584UL);
#line 340
  pvr2_onair_creator_fe_props_group0 = (struct pvr2_dvb_adapter *)tmp;
#line 341
  return;
}
}
#line 343 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_initialize_pvr2_dvb_props_8(void) 
{ 
  void *tmp ;

  {
#line 344
  tmp = ldv_init_zalloc(2584UL);
#line 344
  pvr2_750xx_dvb_props_group0 = (struct pvr2_dvb_adapter *)tmp;
#line 345
  return;
}
}
#line 347 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_main_exported_8(void) 
{ 
  int tmp ;

  {
#line 349
  tmp = __VERIFIER_nondet_int();
#line 349
  switch (tmp) {
  case 0: ;
#line 352
  if (ldv_state_variable_8 == 1) {
#line 354
    pvr2_tda18271_8295_attach(pvr2_750xx_dvb_props_group0);
#line 356
    ldv_state_variable_8 = 1;
  } else {

  }
#line 359
  goto ldv_52107;
  case 1: ;
#line 362
  if (ldv_state_variable_8 == 1) {
#line 364
    pvr2_s5h1409_attach(pvr2_750xx_dvb_props_group0);
#line 366
    ldv_state_variable_8 = 1;
  } else {

  }
#line 369
  goto ldv_52107;
  default: 
#line 370
  ldv_stop();
  }
  ldv_52107: ;
#line 374
  return;
}
}
#line 376 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_main_exported_11(void) 
{ 
  int tmp ;

  {
#line 378
  tmp = __VERIFIER_nondet_int();
#line 378
  switch (tmp) {
  case 0: ;
#line 381
  if (ldv_state_variable_11 == 1) {
#line 383
    pvr2_lgh06xf_attach(pvr2_onair_creator_fe_props_group0);
#line 385
    ldv_state_variable_11 = 1;
  } else {

  }
#line 388
  goto ldv_52114;
  case 1: ;
#line 391
  if (ldv_state_variable_11 == 1) {
#line 393
    pvr2_lgdt3303_attach(pvr2_onair_creator_fe_props_group0);
#line 395
    ldv_state_variable_11 = 1;
  } else {

  }
#line 398
  goto ldv_52114;
  default: 
#line 399
  ldv_stop();
  }
  ldv_52114: ;
#line 403
  return;
}
}
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_main_exported_7(void) 
{ 
  int tmp ;

  {
#line 407
  tmp = __VERIFIER_nondet_int();
#line 407
  switch (tmp) {
  case 0: ;
#line 410
  if (ldv_state_variable_7 == 1) {
#line 412
    pvr2_tda18271_8295_attach(pvr2_751xx_dvb_props_group0);
#line 414
    ldv_state_variable_7 = 1;
  } else {

  }
#line 417
  goto ldv_52121;
  case 1: ;
#line 420
  if (ldv_state_variable_7 == 1) {
#line 422
    pvr2_s5h1411_attach(pvr2_751xx_dvb_props_group0);
#line 424
    ldv_state_variable_7 = 1;
  } else {

  }
#line 427
  goto ldv_52121;
  default: 
#line 428
  ldv_stop();
  }
  ldv_52121: ;
#line 432
  return;
}
}
#line 434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_main_exported_10(void) 
{ 
  int tmp ;

  {
#line 436
  tmp = __VERIFIER_nondet_int();
#line 436
  switch (tmp) {
  case 0: ;
#line 439
  if (ldv_state_variable_10 == 1) {
#line 441
    pvr2_fcv1236d_attach(pvr2_onair_usb2_fe_props_group0);
#line 443
    ldv_state_variable_10 = 1;
  } else {

  }
#line 446
  goto ldv_52128;
  case 1: ;
#line 449
  if (ldv_state_variable_10 == 1) {
#line 451
    pvr2_lgdt3302_attach(pvr2_onair_usb2_fe_props_group0);
#line 453
    ldv_state_variable_10 = 1;
  } else {

  }
#line 456
  goto ldv_52128;
  default: 
#line 457
  ldv_stop();
  }
  ldv_52128: ;
#line 461
  return;
}
}
#line 463 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_main_exported_9(void) 
{ 
  int tmp ;

  {
#line 465
  tmp = __VERIFIER_nondet_int();
#line 465
  switch (tmp) {
  case 0: ;
#line 468
  if (ldv_state_variable_9 == 1) {
#line 470
    pvr2_73xxx_tda18271_8295_attach(pvr2_73xxx_dvb_props_group0);
#line 472
    ldv_state_variable_9 = 1;
  } else {

  }
#line 475
  goto ldv_52135;
  case 1: ;
#line 478
  if (ldv_state_variable_9 == 1) {
#line 480
    pvr2_tda10048_attach(pvr2_73xxx_dvb_props_group0);
#line 482
    ldv_state_variable_9 = 1;
  } else {

  }
#line 485
  goto ldv_52135;
  default: 
#line 486
  ldv_stop();
  }
  ldv_52135: ;
#line 490
  return;
}
}
#line 515 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
bool ldv_queue_work_on_500(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 519
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 519
  ldv_func_res = tmp;
#line 521
  activate_work_1(ldv_func_arg3, 2);
#line 523
  return (ldv_func_res);
}
}
#line 526 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
bool ldv_queue_delayed_work_on_501(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 530
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 530
  ldv_func_res = tmp;
#line 532
  activate_work_1(& ldv_func_arg3->work, 2);
#line 534
  return (ldv_func_res);
}
}
#line 537 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
bool ldv_queue_work_on_502(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 541
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 541
  ldv_func_res = tmp;
#line 543
  activate_work_1(ldv_func_arg3, 2);
#line 545
  return (ldv_func_res);
}
}
#line 548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_flush_workqueue_503(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 551
  flush_workqueue(ldv_func_arg1);
#line 553
  call_and_disable_all_1(2);
#line 554
  return;
}
}
#line 556 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
bool ldv_queue_delayed_work_on_504(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 560
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 560
  ldv_func_res = tmp;
#line 562
  activate_work_1(& ldv_func_arg3->work, 2);
#line 564
  return (ldv_func_res);
}
}
#line 567 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_mutex_lock_505(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 570
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 572
  mutex_lock(ldv_func_arg1);
#line 573
  return;
}
}
#line 575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_mutex_unlock_506(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 578
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 580
  mutex_unlock(ldv_func_arg1);
#line 581
  return;
}
}
#line 583 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_mutex_lock_507(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 586
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 588
  mutex_lock(ldv_func_arg1);
#line 589
  return;
}
}
#line 591 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
int ldv_mutex_trylock_508(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 595
  tmp = mutex_trylock(ldv_func_arg1);
#line 595
  ldv_func_res = tmp;
#line 597
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 597
  return (tmp___0);
#line 599
  return (ldv_func_res);
}
}
#line 602 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_mutex_unlock_509(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 605
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 607
  mutex_unlock(ldv_func_arg1);
#line 608
  return;
}
}
#line 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_mutex_unlock_510(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 613
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 615
  mutex_unlock(ldv_func_arg1);
#line 616
  return;
}
}
#line 618 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_mutex_lock_511(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 621
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 623
  mutex_lock(ldv_func_arg1);
#line 624
  return;
}
}
#line 626 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_mutex_lock_512(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 629
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 631
  mutex_lock(ldv_func_arg1);
#line 632
  return;
}
}
#line 634 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-devattr.o.c.prepared"
void ldv_mutex_unlock_513(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 637
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 639
  mutex_unlock(ldv_func_arg1);
#line 640
  return;
}
}
#line 3 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
bool ldv_is_err(void const   *ptr ) ;
#line 41 "include/linux/err.h"
__inline static bool IS_ERR(void const   *ptr ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_540(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_538(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_541(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_542(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_545(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_547(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_549(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_551(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void ldv_mutex_lock_537(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_539(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_543(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_544(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_546(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_548(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_550(struct mutex *ldv_func_arg1 ) ;
#line 141
void ldv_mutex_lock_mutex_of_pvr2_context(struct mutex *lock ) ;
#line 145
void ldv_mutex_unlock_mutex_of_pvr2_context(struct mutex *lock ) ;
#line 180
void ldv_mutex_lock_pvr2_context_mutex(struct mutex *lock ) ;
#line 184
void ldv_mutex_unlock_pvr2_context_mutex(struct mutex *lock ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_532(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_534(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_533(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_536(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_535(struct workqueue_struct *ldv_func_arg1 ) ;
#line 2410 "include/linux/sched.h"
extern int wake_up_process(struct task_struct * ) ;
#line 76 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-context.h"
unsigned int pvr2_channel_get_limited_inputs(struct pvr2_channel *cp ) ;
#line 75 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-io.h"
void pvr2_stream_kill(struct pvr2_stream *sp ) ;
#line 27 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-ioread.h"
struct pvr2_ioread *pvr2_ioread_create(void) ;
#line 29
int pvr2_ioread_setup(struct pvr2_ioread *cp , struct pvr2_stream *sp ) ;
#line 31
void pvr2_ioread_set_sync_key(struct pvr2_ioread *cp , char const   *sync_key_ptr ,
                              unsigned int sync_key_len ) ;
#line 8 "include/linux/kthread.h"
extern struct task_struct *kthread_create_on_node(int (*)(void * ) , void * , int  ,
                                                  char const   *  , ...) ;
#line 41
extern int kthread_stop(struct task_struct * ) ;
#line 42
extern bool kthread_should_stop(void) ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static struct pvr2_context *pvr2_context_exist_first  ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static struct pvr2_context *pvr2_context_exist_last  ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static struct pvr2_context *pvr2_context_notify_first  ;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static struct pvr2_context *pvr2_context_notify_last  ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static struct mutex pvr2_context_mutex  =    {{1}, {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "pvr2_context_mutex.wait_lock",
                                                          0, 0UL}}}}, {& pvr2_context_mutex.wait_list,
                                                                       & pvr2_context_mutex.wait_list},
    0, (void *)(& pvr2_context_mutex), {0, {0, 0}, "pvr2_context_mutex", 0, 0UL}};
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static wait_queue_head_t pvr2_context_sync_data  =    {{{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "pvr2_context_sync_data.lock",
                                                     0, 0UL}}}}, {& pvr2_context_sync_data.task_list,
                                                                  & pvr2_context_sync_data.task_list}};
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static wait_queue_head_t pvr2_context_cleanup_data  =    {{{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "pvr2_context_cleanup_data.lock",
                                                     0, 0UL}}}}, {& pvr2_context_cleanup_data.task_list,
                                                                  & pvr2_context_cleanup_data.task_list}};
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static int pvr2_context_cleanup_flag  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static int pvr2_context_cleaned_flag  ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static struct task_struct *pvr2_context_thread_ptr  ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static void pvr2_context_set_notify(struct pvr2_context *mp , int fl ) 
{ 
  int signal_flag ;

  {
#line 45
  signal_flag = 0;
#line 46
  ldv_mutex_lock_544(& pvr2_context_mutex);
#line 47
  if (fl != 0) {
#line 48
    if (mp->notify_flag == 0) {
#line 49
      signal_flag = (unsigned long )pvr2_context_notify_first == (unsigned long )((struct pvr2_context *)0);
#line 50
      mp->notify_prev = pvr2_context_notify_last;
#line 51
      mp->notify_next = (struct pvr2_context *)0;
#line 52
      pvr2_context_notify_last = mp;
#line 53
      if ((unsigned long )mp->notify_prev != (unsigned long )((struct pvr2_context *)0)) {
#line 54
        (mp->notify_prev)->notify_next = mp;
      } else {
#line 56
        pvr2_context_notify_first = mp;
      }
#line 58
      mp->notify_flag = 1;
    } else {

    }
  } else
#line 61
  if (mp->notify_flag != 0) {
#line 62
    mp->notify_flag = 0;
#line 63
    if ((unsigned long )mp->notify_next != (unsigned long )((struct pvr2_context *)0)) {
#line 64
      (mp->notify_next)->notify_prev = mp->notify_prev;
    } else {
#line 66
      pvr2_context_notify_last = mp->notify_prev;
    }
#line 68
    if ((unsigned long )mp->notify_prev != (unsigned long )((struct pvr2_context *)0)) {
#line 69
      (mp->notify_prev)->notify_next = mp->notify_next;
    } else {
#line 71
      pvr2_context_notify_first = mp->notify_next;
    }
  } else {

  }
#line 75
  ldv_mutex_unlock_545(& pvr2_context_mutex);
#line 76
  if (signal_flag != 0) {
#line 76
    __wake_up(& pvr2_context_sync_data, 3U, 1, (void *)0);
  } else {

  }
#line 77
  return;
}
}
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static void pvr2_context_destroy(struct pvr2_context *mp ) 
{ 


  {
#line 82
  if ((pvrusb2_debug & 8192) != 0) {
#line 82
    printk("\016pvrusb2: pvr2_context %p (destroy)\n", mp);
  } else {

  }
#line 83
  pvr2_hdw_destroy(mp->hdw);
#line 84
  pvr2_context_set_notify(mp, 0);
#line 85
  ldv_mutex_lock_546(& pvr2_context_mutex);
#line 86
  if ((unsigned long )mp->exist_next != (unsigned long )((struct pvr2_context *)0)) {
#line 87
    (mp->exist_next)->exist_prev = mp->exist_prev;
  } else {
#line 89
    pvr2_context_exist_last = mp->exist_prev;
  }
#line 91
  if ((unsigned long )mp->exist_prev != (unsigned long )((struct pvr2_context *)0)) {
#line 92
    (mp->exist_prev)->exist_next = mp->exist_next;
  } else {
#line 94
    pvr2_context_exist_first = mp->exist_next;
  }
#line 96
  if ((unsigned long )pvr2_context_exist_first == (unsigned long )((struct pvr2_context *)0)) {
#line 99
    __wake_up(& pvr2_context_sync_data, 3U, 1, (void *)0);
  } else {

  }
#line 101
  ldv_mutex_unlock_547(& pvr2_context_mutex);
#line 102
  kfree((void const   *)mp);
#line 103
  return;
}
}
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static void pvr2_context_notify(struct pvr2_context *mp ) 
{ 


  {
#line 108
  pvr2_context_set_notify(mp, 1);
#line 109
  return;
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static void pvr2_context_check(struct pvr2_context *mp ) 
{ 
  struct pvr2_channel *ch1 ;
  struct pvr2_channel *ch2 ;
  int tmp ;

  {
#line 115
  if ((pvrusb2_debug & 8192) != 0) {
#line 115
    printk("\016pvrusb2: pvr2_context %p (notify)\n", mp);
  } else {

  }
#line 117
  if (mp->initialized_flag == 0 && mp->disconnect_flag == 0) {
#line 118
    mp->initialized_flag = 1;
#line 119
    if ((pvrusb2_debug & 8192) != 0) {
#line 119
      printk("\016pvrusb2: pvr2_context %p (initialize)\n", mp);
    } else {

    }
#line 122
    tmp = pvr2_hdw_initialize(mp->hdw, (void (*)(void * ))(& pvr2_context_notify),
                              (void *)mp);
#line 122
    if (tmp != 0) {
#line 125
      mp->video_stream.stream = pvr2_hdw_get_video_stream(mp->hdw);
#line 130
      if ((unsigned long )mp->setup_func != (unsigned long )((void (*)(struct pvr2_context * ))0)) {
#line 130
        (*(mp->setup_func))(mp);
      } else {

      }
    } else
#line 132
    if ((pvrusb2_debug & 8192) != 0) {
#line 132
      printk("\016pvrusb2: pvr2_context %p (thread skipping setup)\n", mp);
    } else {

    }
  } else {

  }
#line 143
  ch1 = mp->mc_first;
#line 143
  goto ldv_29584;
  ldv_29583: 
#line 144
  ch2 = ch1->mc_next;
#line 145
  if ((unsigned long )ch1->check_func != (unsigned long )((void (*)(struct pvr2_channel * ))0)) {
#line 145
    (*(ch1->check_func))(ch1);
  } else {

  }
#line 143
  ch1 = ch2;
  ldv_29584: ;
#line 143
  if ((unsigned long )ch1 != (unsigned long )((struct pvr2_channel *)0)) {
#line 145
    goto ldv_29583;
  } else {

  }

#line 148
  if (mp->disconnect_flag != 0 && (unsigned long )mp->mc_first == (unsigned long )((struct pvr2_channel *)0)) {
#line 150
    pvr2_context_destroy(mp);
#line 151
    return;
  } else {

  }
#line 153
  return;
}
}
#line 156 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static int pvr2_context_shutok(void) 
{ 


  {
#line 158
  return (pvr2_context_cleanup_flag != 0 && (unsigned long )pvr2_context_exist_first == (unsigned long )((struct pvr2_context *)0));
}
}
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static int pvr2_context_thread_func(void *foo ) 
{ 
  struct pvr2_context *mp ;
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __ret___1 ;
  wait_queue_t __wait___0 ;
  long __ret___2 ;
  long __int___0 ;
  long tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;

  {
#line 166
  if ((pvrusb2_debug & 8192) != 0) {
#line 166
    printk("\016pvrusb2: pvr2_context thread start\n");
  } else {

  }
  ldv_29605: ;
#line 169
  goto ldv_29594;
  ldv_29593: 
#line 170
  pvr2_context_set_notify(mp, 0);
#line 171
  pvr2_context_check(mp);
  ldv_29594: 
#line 169
  mp = pvr2_context_notify_first;
#line 169
  if ((unsigned long )mp != (unsigned long )((struct pvr2_context *)0)) {
#line 171
    goto ldv_29593;
  } else {

  }
#line 173
  __ret = 0;
#line 173
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c",
                176, 0);
#line 173
  if ((unsigned long )pvr2_context_notify_first == (unsigned long )((struct pvr2_context *)0)) {
#line 173
    tmp___1 = pvr2_context_shutok();
#line 173
    if (tmp___1 == 0) {
#line 173
      __ret___0 = 0L;
#line 173
      INIT_LIST_HEAD(& __wait.task_list);
#line 173
      __wait.flags = 0U;
      ldv_29602: 
#line 173
      tmp = prepare_to_wait_event(& pvr2_context_sync_data, & __wait, 1);
#line 173
      __int = tmp;
#line 173
      if ((unsigned long )pvr2_context_notify_first != (unsigned long )((struct pvr2_context *)0)) {
#line 173
        goto ldv_29601;
      } else {
#line 173
        tmp___0 = pvr2_context_shutok();
#line 173
        if (tmp___0 != 0) {
#line 173
          goto ldv_29601;
        } else {

        }
      }
#line 173
      if (__int != 0L) {
#line 173
        __ret___0 = __int;
#line 173
        goto ldv_29601;
      } else {

      }
#line 173
      schedule();
#line 173
      goto ldv_29602;
      ldv_29601: 
#line 173
      finish_wait(& pvr2_context_sync_data, & __wait);
#line 173
      __ret = (int )__ret___0;
    } else {

    }
  } else {

  }
#line 177
  tmp___2 = pvr2_context_shutok();
#line 177
  if (tmp___2 == 0) {
#line 179
    goto ldv_29605;
  } else {

  }
#line 179
  pvr2_context_cleaned_flag = 1;
#line 180
  __wake_up(& pvr2_context_cleanup_data, 3U, 1, (void *)0);
#line 182
  if ((pvrusb2_debug & 8192) != 0) {
#line 182
    printk("\016pvrusb2: pvr2_context thread cleaned up\n");
  } else {

  }
#line 184
  __ret___1 = 0;
#line 184
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c",
                186, 0);
#line 184
  tmp___5 = kthread_should_stop();
#line 184
  if (tmp___5) {
#line 184
    tmp___6 = 0;
  } else {
#line 184
    tmp___6 = 1;
  }
#line 184
  if (tmp___6) {
#line 184
    __ret___2 = 0L;
#line 184
    INIT_LIST_HEAD(& __wait___0.task_list);
#line 184
    __wait___0.flags = 0U;
    ldv_29613: 
#line 184
    tmp___3 = prepare_to_wait_event(& pvr2_context_sync_data, & __wait___0, 1);
#line 184
    __int___0 = tmp___3;
#line 184
    tmp___4 = kthread_should_stop();
#line 184
    if ((int )tmp___4) {
#line 184
      goto ldv_29612;
    } else {

    }
#line 184
    if (__int___0 != 0L) {
#line 184
      __ret___2 = __int___0;
#line 184
      goto ldv_29612;
    } else {

    }
#line 184
    schedule();
#line 184
    goto ldv_29613;
    ldv_29612: 
#line 184
    finish_wait(& pvr2_context_sync_data, & __wait___0);
#line 184
    __ret___1 = (int )__ret___2;
  } else {

  }
#line 188
  if ((pvrusb2_debug & 8192) != 0) {
#line 188
    printk("\016pvrusb2: pvr2_context thread end\n");
  } else {

  }
#line 190
  return (0);
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
int pvr2_context_global_init(void) 
{ 
  struct task_struct *__k ;
  struct task_struct *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 196
  tmp = kthread_create_on_node(& pvr2_context_thread_func, (void *)0, -1, "pvrusb2-context");
#line 196
  __k = tmp;
#line 196
  tmp___0 = IS_ERR((void const   *)__k);
#line 196
  if (tmp___0) {
#line 196
    tmp___1 = 0;
  } else {
#line 196
    tmp___1 = 1;
  }
#line 196
  if (tmp___1) {
#line 196
    wake_up_process(__k);
  } else {

  }
#line 196
  pvr2_context_thread_ptr = __k;
#line 199
  return ((unsigned long )pvr2_context_thread_ptr != (unsigned long )((struct task_struct *)0) ? 0 : -12);
}
}
#line 203 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
void pvr2_context_global_done(void) 
{ 
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp ;

  {
#line 205
  pvr2_context_cleanup_flag = 1;
#line 206
  __wake_up(& pvr2_context_sync_data, 3U, 1, (void *)0);
#line 207
  __ret = 0;
#line 207
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c",
                209, 0);
#line 207
  if (pvr2_context_cleaned_flag == 0) {
#line 207
    __ret___0 = 0L;
#line 207
    INIT_LIST_HEAD(& __wait.task_list);
#line 207
    __wait.flags = 0U;
    ldv_29630: 
#line 207
    tmp = prepare_to_wait_event(& pvr2_context_cleanup_data, & __wait, 1);
#line 207
    __int = tmp;
#line 207
    if (pvr2_context_cleaned_flag != 0) {
#line 207
      goto ldv_29629;
    } else {

    }
#line 207
    if (__int != 0L) {
#line 207
      __ret___0 = __int;
#line 207
      goto ldv_29629;
    } else {

    }
#line 207
    schedule();
#line 207
    goto ldv_29630;
    ldv_29629: 
#line 207
    finish_wait(& pvr2_context_cleanup_data, & __wait);
#line 207
    __ret = (int )__ret___0;
  } else {

  }
#line 210
  kthread_stop(pvr2_context_thread_ptr);
#line 211
  return;
}
}
#line 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
struct pvr2_context *pvr2_context_create(struct usb_interface *intf , struct usb_device_id  const  *devid ,
                                         void (*setup_func)(struct pvr2_context * ) ) 
{ 
  struct pvr2_context *mp ;
  void *tmp ;
  struct lock_class_key __key ;

  {
#line 219
  mp = (struct pvr2_context *)0;
#line 220
  tmp = kzalloc(256UL, 208U);
#line 220
  mp = (struct pvr2_context *)tmp;
#line 221
  if ((unsigned long )mp == (unsigned long )((struct pvr2_context *)0)) {
#line 221
    goto done;
  } else {

  }
#line 222
  if ((pvrusb2_debug & 8192) != 0) {
#line 222
    printk("\016pvrusb2: pvr2_context %p (create)\n", mp);
  } else {

  }
#line 223
  mp->setup_func = setup_func;
#line 224
  __mutex_init(& mp->mutex, "&mp->mutex", & __key);
#line 225
  ldv_mutex_lock_548(& pvr2_context_mutex);
#line 226
  mp->exist_prev = pvr2_context_exist_last;
#line 227
  mp->exist_next = (struct pvr2_context *)0;
#line 228
  pvr2_context_exist_last = mp;
#line 229
  if ((unsigned long )mp->exist_prev != (unsigned long )((struct pvr2_context *)0)) {
#line 230
    (mp->exist_prev)->exist_next = mp;
  } else {
#line 232
    pvr2_context_exist_first = mp;
  }
#line 234
  ldv_mutex_unlock_549(& pvr2_context_mutex);
#line 235
  mp->hdw = pvr2_hdw_create(intf, devid);
#line 236
  if ((unsigned long )mp->hdw == (unsigned long )((struct pvr2_hdw *)0)) {
#line 237
    pvr2_context_destroy(mp);
#line 238
    mp = (struct pvr2_context *)0;
#line 239
    goto done;
  } else {

  }
#line 241
  pvr2_context_set_notify(mp, 1);
  done: ;
#line 243
  return (mp);
}
}
#line 247 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static void pvr2_context_reset_input_limits(struct pvr2_context *mp ) 
{ 
  unsigned int tmsk ;
  unsigned int mmsk ;
  struct pvr2_channel *cp ;
  struct pvr2_hdw *hdw ;

  {
#line 251
  hdw = mp->hdw;
#line 252
  mmsk = pvr2_hdw_get_input_available(hdw);
#line 253
  tmsk = mmsk;
#line 254
  cp = mp->mc_first;
#line 254
  goto ldv_29651;
  ldv_29650: ;
#line 255
  if (cp->input_mask == 0U) {
#line 255
    goto ldv_29649;
  } else {

  }
#line 256
  tmsk = cp->input_mask & tmsk;
  ldv_29649: 
#line 254
  cp = cp->mc_next;
  ldv_29651: ;
#line 254
  if ((unsigned long )cp != (unsigned long )((struct pvr2_channel *)0)) {
#line 256
    goto ldv_29650;
  } else {

  }
#line 258
  pvr2_hdw_set_input_allowed(hdw, mmsk, tmsk);
#line 259
  pvr2_hdw_commit_ctl(hdw);
#line 260
  return;
}
}
#line 263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static void pvr2_context_enter(struct pvr2_context *mp ) 
{ 


  {
#line 265
  ldv_mutex_lock_550(& mp->mutex);
#line 266
  return;
}
}
#line 269 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static void pvr2_context_exit(struct pvr2_context *mp ) 
{ 
  int destroy_flag ;

  {
#line 271
  destroy_flag = 0;
#line 272
  if ((unsigned long )mp->mc_first == (unsigned long )((struct pvr2_channel *)0) && mp->disconnect_flag != 0) {
#line 273
    destroy_flag = 1;
  } else {

  }
#line 275
  ldv_mutex_unlock_551(& mp->mutex);
#line 276
  if (destroy_flag != 0) {
#line 276
    pvr2_context_notify(mp);
  } else {

  }
#line 277
  return;
}
}
#line 280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
void pvr2_context_disconnect(struct pvr2_context *mp ) 
{ 


  {
#line 282
  pvr2_hdw_disconnect(mp->hdw);
#line 283
  mp->disconnect_flag = 1;
#line 284
  pvr2_context_notify(mp);
#line 285
  return;
}
}
#line 288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
void pvr2_channel_init(struct pvr2_channel *cp , struct pvr2_context *mp ) 
{ 


  {
#line 290
  pvr2_context_enter(mp);
#line 291
  cp->hdw = mp->hdw;
#line 292
  cp->mc_head = mp;
#line 293
  cp->mc_next = (struct pvr2_channel *)0;
#line 294
  cp->mc_prev = mp->mc_last;
#line 295
  if ((unsigned long )mp->mc_last != (unsigned long )((struct pvr2_channel *)0)) {
#line 296
    (mp->mc_last)->mc_next = cp;
  } else {
#line 298
    mp->mc_first = cp;
  }
#line 300
  mp->mc_last = cp;
#line 301
  pvr2_context_exit(mp);
#line 302
  return;
}
}
#line 305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static void pvr2_channel_disclaim_stream(struct pvr2_channel *cp ) 
{ 


  {
#line 307
  if ((unsigned long )cp->stream == (unsigned long )((struct pvr2_context_stream *)0)) {
#line 307
    return;
  } else {

  }
#line 308
  pvr2_stream_kill((cp->stream)->stream);
#line 309
  (cp->stream)->user = (struct pvr2_channel *)0;
#line 310
  cp->stream = (struct pvr2_context_stream *)0;
#line 311
  return;
}
}
#line 314 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
void pvr2_channel_done(struct pvr2_channel *cp ) 
{ 
  struct pvr2_context *mp ;

  {
#line 316
  mp = cp->mc_head;
#line 317
  pvr2_context_enter(mp);
#line 318
  cp->input_mask = 0U;
#line 319
  pvr2_channel_disclaim_stream(cp);
#line 320
  pvr2_context_reset_input_limits(mp);
#line 321
  if ((unsigned long )cp->mc_next != (unsigned long )((struct pvr2_channel *)0)) {
#line 322
    (cp->mc_next)->mc_prev = cp->mc_prev;
  } else {
#line 324
    mp->mc_last = cp->mc_prev;
  }
#line 326
  if ((unsigned long )cp->mc_prev != (unsigned long )((struct pvr2_channel *)0)) {
#line 327
    (cp->mc_prev)->mc_next = cp->mc_next;
  } else {
#line 329
    mp->mc_first = cp->mc_next;
  }
#line 331
  cp->hdw = (struct pvr2_hdw *)0;
#line 332
  pvr2_context_exit(mp);
#line 333
  return;
}
}
#line 336 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
int pvr2_channel_limit_inputs(struct pvr2_channel *cp , unsigned int cmsk ) 
{ 
  unsigned int tmsk ;
  unsigned int mmsk ;
  int ret ;
  struct pvr2_channel *p2 ;
  struct pvr2_hdw *hdw ;

  {
#line 339
  ret = 0;
#line 341
  hdw = cp->hdw;
#line 343
  mmsk = pvr2_hdw_get_input_available(hdw);
#line 344
  cmsk = cmsk & mmsk;
#line 345
  if (cp->input_mask == cmsk) {
#line 347
    return (0);
  } else {

  }
#line 350
  pvr2_context_enter(cp->mc_head);
#line 352
  if (cmsk == 0U) {
#line 353
    cp->input_mask = 0U;
#line 354
    pvr2_context_reset_input_limits(cp->mc_head);
#line 355
    goto ldv_29683;
  } else {

  }
#line 357
  tmsk = mmsk;
#line 358
  p2 = (cp->mc_head)->mc_first;
#line 358
  goto ldv_29686;
  ldv_29685: ;
#line 359
  if ((unsigned long )p2 == (unsigned long )cp) {
#line 359
    goto ldv_29684;
  } else {

  }
#line 360
  if (p2->input_mask == 0U) {
#line 360
    goto ldv_29684;
  } else {

  }
#line 361
  tmsk = p2->input_mask & tmsk;
  ldv_29684: 
#line 358
  p2 = p2->mc_next;
  ldv_29686: ;
#line 358
  if ((unsigned long )p2 != (unsigned long )((struct pvr2_channel *)0)) {
#line 360
    goto ldv_29685;
  } else {

  }

#line 363
  if ((tmsk & cmsk) == 0U) {
#line 364
    ret = -1;
#line 365
    goto ldv_29683;
  } else {

  }
#line 367
  tmsk = tmsk & cmsk;
#line 368
  ret = pvr2_hdw_set_input_allowed(hdw, mmsk, tmsk);
#line 368
  if (ret != 0) {
#line 371
    goto ldv_29683;
  } else {

  }
#line 373
  cp->input_mask = cmsk;
#line 374
  pvr2_hdw_commit_ctl(hdw);
  ldv_29683: 
#line 376
  pvr2_context_exit(cp->mc_head);
#line 377
  return (ret);
}
}
#line 381 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
unsigned int pvr2_channel_get_limited_inputs(struct pvr2_channel *cp ) 
{ 


  {
#line 383
  return (cp->input_mask);
}
}
#line 387 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
int pvr2_channel_claim_stream(struct pvr2_channel *cp , struct pvr2_context_stream *sp ) 
{ 
  int code ;

  {
#line 390
  code = 0;
#line 391
  pvr2_context_enter(cp->mc_head);
#line 392
  if ((unsigned long )cp->stream == (unsigned long )sp) {
#line 392
    goto ldv_29696;
  } else {

  }
#line 393
  if ((unsigned long )sp != (unsigned long )((struct pvr2_context_stream *)0) && (unsigned long )sp->user != (unsigned long )((struct pvr2_channel *)0)) {
#line 394
    code = -16;
#line 395
    goto ldv_29696;
  } else {

  }
#line 397
  pvr2_channel_disclaim_stream(cp);
#line 398
  if ((unsigned long )sp == (unsigned long )((struct pvr2_context_stream *)0)) {
#line 398
    goto ldv_29696;
  } else {

  }
#line 399
  sp->user = cp;
#line 400
  cp->stream = sp;
  ldv_29696: 
#line 402
  pvr2_context_exit(cp->mc_head);
#line 403
  return (code);
}
}
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
static char stream_sync_key[4U]  = {      0,      0,      1,      -70};
#line 412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.c"
struct pvr2_ioread *pvr2_channel_create_mpeg_stream(struct pvr2_context_stream *sp ) 
{ 
  struct pvr2_ioread *cp ;

  {
#line 416
  cp = pvr2_ioread_create();
#line 417
  if ((unsigned long )cp == (unsigned long )((struct pvr2_ioread *)0)) {
#line 417
    return ((struct pvr2_ioread *)0);
  } else {

  }
#line 418
  pvr2_ioread_setup(cp, sp->stream);
#line 419
  pvr2_ioread_set_sync_key(cp, (char const   *)(& stream_sync_key), 4U);
#line 420
  return (cp);
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  bool tmp ;

  {
#line 341
  tmp = ldv_is_err(ptr);
#line 341
  return (tmp);
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
bool ldv_queue_work_on_532(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 354
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 354
  ldv_func_res = tmp;
#line 356
  activate_work_1(ldv_func_arg3, 2);
#line 358
  return (ldv_func_res);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
bool ldv_queue_delayed_work_on_533(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 365
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 365
  ldv_func_res = tmp;
#line 367
  activate_work_1(& ldv_func_arg3->work, 2);
#line 369
  return (ldv_func_res);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
bool ldv_queue_work_on_534(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 376
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 376
  ldv_func_res = tmp;
#line 378
  activate_work_1(ldv_func_arg3, 2);
#line 380
  return (ldv_func_res);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void ldv_flush_workqueue_535(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 386
  flush_workqueue(ldv_func_arg1);
#line 388
  call_and_disable_all_1(2);
#line 389
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
bool ldv_queue_delayed_work_on_536(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 395
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 395
  ldv_func_res = tmp;
#line 397
  activate_work_1(& ldv_func_arg3->work, 2);
#line 399
  return (ldv_func_res);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void ldv_mutex_lock_537(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 405
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 407
  mutex_lock(ldv_func_arg1);
#line 408
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void ldv_mutex_unlock_538(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 413
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 415
  mutex_unlock(ldv_func_arg1);
#line 416
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void ldv_mutex_lock_539(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 421
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 423
  mutex_lock(ldv_func_arg1);
#line 424
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
int ldv_mutex_trylock_540(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 430
  tmp = mutex_trylock(ldv_func_arg1);
#line 430
  ldv_func_res = tmp;
#line 432
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 432
  return (tmp___0);
#line 434
  return (ldv_func_res);
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void ldv_mutex_unlock_541(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 440
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 442
  mutex_unlock(ldv_func_arg1);
#line 443
  return;
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void ldv_mutex_unlock_542(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 448
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 450
  mutex_unlock(ldv_func_arg1);
#line 451
  return;
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void ldv_mutex_lock_543(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 456
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 458
  mutex_lock(ldv_func_arg1);
#line 459
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void ldv_mutex_lock_544(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 464
  ldv_mutex_lock_pvr2_context_mutex(ldv_func_arg1);
#line 466
  mutex_lock(ldv_func_arg1);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void ldv_mutex_unlock_545(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 472
  ldv_mutex_unlock_pvr2_context_mutex(ldv_func_arg1);
#line 474
  mutex_unlock(ldv_func_arg1);
#line 475
  return;
}
}
#line 477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void ldv_mutex_lock_546(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 480
  ldv_mutex_lock_pvr2_context_mutex(ldv_func_arg1);
#line 482
  mutex_lock(ldv_func_arg1);
#line 483
  return;
}
}
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void ldv_mutex_unlock_547(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 488
  ldv_mutex_unlock_pvr2_context_mutex(ldv_func_arg1);
#line 490
  mutex_unlock(ldv_func_arg1);
#line 491
  return;
}
}
#line 493 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void ldv_mutex_lock_548(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 496
  ldv_mutex_lock_pvr2_context_mutex(ldv_func_arg1);
#line 498
  mutex_lock(ldv_func_arg1);
#line 499
  return;
}
}
#line 501 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void ldv_mutex_unlock_549(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 504
  ldv_mutex_unlock_pvr2_context_mutex(ldv_func_arg1);
#line 506
  mutex_unlock(ldv_func_arg1);
#line 507
  return;
}
}
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void ldv_mutex_lock_550(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 512
  ldv_mutex_lock_mutex_of_pvr2_context(ldv_func_arg1);
#line 514
  mutex_lock(ldv_func_arg1);
#line 515
  return;
}
}
#line 517 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-context.o.c.prepared"
void ldv_mutex_unlock_551(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 520
  ldv_mutex_unlock_mutex_of_pvr2_context(ldv_func_arg1);
#line 522
  mutex_unlock(ldv_func_arg1);
#line 523
  return;
}
}
#line 48 "include/linux/list.h"
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 75 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 77
  __list_add(new, head->prev, head);
#line 78
  return;
}
}
#line 112
extern void __list_del_entry(struct list_head * ) ;
#line 143 "include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
#line 145
  __list_del_entry(entry);
#line 146
  INIT_LIST_HEAD(entry);
#line 147
  return;
}
}
#line 121 "include/linux/string.h"
extern void *kmemdup(void const   * , size_t  , gfp_t  ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_584(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_582(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_585(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_586(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_589(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_591(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_593(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_595(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_597(struct mutex *ldv_func_arg1 ) ;
#line 213
void ldv_mutex_unlock_599(struct mutex *ldv_func_arg1 ) ;
#line 217
void ldv_mutex_unlock_601(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_lock_581(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_583(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_587(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_588(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_590(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_592(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_594(struct mutex *ldv_func_arg1 ) ;
#line 49
void ldv_mutex_lock_596(struct mutex *ldv_func_arg1 ) ;
#line 53
void ldv_mutex_lock_598(struct mutex *ldv_func_arg1 ) ;
#line 57
void ldv_mutex_lock_600(struct mutex *ldv_func_arg1 ) ;
#line 179
void ldv_mutex_lock_mutex_of_pvr2_stream(struct mutex *lock ) ;
#line 183
void ldv_mutex_unlock_mutex_of_pvr2_stream(struct mutex *lock ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 34 "include/linux/spinlock_api_smp.h"
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 45
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 299 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField17.rlock);
}
}
#line 370 "include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 372
  _raw_spin_unlock_irqrestore(& lock->__annonCompField17.rlock, flags);
#line 373
  return;
}
}
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_576(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_578(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_577(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_580(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_579(struct workqueue_struct *ldv_func_arg1 ) ;
#line 61 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-io.h"
int pvr2_stream_get_buffer_count(struct pvr2_stream *sp ) ;
#line 62
int pvr2_stream_set_buffer_count(struct pvr2_stream *sp , unsigned int cnt ) ;
#line 66
struct pvr2_buffer *pvr2_stream_get_idle_buffer(struct pvr2_stream *sp ) ;
#line 67
struct pvr2_buffer *pvr2_stream_get_ready_buffer(struct pvr2_stream *sp ) ;
#line 68
struct pvr2_buffer *pvr2_stream_get_buffer(struct pvr2_stream *sp , int id ) ;
#line 71
int pvr2_stream_get_ready_count(struct pvr2_stream *sp ) ;
#line 78
int pvr2_buffer_set_buffer(struct pvr2_buffer *bp , void *ptr , unsigned int cnt ) ;
#line 81
unsigned int pvr2_buffer_get_count(struct pvr2_buffer *bp ) ;
#line 84
int pvr2_buffer_get_status(struct pvr2_buffer *bp ) ;
#line 87
int pvr2_buffer_get_id(struct pvr2_buffer *bp ) ;
#line 90
int pvr2_buffer_queue(struct pvr2_buffer *bp ) ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
static char const   *pvr2_buffer_state_decode(enum pvr2_buffer_state st ) ;
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
static char const   *pvr2_buffer_state_decode(enum pvr2_buffer_state st ) 
{ 


  {
#line 103
  switch ((unsigned int )st) {
  case 0U: ;
#line 104
  return ("none");
  case 1U: ;
#line 105
  return ("idle");
  case 2U: ;
#line 106
  return ("queued");
  case 3U: ;
#line 107
  return ("ready");
  }
#line 109
  return ("unknown");
}
}
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
static void pvr2_buffer_remove(struct pvr2_buffer *bp ) 
{ 
  unsigned int *cnt ;
  unsigned int *bcnt ;
  unsigned int ccnt ;
  struct pvr2_stream *sp ;
  char const   *tmp ;

  {
#line 135
  sp = bp->stream;
#line 136
  switch ((unsigned int )bp->state) {
  case 1U: 
#line 138
  cnt = & sp->i_count;
#line 139
  bcnt = & sp->i_bcount;
#line 140
  ccnt = bp->max_count;
#line 141
  goto ldv_27799;
  case 2U: 
#line 143
  cnt = & sp->q_count;
#line 144
  bcnt = & sp->q_bcount;
#line 145
  ccnt = bp->max_count;
#line 146
  goto ldv_27799;
  case 3U: 
#line 148
  cnt = & sp->r_count;
#line 149
  bcnt = & sp->r_bcount;
#line 150
  ccnt = bp->used_count;
#line 151
  goto ldv_27799;
  default: ;
#line 153
  return;
  }
  ldv_27799: 
#line 155
  list_del_init(& bp->list_overhead);
#line 156
  *cnt = *cnt - 1U;
#line 157
  *bcnt = *bcnt - ccnt;
#line 158
  if ((pvrusb2_debug & 16777216) != 0) {
#line 158
    tmp = pvr2_buffer_state_decode(bp->state);
#line 158
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferPool     %8s dec cap=%07d cnt=%02d\n",
           tmp, *bcnt, *cnt);
  } else {

  }
#line 162
  bp->state = 0;
#line 163
  return;
}
}
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
static void pvr2_buffer_set_none(struct pvr2_buffer *bp ) 
{ 
  unsigned long irq_flags ;
  struct pvr2_stream *sp ;
  char const   *tmp ;
  char const   *tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 170
  sp = bp->stream;
#line 171
  if ((pvrusb2_debug & 16777216) != 0) {
#line 171
    tmp = pvr2_buffer_state_decode(0);
#line 171
    tmp___0 = pvr2_buffer_state_decode(bp->state);
#line 171
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferState    %p %6s --> %6s\n", bp,
           tmp___0, tmp);
  } else {

  }
#line 176
  tmp___1 = spinlock_check(& sp->list_lock);
#line 176
  irq_flags = _raw_spin_lock_irqsave(tmp___1);
#line 177
  pvr2_buffer_remove(bp);
#line 178
  spin_unlock_irqrestore(& sp->list_lock, irq_flags);
#line 179
  return;
}
}
#line 181 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
static int pvr2_buffer_set_ready(struct pvr2_buffer *bp ) 
{ 
  int fl ;
  unsigned long irq_flags ;
  struct pvr2_stream *sp ;
  char const   *tmp ;
  char const   *tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 187
  sp = bp->stream;
#line 188
  if ((pvrusb2_debug & 16777216) != 0) {
#line 188
    tmp = pvr2_buffer_state_decode(3);
#line 188
    tmp___0 = pvr2_buffer_state_decode(bp->state);
#line 188
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferState    %p %6s --> %6s\n", bp,
           tmp___0, tmp);
  } else {

  }
#line 193
  tmp___1 = spinlock_check(& sp->list_lock);
#line 193
  irq_flags = _raw_spin_lock_irqsave(tmp___1);
#line 194
  fl = sp->r_count == 0U;
#line 195
  pvr2_buffer_remove(bp);
#line 196
  list_add_tail(& bp->list_overhead, & sp->ready_list);
#line 197
  bp->state = 3;
#line 198
  sp->r_count = sp->r_count + 1U;
#line 199
  sp->r_bcount = sp->r_bcount + bp->used_count;
#line 200
  if ((pvrusb2_debug & 16777216) != 0) {
#line 200
    tmp___2 = pvr2_buffer_state_decode(bp->state);
#line 200
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferPool     %8s inc cap=%07d cnt=%02d\n",
           tmp___2, sp->r_bcount, sp->r_count);
  } else {

  }
#line 205
  spin_unlock_irqrestore(& sp->list_lock, irq_flags);
#line 206
  return (fl);
}
}
#line 209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
static void pvr2_buffer_set_idle(struct pvr2_buffer *bp ) 
{ 
  unsigned long irq_flags ;
  struct pvr2_stream *sp ;
  char const   *tmp ;
  char const   *tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 214
  sp = bp->stream;
#line 215
  if ((pvrusb2_debug & 16777216) != 0) {
#line 215
    tmp = pvr2_buffer_state_decode(1);
#line 215
    tmp___0 = pvr2_buffer_state_decode(bp->state);
#line 215
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferState    %p %6s --> %6s\n", bp,
           tmp___0, tmp);
  } else {

  }
#line 220
  tmp___1 = spinlock_check(& sp->list_lock);
#line 220
  irq_flags = _raw_spin_lock_irqsave(tmp___1);
#line 221
  pvr2_buffer_remove(bp);
#line 222
  list_add_tail(& bp->list_overhead, & sp->idle_list);
#line 223
  bp->state = 1;
#line 224
  sp->i_count = sp->i_count + 1U;
#line 225
  sp->i_bcount = sp->i_bcount + bp->max_count;
#line 226
  if ((pvrusb2_debug & 16777216) != 0) {
#line 226
    tmp___2 = pvr2_buffer_state_decode(bp->state);
#line 226
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferPool     %8s inc cap=%07d cnt=%02d\n",
           tmp___2, sp->i_bcount, sp->i_count);
  } else {

  }
#line 231
  spin_unlock_irqrestore(& sp->list_lock, irq_flags);
#line 232
  return;
}
}
#line 234 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
static void pvr2_buffer_set_queued(struct pvr2_buffer *bp ) 
{ 
  unsigned long irq_flags ;
  struct pvr2_stream *sp ;
  char const   *tmp ;
  char const   *tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 239
  sp = bp->stream;
#line 240
  if ((pvrusb2_debug & 16777216) != 0) {
#line 240
    tmp = pvr2_buffer_state_decode(2);
#line 240
    tmp___0 = pvr2_buffer_state_decode(bp->state);
#line 240
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferState    %p %6s --> %6s\n", bp,
           tmp___0, tmp);
  } else {

  }
#line 245
  tmp___1 = spinlock_check(& sp->list_lock);
#line 245
  irq_flags = _raw_spin_lock_irqsave(tmp___1);
#line 246
  pvr2_buffer_remove(bp);
#line 247
  list_add_tail(& bp->list_overhead, & sp->queued_list);
#line 248
  bp->state = 2;
#line 249
  sp->q_count = sp->q_count + 1U;
#line 250
  sp->q_bcount = sp->q_bcount + bp->max_count;
#line 251
  if ((pvrusb2_debug & 16777216) != 0) {
#line 251
    tmp___2 = pvr2_buffer_state_decode(bp->state);
#line 251
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferPool     %8s inc cap=%07d cnt=%02d\n",
           tmp___2, sp->q_bcount, sp->q_count);
  } else {

  }
#line 256
  spin_unlock_irqrestore(& sp->list_lock, irq_flags);
#line 257
  return;
}
}
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
static void pvr2_buffer_wipe(struct pvr2_buffer *bp ) 
{ 


  {
#line 261
  if ((unsigned int )bp->state == 2U) {
#line 262
    usb_kill_urb(bp->purb);
  } else {

  }
#line 263
  return;
}
}
#line 266 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
static int pvr2_buffer_init(struct pvr2_buffer *bp , struct pvr2_stream *sp , unsigned int id ) 
{ 


  {
#line 270
  memset((void *)bp, 0, 72UL);
#line 271
  bp->signature = 1197814385;
#line 272
  bp->id = (int )id;
#line 273
  if ((pvrusb2_debug & 8388608) != 0) {
#line 273
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferInit     %p stream=%p\n", bp,
           sp);
  } else {

  }
#line 275
  bp->stream = sp;
#line 276
  bp->state = 0;
#line 277
  INIT_LIST_HEAD(& bp->list_overhead);
#line 278
  bp->purb = usb_alloc_urb(0, 208U);
#line 279
  if ((unsigned long )bp->purb == (unsigned long )((struct urb *)0)) {
#line 279
    return (-12);
  } else {

  }
#line 283
  return (0);
}
}
#line 286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
static void pvr2_buffer_done(struct pvr2_buffer *bp ) 
{ 


  {
#line 291
  pvr2_buffer_wipe(bp);
#line 292
  pvr2_buffer_set_none(bp);
#line 293
  bp->signature = 0;
#line 294
  bp->stream = (struct pvr2_stream *)0;
#line 295
  usb_free_urb(bp->purb);
#line 296
  if ((pvrusb2_debug & 8388608) != 0) {
#line 296
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferDone     %p\n", bp);
  } else {

  }
#line 297
  return;
}
}
#line 300 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
static int pvr2_stream_buffer_count(struct pvr2_stream *sp , unsigned int cnt ) 
{ 
  int ret ;
  unsigned int scnt ;
  struct pvr2_buffer **nb ;
  void *tmp ;
  struct pvr2_buffer *bp ;
  void *tmp___0 ;
  struct pvr2_buffer *bp___0 ;
  struct pvr2_buffer **nb___0 ;
  void *tmp___1 ;

  {
#line 306
  if (sp->buffer_total_count == cnt) {
#line 306
    return (0);
  } else {

  }
#line 308
  if ((pvrusb2_debug & 8388608) != 0) {
#line 308
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ poolResize     stream=%p cur=%d adj=%+d\n",
           sp, sp->buffer_total_count, cnt - sp->buffer_total_count);
  } else {

  }
#line 315
  scnt = cnt & 4294967264U;
#line 316
  if (cnt > scnt) {
#line 316
    scnt = scnt + 32U;
  } else {

  }
#line 318
  if (sp->buffer_total_count < cnt) {
#line 319
    if (sp->buffer_slot_count < scnt) {
#line 321
      tmp = kmalloc((unsigned long )scnt * 8UL, 208U);
#line 321
      nb = (struct pvr2_buffer **)tmp;
#line 322
      if ((unsigned long )nb == (unsigned long )((struct pvr2_buffer **)0)) {
#line 322
        return (-12);
      } else {

      }
#line 323
      if (sp->buffer_slot_count != 0U) {
#line 324
        memcpy((void *)nb, (void const   *)sp->buffers, (unsigned long )sp->buffer_slot_count * 8UL);
#line 326
        kfree((void const   *)sp->buffers);
      } else {

      }
#line 328
      sp->buffers = nb;
#line 329
      sp->buffer_slot_count = scnt;
    } else {

    }
#line 331
    goto ldv_27856;
    ldv_27855: 
#line 333
    tmp___0 = kmalloc(72UL, 208U);
#line 333
    bp = (struct pvr2_buffer *)tmp___0;
#line 334
    if ((unsigned long )bp == (unsigned long )((struct pvr2_buffer *)0)) {
#line 334
      return (-12);
    } else {

    }
#line 335
    ret = pvr2_buffer_init(bp, sp, sp->buffer_total_count);
#line 336
    if (ret != 0) {
#line 337
      kfree((void const   *)bp);
#line 338
      return (-12);
    } else {

    }
#line 340
    *(sp->buffers + (unsigned long )sp->buffer_total_count) = bp;
#line 341
    sp->buffer_total_count = sp->buffer_total_count + 1U;
#line 342
    pvr2_buffer_set_idle(bp);
    ldv_27856: ;
#line 331
    if (sp->buffer_total_count < cnt) {
#line 333
      goto ldv_27855;
    } else {

    }

  } else {
#line 345
    goto ldv_27860;
    ldv_27859: 
#line 347
    bp___0 = *(sp->buffers + (unsigned long )(sp->buffer_total_count - 1U));
#line 349
    *(sp->buffers + (unsigned long )(sp->buffer_total_count - 1U)) = (struct pvr2_buffer *)0;
#line 350
    sp->buffer_total_count = sp->buffer_total_count - 1U;
#line 351
    pvr2_buffer_done(bp___0);
#line 352
    kfree((void const   *)bp___0);
    ldv_27860: ;
#line 345
    if (sp->buffer_total_count > cnt) {
#line 347
      goto ldv_27859;
    } else {

    }

#line 354
    if (sp->buffer_slot_count > scnt) {
#line 355
      nb___0 = (struct pvr2_buffer **)0;
#line 356
      if (scnt != 0U) {
#line 357
        tmp___1 = kmemdup((void const   *)sp->buffers, (unsigned long )scnt * 8UL,
                          208U);
#line 357
        nb___0 = (struct pvr2_buffer **)tmp___1;
#line 359
        if ((unsigned long )nb___0 == (unsigned long )((struct pvr2_buffer **)0)) {
#line 359
          return (-12);
        } else {

        }
      } else {

      }
#line 361
      kfree((void const   *)sp->buffers);
#line 362
      sp->buffers = nb___0;
#line 363
      sp->buffer_slot_count = scnt;
    } else {

    }
  }
#line 366
  return (0);
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
static int pvr2_stream_achieve_buffer_count(struct pvr2_stream *sp ) 
{ 
  struct pvr2_buffer *bp ;
  unsigned int cnt ;
  int tmp ;

  {
#line 374
  if (sp->buffer_total_count == sp->buffer_target_count) {
#line 374
    return (0);
  } else {

  }
#line 376
  if ((pvrusb2_debug & 8388608) != 0) {
#line 376
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ poolCheck      stream=%p cur=%d tgt=%d\n",
           sp, sp->buffer_total_count, sp->buffer_target_count);
  } else {

  }
#line 381
  if (sp->buffer_total_count < sp->buffer_target_count) {
#line 382
    tmp = pvr2_stream_buffer_count(sp, sp->buffer_target_count);
#line 382
    return (tmp);
  } else {

  }
#line 385
  cnt = 0U;
#line 386
  goto ldv_27870;
  ldv_27869: 
#line 387
  bp = *(sp->buffers + (unsigned long )((sp->buffer_total_count - cnt) - 1U));
#line 388
  if ((unsigned int )bp->state != 1U) {
#line 388
    goto ldv_27868;
  } else {

  }
#line 389
  cnt = cnt + 1U;
  ldv_27870: ;
#line 386
  if (sp->buffer_total_count - cnt > sp->buffer_target_count) {
#line 388
    goto ldv_27869;
  } else {

  }
  ldv_27868: ;
#line 391
  if (cnt != 0U) {
#line 392
    pvr2_stream_buffer_count(sp, sp->buffer_total_count - cnt);
  } else {

  }
#line 395
  return (0);
}
}
#line 398 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
static void pvr2_stream_internal_flush(struct pvr2_stream *sp ) 
{ 
  struct list_head *lp ;
  struct pvr2_buffer *bp1 ;
  struct list_head  const  *__mptr ;

  {
#line 402
  goto ldv_27878;
  ldv_27879: 
#line 403
  __mptr = (struct list_head  const  *)lp;
#line 403
  bp1 = (struct pvr2_buffer *)__mptr + 0xffffffffffffffd0UL;
#line 404
  pvr2_buffer_wipe(bp1);
#line 410
  if ((unsigned int )bp1->state != 2U) {
#line 410
    goto ldv_27878;
  } else {

  }
#line 411
  pvr2_buffer_set_idle(bp1);
  ldv_27878: 
#line 402
  lp = sp->queued_list.next;
#line 402
  if ((unsigned long )lp != (unsigned long )(& sp->queued_list)) {
#line 404
    goto ldv_27879;
  } else {

  }

#line 413
  if (sp->buffer_total_count != sp->buffer_target_count) {
#line 414
    pvr2_stream_achieve_buffer_count(sp);
  } else {

  }
#line 415
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
static void pvr2_stream_init(struct pvr2_stream *sp ) 
{ 
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 420
  spinlock_check(& sp->list_lock);
#line 420
  __raw_spin_lock_init(& sp->list_lock.__annonCompField17.rlock, "&(&sp->list_lock)->rlock",
                       & __key);
#line 421
  __mutex_init(& sp->mutex, "&sp->mutex", & __key___0);
#line 422
  INIT_LIST_HEAD(& sp->queued_list);
#line 423
  INIT_LIST_HEAD(& sp->ready_list);
#line 424
  INIT_LIST_HEAD(& sp->idle_list);
#line 425
  return;
}
}
#line 427 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
static void pvr2_stream_done(struct pvr2_stream *sp ) 
{ 


  {
#line 429
  ldv_mutex_lock_588(& sp->mutex);
#line 430
  pvr2_stream_internal_flush(sp);
#line 431
  pvr2_stream_buffer_count(sp, 0U);
#line 432
  ldv_mutex_unlock_589(& sp->mutex);
#line 433
  return;
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
static void buffer_complete(struct urb *urb ) 
{ 
  struct pvr2_buffer *bp ;
  struct pvr2_stream *sp ;
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;

  {
#line 437
  bp = (struct pvr2_buffer *)urb->context;
#line 441
  sp = bp->stream;
#line 442
  bp->used_count = 0U;
#line 443
  bp->status = 0;
#line 444
  if ((pvrusb2_debug & 16777216) != 0) {
#line 444
    printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferComplete %p stat=%d cnt=%d\n",
           bp, urb->status, urb->actual_length);
  } else {

  }
#line 447
  tmp = spinlock_check(& sp->list_lock);
#line 447
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 448
  if (((urb->status == 0 || urb->status == -2) || urb->status == -104) || urb->status == -108) {
#line 452
    sp->buffers_processed = sp->buffers_processed + 1U;
#line 453
    sp->bytes_processed = sp->bytes_processed + urb->actual_length;
#line 454
    bp->used_count = urb->actual_length;
#line 455
    if (sp->fail_count != 0U) {
#line 456
      if ((pvrusb2_debug & 4) != 0) {
#line 456
        printk("\016pvrusb2: stream %p transfer ok - fail count reset\n", sp);
      } else {

      }
#line 459
      sp->fail_count = 0U;
    } else {

    }
  } else
#line 461
  if (sp->fail_count < sp->fail_tolerance) {
#line 464
    sp->fail_count = sp->fail_count + 1U;
#line 465
    sp->buffers_failed = sp->buffers_failed + 1U;
#line 466
    if ((pvrusb2_debug & 4) != 0) {
#line 466
      printk("\016pvrusb2: stream %p ignoring error %d - fail count increased to %u\n",
             sp, urb->status, sp->fail_count);
    } else {

    }
  } else {
#line 471
    sp->buffers_failed = sp->buffers_failed + 1U;
#line 472
    bp->status = urb->status;
  }
#line 474
  spin_unlock_irqrestore(& sp->list_lock, irq_flags);
#line 475
  pvr2_buffer_set_ready(bp);
#line 476
  if ((unsigned long )sp != (unsigned long )((struct pvr2_stream *)0) && (unsigned long )sp->callback_func != (unsigned long )((void (*)(void * ))0)) {
#line 477
    (*(sp->callback_func))(sp->callback_data);
  } else {

  }
#line 478
  return;
}
}
#line 481 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
struct pvr2_stream *pvr2_stream_create(void) 
{ 
  struct pvr2_stream *sp ;
  void *tmp ;

  {
#line 484
  tmp = kzalloc(384UL, 208U);
#line 484
  sp = (struct pvr2_stream *)tmp;
#line 485
  if ((unsigned long )sp == (unsigned long )((struct pvr2_stream *)0)) {
#line 485
    return (sp);
  } else {

  }
#line 486
  if ((pvrusb2_debug & 32) != 0) {
#line 486
    printk("\016pvrusb2: pvr2_stream_create: sp=%p\n", sp);
  } else {

  }
#line 487
  pvr2_stream_init(sp);
#line 488
  return (sp);
}
}
#line 491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
void pvr2_stream_destroy(struct pvr2_stream *sp ) 
{ 


  {
#line 493
  if ((unsigned long )sp == (unsigned long )((struct pvr2_stream *)0)) {
#line 493
    return;
  } else {

  }
#line 494
  if ((pvrusb2_debug & 32) != 0) {
#line 494
    printk("\016pvrusb2: pvr2_stream_destroy: sp=%p\n", sp);
  } else {

  }
#line 495
  pvr2_stream_done(sp);
#line 496
  kfree((void const   *)sp);
#line 497
  return;
}
}
#line 499 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
void pvr2_stream_setup(struct pvr2_stream *sp , struct usb_device *dev , int endpoint ,
                       unsigned int tolerance___0 ) 
{ 


  {
#line 504
  ldv_mutex_lock_590(& sp->mutex);
#line 505
  pvr2_stream_internal_flush(sp);
#line 506
  sp->dev = dev;
#line 507
  sp->endpoint = endpoint;
#line 508
  sp->fail_tolerance = tolerance___0;
#line 509
  ldv_mutex_unlock_591(& sp->mutex);
#line 510
  return;
}
}
#line 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
void pvr2_stream_set_callback(struct pvr2_stream *sp , void (*func)(void * ) , void *data ) 
{ 
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;

  {
#line 517
  ldv_mutex_lock_592(& sp->mutex);
#line 519
  tmp = spinlock_check(& sp->list_lock);
#line 519
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 520
  sp->callback_data = data;
#line 521
  sp->callback_func = func;
#line 522
  spin_unlock_irqrestore(& sp->list_lock, irq_flags);
#line 524
  ldv_mutex_unlock_593(& sp->mutex);
#line 525
  return;
}
}
#line 527 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
void pvr2_stream_get_stats(struct pvr2_stream *sp , struct pvr2_stream_stats *stats ,
                           int zero_counts ) 
{ 
  unsigned long irq_flags ;
  raw_spinlock_t *tmp ;

  {
#line 532
  tmp = spinlock_check(& sp->list_lock);
#line 532
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 533
  if ((unsigned long )stats != (unsigned long )((struct pvr2_stream_stats *)0)) {
#line 534
    stats->buffers_in_queue = sp->q_count;
#line 535
    stats->buffers_in_idle = sp->i_count;
#line 536
    stats->buffers_in_ready = sp->r_count;
#line 537
    stats->buffers_processed = sp->buffers_processed;
#line 538
    stats->buffers_failed = sp->buffers_failed;
#line 539
    stats->bytes_processed = sp->bytes_processed;
  } else {

  }
#line 541
  if (zero_counts != 0) {
#line 542
    sp->buffers_processed = 0U;
#line 543
    sp->buffers_failed = 0U;
#line 544
    sp->bytes_processed = 0U;
  } else {

  }
#line 546
  spin_unlock_irqrestore(& sp->list_lock, irq_flags);
#line 547
  return;
}
}
#line 550 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
int pvr2_stream_get_buffer_count(struct pvr2_stream *sp ) 
{ 


  {
#line 552
  return ((int )sp->buffer_target_count);
}
}
#line 555 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
int pvr2_stream_set_buffer_count(struct pvr2_stream *sp , unsigned int cnt ) 
{ 
  int ret ;

  {
#line 558
  if (sp->buffer_target_count == cnt) {
#line 558
    return (0);
  } else {

  }
#line 559
  ldv_mutex_lock_594(& sp->mutex);
#line 561
  sp->buffer_target_count = cnt;
#line 562
  ret = pvr2_stream_achieve_buffer_count(sp);
#line 564
  ldv_mutex_unlock_595(& sp->mutex);
#line 565
  return (ret);
}
}
#line 568 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
struct pvr2_buffer *pvr2_stream_get_idle_buffer(struct pvr2_stream *sp ) 
{ 
  struct list_head *lp ;
  struct list_head  const  *__mptr ;

  {
#line 570
  lp = sp->idle_list.next;
#line 571
  if ((unsigned long )(& sp->idle_list) == (unsigned long )lp) {
#line 571
    return ((struct pvr2_buffer *)0);
  } else {

  }
#line 572
  __mptr = (struct list_head  const  *)lp;
#line 572
  return ((struct pvr2_buffer *)__mptr + 0xffffffffffffffd0UL);
}
}
#line 575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
struct pvr2_buffer *pvr2_stream_get_ready_buffer(struct pvr2_stream *sp ) 
{ 
  struct list_head *lp ;
  struct list_head  const  *__mptr ;

  {
#line 577
  lp = sp->ready_list.next;
#line 578
  if ((unsigned long )(& sp->ready_list) == (unsigned long )lp) {
#line 578
    return ((struct pvr2_buffer *)0);
  } else {

  }
#line 579
  __mptr = (struct list_head  const  *)lp;
#line 579
  return ((struct pvr2_buffer *)__mptr + 0xffffffffffffffd0UL);
}
}
#line 582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
struct pvr2_buffer *pvr2_stream_get_buffer(struct pvr2_stream *sp , int id ) 
{ 


  {
#line 584
  if (id < 0) {
#line 584
    return ((struct pvr2_buffer *)0);
  } else {

  }
#line 585
  if ((unsigned int )id >= sp->buffer_total_count) {
#line 585
    return ((struct pvr2_buffer *)0);
  } else {

  }
#line 586
  return (*(sp->buffers + (unsigned long )id));
}
}
#line 589 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
int pvr2_stream_get_ready_count(struct pvr2_stream *sp ) 
{ 


  {
#line 591
  return ((int )sp->r_count);
}
}
#line 594 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
void pvr2_stream_kill(struct pvr2_stream *sp ) 
{ 
  struct pvr2_buffer *bp ;

  {
#line 597
  ldv_mutex_lock_596(& sp->mutex);
#line 599
  pvr2_stream_internal_flush(sp);
#line 600
  goto ldv_27961;
  ldv_27960: 
#line 601
  pvr2_buffer_set_idle(bp);
  ldv_27961: 
#line 600
  bp = pvr2_stream_get_ready_buffer(sp);
#line 600
  if ((unsigned long )bp != (unsigned long )((struct pvr2_buffer *)0)) {
#line 602
    goto ldv_27960;
  } else {

  }

#line 603
  if (sp->buffer_total_count != sp->buffer_target_count) {
#line 604
    pvr2_stream_achieve_buffer_count(sp);
  } else {

  }
#line 607
  ldv_mutex_unlock_597(& sp->mutex);
#line 608
  return;
}
}
#line 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
int pvr2_buffer_queue(struct pvr2_buffer *bp ) 
{ 
  int ret ;
  struct pvr2_stream *sp ;
  unsigned int tmp ;

  {
#line 617
  ret = 0;
#line 619
  if ((unsigned long )bp == (unsigned long )((struct pvr2_buffer *)0)) {
#line 619
    return (-22);
  } else {

  }
#line 620
  sp = bp->stream;
#line 621
  ldv_mutex_lock_598(& sp->mutex);
#line 623
  pvr2_buffer_wipe(bp);
#line 624
  if ((unsigned long )sp->dev == (unsigned long )((struct usb_device *)0)) {
#line 625
    ret = -5;
#line 626
    goto ldv_27968;
  } else {

  }
#line 628
  pvr2_buffer_set_queued(bp);
#line 636
  bp->status = -115;
#line 637
  tmp = __create_pipe(sp->dev, (unsigned int )sp->endpoint);
#line 637
  usb_fill_bulk_urb(bp->purb, sp->dev, tmp | 3221225600U, bp->ptr, (int )bp->max_count,
                    & buffer_complete, (void *)bp);
#line 645
  usb_submit_urb(bp->purb, 208U);
  ldv_27968: 
#line 647
  ldv_mutex_unlock_599(& sp->mutex);
#line 648
  return (ret);
}
}
#line 651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
int pvr2_buffer_set_buffer(struct pvr2_buffer *bp , void *ptr , unsigned int cnt ) 
{ 
  int ret ;
  unsigned long irq_flags ;
  struct pvr2_stream *sp ;
  raw_spinlock_t *tmp ;
  char const   *tmp___0 ;

  {
#line 653
  ret = 0;
#line 656
  if ((unsigned long )bp == (unsigned long )((struct pvr2_buffer *)0)) {
#line 656
    return (-22);
  } else {

  }
#line 657
  sp = bp->stream;
#line 658
  ldv_mutex_lock_600(& sp->mutex);
#line 660
  tmp = spinlock_check(& sp->list_lock);
#line 660
  irq_flags = _raw_spin_lock_irqsave(tmp);
#line 661
  if ((unsigned int )bp->state != 1U) {
#line 662
    ret = -1;
  } else {
#line 664
    bp->ptr = ptr;
#line 665
    (bp->stream)->i_bcount = (bp->stream)->i_bcount - bp->max_count;
#line 666
    bp->max_count = cnt;
#line 667
    (bp->stream)->i_bcount = (bp->stream)->i_bcount + bp->max_count;
#line 668
    if ((pvrusb2_debug & 16777216) != 0) {
#line 668
      tmp___0 = pvr2_buffer_state_decode(1);
#line 668
      printk("\016pvrusb2: /*---TRACE_FLOW---*/ bufferPool     %8s cap cap=%07d cnt=%02d\n",
             tmp___0, (bp->stream)->i_bcount, (bp->stream)->i_count);
    } else {

    }
  }
#line 675
  spin_unlock_irqrestore(& sp->list_lock, irq_flags);
#line 677
  ldv_mutex_unlock_601(& sp->mutex);
#line 678
  return (ret);
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
unsigned int pvr2_buffer_get_count(struct pvr2_buffer *bp ) 
{ 


  {
#line 683
  return (bp->used_count);
}
}
#line 686 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
int pvr2_buffer_get_status(struct pvr2_buffer *bp ) 
{ 


  {
#line 688
  return (bp->status);
}
}
#line 691 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.c"
int pvr2_buffer_get_id(struct pvr2_buffer *bp ) 
{ 


  {
#line 693
  return (bp->id);
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
bool ldv_queue_work_on_576(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 354
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 354
  ldv_func_res = tmp;
#line 356
  activate_work_1(ldv_func_arg3, 2);
#line 358
  return (ldv_func_res);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
bool ldv_queue_delayed_work_on_577(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 365
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 365
  ldv_func_res = tmp;
#line 367
  activate_work_1(& ldv_func_arg3->work, 2);
#line 369
  return (ldv_func_res);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
bool ldv_queue_work_on_578(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 376
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 376
  ldv_func_res = tmp;
#line 378
  activate_work_1(ldv_func_arg3, 2);
#line 380
  return (ldv_func_res);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_flush_workqueue_579(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 386
  flush_workqueue(ldv_func_arg1);
#line 388
  call_and_disable_all_1(2);
#line 389
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
bool ldv_queue_delayed_work_on_580(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 395
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 395
  ldv_func_res = tmp;
#line 397
  activate_work_1(& ldv_func_arg3->work, 2);
#line 399
  return (ldv_func_res);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_lock_581(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 405
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 407
  mutex_lock(ldv_func_arg1);
#line 408
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_unlock_582(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 413
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 415
  mutex_unlock(ldv_func_arg1);
#line 416
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_lock_583(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 421
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 423
  mutex_lock(ldv_func_arg1);
#line 424
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
int ldv_mutex_trylock_584(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 430
  tmp = mutex_trylock(ldv_func_arg1);
#line 430
  ldv_func_res = tmp;
#line 432
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 432
  return (tmp___0);
#line 434
  return (ldv_func_res);
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_unlock_585(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 440
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 442
  mutex_unlock(ldv_func_arg1);
#line 443
  return;
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_unlock_586(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 448
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 450
  mutex_unlock(ldv_func_arg1);
#line 451
  return;
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_lock_587(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 456
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 458
  mutex_lock(ldv_func_arg1);
#line 459
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_lock_588(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 464
  ldv_mutex_lock_mutex_of_pvr2_stream(ldv_func_arg1);
#line 466
  mutex_lock(ldv_func_arg1);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_unlock_589(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 472
  ldv_mutex_unlock_mutex_of_pvr2_stream(ldv_func_arg1);
#line 474
  mutex_unlock(ldv_func_arg1);
#line 475
  return;
}
}
#line 477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_lock_590(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 480
  ldv_mutex_lock_mutex_of_pvr2_stream(ldv_func_arg1);
#line 482
  mutex_lock(ldv_func_arg1);
#line 483
  return;
}
}
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_unlock_591(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 488
  ldv_mutex_unlock_mutex_of_pvr2_stream(ldv_func_arg1);
#line 490
  mutex_unlock(ldv_func_arg1);
#line 491
  return;
}
}
#line 493 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_lock_592(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 496
  ldv_mutex_lock_mutex_of_pvr2_stream(ldv_func_arg1);
#line 498
  mutex_lock(ldv_func_arg1);
#line 499
  return;
}
}
#line 501 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_unlock_593(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 504
  ldv_mutex_unlock_mutex_of_pvr2_stream(ldv_func_arg1);
#line 506
  mutex_unlock(ldv_func_arg1);
#line 507
  return;
}
}
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_lock_594(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 512
  ldv_mutex_lock_mutex_of_pvr2_stream(ldv_func_arg1);
#line 514
  mutex_lock(ldv_func_arg1);
#line 515
  return;
}
}
#line 517 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_unlock_595(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 520
  ldv_mutex_unlock_mutex_of_pvr2_stream(ldv_func_arg1);
#line 522
  mutex_unlock(ldv_func_arg1);
#line 523
  return;
}
}
#line 525 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_lock_596(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 528
  ldv_mutex_lock_mutex_of_pvr2_stream(ldv_func_arg1);
#line 530
  mutex_lock(ldv_func_arg1);
#line 531
  return;
}
}
#line 533 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_unlock_597(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 536
  ldv_mutex_unlock_mutex_of_pvr2_stream(ldv_func_arg1);
#line 538
  mutex_unlock(ldv_func_arg1);
#line 539
  return;
}
}
#line 541 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_lock_598(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 544
  ldv_mutex_lock_mutex_of_pvr2_stream(ldv_func_arg1);
#line 546
  mutex_lock(ldv_func_arg1);
#line 547
  return;
}
}
#line 549 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_unlock_599(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 552
  ldv_mutex_unlock_mutex_of_pvr2_stream(ldv_func_arg1);
#line 554
  mutex_unlock(ldv_func_arg1);
#line 555
  return;
}
}
#line 557 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_lock_600(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 560
  ldv_mutex_lock_mutex_of_pvr2_stream(ldv_func_arg1);
#line 562
  mutex_lock(ldv_func_arg1);
#line 563
  return;
}
}
#line 565 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-io.o.c.prepared"
void ldv_mutex_unlock_601(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 568
  ldv_mutex_unlock_mutex_of_pvr2_stream(ldv_func_arg1);
#line 570
  mutex_unlock(ldv_func_arg1);
#line 571
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_640(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_638(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_641(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_642(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_645(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_646(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_648(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_650(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_652(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void ldv_mutex_lock_637(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_639(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_643(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_644(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_647(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_649(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_651(struct mutex *ldv_func_arg1 ) ;
#line 154
void ldv_mutex_lock_mutex_of_pvr2_ioread(struct mutex *lock ) ;
#line 158
void ldv_mutex_unlock_mutex_of_pvr2_ioread(struct mutex *lock ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_632(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_634(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_633(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_636(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_635(struct workqueue_struct *ldv_func_arg1 ) ;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.c"
static int pvr2_ioread_init(struct pvr2_ioread *cp ) 
{ 
  unsigned int idx ;
  struct lock_class_key __key ;
  void *tmp ;

  {
#line 57
  cp->stream = (struct pvr2_stream *)0;
#line 58
  __mutex_init(& cp->mutex, "&cp->mutex", & __key);
#line 60
  idx = 0U;
#line 60
  goto ldv_30696;
  ldv_30695: 
#line 61
  tmp = kmalloc(16384UL, 208U);
#line 61
  cp->buffer_storage[idx] = (char *)tmp;
#line 62
  if ((unsigned long )cp->buffer_storage[idx] == (unsigned long )((char *)0)) {
#line 62
    goto ldv_30694;
  } else {

  }
#line 60
  idx = idx + 1U;
  ldv_30696: ;
#line 60
  if (idx <= 31U) {
#line 62
    goto ldv_30695;
  } else {

  }
  ldv_30694: ;
#line 65
  if (idx <= 31U) {
#line 67
    idx = 0U;
#line 67
    goto ldv_30699;
    ldv_30698: ;
#line 68
    if ((unsigned long )cp->buffer_storage[idx] == (unsigned long )((char *)0)) {
#line 68
      goto ldv_30697;
    } else {

    }
#line 69
    kfree((void const   *)cp->buffer_storage[idx]);
    ldv_30697: 
#line 67
    idx = idx + 1U;
    ldv_30699: ;
#line 67
    if (idx <= 31U) {
#line 69
      goto ldv_30698;
    } else {

    }

#line 71
    return (-12);
  } else {

  }
#line 73
  return (0);
}
}
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.c"
static void pvr2_ioread_done(struct pvr2_ioread *cp ) 
{ 
  unsigned int idx ;

  {
#line 80
  pvr2_ioread_setup(cp, (struct pvr2_stream *)0);
#line 81
  idx = 0U;
#line 81
  goto ldv_30707;
  ldv_30706: ;
#line 82
  if ((unsigned long )cp->buffer_storage[idx] == (unsigned long )((char *)0)) {
#line 82
    goto ldv_30705;
  } else {

  }
#line 83
  kfree((void const   *)cp->buffer_storage[idx]);
  ldv_30705: 
#line 81
  idx = idx + 1U;
  ldv_30707: ;
#line 81
  if (idx <= 31U) {
#line 83
    goto ldv_30706;
  } else {

  }

#line 88
  return;
}
}
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.c"
struct pvr2_ioread *pvr2_ioread_create(void) 
{ 
  struct pvr2_ioread *cp ;
  void *tmp ;
  int tmp___0 ;

  {
#line 90
  tmp = kzalloc(488UL, 208U);
#line 90
  cp = (struct pvr2_ioread *)tmp;
#line 91
  if ((unsigned long )cp == (unsigned long )((struct pvr2_ioread *)0)) {
#line 91
    return ((struct pvr2_ioread *)0);
  } else {

  }
#line 92
  if ((pvrusb2_debug & 2048) != 0) {
#line 92
    printk("\016pvrusb2: pvr2_ioread_create id=%p\n", cp);
  } else {

  }
#line 93
  tmp___0 = pvr2_ioread_init(cp);
#line 93
  if (tmp___0 < 0) {
#line 94
    kfree((void const   *)cp);
#line 95
    return ((struct pvr2_ioread *)0);
  } else {

  }
#line 97
  return (cp);
}
}
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.c"
void pvr2_ioread_destroy(struct pvr2_ioread *cp ) 
{ 


  {
#line 102
  if ((unsigned long )cp == (unsigned long )((struct pvr2_ioread *)0)) {
#line 102
    return;
  } else {

  }
#line 103
  pvr2_ioread_done(cp);
#line 104
  if ((pvrusb2_debug & 2048) != 0) {
#line 104
    printk("\016pvrusb2: pvr2_ioread_destroy id=%p\n", cp);
  } else {

  }
#line 105
  if ((unsigned long )cp->sync_key_ptr != (unsigned long )((char *)0)) {
#line 106
    kfree((void const   *)cp->sync_key_ptr);
#line 107
    cp->sync_key_ptr = (char *)0;
  } else {

  }
#line 109
  kfree((void const   *)cp);
#line 110
  return;
}
}
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.c"
void pvr2_ioread_set_sync_key(struct pvr2_ioread *cp , char const   *sync_key_ptr ,
                              unsigned int sync_key_len ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 116
  if ((unsigned long )cp == (unsigned long )((struct pvr2_ioread *)0)) {
#line 116
    return;
  } else {

  }
#line 118
  if ((unsigned long )sync_key_ptr == (unsigned long )((char const   *)0)) {
#line 118
    sync_key_len = 0U;
  } else {

  }
#line 119
  if (cp->sync_key_len == sync_key_len) {
#line 119
    if (sync_key_len == 0U) {
#line 121
      return;
    } else {
#line 119
      tmp = memcmp((void const   *)sync_key_ptr, (void const   *)cp->sync_key_ptr,
                   (size_t )sync_key_len);
#line 119
      if (tmp == 0) {
#line 121
        return;
      } else {

      }
    }
  } else {

  }
#line 123
  if (cp->sync_key_len != sync_key_len) {
#line 124
    if ((unsigned long )cp->sync_key_ptr != (unsigned long )((char *)0)) {
#line 125
      kfree((void const   *)cp->sync_key_ptr);
#line 126
      cp->sync_key_ptr = (char *)0;
    } else {

    }
#line 128
    cp->sync_key_len = 0U;
#line 129
    if (sync_key_len != 0U) {
#line 130
      tmp___0 = kmalloc((size_t )sync_key_len, 208U);
#line 130
      cp->sync_key_ptr = (char *)tmp___0;
#line 131
      if ((unsigned long )cp->sync_key_ptr != (unsigned long )((char *)0)) {
#line 132
        cp->sync_key_len = sync_key_len;
      } else {

      }
    } else {

    }
  } else {

  }
#line 136
  if (cp->sync_key_len == 0U) {
#line 136
    return;
  } else {

  }
#line 137
  memcpy((void *)cp->sync_key_ptr, (void const   *)sync_key_ptr, (size_t )cp->sync_key_len);
#line 138
  return;
}
}
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.c"
static void pvr2_ioread_stop(struct pvr2_ioread *cp ) 
{ 


  {
#line 142
  if (cp->enabled == 0) {
#line 142
    return;
  } else {

  }
#line 143
  if ((pvrusb2_debug & 64) != 0) {
#line 143
    printk("\016pvrusb2: /*---TRACE_READ---*/ pvr2_ioread_stop id=%p\n", cp);
  } else {

  }
#line 145
  pvr2_stream_kill(cp->stream);
#line 146
  cp->c_buf = (struct pvr2_buffer *)0;
#line 147
  cp->c_data_ptr = (char *)0;
#line 148
  cp->c_data_len = 0U;
#line 149
  cp->c_data_offs = 0U;
#line 150
  cp->enabled = 0;
#line 151
  cp->stream_running = 0;
#line 152
  cp->spigot_open = 0;
#line 153
  if (cp->sync_state != 0U) {
#line 154
    if ((pvrusb2_debug & 33554432) != 0) {
#line 154
      printk("\016pvrusb2: /*---TRACE_READ---*/ sync_state <== 0\n");
    } else {

    }
#line 156
    cp->sync_state = 0U;
  } else {

  }
#line 158
  return;
}
}
#line 160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.c"
static int pvr2_ioread_start(struct pvr2_ioread *cp ) 
{ 
  int stat ;
  struct pvr2_buffer *bp ;

  {
#line 164
  if (cp->enabled != 0) {
#line 164
    return (0);
  } else {

  }
#line 165
  if ((unsigned long )cp->stream == (unsigned long )((struct pvr2_stream *)0)) {
#line 165
    return (0);
  } else {

  }
#line 166
  if ((pvrusb2_debug & 64) != 0) {
#line 166
    printk("\016pvrusb2: /*---TRACE_READ---*/ pvr2_ioread_start id=%p\n", cp);
  } else {

  }
#line 168
  goto ldv_30730;
  ldv_30729: 
#line 169
  stat = pvr2_buffer_queue(bp);
#line 170
  if (stat < 0) {
#line 171
    if ((pvrusb2_debug & 33554432) != 0) {
#line 171
      printk("\016pvrusb2: /*---TRACE_READ---*/ pvr2_ioread_start id=%p error=%d\n",
             cp, stat);
    } else {

    }
#line 176
    pvr2_ioread_stop(cp);
#line 177
    return (stat);
  } else {

  }
  ldv_30730: 
#line 168
  bp = pvr2_stream_get_idle_buffer(cp->stream);
#line 168
  if ((unsigned long )bp != (unsigned long )((struct pvr2_buffer *)0)) {
#line 170
    goto ldv_30729;
  } else {

  }
#line 180
  cp->enabled = 1;
#line 181
  cp->c_buf = (struct pvr2_buffer *)0;
#line 182
  cp->c_data_ptr = (char *)0;
#line 183
  cp->c_data_len = 0U;
#line 184
  cp->c_data_offs = 0U;
#line 185
  cp->stream_running = 0;
#line 186
  if (cp->sync_key_len != 0U) {
#line 187
    if ((pvrusb2_debug & 33554432) != 0) {
#line 187
      printk("\016pvrusb2: /*---TRACE_READ---*/ sync_state <== 1\n");
    } else {

    }
#line 189
    cp->sync_state = 1U;
#line 190
    cp->sync_trashed_count = 0U;
#line 191
    cp->sync_buf_offs = 0U;
  } else {

  }
#line 193
  cp->spigot_open = 0;
#line 194
  return (0);
}
}
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.c"
struct pvr2_stream *pvr2_ioread_get_stream(struct pvr2_ioread *cp ) 
{ 


  {
#line 199
  return (cp->stream);
}
}
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.c"
int pvr2_ioread_setup(struct pvr2_ioread *cp , struct pvr2_stream *sp ) 
{ 
  int ret ;
  unsigned int idx ;
  struct pvr2_buffer *bp ;
  int tmp ;

  {
#line 208
  ldv_mutex_lock_644(& cp->mutex);
#line 210
  if ((unsigned long )cp->stream != (unsigned long )((struct pvr2_stream *)0)) {
#line 211
    if ((pvrusb2_debug & 64) != 0) {
#line 211
      printk("\016pvrusb2: /*---TRACE_READ---*/ pvr2_ioread_setup (tear-down) id=%p\n",
             cp);
    } else {

    }
#line 214
    pvr2_ioread_stop(cp);
#line 215
    pvr2_stream_kill(cp->stream);
#line 216
    tmp = pvr2_stream_get_buffer_count(cp->stream);
#line 216
    if (tmp != 0) {
#line 217
      pvr2_stream_set_buffer_count(cp->stream, 0U);
    } else {

    }
#line 219
    cp->stream = (struct pvr2_stream *)0;
  } else {

  }
#line 221
  if ((unsigned long )sp != (unsigned long )((struct pvr2_stream *)0)) {
#line 222
    if ((pvrusb2_debug & 64) != 0) {
#line 222
      printk("\016pvrusb2: /*---TRACE_READ---*/ pvr2_ioread_setup (setup) id=%p\n",
             cp);
    } else {

    }
#line 225
    pvr2_stream_kill(sp);
#line 226
    ret = pvr2_stream_set_buffer_count(sp, 32U);
#line 227
    if (ret < 0) {
#line 228
      ldv_mutex_unlock_645(& cp->mutex);
#line 229
      return (ret);
    } else {

    }
#line 231
    idx = 0U;
#line 231
    goto ldv_30743;
    ldv_30742: 
#line 232
    bp = pvr2_stream_get_buffer(sp, (int )idx);
#line 233
    pvr2_buffer_set_buffer(bp, (void *)cp->buffer_storage[idx], 16384U);
#line 231
    idx = idx + 1U;
    ldv_30743: ;
#line 231
    if (idx <= 31U) {
#line 233
      goto ldv_30742;
    } else {

    }
#line 237
    cp->stream = sp;
  } else {

  }
#line 240
  ldv_mutex_unlock_646(& cp->mutex);
#line 242
  return (0);
}
}
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.c"
int pvr2_ioread_set_enabled(struct pvr2_ioread *cp , int fl ) 
{ 
  int ret ;

  {
#line 247
  ret = 0;
#line 248
  if ((fl != 0) ^ (cp->enabled == 0)) {
#line 248
    return (ret);
  } else {

  }
#line 250
  ldv_mutex_lock_647(& cp->mutex);
#line 252
  if (fl != 0) {
#line 253
    ret = pvr2_ioread_start(cp);
  } else {
#line 255
    pvr2_ioread_stop(cp);
  }
#line 258
  ldv_mutex_unlock_648(& cp->mutex);
#line 259
  return (ret);
}
}
#line 262 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.c"
static int pvr2_ioread_get_buffer(struct pvr2_ioread *cp ) 
{ 
  int stat ;
  int tmp ;

  {
#line 266
  goto ldv_30755;
  ldv_30756: ;
#line 267
  if ((unsigned long )cp->c_buf != (unsigned long )((struct pvr2_buffer *)0)) {
#line 269
    stat = pvr2_buffer_queue(cp->c_buf);
#line 270
    if (stat < 0) {
#line 272
      if ((pvrusb2_debug & 33554432) != 0) {
#line 272
        printk("\016pvrusb2: /*---TRACE_READ---*/ pvr2_ioread_read id=%p queue_error=%d\n",
               cp, stat);
      } else {

      }
#line 277
      pvr2_ioread_stop(cp);
#line 278
      return (0);
    } else {

    }
#line 280
    cp->c_buf = (struct pvr2_buffer *)0;
#line 281
    cp->c_data_ptr = (char *)0;
#line 282
    cp->c_data_len = 0U;
#line 283
    cp->c_data_offs = 0U;
  } else {

  }
#line 286
  cp->c_buf = pvr2_stream_get_ready_buffer(cp->stream);
#line 287
  if ((unsigned long )cp->c_buf == (unsigned long )((struct pvr2_buffer *)0)) {
#line 287
    goto ldv_30754;
  } else {

  }
#line 288
  cp->c_data_len = pvr2_buffer_get_count(cp->c_buf);
#line 289
  if (cp->c_data_len == 0U) {
#line 291
    stat = pvr2_buffer_get_status(cp->c_buf);
#line 292
    if (stat < 0) {
#line 294
      if ((pvrusb2_debug & 33554432) != 0) {
#line 294
        printk("\016pvrusb2: /*---TRACE_READ---*/ pvr2_ioread_read id=%p buffer_error=%d\n",
               cp, stat);
      } else {

      }
#line 299
      pvr2_ioread_stop(cp);
#line 301
      return (0);
    } else {

    }
#line 304
    goto ldv_30755;
  } else {

  }
#line 306
  cp->c_data_offs = 0U;
#line 307
  tmp = pvr2_buffer_get_id(cp->c_buf);
#line 307
  cp->c_data_ptr = cp->buffer_storage[tmp];
  ldv_30755: ;
#line 266
  if (cp->c_data_len <= cp->c_data_offs) {
#line 268
    goto ldv_30756;
  } else {

  }
  ldv_30754: ;
#line 310
  return (1);
}
}
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.c"
static void pvr2_ioread_filter(struct pvr2_ioread *cp ) 
{ 
  unsigned int idx ;
  int tmp ;

  {
#line 316
  if (cp->enabled == 0) {
#line 316
    return;
  } else {

  }
#line 317
  if (cp->sync_state != 1U) {
#line 317
    return;
  } else {

  }
#line 322
  ldv_mutex_lock_649(& cp->mutex);
  ldv_30766: 
#line 325
  tmp = pvr2_ioread_get_buffer(cp);
#line 325
  if (tmp == 0) {
#line 325
    goto ldv_30761;
  } else {

  }
#line 326
  if (cp->c_data_len == 0U) {
#line 326
    goto ldv_30761;
  } else {

  }
#line 330
  idx = cp->c_data_offs;
#line 330
  goto ldv_30764;
  ldv_30763: ;
#line 331
  if (cp->sync_buf_offs >= cp->sync_key_len) {
#line 331
    goto ldv_30762;
  } else {

  }
#line 332
  if ((int )((signed char )*(cp->c_data_ptr + (unsigned long )idx)) == (int )((signed char )*(cp->sync_key_ptr + (unsigned long )cp->sync_buf_offs))) {
#line 335
    cp->sync_buf_offs = cp->sync_buf_offs + 1U;
  } else {
#line 338
    cp->sync_buf_offs = 0U;
  }
#line 330
  idx = idx + 1U;
  ldv_30764: ;
#line 330
  if (cp->c_data_len > idx) {
#line 332
    goto ldv_30763;
  } else {

  }
  ldv_30762: 
#line 343
  cp->c_data_offs = cp->c_data_offs + idx;
#line 344
  cp->sync_trashed_count = cp->sync_trashed_count + idx;
#line 347
  if (cp->sync_buf_offs >= cp->sync_key_len) {
#line 348
    cp->sync_trashed_count = cp->sync_trashed_count - cp->sync_key_len;
#line 349
    if ((pvrusb2_debug & 33554432) != 0) {
#line 349
      printk("\016pvrusb2: /*---TRACE_READ---*/ sync_state <== 2 (skipped %u bytes)\n",
             cp->sync_trashed_count);
    } else {

    }
#line 353
    cp->sync_state = 2U;
#line 354
    cp->sync_buf_offs = 0U;
#line 355
    goto ldv_30761;
  } else {

  }
#line 358
  if (cp->c_data_offs < cp->c_data_len) {
#line 360
    if ((pvrusb2_debug & 2) != 0) {
#line 360
      printk("\016pvrusb2: OLD_ERROR: pvr2_ioread filter sync problem len=%u offs=%u\n",
             cp->c_data_len, cp->c_data_offs);
    } else {

    }
#line 366
    goto ldv_30761;
  } else {

  }
#line 369
  goto ldv_30765;
  ldv_30765: ;
#line 370
  goto ldv_30766;
  ldv_30761: 
#line 371
  ldv_mutex_unlock_650(& cp->mutex);
#line 372
  return;
}
}
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.c"
int pvr2_ioread_avail(struct pvr2_ioread *cp ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 377
  if (cp->enabled == 0) {
#line 379
    return (-5);
  } else {

  }
#line 382
  if (cp->sync_state == 1U) {
#line 383
    pvr2_ioread_filter(cp);
#line 384
    if (cp->sync_state == 1U) {
#line 384
      return (-11);
    } else {

    }
  } else {

  }
#line 387
  ret = 0;
#line 388
  if (cp->stream_running != 0) {
#line 389
    tmp = pvr2_stream_get_ready_count(cp->stream);
#line 389
    if (tmp == 0) {
#line 391
      ret = -11;
    } else {

    }
  } else {
#line 394
    tmp___0 = pvr2_stream_get_ready_count(cp->stream);
#line 394
    if (tmp___0 <= 15) {
#line 396
      ret = -11;
    } else {

    }
  }
#line 400
  if ((cp->spigot_open == 0) ^ (ret != 0)) {
#line 401
    cp->spigot_open = ret == 0;
#line 402
    if ((pvrusb2_debug & 33554432) != 0) {
#line 402
      printk("\016pvrusb2: /*---TRACE_READ---*/ data is %s\n", cp->spigot_open != 0 ? (char *)"available" : (char *)"pending");
    } else {

    }
  } else {

  }
#line 407
  return (ret);
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.c"
int pvr2_ioread_read(struct pvr2_ioread *cp , void *buf , unsigned int cnt ) 
{ 
  unsigned int copied_cnt ;
  unsigned int bcnt ;
  char const   *src ;
  int stat ;
  int ret ;
  unsigned int req_cnt ;
  int tmp ;
  unsigned long tmp___0 ;

  {
#line 416
  ret = 0;
#line 417
  req_cnt = cnt;
#line 419
  if (cnt == 0U) {
#line 420
    if ((pvrusb2_debug & 8) != 0) {
#line 420
      printk("\016pvrusb2: /*---TRACE_READ---*/ pvr2_ioread_read id=%p ZERO Request? Returning zero.\n",
             cp);
    } else {

    }
#line 423
    return (0);
  } else {

  }
#line 426
  stat = pvr2_ioread_avail(cp);
#line 427
  if (stat < 0) {
#line 427
    return (stat);
  } else {

  }
#line 429
  cp->stream_running = 1;
#line 431
  ldv_mutex_lock_651(& cp->mutex);
#line 435
  copied_cnt = 0U;
#line 436
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 436
    cnt = 0U;
  } else {

  }
  ldv_30783: 
#line 438
  tmp = pvr2_ioread_get_buffer(cp);
#line 438
  if (tmp == 0) {
#line 439
    ret = -5;
#line 440
    goto ldv_30782;
  } else {

  }
#line 443
  if (cnt == 0U) {
#line 443
    goto ldv_30782;
  } else {

  }
#line 445
  if (cp->sync_state == 2U) {
#line 448
    src = (char const   *)cp->sync_key_ptr + (unsigned long )cp->sync_buf_offs;
#line 449
    bcnt = cp->sync_key_len - cp->sync_buf_offs;
  } else {
#line 452
    src = (char const   *)cp->c_data_ptr + (unsigned long )cp->c_data_offs;
#line 453
    bcnt = cp->c_data_len - cp->c_data_offs;
  }
#line 456
  if (bcnt == 0U) {
#line 456
    goto ldv_30782;
  } else {

  }
#line 459
  if (bcnt > cnt) {
#line 459
    bcnt = cnt;
  } else {

  }
#line 461
  tmp___0 = copy_to_user(buf, (void const   *)src, (unsigned long )bcnt);
#line 461
  if (tmp___0 != 0UL) {
#line 465
    ret = -14;
#line 466
    goto ldv_30782;
  } else {

  }
#line 468
  cnt = cnt - bcnt;
#line 469
  buf = buf + (unsigned long )bcnt;
#line 470
  copied_cnt = copied_cnt + bcnt;
#line 472
  if (cp->sync_state == 2U) {
#line 475
    cp->sync_buf_offs = cp->sync_buf_offs + bcnt;
#line 476
    if (cp->sync_buf_offs >= cp->sync_key_len) {
#line 479
      if ((pvrusb2_debug & 33554432) != 0) {
#line 479
        printk("\016pvrusb2: /*---TRACE_READ---*/ sync_state <== 0\n");
      } else {

      }
#line 482
      cp->sync_state = 0U;
    } else {

    }
  } else {
#line 486
    cp->c_data_offs = cp->c_data_offs + bcnt;
  }
#line 488
  goto ldv_30783;
  ldv_30782: 
#line 491
  ldv_mutex_unlock_652(& cp->mutex);
#line 493
  if (ret == 0) {
#line 494
    if (copied_cnt != 0U) {
#line 496
      ret = (int )copied_cnt;
    } else {
#line 500
      ret = -11;
    }
  } else {

  }
#line 504
  if ((pvrusb2_debug & 33554432) != 0) {
#line 504
    printk("\016pvrusb2: /*---TRACE_READ---*/ pvr2_ioread_read id=%p request=%d result=%d\n",
           cp, req_cnt, ret);
  } else {

  }
#line 508
  return (ret);
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
bool ldv_queue_work_on_632(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 354
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 354
  ldv_func_res = tmp;
#line 356
  activate_work_1(ldv_func_arg3, 2);
#line 358
  return (ldv_func_res);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
bool ldv_queue_delayed_work_on_633(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 365
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 365
  ldv_func_res = tmp;
#line 367
  activate_work_1(& ldv_func_arg3->work, 2);
#line 369
  return (ldv_func_res);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
bool ldv_queue_work_on_634(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 376
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 376
  ldv_func_res = tmp;
#line 378
  activate_work_1(ldv_func_arg3, 2);
#line 380
  return (ldv_func_res);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void ldv_flush_workqueue_635(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 386
  flush_workqueue(ldv_func_arg1);
#line 388
  call_and_disable_all_1(2);
#line 389
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
bool ldv_queue_delayed_work_on_636(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 395
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 395
  ldv_func_res = tmp;
#line 397
  activate_work_1(& ldv_func_arg3->work, 2);
#line 399
  return (ldv_func_res);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void ldv_mutex_lock_637(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 405
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 407
  mutex_lock(ldv_func_arg1);
#line 408
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void ldv_mutex_unlock_638(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 413
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 415
  mutex_unlock(ldv_func_arg1);
#line 416
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void ldv_mutex_lock_639(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 421
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 423
  mutex_lock(ldv_func_arg1);
#line 424
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
int ldv_mutex_trylock_640(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 430
  tmp = mutex_trylock(ldv_func_arg1);
#line 430
  ldv_func_res = tmp;
#line 432
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 432
  return (tmp___0);
#line 434
  return (ldv_func_res);
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void ldv_mutex_unlock_641(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 440
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 442
  mutex_unlock(ldv_func_arg1);
#line 443
  return;
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void ldv_mutex_unlock_642(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 448
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 450
  mutex_unlock(ldv_func_arg1);
#line 451
  return;
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void ldv_mutex_lock_643(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 456
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 458
  mutex_lock(ldv_func_arg1);
#line 459
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void ldv_mutex_lock_644(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 464
  ldv_mutex_lock_mutex_of_pvr2_ioread(ldv_func_arg1);
#line 466
  mutex_lock(ldv_func_arg1);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void ldv_mutex_unlock_645(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 472
  ldv_mutex_unlock_mutex_of_pvr2_ioread(ldv_func_arg1);
#line 474
  mutex_unlock(ldv_func_arg1);
#line 475
  return;
}
}
#line 477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void ldv_mutex_unlock_646(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 480
  ldv_mutex_unlock_mutex_of_pvr2_ioread(ldv_func_arg1);
#line 482
  mutex_unlock(ldv_func_arg1);
#line 483
  return;
}
}
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void ldv_mutex_lock_647(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 488
  ldv_mutex_lock_mutex_of_pvr2_ioread(ldv_func_arg1);
#line 490
  mutex_lock(ldv_func_arg1);
#line 491
  return;
}
}
#line 493 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void ldv_mutex_unlock_648(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 496
  ldv_mutex_unlock_mutex_of_pvr2_ioread(ldv_func_arg1);
#line 498
  mutex_unlock(ldv_func_arg1);
#line 499
  return;
}
}
#line 501 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void ldv_mutex_lock_649(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 504
  ldv_mutex_lock_mutex_of_pvr2_ioread(ldv_func_arg1);
#line 506
  mutex_lock(ldv_func_arg1);
#line 507
  return;
}
}
#line 509 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void ldv_mutex_unlock_650(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 512
  ldv_mutex_unlock_mutex_of_pvr2_ioread(ldv_func_arg1);
#line 514
  mutex_unlock(ldv_func_arg1);
#line 515
  return;
}
}
#line 517 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void ldv_mutex_lock_651(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 520
  ldv_mutex_lock_mutex_of_pvr2_ioread(ldv_func_arg1);
#line 522
  mutex_lock(ldv_func_arg1);
#line 523
  return;
}
}
#line 525 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-ioread.o.c.prepared"
void ldv_mutex_unlock_652(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 528
  ldv_mutex_unlock_mutex_of_pvr2_ioread(ldv_func_arg1);
#line 530
  mutex_unlock(ldv_func_arg1);
#line 531
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_686(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_684(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_687(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_688(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_691(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
void ldv_mutex_lock_683(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_685(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_689(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_690(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_678(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_680(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_679(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_682(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_681(struct workqueue_struct *ldv_func_arg1 ) ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.c"
static struct routing_scheme_item  const  routing_scheme0___1[5U]  = {      {7, 8}, 
        {0, 0}, 
        {3, 0}, 
        {1296, 0}, 
        {3, 0}};
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.c"
static struct routing_scheme___0  const  routing_def0___1  =    {(struct routing_scheme_item  const  *)(& routing_scheme0___1), 5U};
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.c"
static struct routing_scheme_item  const  routing_schemegv[5U]  = {      {2, 5}, 
        {0, 0}, 
        {1, 0}, 
        {1072, 0}, 
        {1, 0}};
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.c"
static struct routing_scheme___0  const  routing_defgv  =    {(struct routing_scheme_item  const  *)(& routing_schemegv), 5U};
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.c"
static struct routing_scheme_item  const  routing_schemeav400[4U]  = {      {0, 0}, 
        {0, 0}, 
        {1, 0}, 
        {1056, 0}};
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.c"
static struct routing_scheme___0  const  routing_defav400  =    {(struct routing_scheme_item  const  *)(& routing_schemeav400), 4U};
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.c"
static struct routing_scheme___0  const  *routing_schemes___1[4U]  = {      & routing_def0___1,      & routing_defgv,      0,      & routing_defav400};
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.c"
void pvr2_cx25840_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) 
{ 
  enum cx25840_video_input vid_input ;
  enum cx25840_audio_input aud_input ;
  struct routing_scheme___0  const  *sp ;
  unsigned int sid ;

  {
#line 127
  if ((pvrusb2_debug & 65536) != 0) {
#line 127
    printk("\016pvrusb2: subdev cx2584x update...\n");
  } else {

  }
#line 128
  if (hdw->input_dirty != 0 || hdw->force_dirty != 0) {
#line 132
    sid = (unsigned int )(hdw->hdw_desc)->signal_routing_scheme;
#line 134
    sp = sid <= 3U ? routing_schemes___1[sid] : (struct routing_scheme___0  const  *)0;
#line 136
    if (((unsigned long )sp == (unsigned long )((struct routing_scheme___0  const  *)0) || hdw->input_val < 0) || (unsigned int )hdw->input_val >= (unsigned int )sp->cnt) {
#line 139
      if ((pvrusb2_debug & 2) != 0) {
#line 139
        printk("\016pvrusb2: *** WARNING *** subdev cx2584x set_input: Invalid routing scheme (%u) and/or input (%d)\n",
               sid, hdw->input_val);
      } else {

      }
#line 144
      return;
    } else {

    }
#line 146
    vid_input = (enum cx25840_video_input )(sp->def + (unsigned long )hdw->input_val)->vid;
#line 147
    aud_input = (enum cx25840_audio_input )(sp->def + (unsigned long )hdw->input_val)->aud;
#line 148
    if ((pvrusb2_debug & 65536) != 0) {
#line 148
      printk("\016pvrusb2: subdev cx2584x set_input vid=0x%x aud=0x%x\n", (unsigned int )vid_input,
             (unsigned int )aud_input);
    } else {

    }
#line 151
    (*(((sd->ops)->video)->s_routing))(sd, (unsigned int )vid_input, 0U, 0U);
#line 152
    (*(((sd->ops)->audio)->s_routing))(sd, (unsigned int )aud_input, 0U, 0U);
  } else {

  }
#line 154
  return;
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
bool ldv_queue_work_on_678(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 354
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 354
  ldv_func_res = tmp;
#line 356
  activate_work_1(ldv_func_arg3, 2);
#line 358
  return (ldv_func_res);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
bool ldv_queue_delayed_work_on_679(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 365
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 365
  ldv_func_res = tmp;
#line 367
  activate_work_1(& ldv_func_arg3->work, 2);
#line 369
  return (ldv_func_res);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
bool ldv_queue_work_on_680(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 376
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 376
  ldv_func_res = tmp;
#line 378
  activate_work_1(ldv_func_arg3, 2);
#line 380
  return (ldv_func_res);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
void ldv_flush_workqueue_681(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 386
  flush_workqueue(ldv_func_arg1);
#line 388
  call_and_disable_all_1(2);
#line 389
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
bool ldv_queue_delayed_work_on_682(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 395
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 395
  ldv_func_res = tmp;
#line 397
  activate_work_1(& ldv_func_arg3->work, 2);
#line 399
  return (ldv_func_res);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
void ldv_mutex_lock_683(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 405
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 407
  mutex_lock(ldv_func_arg1);
#line 408
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
void ldv_mutex_unlock_684(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 413
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 415
  mutex_unlock(ldv_func_arg1);
#line 416
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
void ldv_mutex_lock_685(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 421
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 423
  mutex_lock(ldv_func_arg1);
#line 424
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
int ldv_mutex_trylock_686(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 430
  tmp = mutex_trylock(ldv_func_arg1);
#line 430
  ldv_func_res = tmp;
#line 432
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 432
  return (tmp___0);
#line 434
  return (ldv_func_res);
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
void ldv_mutex_unlock_687(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 440
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 442
  mutex_unlock(ldv_func_arg1);
#line 443
  return;
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
void ldv_mutex_unlock_688(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 448
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 450
  mutex_unlock(ldv_func_arg1);
#line 451
  return;
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
void ldv_mutex_lock_689(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 456
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 458
  mutex_lock(ldv_func_arg1);
#line 459
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
void ldv_mutex_lock_690(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 464
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 466
  mutex_lock(ldv_func_arg1);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cx2584x-v4l.o.c.prepared"
void ldv_mutex_unlock_691(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 472
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 474
  mutex_unlock(ldv_func_arg1);
#line 475
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_718(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_716(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_719(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_720(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_723(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
void ldv_mutex_lock_715(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_717(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_721(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_722(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_710(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_712(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_711(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_714(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_713(struct workqueue_struct *ldv_func_arg1 ) ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.c"
void pvr2_wm8775_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) 
{ 
  u32 input ;

  {
#line 40
  if (hdw->input_dirty != 0 || hdw->force_dirty != 0) {
#line 43
    switch (hdw->input_val) {
    case 4: 
#line 45
    input = 1U;
#line 46
    goto ldv_51786;
    default: 
#line 49
    input = 2U;
#line 50
    goto ldv_51786;
    }
    ldv_51786: ;
#line 52
    if ((pvrusb2_debug & 65536) != 0) {
#line 52
      printk("\016pvrusb2: subdev wm8775 set_input(val=%d route=0x%x)\n", hdw->input_val,
             input);
    } else {

    }
#line 56
    (*(((sd->ops)->audio)->s_routing))(sd, input, 0U, 0U);
  } else {

  }
#line 58
  return;
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
bool ldv_queue_work_on_710(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 354
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 354
  ldv_func_res = tmp;
#line 356
  activate_work_1(ldv_func_arg3, 2);
#line 358
  return (ldv_func_res);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
bool ldv_queue_delayed_work_on_711(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 365
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 365
  ldv_func_res = tmp;
#line 367
  activate_work_1(& ldv_func_arg3->work, 2);
#line 369
  return (ldv_func_res);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
bool ldv_queue_work_on_712(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 376
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 376
  ldv_func_res = tmp;
#line 378
  activate_work_1(ldv_func_arg3, 2);
#line 380
  return (ldv_func_res);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
void ldv_flush_workqueue_713(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 386
  flush_workqueue(ldv_func_arg1);
#line 388
  call_and_disable_all_1(2);
#line 389
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
bool ldv_queue_delayed_work_on_714(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 395
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 395
  ldv_func_res = tmp;
#line 397
  activate_work_1(& ldv_func_arg3->work, 2);
#line 399
  return (ldv_func_res);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
void ldv_mutex_lock_715(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 405
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 407
  mutex_lock(ldv_func_arg1);
#line 408
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
void ldv_mutex_unlock_716(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 413
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 415
  mutex_unlock(ldv_func_arg1);
#line 416
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
void ldv_mutex_lock_717(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 421
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 423
  mutex_lock(ldv_func_arg1);
#line 424
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
int ldv_mutex_trylock_718(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 430
  tmp = mutex_trylock(ldv_func_arg1);
#line 430
  ldv_func_res = tmp;
#line 432
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 432
  return (tmp___0);
#line 434
  return (ldv_func_res);
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
void ldv_mutex_unlock_719(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 440
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 442
  mutex_unlock(ldv_func_arg1);
#line 443
  return;
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
void ldv_mutex_unlock_720(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 448
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 450
  mutex_unlock(ldv_func_arg1);
#line 451
  return;
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
void ldv_mutex_lock_721(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 456
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 458
  mutex_lock(ldv_func_arg1);
#line 459
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
void ldv_mutex_lock_722(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 464
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 466
  mutex_lock(ldv_func_arg1);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-wm8775.o.c.prepared"
void ldv_mutex_unlock_723(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 472
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 474
  mutex_unlock(ldv_func_arg1);
#line 475
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_750(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_748(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_751(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_752(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_755(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
void ldv_mutex_lock_747(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_749(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_753(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_754(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_742(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_744(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_743(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_746(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_745(struct workqueue_struct *ldv_func_arg1 ) ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.c"
static int const   routing_scheme1___0[5U]  = {      2,      0,      0,      0, 
        2};
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.c"
static struct routing_scheme  const  routing_def1___0  =    {(int const   *)(& routing_scheme1___0), 5U};
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.c"
static struct routing_scheme  const  *routing_schemes___2[3U]  = {      0,      0,      & routing_def1___0};
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.c"
void pvr2_cs53l32a_subdev_update(struct pvr2_hdw *hdw , struct v4l2_subdev *sd ) 
{ 
  struct routing_scheme  const  *sp ;
  unsigned int sid ;
  u32 input ;

  {
#line 63
  if (hdw->input_dirty != 0 || hdw->force_dirty != 0) {
#line 65
    sid = (unsigned int )(hdw->hdw_desc)->signal_routing_scheme;
#line 67
    if ((pvrusb2_debug & 65536) != 0) {
#line 67
      printk("\016pvrusb2: subdev v4l2 set_input(%d)\n", hdw->input_val);
    } else {

    }
#line 69
    sp = sid <= 2U ? routing_schemes___2[sid] : (struct routing_scheme  const  *)0;
#line 71
    if (((unsigned long )sp == (unsigned long )((struct routing_scheme  const  *)0) || hdw->input_val < 0) || (unsigned int )hdw->input_val >= (unsigned int )sp->cnt) {
#line 74
      if ((pvrusb2_debug & 2) != 0) {
#line 74
        printk("\016pvrusb2: *** WARNING *** subdev v4l2 set_input: Invalid routing scheme (%u) and/or input (%d)\n",
               sid, hdw->input_val);
      } else {

      }
#line 79
      return;
    } else {

    }
#line 81
    input = (u32 )*(sp->def + (unsigned long )hdw->input_val);
#line 82
    (*(((sd->ops)->audio)->s_routing))(sd, input, 0U, 0U);
  } else {

  }
#line 84
  return;
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
bool ldv_queue_work_on_742(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 354
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 354
  ldv_func_res = tmp;
#line 356
  activate_work_1(ldv_func_arg3, 2);
#line 358
  return (ldv_func_res);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
bool ldv_queue_delayed_work_on_743(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 365
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 365
  ldv_func_res = tmp;
#line 367
  activate_work_1(& ldv_func_arg3->work, 2);
#line 369
  return (ldv_func_res);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
bool ldv_queue_work_on_744(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 376
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 376
  ldv_func_res = tmp;
#line 378
  activate_work_1(ldv_func_arg3, 2);
#line 380
  return (ldv_func_res);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
void ldv_flush_workqueue_745(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 386
  flush_workqueue(ldv_func_arg1);
#line 388
  call_and_disable_all_1(2);
#line 389
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
bool ldv_queue_delayed_work_on_746(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 395
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 395
  ldv_func_res = tmp;
#line 397
  activate_work_1(& ldv_func_arg3->work, 2);
#line 399
  return (ldv_func_res);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
void ldv_mutex_lock_747(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 405
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 407
  mutex_lock(ldv_func_arg1);
#line 408
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
void ldv_mutex_unlock_748(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 413
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 415
  mutex_unlock(ldv_func_arg1);
#line 416
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
void ldv_mutex_lock_749(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 421
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 423
  mutex_lock(ldv_func_arg1);
#line 424
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
int ldv_mutex_trylock_750(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 430
  tmp = mutex_trylock(ldv_func_arg1);
#line 430
  ldv_func_res = tmp;
#line 432
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 432
  return (tmp___0);
#line 434
  return (ldv_func_res);
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
void ldv_mutex_unlock_751(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 440
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 442
  mutex_unlock(ldv_func_arg1);
#line 443
  return;
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
void ldv_mutex_unlock_752(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 448
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 450
  mutex_unlock(ldv_func_arg1);
#line 451
  return;
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
void ldv_mutex_lock_753(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 456
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 458
  mutex_lock(ldv_func_arg1);
#line 459
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
void ldv_mutex_lock_754(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 464
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 466
  mutex_lock(ldv_func_arg1);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-cs53l32a.o.c.prepared"
void ldv_mutex_unlock_755(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 472
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 474
  mutex_unlock(ldv_func_arg1);
#line 475
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
long ldv_ptr_err(void const   *ptr ) ;
#line 87 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "./arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_2696: ;
#line 14
  return (pfo_ret__);
}
}
#line 32 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 11 "./arch/x86/include/asm/cmpxchg.h"
extern void __xchg_wrong_size(void) ;
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 54 "include/linux/debug_locks.h"
extern void debug_check_no_locks_held(void) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_784(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_779(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_782(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_785(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_787(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_789(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
void ldv_mutex_lock_780(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_781(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_783(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_786(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_788(struct mutex *ldv_func_arg1 ) ;
#line 94
void ldv_mutex_lock_lock_of_pvr2_dvb_adapter(struct mutex *lock ) ;
#line 98
void ldv_mutex_unlock_lock_of_pvr2_dvb_adapter(struct mutex *lock ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_774(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_776(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_775(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_778(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_777(struct workqueue_struct *ldv_func_arg1 ) ;
#line 12 "include/linux/freezer.h"
extern atomic_t system_freezing_cnt ;
#line 29
extern bool freezing_slow_path(struct task_struct * ) ;
#line 34 "include/linux/freezer.h"
__inline static bool freezing(struct task_struct *p ) 
{ 
  int tmp ;
  long tmp___0 ;
  bool tmp___1 ;

  {
#line 36
  tmp = atomic_read((atomic_t const   *)(& system_freezing_cnt));
#line 36
  tmp___0 = ldv__builtin_expect(tmp == 0, 1L);
#line 36
  if (tmp___0 != 0L) {
#line 37
    return (0);
  } else {

  }
#line 38
  tmp___1 = freezing_slow_path(p);
#line 38
  return (tmp___1);
}
}
#line 44
extern bool __refrigerator(bool  ) ;
#line 54 "include/linux/freezer.h"
__inline static bool try_to_freeze_unsafe(void) 
{ 
  struct task_struct *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;

  {
#line 56
  __might_sleep("include/linux/freezer.h", 56, 0);
#line 57
  tmp = get_current();
#line 57
  tmp___0 = freezing(tmp);
#line 57
  if (tmp___0) {
#line 57
    tmp___1 = 0;
  } else {
#line 57
    tmp___1 = 1;
  }
#line 57
  tmp___2 = ldv__builtin_expect((long )tmp___1, 1L);
#line 57
  if (tmp___2 != 0L) {
#line 58
    return (0);
  } else {

  }
#line 59
  tmp___3 = __refrigerator(0);
#line 59
  return (tmp___3);
}
}
#line 62 "include/linux/freezer.h"
__inline static bool try_to_freeze(void) 
{ 
  struct task_struct *tmp ;
  bool tmp___0 ;

  {
#line 64
  tmp = get_current();
#line 64
  if ((tmp->flags & 32768U) == 0U) {
#line 65
    debug_check_no_locks_held();
  } else {

  }
#line 66
  tmp___0 = try_to_freeze_unsafe();
#line 66
  return (tmp___0);
}
}
#line 70
extern bool set_freezable(void) ;
#line 113 "drivers/media/dvb-core/dvbdev.h"
extern int dvb_register_adapter(struct dvb_adapter * , char const   * , struct module * ,
                                struct device * , short * ) ;
#line 116
extern int dvb_unregister_adapter(struct dvb_adapter * ) ;
#line 433 "drivers/media/dvb-core/dvb_frontend.h"
extern int dvb_register_frontend(struct dvb_adapter * , struct dvb_frontend * ) ;
#line 436
extern int dvb_unregister_frontend(struct dvb_frontend * ) ;
#line 438
extern void dvb_frontend_detach(struct dvb_frontend * ) ;
#line 141 "drivers/media/dvb-core/dvb_demux.h"
extern int dvb_dmx_init(struct dvb_demux * ) ;
#line 142
extern void dvb_dmx_release(struct dvb_demux * ) ;
#line 145
extern void dvb_dmx_swfilter(struct dvb_demux * , u8 const   * , size_t  ) ;
#line 46 "drivers/media/dvb-core/dvb_net.h"
extern void dvb_net_release(struct dvb_net * ) ;
#line 47
extern int dvb_net_init(struct dvb_adapter * , struct dvb_net * , struct dmx_demux * ) ;
#line 116 "drivers/media/dvb-core/dmxdev.h"
extern int dvb_dmxdev_init(struct dmxdev * , struct dvb_adapter * ) ;
#line 117
extern void dvb_dmxdev_release(struct dmxdev * ) ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
static short adapter_nr[8U]  = 
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
static int pvr2_dvb_feed_func(struct pvr2_dvb_adapter *adap ) 
{ 
  int ret ;
  unsigned int count ;
  struct pvr2_buffer *bp ;
  struct pvr2_stream *stream ;
  bool tmp ;
  int tmp___0 ;
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;

  {
#line 41
  if ((pvrusb2_debug & 268435456) != 0) {
#line 41
    printk("\016pvrusb2: dvb feed thread started\n");
  } else {

  }
#line 42
  set_freezable();
#line 44
  stream = (adap->channel.stream)->stream;
  ldv_51902: 
#line 47
  tmp = kthread_should_stop();
#line 47
  if ((int )tmp) {
#line 47
    goto ldv_51891;
  } else {

  }
#line 50
  try_to_freeze();
#line 52
  bp = pvr2_stream_get_ready_buffer(stream);
#line 53
  if ((unsigned long )bp != (unsigned long )((struct pvr2_buffer *)0)) {
#line 54
    count = pvr2_buffer_get_count(bp);
#line 55
    if (count != 0U) {
#line 56
      tmp___0 = pvr2_buffer_get_id(bp);
#line 56
      dvb_dmx_swfilter(& adap->demux, (u8 const   *)adap->buffer_storage[tmp___0],
                       (size_t )count);
    } else {
#line 62
      ret = pvr2_buffer_get_status(bp);
#line 63
      if (ret < 0) {
#line 63
        goto ldv_51891;
      } else {

      }
    }
#line 65
    ret = pvr2_buffer_queue(bp);
#line 66
    if (ret < 0) {
#line 66
      goto ldv_51891;
    } else {

    }
#line 72
    goto ldv_51892;
  } else {

  }
#line 78
  __ret = 0;
#line 78
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c",
                81, 0);
#line 78
  tmp___4 = pvr2_stream_get_ready_count(stream);
#line 78
  if (tmp___4 <= 0) {
#line 78
    tmp___5 = kthread_should_stop();
#line 78
    if (tmp___5) {
#line 78
      tmp___6 = 0;
    } else {
#line 78
      tmp___6 = 1;
    }
#line 78
    if (tmp___6) {
#line 78
      __ret___0 = 0L;
#line 78
      INIT_LIST_HEAD(& __wait.task_list);
#line 78
      __wait.flags = 0U;
      ldv_51899: 
#line 78
      tmp___1 = prepare_to_wait_event(& adap->buffer_wait_data, & __wait, 1);
#line 78
      __int = tmp___1;
#line 78
      tmp___2 = pvr2_stream_get_ready_count(stream);
#line 78
      if (tmp___2 > 0) {
#line 78
        goto ldv_51898;
      } else {
#line 78
        tmp___3 = kthread_should_stop();
#line 78
        if ((int )tmp___3) {
#line 78
          goto ldv_51898;
        } else {

        }
      }
#line 78
      if (__int != 0L) {
#line 78
        __ret___0 = __int;
#line 78
        goto ldv_51898;
      } else {

      }
#line 78
      schedule();
#line 78
      goto ldv_51899;
      ldv_51898: 
#line 78
      finish_wait(& adap->buffer_wait_data, & __wait);
#line 78
      __ret = (int )__ret___0;
    } else {

    }
  } else {

  }
#line 78
  ret = __ret;
#line 82
  if (ret < 0) {
#line 82
    goto ldv_51891;
  } else {

  }
  ldv_51892: ;
#line 83
  goto ldv_51902;
  ldv_51891: ;
#line 88
  if ((pvrusb2_debug & 268435456) != 0) {
#line 88
    printk("\016pvrusb2: dvb feed thread stopped\n");
  } else {

  }
#line 90
  return (0);
}
}
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
static int pvr2_dvb_feed_thread(void *data ) 
{ 
  int stat ;
  int tmp ;
  struct task_struct *tmp___0 ;
  long volatile   __ret ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;

  {
#line 95
  tmp = pvr2_dvb_feed_func((struct pvr2_dvb_adapter *)data);
#line 95
  stat = tmp;
#line 97
  goto ldv_51916;
  ldv_51915: 
#line 98
  tmp___0 = get_current();
#line 98
  tmp___0->task_state_change = 0UL;
#line 98
  __ret = 1L;
#line 98
  switch (8UL) {
  case 1UL: 
#line 98
  tmp___1 = get_current();
#line 98
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
#line 98
  goto ldv_51909;
  case 2UL: 
#line 98
  tmp___2 = get_current();
#line 98
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
#line 98
  goto ldv_51909;
  case 4UL: 
#line 98
  tmp___3 = get_current();
#line 98
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
#line 98
  goto ldv_51909;
  case 8UL: 
#line 98
  tmp___4 = get_current();
#line 98
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                       "cc");
#line 98
  goto ldv_51909;
  default: 
#line 98
  __xchg_wrong_size();
  }
  ldv_51909: 
#line 99
  schedule();
  ldv_51916: 
#line 97
  tmp___5 = kthread_should_stop();
#line 97
  if (tmp___5) {
#line 97
    tmp___6 = 0;
  } else {
#line 97
    tmp___6 = 1;
  }
#line 97
  if (tmp___6) {
#line 99
    goto ldv_51915;
  } else {

  }

#line 101
  return (stat);
}
}
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
static void pvr2_dvb_notify(struct pvr2_dvb_adapter *adap ) 
{ 


  {
#line 106
  __wake_up(& adap->buffer_wait_data, 3U, 1, (void *)0);
#line 107
  return;
}
}
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
static void pvr2_dvb_stream_end(struct pvr2_dvb_adapter *adap ) 
{ 
  unsigned int idx ;
  struct pvr2_stream *stream ;

  {
#line 114
  if ((unsigned long )adap->thread != (unsigned long )((struct task_struct *)0)) {
#line 115
    kthread_stop(adap->thread);
#line 116
    adap->thread = (struct task_struct *)0;
  } else {

  }
#line 119
  if ((unsigned long )adap->channel.stream != (unsigned long )((struct pvr2_context_stream *)0)) {
#line 120
    stream = (adap->channel.stream)->stream;
  } else {
#line 122
    stream = (struct pvr2_stream *)0;
  }
#line 124
  if ((unsigned long )stream != (unsigned long )((struct pvr2_stream *)0)) {
#line 125
    pvr2_hdw_set_streaming(adap->channel.hdw, 0);
#line 126
    pvr2_stream_set_callback(stream, (void (*)(void * ))0, (void *)0);
#line 127
    pvr2_stream_kill(stream);
#line 128
    pvr2_stream_set_buffer_count(stream, 0U);
#line 129
    pvr2_channel_claim_stream(& adap->channel, (struct pvr2_context_stream *)0);
  } else {

  }
#line 132
  if ((unsigned int )*((unsigned char *)adap + 2232UL) != 0U) {
#line 133
    idx = 0U;
#line 133
    goto ldv_51928;
    ldv_51927: ;
#line 134
    if ((unsigned long )adap->buffer_storage[idx] == (unsigned long )((char *)0)) {
#line 134
      goto ldv_51926;
    } else {

    }
#line 135
    kfree((void const   *)adap->buffer_storage[idx]);
#line 136
    adap->buffer_storage[idx] = (char *)0;
    ldv_51926: 
#line 133
    idx = idx + 1U;
    ldv_51928: ;
#line 133
    if (idx <= 31U) {
#line 135
      goto ldv_51927;
    } else {

    }
#line 138
    adap->stream_run = 0U;
  } else {

  }
#line 140
  return;
}
}
#line 142 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
static int pvr2_dvb_stream_do_start(struct pvr2_dvb_adapter *adap ) 
{ 
  struct pvr2_context *pvr ;
  unsigned int idx ;
  int ret ;
  struct pvr2_buffer *bp ;
  struct pvr2_stream *stream ;
  void *tmp ;
  struct task_struct *__k ;
  struct task_struct *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  bool tmp___4 ;

  {
#line 144
  pvr = adap->channel.mc_head;
#line 148
  stream = (struct pvr2_stream *)0;
#line 150
  if ((unsigned int )*((unsigned char *)adap + 2232UL) != 0U) {
#line 150
    return (-5);
  } else {

  }
#line 152
  ret = pvr2_channel_claim_stream(& adap->channel, & pvr->video_stream);
#line 154
  if (ret < 0) {
#line 154
    return (ret);
  } else {

  }
#line 156
  stream = (adap->channel.stream)->stream;
#line 158
  idx = 0U;
#line 158
  goto ldv_51939;
  ldv_51938: 
#line 159
  tmp = kmalloc(16384UL, 208U);
#line 159
  adap->buffer_storage[idx] = (char *)tmp;
#line 161
  if ((unsigned long )adap->buffer_storage[idx] == (unsigned long )((char *)0)) {
#line 161
    return (-12);
  } else {

  }
#line 158
  idx = idx + 1U;
  ldv_51939: ;
#line 158
  if (idx <= 31U) {
#line 160
    goto ldv_51938;
  } else {

  }
#line 164
  pvr2_stream_set_callback(pvr->video_stream.stream, (void (*)(void * ))(& pvr2_dvb_notify),
                           (void *)adap);
#line 167
  ret = pvr2_stream_set_buffer_count(stream, 32U);
#line 168
  if (ret < 0) {
#line 168
    return (ret);
  } else {

  }
#line 170
  idx = 0U;
#line 170
  goto ldv_51942;
  ldv_51941: 
#line 171
  bp = pvr2_stream_get_buffer(stream, (int )idx);
#line 172
  pvr2_buffer_set_buffer(bp, (void *)adap->buffer_storage[idx], 16384U);
#line 170
  idx = idx + 1U;
  ldv_51942: ;
#line 170
  if (idx <= 31U) {
#line 172
    goto ldv_51941;
  } else {

  }
#line 177
  ret = pvr2_hdw_set_streaming(adap->channel.hdw, 1);
#line 178
  if (ret < 0) {
#line 178
    return (ret);
  } else {

  }
#line 180
  goto ldv_51945;
  ldv_51944: 
#line 181
  ret = pvr2_buffer_queue(bp);
#line 182
  if (ret < 0) {
#line 182
    return (ret);
  } else {

  }
  ldv_51945: 
#line 180
  bp = pvr2_stream_get_idle_buffer(stream);
#line 180
  if ((unsigned long )bp != (unsigned long )((struct pvr2_buffer *)0)) {
#line 182
    goto ldv_51944;
  } else {

  }
#line 185
  tmp___0 = kthread_create_on_node(& pvr2_dvb_feed_thread, (void *)adap, -1, "pvrusb2-dvb");
#line 185
  __k = tmp___0;
#line 185
  tmp___1 = IS_ERR((void const   *)__k);
#line 185
  if (tmp___1) {
#line 185
    tmp___2 = 0;
  } else {
#line 185
    tmp___2 = 1;
  }
#line 185
  if (tmp___2) {
#line 185
    wake_up_process(__k);
  } else {

  }
#line 185
  adap->thread = __k;
#line 187
  tmp___4 = IS_ERR((void const   *)adap->thread);
#line 187
  if ((int )tmp___4) {
#line 188
    tmp___3 = PTR_ERR((void const   *)adap->thread);
#line 188
    ret = (int )tmp___3;
#line 189
    adap->thread = (struct task_struct *)0;
#line 190
    return (ret);
  } else {

  }
#line 193
  adap->stream_run = 1U;
#line 195
  return (0);
}
}
#line 198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
static int pvr2_dvb_stream_start(struct pvr2_dvb_adapter *adap ) 
{ 
  int ret ;
  int tmp ;

  {
#line 200
  tmp = pvr2_dvb_stream_do_start(adap);
#line 200
  ret = tmp;
#line 201
  if (ret < 0) {
#line 201
    pvr2_dvb_stream_end(adap);
  } else {

  }
#line 202
  return (ret);
}
}
#line 205 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
static int pvr2_dvb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed , int onoff ) 
{ 
  struct pvr2_dvb_adapter *adap ;
  int ret ;

  {
#line 207
  adap = (struct pvr2_dvb_adapter *)(dvbdmxfeed->demux)->priv;
#line 208
  ret = 0;
#line 210
  if ((unsigned long )adap == (unsigned long )((struct pvr2_dvb_adapter *)0)) {
#line 210
    return (-19);
  } else {

  }
#line 212
  ldv_mutex_lock_788(& adap->lock);
#line 214
  if (onoff != 0) {
#line 215
    if (adap->feedcount == 0) {
#line 216
      if ((pvrusb2_debug & 268435456) != 0) {
#line 216
        printk("\016pvrusb2: start feeding demux\n");
      } else {

      }
#line 218
      ret = pvr2_dvb_stream_start(adap);
#line 219
      if (ret < 0) {
#line 219
        goto ldv_51959;
      } else {

      }
    } else {

    }
#line 221
    adap->feedcount = adap->feedcount + 1;
  } else
#line 222
  if (adap->feedcount > 0) {
#line 223
    adap->feedcount = adap->feedcount - 1;
#line 224
    if (adap->feedcount == 0) {
#line 225
      if ((pvrusb2_debug & 268435456) != 0) {
#line 225
        printk("\016pvrusb2: stop feeding demux\n");
      } else {

      }
#line 227
      pvr2_dvb_stream_end(adap);
    } else {

    }
  } else {

  }
  ldv_51959: 
#line 231
  ldv_mutex_unlock_789(& adap->lock);
#line 233
  return (ret);
}
}
#line 236 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
static int pvr2_dvb_start_feed(struct dvb_demux_feed *dvbdmxfeed ) 
{ 
  int tmp ;

  {
#line 238
  if ((pvrusb2_debug & 268435456) != 0) {
#line 238
    printk("\016pvrusb2: start pid: 0x%04x\n", (int )dvbdmxfeed->pid);
  } else {

  }
#line 239
  tmp = pvr2_dvb_ctrl_feed(dvbdmxfeed, 1);
#line 239
  return (tmp);
}
}
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
static int pvr2_dvb_stop_feed(struct dvb_demux_feed *dvbdmxfeed ) 
{ 
  int tmp ;

  {
#line 244
  if ((pvrusb2_debug & 268435456) != 0) {
#line 244
    printk("\016pvrusb2: stop pid: 0x%04x\n", (int )dvbdmxfeed->pid);
  } else {

  }
#line 245
  tmp = pvr2_dvb_ctrl_feed(dvbdmxfeed, 0);
#line 245
  return (tmp);
}
}
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
static int pvr2_dvb_bus_ctrl(struct dvb_frontend *fe , int acquire ) 
{ 
  struct pvr2_dvb_adapter *adap ;
  int tmp ;

  {
#line 250
  adap = (struct pvr2_dvb_adapter *)(fe->dvb)->priv;
#line 251
  tmp = pvr2_channel_limit_inputs(& adap->channel, acquire != 0 ? 2U : 0U);
#line 251
  return (tmp);
}
}
#line 256 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
static int pvr2_dvb_adapter_init(struct pvr2_dvb_adapter *adap ) 
{ 
  int ret ;

  {
#line 260
  ret = dvb_register_adapter(& adap->dvb_adap, "pvrusb2-dvb", & __this_module, & ((adap->channel.hdw)->usb_dev)->dev,
                             (short *)(& adapter_nr));
#line 264
  if (ret < 0) {
#line 265
    if ((pvrusb2_debug & 2) != 0) {
#line 265
      printk("\016pvrusb2: dvb_register_adapter failed: error %d\n", ret);
    } else {

    }
#line 267
    goto err;
  } else {

  }
#line 269
  adap->dvb_adap.priv = (void *)adap;
#line 271
  adap->demux.dmx.capabilities = 13U;
#line 274
  adap->demux.priv = (void *)adap;
#line 275
  adap->demux.filternum = 256;
#line 276
  adap->demux.feednum = 256;
#line 277
  adap->demux.start_feed = & pvr2_dvb_start_feed;
#line 278
  adap->demux.stop_feed = & pvr2_dvb_stop_feed;
#line 279
  adap->demux.write_to_decoder = (int (*)(struct dvb_demux_feed * , u8 const   * ,
                                          size_t  ))0;
#line 281
  ret = dvb_dmx_init(& adap->demux);
#line 282
  if (ret < 0) {
#line 283
    if ((pvrusb2_debug & 2) != 0) {
#line 283
      printk("\016pvrusb2: dvb_dmx_init failed: error %d\n", ret);
    } else {

    }
#line 285
    goto err_dmx;
  } else {

  }
#line 288
  adap->dmxdev.filternum = adap->demux.filternum;
#line 289
  adap->dmxdev.demux = & adap->demux.dmx;
#line 290
  adap->dmxdev.capabilities = 0;
#line 292
  ret = dvb_dmxdev_init(& adap->dmxdev, & adap->dvb_adap);
#line 293
  if (ret < 0) {
#line 294
    if ((pvrusb2_debug & 2) != 0) {
#line 294
      printk("\016pvrusb2: dvb_dmxdev_init failed: error %d\n", ret);
    } else {

    }
#line 296
    goto err_dmx_dev;
  } else {

  }
#line 299
  dvb_net_init(& adap->dvb_adap, & adap->dvb_net, & adap->demux.dmx);
#line 301
  return (0);
  err_dmx_dev: 
#line 304
  dvb_dmx_release(& adap->demux);
  err_dmx: 
#line 306
  dvb_unregister_adapter(& adap->dvb_adap);
  err: ;
#line 308
  return (ret);
}
}
#line 311 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
static int pvr2_dvb_adapter_exit(struct pvr2_dvb_adapter *adap ) 
{ 


  {
#line 313
  if (pvrusb2_debug & 1) {
#line 313
    printk("\016pvrusb2: unregistering DVB devices\n");
  } else {

  }
#line 314
  dvb_net_release(& adap->dvb_net);
#line 315
  (*(adap->demux.dmx.close))(& adap->demux.dmx);
#line 316
  dvb_dmxdev_release(& adap->dmxdev);
#line 317
  dvb_dmx_release(& adap->demux);
#line 318
  dvb_unregister_adapter(& adap->dvb_adap);
#line 319
  return (0);
}
}
#line 322 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
static int pvr2_dvb_frontend_init(struct pvr2_dvb_adapter *adap ) 
{ 
  struct pvr2_hdw *hdw ;
  struct pvr2_dvb_props  const  *dvb_props ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 324
  hdw = adap->channel.hdw;
#line 325
  dvb_props = (hdw->hdw_desc)->dvb_props;
#line 326
  ret = 0;
#line 328
  if ((unsigned long )dvb_props == (unsigned long )((struct pvr2_dvb_props  const  *)0)) {
#line 329
    if ((pvrusb2_debug & 2) != 0) {
#line 329
      printk("\016pvrusb2: fe_props not defined!\n");
    } else {

    }
#line 330
    return (-22);
  } else {

  }
#line 333
  ret = pvr2_channel_limit_inputs(& adap->channel, 2U);
#line 336
  if (ret != 0) {
#line 337
    if ((pvrusb2_debug & 2) != 0) {
#line 337
      printk("\016pvrusb2: failed to grab control of dtv input (code=%d)\n", ret);
    } else {

    }
#line 340
    return (ret);
  } else {

  }
#line 343
  if ((unsigned long )dvb_props->frontend_attach == (unsigned long )((int (*/* const  */)(struct pvr2_dvb_adapter * ))0)) {
#line 344
    if ((pvrusb2_debug & 2) != 0) {
#line 344
      printk("\016pvrusb2: frontend_attach not defined!\n");
    } else {

    }
#line 346
    ret = -22;
#line 347
    goto done;
  } else {

  }
#line 350
  tmp___0 = (*(dvb_props->frontend_attach))(adap);
#line 350
  if (tmp___0 == 0 && (unsigned long )adap->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 352
    tmp = dvb_register_frontend(& adap->dvb_adap, adap->fe);
#line 352
    if (tmp != 0) {
#line 353
      if ((pvrusb2_debug & 2) != 0) {
#line 353
        printk("\016pvrusb2: frontend registration failed!\n");
      } else {

      }
#line 355
      dvb_frontend_detach(adap->fe);
#line 356
      adap->fe = (struct dvb_frontend *)0;
#line 357
      ret = -19;
#line 358
      goto done;
    } else {

    }
#line 361
    if ((unsigned long )dvb_props->tuner_attach != (unsigned long )((int (*/* const  */)(struct pvr2_dvb_adapter * ))0)) {
#line 362
      (*(dvb_props->tuner_attach))(adap);
    } else {

    }
#line 364
    if ((unsigned long )(adap->fe)->ops.analog_ops.standby != (unsigned long )((void (*)(struct dvb_frontend * ))0)) {
#line 365
      (*((adap->fe)->ops.analog_ops.standby))(adap->fe);
    } else {

    }
#line 368
    (adap->fe)->ops.ts_bus_ctrl = & pvr2_dvb_bus_ctrl;
  } else {
#line 371
    if ((pvrusb2_debug & 2) != 0) {
#line 371
      printk("\016pvrusb2: no frontend was attached!\n");
    } else {

    }
#line 373
    ret = -19;
#line 374
    return (ret);
  }
  done: 
#line 378
  pvr2_channel_limit_inputs(& adap->channel, 0U);
#line 379
  return (ret);
}
}
#line 382 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
static int pvr2_dvb_frontend_exit(struct pvr2_dvb_adapter *adap ) 
{ 


  {
#line 384
  if ((unsigned long )adap->fe != (unsigned long )((struct dvb_frontend *)0)) {
#line 385
    dvb_unregister_frontend(adap->fe);
#line 386
    dvb_frontend_detach(adap->fe);
  } else {

  }
#line 388
  return (0);
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
static void pvr2_dvb_destroy(struct pvr2_dvb_adapter *adap ) 
{ 


  {
#line 393
  pvr2_dvb_stream_end(adap);
#line 394
  pvr2_dvb_frontend_exit(adap);
#line 395
  pvr2_dvb_adapter_exit(adap);
#line 396
  pvr2_channel_done(& adap->channel);
#line 397
  kfree((void const   *)adap);
#line 398
  return;
}
}
#line 400 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
static void pvr2_dvb_internal_check(struct pvr2_channel *chp ) 
{ 
  struct pvr2_dvb_adapter *adap ;
  struct pvr2_channel  const  *__mptr ;

  {
#line 403
  __mptr = (struct pvr2_channel  const  *)chp;
#line 403
  adap = (struct pvr2_dvb_adapter *)__mptr;
#line 404
  if ((adap->channel.mc_head)->disconnect_flag == 0) {
#line 404
    return;
  } else {

  }
#line 405
  pvr2_dvb_destroy(adap);
#line 406
  return;
}
}
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.c"
struct pvr2_dvb_adapter *pvr2_dvb_create(struct pvr2_context *pvr ) 
{ 
  int ret ;
  struct pvr2_dvb_adapter *adap ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 410
  ret = 0;
#line 412
  if ((unsigned long )((pvr->hdw)->hdw_desc)->dvb_props == (unsigned long )((struct pvr2_dvb_props  const  */* const  */)0)) {
#line 415
    return ((struct pvr2_dvb_adapter *)0);
  } else {

  }
#line 417
  tmp = kzalloc(2584UL, 208U);
#line 417
  adap = (struct pvr2_dvb_adapter *)tmp;
#line 418
  if ((unsigned long )adap == (unsigned long )((struct pvr2_dvb_adapter *)0)) {
#line 418
    return (adap);
  } else {

  }
#line 419
  pvr2_channel_init(& adap->channel, pvr);
#line 420
  adap->channel.check_func = & pvr2_dvb_internal_check;
#line 421
  __init_waitqueue_head(& adap->buffer_wait_data, "&adap->buffer_wait_data", & __key);
#line 422
  __mutex_init(& adap->lock, "&adap->lock", & __key___0);
#line 423
  ret = pvr2_dvb_adapter_init(adap);
#line 424
  if (ret < 0) {
#line 424
    goto fail1;
  } else {

  }
#line 425
  ret = pvr2_dvb_frontend_init(adap);
#line 426
  if (ret < 0) {
#line 426
    goto fail2;
  } else {

  }
#line 427
  return (adap);
  fail2: 
#line 430
  pvr2_dvb_adapter_exit(adap);
  fail1: 
#line 432
  pvr2_channel_done(& adap->channel);
#line 433
  return ((struct pvr2_dvb_adapter *)0);
}
}
#line 332 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 335
  tmp = ldv_ptr_err(ptr);
#line 335
  return (tmp);
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
bool ldv_queue_work_on_774(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 354
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 354
  ldv_func_res = tmp;
#line 356
  activate_work_1(ldv_func_arg3, 2);
#line 358
  return (ldv_func_res);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
bool ldv_queue_delayed_work_on_775(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 365
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 365
  ldv_func_res = tmp;
#line 367
  activate_work_1(& ldv_func_arg3->work, 2);
#line 369
  return (ldv_func_res);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
bool ldv_queue_work_on_776(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 376
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 376
  ldv_func_res = tmp;
#line 378
  activate_work_1(ldv_func_arg3, 2);
#line 380
  return (ldv_func_res);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
void ldv_flush_workqueue_777(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 386
  flush_workqueue(ldv_func_arg1);
#line 388
  call_and_disable_all_1(2);
#line 389
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
bool ldv_queue_delayed_work_on_778(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 395
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 395
  ldv_func_res = tmp;
#line 397
  activate_work_1(& ldv_func_arg3->work, 2);
#line 399
  return (ldv_func_res);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
void ldv_mutex_unlock_779(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 405
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 407
  mutex_unlock(ldv_func_arg1);
#line 408
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
void ldv_mutex_lock_780(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 413
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 415
  mutex_lock(ldv_func_arg1);
#line 416
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
void ldv_mutex_lock_781(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 421
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 423
  mutex_lock(ldv_func_arg1);
#line 424
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
void ldv_mutex_unlock_782(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 429
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 431
  mutex_unlock(ldv_func_arg1);
#line 432
  return;
}
}
#line 434 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
void ldv_mutex_lock_783(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 437
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 439
  mutex_lock(ldv_func_arg1);
#line 440
  return;
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
int ldv_mutex_trylock_784(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 446
  tmp = mutex_trylock(ldv_func_arg1);
#line 446
  ldv_func_res = tmp;
#line 448
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 448
  return (tmp___0);
#line 450
  return (ldv_func_res);
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
void ldv_mutex_unlock_785(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 456
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 458
  mutex_unlock(ldv_func_arg1);
#line 459
  return;
}
}
#line 461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
void ldv_mutex_lock_786(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 464
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 466
  mutex_lock(ldv_func_arg1);
#line 467
  return;
}
}
#line 469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
void ldv_mutex_unlock_787(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 472
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 474
  mutex_unlock(ldv_func_arg1);
#line 475
  return;
}
}
#line 477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
void ldv_mutex_lock_788(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 480
  ldv_mutex_lock_lock_of_pvr2_dvb_adapter(ldv_func_arg1);
#line 482
  mutex_lock(ldv_func_arg1);
#line 483
  return;
}
}
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-dvb.o.c.prepared"
void ldv_mutex_unlock_789(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 488
  ldv_mutex_unlock_lock_of_pvr2_dvb_adapter(ldv_func_arg1);
#line 490
  mutex_unlock(ldv_func_arg1);
#line 491
  return;
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_818(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_816(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_819(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_820(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
void ldv_mutex_lock_815(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_817(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_821(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_810(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_812(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_811(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_814(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_813(struct workqueue_struct *ldv_func_arg1 ) ;
#line 249 "include/linux/sysfs.h"
extern int sysfs_create_group(struct kobject * , struct attribute_group  const  * ) ;
#line 255
extern void sysfs_remove_group(struct kobject * , struct attribute_group  const  * ) ;
#line 415 "include/linux/device.h"
extern int __class_register(struct class * , struct lock_class_key * ) ;
#line 417
extern void class_unregister(struct class * ) ;
#line 591
extern int device_create_file(struct device * , struct device_attribute  const  * ) ;
#line 593
extern void device_remove_file(struct device * , struct device_attribute  const  * ) ;
#line 842
extern int dev_set_name(struct device * , char const   *  , ...) ;
#line 954
extern int device_register(struct device * ) ;
#line 955
extern void device_unregister(struct device * ) ;
#line 1046
extern struct device *get_device(struct device * ) ;
#line 1047
extern void put_device(struct device * ) ;
#line 29 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/pvrusb2/pvrusb2-debugifc.h"
int pvr2_debugifc_print_info(struct pvr2_hdw *hdw , char *buf , unsigned int acnt ) ;
#line 35
int pvr2_debugifc_print_status(struct pvr2_hdw *hdw , char *buf , unsigned int acnt ) ;
#line 39
int pvr2_debugifc_docmd(struct pvr2_hdw *hdw , char const   *buf , unsigned int count ) ;
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t show_name(struct device *class_dev , struct device_attribute *attr ,
                         char *buf ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  char const   *name ;
  struct device_attribute  const  *__mptr ;
  int tmp ;

  {
#line 93
  __mptr = (struct device_attribute  const  *)attr;
#line 93
  cip = (struct pvr2_sysfs_ctl_item *)__mptr;
#line 94
  name = pvr2_ctrl_get_desc(cip->cptr);
#line 95
  if ((pvrusb2_debug & 16384) != 0) {
#line 95
    printk("\016pvrusb2: pvr2_sysfs(%p) show_name(cid=%d) is %s\n", cip->chptr, cip->ctl_id,
           name);
  } else {

  }
#line 97
  if ((unsigned long )name == (unsigned long )((char const   *)0)) {
#line 97
    return (-22L);
  } else {

  }
#line 98
  tmp = scnprintf(buf, 4096UL, "%s\n", name);
#line 98
  return ((ssize_t )tmp);
}
}
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t show_type(struct device *class_dev , struct device_attribute *attr ,
                         char *buf ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  char const   *name ;
  enum pvr2_ctl_type tp ;
  struct device_attribute  const  *__mptr ;
  int tmp ;

  {
#line 108
  __mptr = (struct device_attribute  const  *)attr;
#line 108
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xffffffffffffffd0UL;
#line 109
  tp = pvr2_ctrl_get_type(cip->cptr);
#line 110
  switch ((unsigned int )tp) {
  case 0U: 
#line 111
  name = "integer";
#line 111
  goto ldv_29519;
  case 1U: 
#line 112
  name = "enum";
#line 112
  goto ldv_29519;
  case 2U: 
#line 113
  name = "bitmask";
#line 113
  goto ldv_29519;
  case 3U: 
#line 114
  name = "boolean";
#line 114
  goto ldv_29519;
  default: 
#line 115
  name = "?";
#line 115
  goto ldv_29519;
  }
  ldv_29519: ;
#line 117
  if ((pvrusb2_debug & 16384) != 0) {
#line 117
    printk("\016pvrusb2: pvr2_sysfs(%p) show_type(cid=%d) is %s\n", cip->chptr, cip->ctl_id,
           name);
  } else {

  }
#line 119
  if ((unsigned long )name == (unsigned long )((char const   *)0)) {
#line 119
    return (-22L);
  } else {

  }
#line 120
  tmp = scnprintf(buf, 4096UL, "%s\n", name);
#line 120
  return ((ssize_t )tmp);
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t show_min(struct device *class_dev , struct device_attribute *attr ,
                        char *buf ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  long val ;
  struct device_attribute  const  *__mptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 129
  __mptr = (struct device_attribute  const  *)attr;
#line 129
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xffffffffffffffa0UL;
#line 130
  tmp = pvr2_ctrl_get_min(cip->cptr);
#line 130
  val = (long )tmp;
#line 131
  if ((pvrusb2_debug & 16384) != 0) {
#line 131
    printk("\016pvrusb2: pvr2_sysfs(%p) show_min(cid=%d) is %ld\n", cip->chptr, cip->ctl_id,
           val);
  } else {

  }
#line 133
  tmp___0 = scnprintf(buf, 4096UL, "%ld\n", val);
#line 133
  return ((ssize_t )tmp___0);
}
}
#line 136 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t show_max(struct device *class_dev , struct device_attribute *attr ,
                        char *buf ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  long val ;
  struct device_attribute  const  *__mptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 142
  __mptr = (struct device_attribute  const  *)attr;
#line 142
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xffffffffffffff70UL;
#line 143
  tmp = pvr2_ctrl_get_max(cip->cptr);
#line 143
  val = (long )tmp;
#line 144
  if ((pvrusb2_debug & 16384) != 0) {
#line 144
    printk("\016pvrusb2: pvr2_sysfs(%p) show_max(cid=%d) is %ld\n", cip->chptr, cip->ctl_id,
           val);
  } else {

  }
#line 146
  tmp___0 = scnprintf(buf, 4096UL, "%ld\n", val);
#line 146
  return ((ssize_t )tmp___0);
}
}
#line 149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t show_def(struct device *class_dev , struct device_attribute *attr ,
                        char *buf ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  int val ;
  int ret ;
  unsigned int cnt ;
  struct device_attribute  const  *__mptr ;

  {
#line 156
  cnt = 0U;
#line 157
  __mptr = (struct device_attribute  const  *)attr;
#line 157
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xffffffffffffff40UL;
#line 158
  ret = pvr2_ctrl_get_def(cip->cptr, & val);
#line 159
  if (ret < 0) {
#line 159
    return ((ssize_t )ret);
  } else {

  }
#line 160
  ret = pvr2_ctrl_value_to_sym(cip->cptr, -1, val, buf, 4095U, & cnt);
#line 162
  if ((pvrusb2_debug & 16384) != 0) {
#line 162
    printk("\016pvrusb2: pvr2_sysfs(%p) show_def(cid=%d) is %.*s (%d)\n", cip->chptr,
           cip->ctl_id, cnt, buf, val);
  } else {

  }
#line 164
  *(buf + (unsigned long )cnt) = 10;
#line 165
  return ((ssize_t )(cnt + 1U));
}
}
#line 168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t show_val_norm(struct device *class_dev , struct device_attribute *attr ,
                             char *buf ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  int val ;
  int ret ;
  unsigned int cnt ;
  struct device_attribute  const  *__mptr ;

  {
#line 175
  cnt = 0U;
#line 176
  __mptr = (struct device_attribute  const  *)attr;
#line 176
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xfffffffffffffeb0UL;
#line 177
  ret = pvr2_ctrl_get_value(cip->cptr, & val);
#line 178
  if (ret < 0) {
#line 178
    return ((ssize_t )ret);
  } else {

  }
#line 179
  ret = pvr2_ctrl_value_to_sym(cip->cptr, -1, val, buf, 4095U, & cnt);
#line 181
  if ((pvrusb2_debug & 16384) != 0) {
#line 181
    printk("\016pvrusb2: pvr2_sysfs(%p) show_val_norm(cid=%d) is %.*s (%d)\n", cip->chptr,
           cip->ctl_id, cnt, buf, val);
  } else {

  }
#line 183
  *(buf + (unsigned long )cnt) = 10;
#line 184
  return ((ssize_t )(cnt + 1U));
}
}
#line 187 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t show_val_custom(struct device *class_dev , struct device_attribute *attr ,
                               char *buf ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  int val ;
  int ret ;
  unsigned int cnt ;
  struct device_attribute  const  *__mptr ;

  {
#line 194
  cnt = 0U;
#line 195
  __mptr = (struct device_attribute  const  *)attr;
#line 195
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xfffffffffffffe80UL;
#line 196
  ret = pvr2_ctrl_get_value(cip->cptr, & val);
#line 197
  if (ret < 0) {
#line 197
    return ((ssize_t )ret);
  } else {

  }
#line 198
  ret = pvr2_ctrl_custom_value_to_sym(cip->cptr, -1, val, buf, 4095U, & cnt);
#line 200
  if ((pvrusb2_debug & 16384) != 0) {
#line 200
    printk("\016pvrusb2: pvr2_sysfs(%p) show_val_custom(cid=%d) is %.*s (%d)\n", cip->chptr,
           cip->ctl_id, cnt, buf, val);
  } else {

  }
#line 202
  *(buf + (unsigned long )cnt) = 10;
#line 203
  return ((ssize_t )(cnt + 1U));
}
}
#line 206 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t show_enum(struct device *class_dev , struct device_attribute *attr ,
                         char *buf ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  long val ;
  unsigned int bcnt ;
  unsigned int ccnt ;
  unsigned int ecnt ;
  struct device_attribute  const  *__mptr ;
  int tmp ;

  {
#line 213
  __mptr = (struct device_attribute  const  *)attr;
#line 213
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xffffffffffffff10UL;
#line 214
  tmp = pvr2_ctrl_get_cnt(cip->cptr);
#line 214
  ecnt = (unsigned int )tmp;
#line 215
  bcnt = 0U;
#line 216
  val = 0L;
#line 216
  goto ldv_29590;
  ldv_29589: 
#line 217
  pvr2_ctrl_get_valname(cip->cptr, (int )val, buf + (unsigned long )bcnt, 4096U - bcnt,
                        & ccnt);
#line 219
  if (ccnt == 0U) {
#line 219
    goto ldv_29587;
  } else {

  }
#line 220
  bcnt = bcnt + ccnt;
#line 221
  if (bcnt > 4095U) {
#line 221
    goto ldv_29588;
  } else {

  }
#line 222
  *(buf + (unsigned long )bcnt) = 10;
#line 223
  bcnt = bcnt + 1U;
  ldv_29587: 
#line 216
  val = val + 1L;
  ldv_29590: ;
#line 216
  if ((long )ecnt > val) {
#line 218
    goto ldv_29589;
  } else {

  }
  ldv_29588: ;
#line 225
  if ((pvrusb2_debug & 16384) != 0) {
#line 225
    printk("\016pvrusb2: pvr2_sysfs(%p) show_enum(cid=%d)\n", cip->chptr, cip->ctl_id);
  } else {

  }
#line 227
  return ((ssize_t )bcnt);
}
}
#line 230 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t show_bits(struct device *class_dev , struct device_attribute *attr ,
                         char *buf ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  int valid_bits ;
  int msk ;
  unsigned int bcnt ;
  unsigned int ccnt ;
  struct device_attribute  const  *__mptr ;

  {
#line 237
  __mptr = (struct device_attribute  const  *)attr;
#line 237
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xfffffffffffffee0UL;
#line 238
  valid_bits = pvr2_ctrl_get_mask(cip->cptr);
#line 239
  bcnt = 0U;
#line 240
  msk = 1;
#line 240
  goto ldv_29606;
  ldv_29605: ;
#line 241
  if ((msk & valid_bits) == 0) {
#line 241
    goto ldv_29603;
  } else {

  }
#line 242
  valid_bits = ~ msk & valid_bits;
#line 243
  pvr2_ctrl_get_valname(cip->cptr, msk, buf + (unsigned long )bcnt, 4096U - bcnt,
                        & ccnt);
#line 245
  bcnt = bcnt + ccnt;
#line 246
  if (bcnt > 4095U) {
#line 246
    goto ldv_29604;
  } else {

  }
#line 247
  *(buf + (unsigned long )bcnt) = 10;
#line 248
  bcnt = bcnt + 1U;
  ldv_29603: 
#line 240
  msk = msk << 1;
  ldv_29606: ;
#line 240
  if (valid_bits != 0) {
#line 242
    goto ldv_29605;
  } else {

  }
  ldv_29604: ;
#line 250
  if ((pvrusb2_debug & 16384) != 0) {
#line 250
    printk("\016pvrusb2: pvr2_sysfs(%p) show_bits(cid=%d)\n", cip->chptr, cip->ctl_id);
  } else {

  }
#line 252
  return ((ssize_t )bcnt);
}
}
#line 255 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static int store_val_any(struct pvr2_sysfs_ctl_item *cip , int customfl , char const   *buf ,
                         unsigned int count ) 
{ 
  int ret ;
  int mask ;
  int val ;

  {
#line 260
  if (customfl != 0) {
#line 261
    ret = pvr2_ctrl_custom_sym_to_value(cip->cptr, buf, count, & mask, & val);
  } else {
#line 264
    ret = pvr2_ctrl_sym_to_value(cip->cptr, buf, count, & mask, & val);
  }
#line 267
  if (ret < 0) {
#line 267
    return (ret);
  } else {

  }
#line 268
  ret = pvr2_ctrl_set_mask_value(cip->cptr, mask, val);
#line 269
  pvr2_hdw_commit_ctl((cip->chptr)->channel.hdw);
#line 270
  return (ret);
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t store_val_norm(struct device *class_dev , struct device_attribute *attr ,
                              char const   *buf , size_t count ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  int ret ;
  struct device_attribute  const  *__mptr ;

  {
#line 279
  __mptr = (struct device_attribute  const  *)attr;
#line 279
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xfffffffffffffeb0UL;
#line 280
  if ((pvrusb2_debug & 16384) != 0) {
#line 280
    printk("\016pvrusb2: pvr2_sysfs(%p) store_val_norm(cid=%d) \"%.*s\"\n", cip->chptr,
           cip->ctl_id, (int )count, buf);
  } else {

  }
#line 282
  ret = store_val_any(cip, 0, buf, (unsigned int )count);
#line 283
  if (ret == 0) {
#line 283
    ret = (int )count;
  } else {

  }
#line 284
  return ((ssize_t )ret);
}
}
#line 287 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t store_val_custom(struct device *class_dev , struct device_attribute *attr ,
                                char const   *buf , size_t count ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  int ret ;
  struct device_attribute  const  *__mptr ;

  {
#line 293
  __mptr = (struct device_attribute  const  *)attr;
#line 293
  cip = (struct pvr2_sysfs_ctl_item *)__mptr + 0xfffffffffffffe80UL;
#line 294
  if ((pvrusb2_debug & 16384) != 0) {
#line 294
    printk("\016pvrusb2: pvr2_sysfs(%p) store_val_custom(cid=%d) \"%.*s\"\n", cip->chptr,
           cip->ctl_id, (int )count, buf);
  } else {

  }
#line 296
  ret = store_val_any(cip, 1, buf, (unsigned int )count);
#line 297
  if (ret == 0) {
#line 297
    ret = (int )count;
  } else {

  }
#line 298
  return ((ssize_t )ret);
}
}
#line 301 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static void pvr2_sysfs_add_control(struct pvr2_sysfs *sfp , int ctl_id ) 
{ 
  struct pvr2_sysfs_ctl_item *cip ;
  struct pvr2_ctrl *cptr ;
  unsigned int cnt ;
  unsigned int acnt ;
  int ret ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  struct lock_class_key __key___4 ;
  struct lock_class_key __key___5 ;
  struct lock_class_key __key___6 ;
  struct lock_class_key __key___7 ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  enum pvr2_ctl_type tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;

  {
#line 308
  cptr = pvr2_hdw_get_ctrl_by_index(sfp->channel.hdw, (unsigned int )ctl_id);
#line 309
  if ((unsigned long )cptr == (unsigned long )((struct pvr2_ctrl *)0)) {
#line 309
    return;
  } else {

  }
#line 311
  tmp = kzalloc(648UL, 208U);
#line 311
  cip = (struct pvr2_sysfs_ctl_item *)tmp;
#line 312
  if ((unsigned long )cip == (unsigned long )((struct pvr2_sysfs_ctl_item *)0)) {
#line 312
    return;
  } else {

  }
#line 313
  if ((pvrusb2_debug & 16384) != 0) {
#line 313
    printk("\016pvrusb2: Creating pvr2_sysfs_ctl_item id=%p\n", cip);
  } else {

  }
#line 315
  cip->cptr = cptr;
#line 316
  cip->ctl_id = ctl_id;
#line 318
  cip->chptr = sfp;
#line 319
  cip->item_next = (struct pvr2_sysfs_ctl_item *)0;
#line 320
  if ((unsigned long )sfp->item_last != (unsigned long )((struct pvr2_sysfs_ctl_item *)0)) {
#line 321
    (sfp->item_last)->item_next = cip;
  } else {
#line 323
    sfp->item_first = cip;
  }
#line 325
  sfp->item_last = cip;
#line 327
  cip->attr_name.attr.key = & __key;
#line 328
  cip->attr_name.attr.name = "name";
#line 329
  cip->attr_name.attr.mode = 292U;
#line 330
  cip->attr_name.show = & show_name;
#line 332
  cip->attr_type.attr.key = & __key___0;
#line 333
  cip->attr_type.attr.name = "type";
#line 334
  cip->attr_type.attr.mode = 292U;
#line 335
  cip->attr_type.show = & show_type;
#line 337
  cip->attr_min.attr.key = & __key___1;
#line 338
  cip->attr_min.attr.name = "min_val";
#line 339
  cip->attr_min.attr.mode = 292U;
#line 340
  cip->attr_min.show = & show_min;
#line 342
  cip->attr_max.attr.key = & __key___2;
#line 343
  cip->attr_max.attr.name = "max_val";
#line 344
  cip->attr_max.attr.mode = 292U;
#line 345
  cip->attr_max.show = & show_max;
#line 347
  cip->attr_def.attr.key = & __key___3;
#line 348
  cip->attr_def.attr.name = "def_val";
#line 349
  cip->attr_def.attr.mode = 292U;
#line 350
  cip->attr_def.show = & show_def;
#line 352
  cip->attr_val.attr.key = & __key___4;
#line 353
  cip->attr_val.attr.name = "cur_val";
#line 354
  cip->attr_val.attr.mode = 292U;
#line 356
  cip->attr_custom.attr.key = & __key___5;
#line 357
  cip->attr_custom.attr.name = "custom_val";
#line 358
  cip->attr_custom.attr.mode = 292U;
#line 360
  cip->attr_enum.attr.key = & __key___6;
#line 361
  cip->attr_enum.attr.name = "enum_val";
#line 362
  cip->attr_enum.attr.mode = 292U;
#line 363
  cip->attr_enum.show = & show_enum;
#line 365
  cip->attr_bits.attr.key = & __key___7;
#line 366
  cip->attr_bits.attr.name = "bit_val";
#line 367
  cip->attr_bits.attr.mode = 292U;
#line 368
  cip->attr_bits.show = & show_bits;
#line 370
  tmp___0 = pvr2_ctrl_is_writable(cptr);
#line 370
  if (tmp___0 != 0) {
#line 371
    cip->attr_val.attr.mode = (umode_t )((unsigned int )cip->attr_val.attr.mode | 144U);
#line 372
    cip->attr_custom.attr.mode = (umode_t )((unsigned int )cip->attr_custom.attr.mode | 144U);
  } else {

  }
#line 375
  acnt = 0U;
#line 376
  tmp___1 = acnt;
#line 376
  acnt = acnt + 1U;
#line 376
  cip->attr_gen[tmp___1] = & cip->attr_name.attr;
#line 377
  tmp___2 = acnt;
#line 377
  acnt = acnt + 1U;
#line 377
  cip->attr_gen[tmp___2] = & cip->attr_type.attr;
#line 378
  tmp___3 = acnt;
#line 378
  acnt = acnt + 1U;
#line 378
  cip->attr_gen[tmp___3] = & cip->attr_val.attr;
#line 379
  tmp___4 = acnt;
#line 379
  acnt = acnt + 1U;
#line 379
  cip->attr_gen[tmp___4] = & cip->attr_def.attr;
#line 380
  cip->attr_val.show = & show_val_norm;
#line 381
  cip->attr_val.store = & store_val_norm;
#line 382
  tmp___6 = pvr2_ctrl_has_custom_symbols(cptr);
#line 382
  if (tmp___6 != 0) {
#line 383
    tmp___5 = acnt;
#line 383
    acnt = acnt + 1U;
#line 383
    cip->attr_gen[tmp___5] = & cip->attr_custom.attr;
#line 384
    cip->attr_custom.show = & show_val_custom;
#line 385
    cip->attr_custom.store = & store_val_custom;
  } else {

  }
#line 387
  tmp___7 = pvr2_ctrl_get_type(cptr);
#line 387
  switch ((unsigned int )tmp___7) {
  case 1U: 
#line 390
  tmp___8 = acnt;
#line 390
  acnt = acnt + 1U;
#line 390
  cip->attr_gen[tmp___8] = & cip->attr_enum.attr;
#line 391
  goto ldv_29655;
  case 0U: 
#line 394
  tmp___9 = acnt;
#line 394
  acnt = acnt + 1U;
#line 394
  cip->attr_gen[tmp___9] = & cip->attr_min.attr;
#line 395
  tmp___10 = acnt;
#line 395
  acnt = acnt + 1U;
#line 395
  cip->attr_gen[tmp___10] = & cip->attr_max.attr;
#line 396
  goto ldv_29655;
  case 2U: 
#line 399
  tmp___11 = acnt;
#line 399
  acnt = acnt + 1U;
#line 399
  cip->attr_gen[tmp___11] = & cip->attr_bits.attr;
#line 400
  goto ldv_29655;
  default: ;
#line 401
  goto ldv_29655;
  }
  ldv_29655: 
#line 404
  tmp___12 = pvr2_ctrl_get_name(cptr);
#line 404
  tmp___13 = scnprintf((char *)(& cip->name), 79UL, "ctl_%s", tmp___12);
#line 404
  cnt = (unsigned int )tmp___13;
#line 406
  cip->name[cnt] = 0;
#line 407
  cip->grp.name = (char const   *)(& cip->name);
#line 408
  cip->grp.attrs = (struct attribute **)(& cip->attr_gen);
#line 410
  ret = sysfs_create_group(& (sfp->class_dev)->kobj, (struct attribute_group  const  *)(& cip->grp));
#line 411
  if (ret != 0) {
#line 412
    if ((pvrusb2_debug & 2) != 0) {
#line 412
      printk("\016pvrusb2: sysfs_create_group error: %d\n", ret);
    } else {

    }
#line 415
    return;
  } else {

  }
#line 417
  cip->created_ok = 1;
#line 418
  return;
}
}
#line 421
static ssize_t debuginfo_show(struct device *class_dev , struct device_attribute *attr ,
                              char *buf ) ;
#line 423
static ssize_t debugcmd_show(struct device *class_dev , struct device_attribute *attr ,
                             char *buf ) ;
#line 425
static ssize_t debugcmd_store(struct device *class_dev , struct device_attribute *attr ,
                              char const   *buf , size_t count ) ;
#line 428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static void pvr2_sysfs_add_debugifc(struct pvr2_sysfs *sfp ) 
{ 
  struct pvr2_sysfs_debugifc *dip ;
  int ret ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 433
  tmp = kzalloc(104UL, 208U);
#line 433
  dip = (struct pvr2_sysfs_debugifc *)tmp;
#line 434
  if ((unsigned long )dip == (unsigned long )((struct pvr2_sysfs_debugifc *)0)) {
#line 434
    return;
  } else {

  }
#line 435
  dip->attr_debugcmd.attr.key = & __key;
#line 436
  dip->attr_debugcmd.attr.name = "debugcmd";
#line 437
  dip->attr_debugcmd.attr.mode = 436U;
#line 438
  dip->attr_debugcmd.show = & debugcmd_show;
#line 439
  dip->attr_debugcmd.store = & debugcmd_store;
#line 440
  dip->attr_debuginfo.attr.key = & __key___0;
#line 441
  dip->attr_debuginfo.attr.name = "debuginfo";
#line 442
  dip->attr_debuginfo.attr.mode = 292U;
#line 443
  dip->attr_debuginfo.show = & debuginfo_show;
#line 444
  sfp->debugifc = dip;
#line 445
  ret = device_create_file(sfp->class_dev, (struct device_attribute  const  *)(& dip->attr_debugcmd));
#line 446
  if (ret < 0) {
#line 447
    if ((pvrusb2_debug & 2) != 0) {
#line 447
      printk("\016pvrusb2: device_create_file error: %d\n", ret);
    } else {

    }
  } else {
#line 451
    dip->debugcmd_created_ok = 1;
  }
#line 453
  ret = device_create_file(sfp->class_dev, (struct device_attribute  const  *)(& dip->attr_debuginfo));
#line 454
  if (ret < 0) {
#line 455
    if ((pvrusb2_debug & 2) != 0) {
#line 455
      printk("\016pvrusb2: device_create_file error: %d\n", ret);
    } else {

    }
  } else {
#line 459
    dip->debuginfo_created_ok = 1;
  }
#line 460
  return;
}
}
#line 464 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static void pvr2_sysfs_tear_down_debugifc(struct pvr2_sysfs *sfp ) 
{ 


  {
#line 466
  if ((unsigned long )sfp->debugifc == (unsigned long )((struct pvr2_sysfs_debugifc *)0)) {
#line 466
    return;
  } else {

  }
#line 467
  if ((sfp->debugifc)->debuginfo_created_ok != 0) {
#line 468
    device_remove_file(sfp->class_dev, (struct device_attribute  const  *)(& (sfp->debugifc)->attr_debuginfo));
  } else {

  }
#line 471
  if ((sfp->debugifc)->debugcmd_created_ok != 0) {
#line 472
    device_remove_file(sfp->class_dev, (struct device_attribute  const  *)(& (sfp->debugifc)->attr_debugcmd));
  } else {

  }
#line 475
  kfree((void const   *)sfp->debugifc);
#line 476
  sfp->debugifc = (struct pvr2_sysfs_debugifc *)0;
#line 477
  return;
}
}
#line 481 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static void pvr2_sysfs_add_controls(struct pvr2_sysfs *sfp ) 
{ 
  unsigned int idx ;
  unsigned int cnt ;

  {
#line 484
  cnt = pvr2_hdw_get_ctrl_count(sfp->channel.hdw);
#line 485
  idx = 0U;
#line 485
  goto ldv_29688;
  ldv_29687: 
#line 486
  pvr2_sysfs_add_control(sfp, (int )idx);
#line 485
  idx = idx + 1U;
  ldv_29688: ;
#line 485
  if (idx < cnt) {
#line 487
    goto ldv_29687;
  } else {

  }

#line 492
  return;
}
}
#line 491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static void pvr2_sysfs_tear_down_controls(struct pvr2_sysfs *sfp ) 
{ 
  struct pvr2_sysfs_ctl_item *cip1 ;
  struct pvr2_sysfs_ctl_item *cip2 ;

  {
#line 494
  cip1 = sfp->item_first;
#line 494
  goto ldv_29696;
  ldv_29695: 
#line 495
  cip2 = cip1->item_next;
#line 496
  if (cip1->created_ok != 0) {
#line 497
    sysfs_remove_group(& (sfp->class_dev)->kobj, (struct attribute_group  const  *)(& cip1->grp));
  } else {

  }
#line 499
  if ((pvrusb2_debug & 16384) != 0) {
#line 499
    printk("\016pvrusb2: Destroying pvr2_sysfs_ctl_item id=%p\n", cip1);
  } else {

  }
#line 500
  kfree((void const   *)cip1);
#line 494
  cip1 = cip2;
  ldv_29696: ;
#line 494
  if ((unsigned long )cip1 != (unsigned long )((struct pvr2_sysfs_ctl_item *)0)) {
#line 496
    goto ldv_29695;
  } else {

  }

#line 501
  return;
}
}
#line 505 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static void pvr2_sysfs_class_release(struct class *class ) 
{ 
  struct pvr2_sysfs_class *clp ;
  struct class  const  *__mptr ;

  {
#line 508
  __mptr = (struct class  const  *)class;
#line 508
  clp = (struct pvr2_sysfs_class *)__mptr;
#line 509
  if ((pvrusb2_debug & 16384) != 0) {
#line 509
    printk("\016pvrusb2: Destroying pvr2_sysfs_class id=%p\n", clp);
  } else {

  }
#line 510
  kfree((void const   *)clp);
#line 511
  return;
}
}
#line 514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static void pvr2_sysfs_release(struct device *class_dev ) 
{ 


  {
#line 516
  if ((pvrusb2_debug & 16384) != 0) {
#line 516
    printk("\016pvrusb2: Releasing class_dev id=%p\n", class_dev);
  } else {

  }
#line 517
  kfree((void const   *)class_dev);
#line 518
  return;
}
}
#line 521 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static void class_dev_destroy(struct pvr2_sysfs *sfp ) 
{ 
  struct device *dev ;

  {
#line 524
  if ((unsigned long )sfp->class_dev == (unsigned long )((struct device *)0)) {
#line 524
    return;
  } else {

  }
#line 526
  pvr2_sysfs_tear_down_debugifc(sfp);
#line 528
  pvr2_sysfs_tear_down_controls(sfp);
#line 529
  if (sfp->hdw_desc_created_ok != 0) {
#line 530
    device_remove_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_hdw_desc));
  } else {

  }
#line 533
  if (sfp->hdw_name_created_ok != 0) {
#line 534
    device_remove_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_hdw_name));
  } else {

  }
#line 537
  if (sfp->bus_info_created_ok != 0) {
#line 538
    device_remove_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_bus_info));
  } else {

  }
#line 541
  if (sfp->v4l_minor_number_created_ok != 0) {
#line 542
    device_remove_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_v4l_minor_number));
  } else {

  }
#line 545
  if (sfp->v4l_radio_minor_number_created_ok != 0) {
#line 546
    device_remove_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_v4l_radio_minor_number));
  } else {

  }
#line 549
  if (sfp->unit_number_created_ok != 0) {
#line 550
    device_remove_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_unit_number));
  } else {

  }
#line 553
  if ((pvrusb2_debug & 16384) != 0) {
#line 553
    printk("\016pvrusb2: Destroying class_dev id=%p\n", sfp->class_dev);
  } else {

  }
#line 554
  dev_set_drvdata(sfp->class_dev, (void *)0);
#line 555
  dev = (sfp->class_dev)->parent;
#line 556
  (sfp->class_dev)->parent = (struct device *)0;
#line 557
  put_device(dev);
#line 558
  device_unregister(sfp->class_dev);
#line 559
  sfp->class_dev = (struct device *)0;
#line 560
  return;
}
}
#line 563 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t v4l_minor_number_show(struct device *class_dev , struct device_attribute *attr ,
                                     char *buf ) 
{ 
  struct pvr2_sysfs *sfp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 567
  tmp = dev_get_drvdata((struct device  const  *)class_dev);
#line 567
  sfp = (struct pvr2_sysfs *)tmp;
#line 568
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 568
    return (-22L);
  } else {

  }
#line 569
  tmp___0 = pvr2_hdw_v4l_get_minor_number(sfp->channel.hdw, 0);
#line 569
  tmp___1 = scnprintf(buf, 4096UL, "%d\n", tmp___0);
#line 569
  return ((ssize_t )tmp___1);
}
}
#line 575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t bus_info_show(struct device *class_dev , struct device_attribute *attr ,
                             char *buf ) 
{ 
  struct pvr2_sysfs *sfp ;
  void *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 579
  tmp = dev_get_drvdata((struct device  const  *)class_dev);
#line 579
  sfp = (struct pvr2_sysfs *)tmp;
#line 580
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 580
    return (-22L);
  } else {

  }
#line 581
  tmp___0 = pvr2_hdw_get_bus_info(sfp->channel.hdw);
#line 581
  tmp___1 = scnprintf(buf, 4096UL, "%s\n", tmp___0);
#line 581
  return ((ssize_t )tmp___1);
}
}
#line 586 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t hdw_name_show(struct device *class_dev , struct device_attribute *attr ,
                             char *buf ) 
{ 
  struct pvr2_sysfs *sfp ;
  void *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 590
  tmp = dev_get_drvdata((struct device  const  *)class_dev);
#line 590
  sfp = (struct pvr2_sysfs *)tmp;
#line 591
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 591
    return (-22L);
  } else {

  }
#line 592
  tmp___0 = pvr2_hdw_get_type(sfp->channel.hdw);
#line 592
  tmp___1 = scnprintf(buf, 4096UL, "%s\n", tmp___0);
#line 592
  return ((ssize_t )tmp___1);
}
}
#line 597 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t hdw_desc_show(struct device *class_dev , struct device_attribute *attr ,
                             char *buf ) 
{ 
  struct pvr2_sysfs *sfp ;
  void *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 601
  tmp = dev_get_drvdata((struct device  const  *)class_dev);
#line 601
  sfp = (struct pvr2_sysfs *)tmp;
#line 602
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 602
    return (-22L);
  } else {

  }
#line 603
  tmp___0 = pvr2_hdw_get_desc(sfp->channel.hdw);
#line 603
  tmp___1 = scnprintf(buf, 4096UL, "%s\n", tmp___0);
#line 603
  return ((ssize_t )tmp___1);
}
}
#line 608 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t v4l_radio_minor_number_show(struct device *class_dev , struct device_attribute *attr ,
                                           char *buf ) 
{ 
  struct pvr2_sysfs *sfp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 613
  tmp = dev_get_drvdata((struct device  const  *)class_dev);
#line 613
  sfp = (struct pvr2_sysfs *)tmp;
#line 614
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 614
    return (-22L);
  } else {

  }
#line 615
  tmp___0 = pvr2_hdw_v4l_get_minor_number(sfp->channel.hdw, 2);
#line 615
  tmp___1 = scnprintf(buf, 4096UL, "%d\n", tmp___0);
#line 615
  return ((ssize_t )tmp___1);
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t unit_number_show(struct device *class_dev , struct device_attribute *attr ,
                                char *buf ) 
{ 
  struct pvr2_sysfs *sfp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 625
  tmp = dev_get_drvdata((struct device  const  *)class_dev);
#line 625
  sfp = (struct pvr2_sysfs *)tmp;
#line 626
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 626
    return (-22L);
  } else {

  }
#line 627
  tmp___0 = pvr2_hdw_get_unit_number(sfp->channel.hdw);
#line 627
  tmp___1 = scnprintf(buf, 4096UL, "%d\n", tmp___0);
#line 627
  return ((ssize_t )tmp___1);
}
}
#line 632 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static void class_dev_create(struct pvr2_sysfs *sfp , struct pvr2_sysfs_class *class_ptr___0 ) 
{ 
  struct usb_device *usb_dev ;
  struct device *class_dev ;
  int ret ;
  void *tmp ;
  char const   *tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  struct lock_class_key __key___4 ;

  {
#line 639
  usb_dev = pvr2_hdw_get_dev(sfp->channel.hdw);
#line 640
  if ((unsigned long )usb_dev == (unsigned long )((struct usb_device *)0)) {
#line 640
    return;
  } else {

  }
#line 641
  tmp = kzalloc(1416UL, 208U);
#line 641
  class_dev = (struct device *)tmp;
#line 642
  if ((unsigned long )class_dev == (unsigned long )((struct device *)0)) {
#line 642
    return;
  } else {

  }
#line 644
  if ((pvrusb2_debug & 16384) != 0) {
#line 644
    printk("\016pvrusb2: Creating class_dev id=%p\n", class_dev);
  } else {

  }
#line 646
  class_dev->class = & class_ptr___0->class;
#line 648
  tmp___0 = pvr2_hdw_get_device_identifier(sfp->channel.hdw);
#line 648
  dev_set_name(class_dev, "%s", tmp___0);
#line 651
  class_dev->parent = get_device(& usb_dev->dev);
#line 653
  sfp->class_dev = class_dev;
#line 654
  dev_set_drvdata(class_dev, (void *)sfp);
#line 655
  ret = device_register(class_dev);
#line 656
  if (ret != 0) {
#line 657
    if ((pvrusb2_debug & 2) != 0) {
#line 657
      printk("\016pvrusb2: device_register failed\n");
    } else {

    }
#line 659
    put_device(class_dev);
#line 660
    return;
  } else {

  }
#line 663
  sfp->attr_v4l_minor_number.attr.key = & __key;
#line 664
  sfp->attr_v4l_minor_number.attr.name = "v4l_minor_number";
#line 665
  sfp->attr_v4l_minor_number.attr.mode = 292U;
#line 666
  sfp->attr_v4l_minor_number.show = & v4l_minor_number_show;
#line 667
  sfp->attr_v4l_minor_number.store = (ssize_t (*)(struct device * , struct device_attribute * ,
                                                  char const   * , size_t  ))0;
#line 668
  ret = device_create_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_v4l_minor_number));
#line 670
  if (ret < 0) {
#line 671
    if ((pvrusb2_debug & 2) != 0) {
#line 671
      printk("\016pvrusb2: device_create_file error: %d\n", ret);
    } else {

    }
  } else {
#line 675
    sfp->v4l_minor_number_created_ok = 1;
  }
#line 678
  sfp->attr_v4l_radio_minor_number.attr.key = & __key___0;
#line 679
  sfp->attr_v4l_radio_minor_number.attr.name = "v4l_radio_minor_number";
#line 680
  sfp->attr_v4l_radio_minor_number.attr.mode = 292U;
#line 681
  sfp->attr_v4l_radio_minor_number.show = & v4l_radio_minor_number_show;
#line 682
  sfp->attr_v4l_radio_minor_number.store = (ssize_t (*)(struct device * , struct device_attribute * ,
                                                        char const   * , size_t  ))0;
#line 683
  ret = device_create_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_v4l_radio_minor_number));
#line 685
  if (ret < 0) {
#line 686
    if ((pvrusb2_debug & 2) != 0) {
#line 686
      printk("\016pvrusb2: device_create_file error: %d\n", ret);
    } else {

    }
  } else {
#line 690
    sfp->v4l_radio_minor_number_created_ok = 1;
  }
#line 693
  sfp->attr_unit_number.attr.key = & __key___1;
#line 694
  sfp->attr_unit_number.attr.name = "unit_number";
#line 695
  sfp->attr_unit_number.attr.mode = 292U;
#line 696
  sfp->attr_unit_number.show = & unit_number_show;
#line 697
  sfp->attr_unit_number.store = (ssize_t (*)(struct device * , struct device_attribute * ,
                                             char const   * , size_t  ))0;
#line 698
  ret = device_create_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_unit_number));
#line 699
  if (ret < 0) {
#line 700
    if ((pvrusb2_debug & 2) != 0) {
#line 700
      printk("\016pvrusb2: device_create_file error: %d\n", ret);
    } else {

    }
  } else {
#line 704
    sfp->unit_number_created_ok = 1;
  }
#line 707
  sfp->attr_bus_info.attr.key = & __key___2;
#line 708
  sfp->attr_bus_info.attr.name = "bus_info_str";
#line 709
  sfp->attr_bus_info.attr.mode = 292U;
#line 710
  sfp->attr_bus_info.show = & bus_info_show;
#line 711
  sfp->attr_bus_info.store = (ssize_t (*)(struct device * , struct device_attribute * ,
                                          char const   * , size_t  ))0;
#line 712
  ret = device_create_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_bus_info));
#line 714
  if (ret < 0) {
#line 715
    if ((pvrusb2_debug & 2) != 0) {
#line 715
      printk("\016pvrusb2: device_create_file error: %d\n", ret);
    } else {

    }
  } else {
#line 719
    sfp->bus_info_created_ok = 1;
  }
#line 722
  sfp->attr_hdw_name.attr.key = & __key___3;
#line 723
  sfp->attr_hdw_name.attr.name = "device_hardware_type";
#line 724
  sfp->attr_hdw_name.attr.mode = 292U;
#line 725
  sfp->attr_hdw_name.show = & hdw_name_show;
#line 726
  sfp->attr_hdw_name.store = (ssize_t (*)(struct device * , struct device_attribute * ,
                                          char const   * , size_t  ))0;
#line 727
  ret = device_create_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_hdw_name));
#line 729
  if (ret < 0) {
#line 730
    if ((pvrusb2_debug & 2) != 0) {
#line 730
      printk("\016pvrusb2: device_create_file error: %d\n", ret);
    } else {

    }
  } else {
#line 734
    sfp->hdw_name_created_ok = 1;
  }
#line 737
  sfp->attr_hdw_desc.attr.key = & __key___4;
#line 738
  sfp->attr_hdw_desc.attr.name = "device_hardware_description";
#line 739
  sfp->attr_hdw_desc.attr.mode = 292U;
#line 740
  sfp->attr_hdw_desc.show = & hdw_desc_show;
#line 741
  sfp->attr_hdw_desc.store = (ssize_t (*)(struct device * , struct device_attribute * ,
                                          char const   * , size_t  ))0;
#line 742
  ret = device_create_file(sfp->class_dev, (struct device_attribute  const  *)(& sfp->attr_hdw_desc));
#line 744
  if (ret < 0) {
#line 745
    if ((pvrusb2_debug & 2) != 0) {
#line 745
      printk("\016pvrusb2: device_create_file error: %d\n", ret);
    } else {

    }
  } else {
#line 749
    sfp->hdw_desc_created_ok = 1;
  }
#line 752
  pvr2_sysfs_add_controls(sfp);
#line 754
  pvr2_sysfs_add_debugifc(sfp);
#line 755
  return;
}
}
#line 759 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static void pvr2_sysfs_internal_check(struct pvr2_channel *chp ) 
{ 
  struct pvr2_sysfs *sfp ;
  struct pvr2_channel  const  *__mptr ;

  {
#line 762
  __mptr = (struct pvr2_channel  const  *)chp;
#line 762
  sfp = (struct pvr2_sysfs *)__mptr;
#line 763
  if ((sfp->channel.mc_head)->disconnect_flag == 0) {
#line 763
    return;
  } else {

  }
#line 764
  if ((pvrusb2_debug & 2048) != 0) {
#line 764
    printk("\016pvrusb2: Destroying pvr2_sysfs id=%p\n", sfp);
  } else {

  }
#line 765
  class_dev_destroy(sfp);
#line 766
  pvr2_channel_done(& sfp->channel);
#line 767
  kfree((void const   *)sfp);
#line 768
  return;
}
}
#line 771 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
struct pvr2_sysfs *pvr2_sysfs_create(struct pvr2_context *mp , struct pvr2_sysfs_class *class_ptr___0 ) 
{ 
  struct pvr2_sysfs *sfp ;
  void *tmp ;

  {
#line 775
  tmp = kzalloc(400UL, 208U);
#line 775
  sfp = (struct pvr2_sysfs *)tmp;
#line 776
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 776
    return (sfp);
  } else {

  }
#line 777
  if ((pvrusb2_debug & 2048) != 0) {
#line 777
    printk("\016pvrusb2: Creating pvr2_sysfs id=%p\n", sfp);
  } else {

  }
#line 778
  pvr2_channel_init(& sfp->channel, mp);
#line 779
  sfp->channel.check_func = & pvr2_sysfs_internal_check;
#line 781
  class_dev_create(sfp, class_ptr___0);
#line 782
  return (sfp);
}
}
#line 787 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
struct pvr2_sysfs_class *pvr2_sysfs_class_create(void) 
{ 
  struct pvr2_sysfs_class *clp ;
  void *tmp ;
  struct lock_class_key __key ;
  int tmp___0 ;

  {
#line 790
  tmp = kzalloc(120UL, 208U);
#line 790
  clp = (struct pvr2_sysfs_class *)tmp;
#line 791
  if ((unsigned long )clp == (unsigned long )((struct pvr2_sysfs_class *)0)) {
#line 791
    return (clp);
  } else {

  }
#line 792
  if ((pvrusb2_debug & 16384) != 0) {
#line 792
    printk("\016pvrusb2: Creating and registering pvr2_sysfs_class id=%p\n", clp);
  } else {

  }
#line 794
  clp->class.name = "pvrusb2";
#line 795
  clp->class.class_release = & pvr2_sysfs_class_release;
#line 796
  clp->class.dev_release = & pvr2_sysfs_release;
#line 797
  tmp___0 = __class_register(& clp->class, & __key);
#line 797
  if (tmp___0 != 0) {
#line 798
    if ((pvrusb2_debug & 16384) != 0) {
#line 798
      printk("\016pvrusb2: Registration failed for pvr2_sysfs_class id=%p\n", clp);
    } else {

    }
#line 800
    kfree((void const   *)clp);
#line 801
    clp = (struct pvr2_sysfs_class *)0;
  } else {

  }
#line 803
  return (clp);
}
}
#line 807 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
void pvr2_sysfs_class_destroy(struct pvr2_sysfs_class *clp ) 
{ 


  {
#line 809
  if ((pvrusb2_debug & 16384) != 0) {
#line 809
    printk("\016pvrusb2: Unregistering pvr2_sysfs_class id=%p\n", clp);
  } else {

  }
#line 810
  class_unregister(& clp->class);
#line 811
  return;
}
}
#line 815 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t debuginfo_show(struct device *class_dev , struct device_attribute *attr ,
                              char *buf ) 
{ 
  struct pvr2_sysfs *sfp ;
  void *tmp ;
  int tmp___0 ;

  {
#line 819
  tmp = dev_get_drvdata((struct device  const  *)class_dev);
#line 819
  sfp = (struct pvr2_sysfs *)tmp;
#line 820
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 820
    return (-22L);
  } else {

  }
#line 821
  pvr2_hdw_trigger_module_log(sfp->channel.hdw);
#line 822
  tmp___0 = pvr2_debugifc_print_info(sfp->channel.hdw, buf, 4096U);
#line 822
  return ((ssize_t )tmp___0);
}
}
#line 826 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t debugcmd_show(struct device *class_dev , struct device_attribute *attr ,
                             char *buf ) 
{ 
  struct pvr2_sysfs *sfp ;
  void *tmp ;
  int tmp___0 ;

  {
#line 830
  tmp = dev_get_drvdata((struct device  const  *)class_dev);
#line 830
  sfp = (struct pvr2_sysfs *)tmp;
#line 831
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 831
    return (-22L);
  } else {

  }
#line 832
  tmp___0 = pvr2_debugifc_print_status(sfp->channel.hdw, buf, 4096U);
#line 832
  return ((ssize_t )tmp___0);
}
}
#line 836 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.c"
static ssize_t debugcmd_store(struct device *class_dev , struct device_attribute *attr ,
                              char const   *buf , size_t count ) 
{ 
  struct pvr2_sysfs *sfp ;
  int ret ;
  void *tmp ;

  {
#line 843
  tmp = dev_get_drvdata((struct device  const  *)class_dev);
#line 843
  sfp = (struct pvr2_sysfs *)tmp;
#line 844
  if ((unsigned long )sfp == (unsigned long )((struct pvr2_sysfs *)0)) {
#line 844
    return (-22L);
  } else {

  }
#line 846
  ret = pvr2_debugifc_docmd(sfp->channel.hdw, buf, (unsigned int )count);
#line 847
  if (ret < 0) {
#line 847
    return ((ssize_t )ret);
  } else {

  }
#line 848
  return ((ssize_t )count);
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
bool ldv_queue_work_on_810(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 354
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 354
  ldv_func_res = tmp;
#line 356
  activate_work_1(ldv_func_arg3, 2);
#line 358
  return (ldv_func_res);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
bool ldv_queue_delayed_work_on_811(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 365
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 365
  ldv_func_res = tmp;
#line 367
  activate_work_1(& ldv_func_arg3->work, 2);
#line 369
  return (ldv_func_res);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
bool ldv_queue_work_on_812(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 376
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 376
  ldv_func_res = tmp;
#line 378
  activate_work_1(ldv_func_arg3, 2);
#line 380
  return (ldv_func_res);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
void ldv_flush_workqueue_813(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 386
  flush_workqueue(ldv_func_arg1);
#line 388
  call_and_disable_all_1(2);
#line 389
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
bool ldv_queue_delayed_work_on_814(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 395
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 395
  ldv_func_res = tmp;
#line 397
  activate_work_1(& ldv_func_arg3->work, 2);
#line 399
  return (ldv_func_res);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
void ldv_mutex_lock_815(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 405
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 407
  mutex_lock(ldv_func_arg1);
#line 408
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
void ldv_mutex_unlock_816(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 413
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 415
  mutex_unlock(ldv_func_arg1);
#line 416
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
void ldv_mutex_lock_817(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 421
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 423
  mutex_lock(ldv_func_arg1);
#line 424
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
int ldv_mutex_trylock_818(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 430
  tmp = mutex_trylock(ldv_func_arg1);
#line 430
  ldv_func_res = tmp;
#line 432
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 432
  return (tmp___0);
#line 434
  return (ldv_func_res);
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
void ldv_mutex_unlock_819(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 440
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 442
  mutex_unlock(ldv_func_arg1);
#line 443
  return;
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
void ldv_mutex_unlock_820(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 448
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 450
  mutex_unlock(ldv_func_arg1);
#line 451
  return;
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-sysfs.o.c.prepared"
void ldv_mutex_lock_821(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 456
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 458
  mutex_lock(ldv_func_arg1);
#line 459
  return;
}
}
#line 514 "include/linux/kernel.h"
extern int hex_to_bin(char  ) ;
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_846(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_844(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_847(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_848(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
void ldv_mutex_lock_843(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_845(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_849(struct mutex *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_838(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_840(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_839(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_842(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_841(struct workqueue_struct *ldv_func_arg1 ) ;
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.c"
static unsigned int debugifc_count_whitespace(char const   *buf , unsigned int count ) 
{ 
  unsigned int scnt ;
  char ch ;

  {
#line 38
  scnt = 0U;
#line 38
  goto ldv_29407;
  ldv_29406: 
#line 39
  ch = *(buf + (unsigned long )scnt);
#line 40
  if ((int )((signed char )ch) == 32) {
#line 40
    goto ldv_29404;
  } else {

  }
#line 41
  if ((int )((signed char )ch) == 9) {
#line 41
    goto ldv_29404;
  } else {

  }
#line 42
  if ((int )((signed char )ch) == 10) {
#line 42
    goto ldv_29404;
  } else {

  }
#line 43
  goto ldv_29405;
  ldv_29404: 
#line 38
  scnt = scnt + 1U;
  ldv_29407: ;
#line 38
  if (scnt < count) {
#line 40
    goto ldv_29406;
  } else {

  }
  ldv_29405: ;
#line 45
  return (scnt);
}
}
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.c"
static unsigned int debugifc_count_nonwhitespace(char const   *buf , unsigned int count ) 
{ 
  unsigned int scnt ;
  char ch ;

  {
#line 55
  scnt = 0U;
#line 55
  goto ldv_29416;
  ldv_29415: 
#line 56
  ch = *(buf + (unsigned long )scnt);
#line 57
  if ((int )((signed char )ch) == 32) {
#line 57
    goto ldv_29414;
  } else {

  }
#line 58
  if ((int )((signed char )ch) == 9) {
#line 58
    goto ldv_29414;
  } else {

  }
#line 59
  if ((int )((signed char )ch) == 10) {
#line 59
    goto ldv_29414;
  } else {

  }
#line 55
  scnt = scnt + 1U;
  ldv_29416: ;
#line 55
  if (scnt < count) {
#line 57
    goto ldv_29415;
  } else {

  }
  ldv_29414: ;
#line 61
  return (scnt);
}
}
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.c"
static unsigned int debugifc_isolate_word(char const   *buf , unsigned int count ,
                                          char const   **wstrPtr , unsigned int *wlenPtr ) 
{ 
  char const   *wptr ;
  unsigned int consume_cnt ;
  unsigned int wlen ;
  unsigned int scnt ;

  {
#line 70
  consume_cnt = 0U;
#line 74
  wptr = (char const   *)0;
#line 75
  wlen = 0U;
#line 76
  scnt = debugifc_count_whitespace(buf, count);
#line 77
  consume_cnt = consume_cnt + scnt;
#line 77
  count = count - scnt;
#line 77
  buf = buf + (unsigned long )scnt;
#line 78
  if (count == 0U) {
#line 78
    goto done;
  } else {

  }
#line 80
  scnt = debugifc_count_nonwhitespace(buf, count);
#line 81
  if (scnt == 0U) {
#line 81
    goto done;
  } else {

  }
#line 82
  wptr = buf;
#line 83
  wlen = scnt;
#line 84
  consume_cnt = consume_cnt + scnt;
#line 84
  count = count - scnt;
#line 84
  buf = buf + (unsigned long )scnt;
  done: 
#line 87
  *wstrPtr = wptr;
#line 88
  *wlenPtr = wlen;
#line 89
  return (consume_cnt);
}
}
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.c"
static int debugifc_parse_unsigned_number(char const   *buf , unsigned int count ,
                                          u32 *num_ptr ) 
{ 
  u32 result ;
  int radix ;
  int val ;
  char const   *tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 96
  result = 0U;
#line 97
  radix = 10;
#line 98
  if ((count > 1U && (int )((signed char )*buf) == 48) && ((int )((signed char )*(buf + 1UL)) == 120 || (int )((signed char )*(buf + 1UL)) == 88)) {
#line 100
    radix = 16;
#line 101
    count = count - 2U;
#line 102
    buf = buf + 2UL;
  } else
#line 103
  if (count != 0U && (int )((signed char )*buf) == 48) {
#line 104
    radix = 8;
  } else {

  }
#line 107
  goto ldv_29437;
  ldv_29436: 
#line 108
  tmp = buf;
#line 108
  buf = buf + 1;
#line 108
  tmp___0 = hex_to_bin((int )*tmp);
#line 108
  val = tmp___0;
#line 109
  if (val < 0 || val >= radix) {
#line 110
    return (-22);
  } else {

  }
#line 111
  result = result * (u32 )radix;
#line 112
  result = result + (u32 )val;
  ldv_29437: 
#line 107
  tmp___1 = count;
#line 107
  count = count - 1U;
#line 107
  if (tmp___1 != 0U) {
#line 109
    goto ldv_29436;
  } else {

  }
#line 114
  *num_ptr = result;
#line 115
  return (0);
}
}
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.c"
static int debugifc_match_keyword(char const   *buf , unsigned int count , char const   *keyword ) 
{ 
  unsigned int kl ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 123
  if ((unsigned long )keyword == (unsigned long )((char const   *)0)) {
#line 123
    return (0);
  } else {

  }
#line 124
  tmp = strlen(keyword);
#line 124
  kl = (unsigned int )tmp;
#line 125
  if (kl != count) {
#line 125
    return (0);
  } else {

  }
#line 126
  tmp___0 = memcmp((void const   *)buf, (void const   *)keyword, (size_t )kl);
#line 126
  return (tmp___0 == 0);
}
}
#line 130 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.c"
int pvr2_debugifc_print_info(struct pvr2_hdw *hdw , char *buf , unsigned int acnt ) 
{ 
  int bcnt ;
  int ccnt ;
  char const   *tmp ;
  unsigned int tmp___0 ;

  {
#line 132
  bcnt = 0;
#line 134
  tmp = pvr2_hdw_get_desc(hdw);
#line 134
  ccnt = scnprintf(buf, (size_t )acnt, "Driver hardware description: %s\n", tmp);
#line 136
  bcnt = bcnt + ccnt;
#line 136
  acnt = acnt - (unsigned int )ccnt;
#line 136
  buf = buf + (unsigned long )ccnt;
#line 137
  ccnt = scnprintf(buf, (size_t )acnt, "Driver state info:\n");
#line 138
  bcnt = bcnt + ccnt;
#line 138
  acnt = acnt - (unsigned int )ccnt;
#line 138
  buf = buf + (unsigned long )ccnt;
#line 139
  tmp___0 = pvr2_hdw_state_report(hdw, buf, acnt);
#line 139
  ccnt = (int )tmp___0;
#line 140
  bcnt = bcnt + ccnt;
#line 140
  acnt = acnt - (unsigned int )ccnt;
#line 140
  buf = buf + (unsigned long )ccnt;
#line 142
  return (bcnt);
}
}
#line 146 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.c"
int pvr2_debugifc_print_status(struct pvr2_hdw *hdw , char *buf , unsigned int acnt ) 
{ 
  int bcnt ;
  int ccnt ;
  int ret ;
  u32 gpio_dir ;
  u32 gpio_in ;
  u32 gpio_out ;
  struct pvr2_stream_stats stats ;
  struct pvr2_stream *sp ;
  int tmp ;

  {
#line 149
  bcnt = 0;
#line 156
  ret = pvr2_hdw_is_hsm(hdw);
#line 157
  ccnt = scnprintf(buf, (size_t )acnt, "USB link speed: %s\n", ret >= 0 ? (ret != 0 ? (char *)"high" : (char *)"full") : (char *)"FAIL");
#line 159
  bcnt = bcnt + ccnt;
#line 159
  acnt = acnt - (unsigned int )ccnt;
#line 159
  buf = buf + (unsigned long )ccnt;
#line 161
  gpio_dir = 0U;
#line 161
  gpio_in = 0U;
#line 161
  gpio_out = 0U;
#line 162
  pvr2_hdw_gpio_get_dir(hdw, & gpio_dir);
#line 163
  pvr2_hdw_gpio_get_out(hdw, & gpio_out);
#line 164
  pvr2_hdw_gpio_get_in(hdw, & gpio_in);
#line 165
  ccnt = scnprintf(buf, (size_t )acnt, "GPIO state: dir=0x%x in=0x%x out=0x%x\n",
                   gpio_dir, gpio_in, gpio_out);
#line 167
  bcnt = bcnt + ccnt;
#line 167
  acnt = acnt - (unsigned int )ccnt;
#line 167
  buf = buf + (unsigned long )ccnt;
#line 169
  tmp = pvr2_hdw_get_streaming(hdw);
#line 169
  ccnt = scnprintf(buf, (size_t )acnt, "Streaming is %s\n", tmp != 0 ? (char *)"on" : (char *)"off");
#line 171
  bcnt = bcnt + ccnt;
#line 171
  acnt = acnt - (unsigned int )ccnt;
#line 171
  buf = buf + (unsigned long )ccnt;
#line 174
  sp = pvr2_hdw_get_video_stream(hdw);
#line 175
  if ((unsigned long )sp != (unsigned long )((struct pvr2_stream *)0)) {
#line 176
    pvr2_stream_get_stats(sp, & stats, 0);
#line 177
    ccnt = scnprintf(buf, (size_t )acnt, "Bytes streamed=%u URBs: queued=%u idle=%u ready=%u processed=%u failed=%u\n",
                     stats.bytes_processed, stats.buffers_in_queue, stats.buffers_in_idle,
                     stats.buffers_in_ready, stats.buffers_processed, stats.buffers_failed);
#line 188
    bcnt = bcnt + ccnt;
#line 188
    acnt = acnt - (unsigned int )ccnt;
#line 188
    buf = buf + (unsigned long )ccnt;
  } else {

  }
#line 191
  return (bcnt);
}
}
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.c"
static int pvr2_debugifc_do1cmd(struct pvr2_hdw *hdw , char const   *buf , unsigned int count ) 
{ 
  char const   *wptr ;
  unsigned int wlen ;
  unsigned int scnt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct pvr2_stream *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int dir_fl ;
  int ret ;
  u32 msk ;
  u32 val ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 202
  scnt = debugifc_isolate_word(buf, count, & wptr, & wlen);
#line 203
  if (scnt == 0U) {
#line 203
    return (0);
  } else {

  }
#line 204
  count = count - scnt;
#line 204
  buf = buf + (unsigned long )scnt;
#line 205
  if ((unsigned long )wptr == (unsigned long )((char const   *)0)) {
#line 205
    return (0);
  } else {

  }
#line 207
  if ((pvrusb2_debug & 67108864) != 0) {
#line 207
    printk("\016pvrusb2: debugifc cmd: \"%.*s\"\n", wlen, wptr);
  } else {

  }
#line 208
  tmp___22 = debugifc_match_keyword(wptr, wlen, "reset");
#line 208
  if (tmp___22 != 0) {
#line 209
    scnt = debugifc_isolate_word(buf, count, & wptr, & wlen);
#line 210
    if (scnt == 0U) {
#line 210
      return (-22);
    } else {

    }
#line 211
    count = count - scnt;
#line 211
    buf = buf + (unsigned long )scnt;
#line 212
    if ((unsigned long )wptr == (unsigned long )((char const   *)0)) {
#line 212
      return (-22);
    } else {

    }
#line 213
    tmp___12 = debugifc_match_keyword(wptr, wlen, "cpu");
#line 213
    if (tmp___12 != 0) {
#line 214
      pvr2_hdw_cpureset_assert(hdw, 1);
#line 215
      pvr2_hdw_cpureset_assert(hdw, 0);
#line 216
      return (0);
    } else {
#line 217
      tmp___11 = debugifc_match_keyword(wptr, wlen, "bus");
#line 217
      if (tmp___11 != 0) {
#line 218
        pvr2_hdw_device_reset(hdw);
      } else {
#line 219
        tmp___10 = debugifc_match_keyword(wptr, wlen, "soft");
#line 219
        if (tmp___10 != 0) {
#line 220
          tmp = pvr2_hdw_cmd_powerup(hdw);
#line 220
          return (tmp);
        } else {
#line 221
          tmp___9 = debugifc_match_keyword(wptr, wlen, "deep");
#line 221
          if (tmp___9 != 0) {
#line 222
            tmp___0 = pvr2_hdw_cmd_deep_reset(hdw);
#line 222
            return (tmp___0);
          } else {
#line 223
            tmp___8 = debugifc_match_keyword(wptr, wlen, "firmware");
#line 223
            if (tmp___8 != 0) {
#line 224
              tmp___1 = pvr2_upload_firmware2(hdw);
#line 224
              return (tmp___1);
            } else {
#line 225
              tmp___7 = debugifc_match_keyword(wptr, wlen, "decoder");
#line 225
              if (tmp___7 != 0) {
#line 226
                tmp___2 = pvr2_hdw_cmd_decoder_reset(hdw);
#line 226
                return (tmp___2);
              } else {
#line 227
                tmp___6 = debugifc_match_keyword(wptr, wlen, "worker");
#line 227
                if (tmp___6 != 0) {
#line 228
                  tmp___3 = pvr2_hdw_untrip(hdw);
#line 228
                  return (tmp___3);
                } else {
#line 229
                  tmp___5 = debugifc_match_keyword(wptr, wlen, "usbstats");
#line 229
                  if (tmp___5 != 0) {
#line 230
                    tmp___4 = pvr2_hdw_get_video_stream(hdw);
#line 230
                    pvr2_stream_get_stats(tmp___4, (struct pvr2_stream_stats *)0,
                                          1);
#line 232
                    return (0);
                  } else {

                  }
                }
              }
            }
          }
        }
      }
    }
#line 234
    return (-22);
  } else {
#line 235
    tmp___21 = debugifc_match_keyword(wptr, wlen, "cpufw");
#line 235
    if (tmp___21 != 0) {
#line 236
      scnt = debugifc_isolate_word(buf, count, & wptr, & wlen);
#line 237
      if (scnt == 0U) {
#line 237
        return (-22);
      } else {

      }
#line 238
      count = count - scnt;
#line 238
      buf = buf + (unsigned long )scnt;
#line 239
      if ((unsigned long )wptr == (unsigned long )((char const   *)0)) {
#line 239
        return (-22);
      } else {

      }
#line 240
      tmp___17 = debugifc_match_keyword(wptr, wlen, "fetch");
#line 240
      if (tmp___17 != 0) {
#line 241
        scnt = debugifc_isolate_word(buf, count, & wptr, & wlen);
#line 242
        if (scnt != 0U && (unsigned long )wptr != (unsigned long )((char const   *)0)) {
#line 243
          count = count - scnt;
#line 243
          buf = buf + (unsigned long )scnt;
#line 244
          tmp___15 = debugifc_match_keyword(wptr, wlen, "prom");
#line 244
          if (tmp___15 != 0) {
#line 246
            pvr2_hdw_cpufw_set_enabled(hdw, 2, 1);
          } else {
#line 247
            tmp___14 = debugifc_match_keyword(wptr, wlen, "ram8k");
#line 247
            if (tmp___14 != 0) {
#line 249
              pvr2_hdw_cpufw_set_enabled(hdw, 0, 1);
            } else {
#line 250
              tmp___13 = debugifc_match_keyword(wptr, wlen, "ram16k");
#line 250
              if (tmp___13 != 0) {
#line 252
                pvr2_hdw_cpufw_set_enabled(hdw, 1, 1);
              } else {
#line 254
                return (-22);
              }
            }
          }
        } else {

        }
#line 257
        pvr2_hdw_cpufw_set_enabled(hdw, 0, 1);
#line 258
        return (0);
      } else {
#line 259
        tmp___16 = debugifc_match_keyword(wptr, wlen, "done");
#line 259
        if (tmp___16 != 0) {
#line 260
          pvr2_hdw_cpufw_set_enabled(hdw, 0, 0);
#line 261
          return (0);
        } else {
#line 263
          return (-22);
        }
      }
    } else {
#line 265
      tmp___20 = debugifc_match_keyword(wptr, wlen, "gpio");
#line 265
      if (tmp___20 != 0) {
#line 266
        dir_fl = 0;
#line 269
        scnt = debugifc_isolate_word(buf, count, & wptr, & wlen);
#line 270
        if (scnt == 0U) {
#line 270
          return (-22);
        } else {

        }
#line 271
        count = count - scnt;
#line 271
        buf = buf + (unsigned long )scnt;
#line 272
        if ((unsigned long )wptr == (unsigned long )((char const   *)0)) {
#line 272
          return (-22);
        } else {

        }
#line 273
        tmp___19 = debugifc_match_keyword(wptr, wlen, "dir");
#line 273
        if (tmp___19 != 0) {
#line 274
          dir_fl = 1;
        } else {
#line 275
          tmp___18 = debugifc_match_keyword(wptr, wlen, "out");
#line 275
          if (tmp___18 == 0) {
#line 276
            return (-22);
          } else {

          }
        }
#line 278
        scnt = debugifc_isolate_word(buf, count, & wptr, & wlen);
#line 279
        if (scnt == 0U) {
#line 279
          return (-22);
        } else {

        }
#line 280
        count = count - scnt;
#line 280
        buf = buf + (unsigned long )scnt;
#line 281
        if ((unsigned long )wptr == (unsigned long )((char const   *)0)) {
#line 281
          return (-22);
        } else {

        }
#line 282
        ret = debugifc_parse_unsigned_number(wptr, wlen, & msk);
#line 283
        if (ret != 0) {
#line 283
          return (ret);
        } else {

        }
#line 284
        scnt = debugifc_isolate_word(buf, count, & wptr, & wlen);
#line 285
        if ((unsigned long )wptr != (unsigned long )((char const   *)0)) {
#line 286
          ret = debugifc_parse_unsigned_number(wptr, wlen, & val);
#line 287
          if (ret != 0) {
#line 287
            return (ret);
          } else {

          }
        } else {
#line 289
          val = msk;
#line 290
          msk = 4294967295U;
        }
#line 292
        if (dir_fl != 0) {
#line 293
          ret = pvr2_hdw_gpio_chg_dir(hdw, msk, val);
        } else {
#line 295
          ret = pvr2_hdw_gpio_chg_out(hdw, msk, val);
        }
#line 297
        return (ret);
      } else {

      }
    }
  }
#line 299
  if ((pvrusb2_debug & 67108864) != 0) {
#line 299
    printk("\016pvrusb2: debugifc failed to recognize cmd: \"%.*s\"\n", wlen, wptr);
  } else {

  }
#line 301
  return (-22);
}
}
#line 305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.c"
int pvr2_debugifc_docmd(struct pvr2_hdw *hdw , char const   *buf , unsigned int count ) 
{ 
  unsigned int bcnt ;
  int ret ;

  {
#line 308
  bcnt = 0U;
#line 311
  goto ldv_29488;
  ldv_29487: 
#line 312
  bcnt = 0U;
#line 312
  goto ldv_29486;
  ldv_29485: ;
#line 313
  if ((int )((signed char )*(buf + (unsigned long )bcnt)) == 10) {
#line 313
    goto ldv_29484;
  } else {

  }
#line 312
  bcnt = bcnt + 1U;
  ldv_29486: ;
#line 312
  if (bcnt < count) {
#line 314
    goto ldv_29485;
  } else {

  }
  ldv_29484: 
#line 316
  ret = pvr2_debugifc_do1cmd(hdw, buf, bcnt);
#line 317
  if (ret < 0) {
#line 317
    return (ret);
  } else {

  }
#line 318
  if (bcnt < count) {
#line 318
    bcnt = bcnt + 1U;
  } else {

  }
#line 319
  buf = buf + (unsigned long )bcnt;
#line 320
  count = count - bcnt;
  ldv_29488: ;
#line 311
  if (count != 0U) {
#line 313
    goto ldv_29487;
  } else {

  }

#line 323
  return (0);
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
bool ldv_queue_work_on_838(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 354
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 354
  ldv_func_res = tmp;
#line 356
  activate_work_1(ldv_func_arg3, 2);
#line 358
  return (ldv_func_res);
}
}
#line 361 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
bool ldv_queue_delayed_work_on_839(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 365
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 365
  ldv_func_res = tmp;
#line 367
  activate_work_1(& ldv_func_arg3->work, 2);
#line 369
  return (ldv_func_res);
}
}
#line 372 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
bool ldv_queue_work_on_840(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 376
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 376
  ldv_func_res = tmp;
#line 378
  activate_work_1(ldv_func_arg3, 2);
#line 380
  return (ldv_func_res);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
void ldv_flush_workqueue_841(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 386
  flush_workqueue(ldv_func_arg1);
#line 388
  call_and_disable_all_1(2);
#line 389
  return;
}
}
#line 391 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
bool ldv_queue_delayed_work_on_842(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 395
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 395
  ldv_func_res = tmp;
#line 397
  activate_work_1(& ldv_func_arg3->work, 2);
#line 399
  return (ldv_func_res);
}
}
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
void ldv_mutex_lock_843(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 405
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 407
  mutex_lock(ldv_func_arg1);
#line 408
  return;
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
void ldv_mutex_unlock_844(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 413
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 415
  mutex_unlock(ldv_func_arg1);
#line 416
  return;
}
}
#line 418 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
void ldv_mutex_lock_845(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 421
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 423
  mutex_lock(ldv_func_arg1);
#line 424
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
int ldv_mutex_trylock_846(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 430
  tmp = mutex_trylock(ldv_func_arg1);
#line 430
  ldv_func_res = tmp;
#line 432
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 432
  return (tmp___0);
#line 434
  return (ldv_func_res);
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
void ldv_mutex_unlock_847(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 440
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 442
  mutex_unlock(ldv_func_arg1);
#line 443
  return;
}
}
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
void ldv_mutex_unlock_848(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 448
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 450
  mutex_unlock(ldv_func_arg1);
#line 451
  return;
}
}
#line 453 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/pvrusb2/pvrusb2-debugifc.o.c.prepared"
void ldv_mutex_lock_849(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 456
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 458
  mutex_lock(ldv_func_arg1);
#line 459
  return;
}
}
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
#line 34
  tmp = ldv_undef_int();
#line 34
  ret = tmp;
#line 36
  if (ret >= 0) {
#line 36
    ldv_stop();
  } else {

  }
#line 38
  return (ret);
}
}
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 8 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_big_lock_mutex_of_pvr2_hdw  =    1;
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_big_lock_mutex_of_pvr2_hdw(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 16
  if (ldv_mutex_big_lock_mutex_of_pvr2_hdw != 1) {
#line 16
    ldv_error();
  } else {

  }
#line 19
  nondetermined = ldv_undef_int();
#line 22
  if (nondetermined != 0) {
#line 25
    ldv_mutex_big_lock_mutex_of_pvr2_hdw = 2;
#line 27
    return (0);
  } else {
#line 32
    return (-4);
  }
}
}
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_big_lock_mutex_of_pvr2_hdw(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 42
  if (ldv_mutex_big_lock_mutex_of_pvr2_hdw != 1) {
#line 42
    ldv_error();
  } else {

  }
#line 45
  nondetermined = ldv_undef_int();
#line 48
  if (nondetermined != 0) {
#line 51
    ldv_mutex_big_lock_mutex_of_pvr2_hdw = 2;
#line 53
    return (0);
  } else {
#line 58
    return (-4);
  }
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw(struct mutex *lock ) 
{ 


  {
#line 66
  if (ldv_mutex_big_lock_mutex_of_pvr2_hdw != 1) {
#line 66
    ldv_error();
  } else {

  }
#line 68
  ldv_mutex_big_lock_mutex_of_pvr2_hdw = 2;
#line 69
  return;
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_big_lock_mutex_of_pvr2_hdw(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 77
  if (ldv_mutex_big_lock_mutex_of_pvr2_hdw != 1) {
#line 77
    ldv_error();
  } else {

  }
#line 80
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 83
  if (is_mutex_held_by_another_thread != 0) {
#line 86
    return (0);
  } else {
#line 91
    ldv_mutex_big_lock_mutex_of_pvr2_hdw = 2;
#line 93
    return (1);
  }
}
}
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_big_lock_mutex_of_pvr2_hdw(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 103
  if (ldv_mutex_big_lock_mutex_of_pvr2_hdw != 1) {
#line 103
    ldv_error();
  } else {

  }
#line 106
  atomic_value_after_dec = ldv_undef_int();
#line 109
  if (atomic_value_after_dec == 0) {
#line 112
    ldv_mutex_big_lock_mutex_of_pvr2_hdw = 2;
#line 114
    return (1);
  } else {

  }
#line 118
  return (0);
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_big_lock_mutex_of_pvr2_hdw(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 127
  if (ldv_mutex_big_lock_mutex_of_pvr2_hdw == 1) {
#line 130
    nondetermined = ldv_undef_int();
#line 133
    if (nondetermined != 0) {
#line 136
      return (0);
    } else {
#line 141
      return (1);
    }
  } else {
#line 147
    return (1);
  }
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw(struct mutex *lock ) 
{ 


  {
#line 155
  if (ldv_mutex_big_lock_mutex_of_pvr2_hdw != 2) {
#line 155
    ldv_error();
  } else {

  }
#line 157
  ldv_mutex_big_lock_mutex_of_pvr2_hdw = 1;
#line 158
  return;
}
}
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_big_lock_mutex_of_pvr2_hdw(void) 
{ 


  {
#line 166
  ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw((struct mutex *)0);
#line 167
  return;
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_big_lock_mutex_of_pvr2_hdw(void) 
{ 
  int tmp ;

  {
#line 172
  tmp = ldv_mutex_trylock_big_lock_mutex_of_pvr2_hdw((struct mutex *)0);
#line 172
  return (tmp);
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_big_lock_mutex_of_pvr2_hdw(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 178
  tmp___0 = ldv_undef_int();
#line 178
  if (tmp___0 != 0) {
#line 180
    ldv_mutex_lock_big_lock_mutex_of_pvr2_hdw((struct mutex *)0);
#line 182
    return (0);
  } else {
#line 185
    tmp = ldv_undef_int_negative();
#line 185
    return (tmp);
  }
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_big_lock_mutex_of_pvr2_hdw(void) 
{ 


  {
#line 191
  ldv_mutex_unlock_big_lock_mutex_of_pvr2_hdw((struct mutex *)0);
#line 192
  return;
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_ctl_lock_mutex_of_pvr2_hdw  =    1;
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_ctl_lock_mutex_of_pvr2_hdw(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 202
  if (ldv_mutex_ctl_lock_mutex_of_pvr2_hdw != 1) {
#line 202
    ldv_error();
  } else {

  }
#line 205
  nondetermined = ldv_undef_int();
#line 208
  if (nondetermined != 0) {
#line 211
    ldv_mutex_ctl_lock_mutex_of_pvr2_hdw = 2;
#line 213
    return (0);
  } else {
#line 218
    return (-4);
  }
}
}
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_ctl_lock_mutex_of_pvr2_hdw(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 228
  if (ldv_mutex_ctl_lock_mutex_of_pvr2_hdw != 1) {
#line 228
    ldv_error();
  } else {

  }
#line 231
  nondetermined = ldv_undef_int();
#line 234
  if (nondetermined != 0) {
#line 237
    ldv_mutex_ctl_lock_mutex_of_pvr2_hdw = 2;
#line 239
    return (0);
  } else {
#line 244
    return (-4);
  }
}
}
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_ctl_lock_mutex_of_pvr2_hdw(struct mutex *lock ) 
{ 


  {
#line 252
  if (ldv_mutex_ctl_lock_mutex_of_pvr2_hdw != 1) {
#line 252
    ldv_error();
  } else {

  }
#line 254
  ldv_mutex_ctl_lock_mutex_of_pvr2_hdw = 2;
#line 255
  return;
}
}
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_ctl_lock_mutex_of_pvr2_hdw(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 263
  if (ldv_mutex_ctl_lock_mutex_of_pvr2_hdw != 1) {
#line 263
    ldv_error();
  } else {

  }
#line 266
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 269
  if (is_mutex_held_by_another_thread != 0) {
#line 272
    return (0);
  } else {
#line 277
    ldv_mutex_ctl_lock_mutex_of_pvr2_hdw = 2;
#line 279
    return (1);
  }
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_ctl_lock_mutex_of_pvr2_hdw(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 289
  if (ldv_mutex_ctl_lock_mutex_of_pvr2_hdw != 1) {
#line 289
    ldv_error();
  } else {

  }
#line 292
  atomic_value_after_dec = ldv_undef_int();
#line 295
  if (atomic_value_after_dec == 0) {
#line 298
    ldv_mutex_ctl_lock_mutex_of_pvr2_hdw = 2;
#line 300
    return (1);
  } else {

  }
#line 304
  return (0);
}
}
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_ctl_lock_mutex_of_pvr2_hdw(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 313
  if (ldv_mutex_ctl_lock_mutex_of_pvr2_hdw == 1) {
#line 316
    nondetermined = ldv_undef_int();
#line 319
    if (nondetermined != 0) {
#line 322
      return (0);
    } else {
#line 327
      return (1);
    }
  } else {
#line 333
    return (1);
  }
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_ctl_lock_mutex_of_pvr2_hdw(struct mutex *lock ) 
{ 


  {
#line 341
  if (ldv_mutex_ctl_lock_mutex_of_pvr2_hdw != 2) {
#line 341
    ldv_error();
  } else {

  }
#line 343
  ldv_mutex_ctl_lock_mutex_of_pvr2_hdw = 1;
#line 344
  return;
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_ctl_lock_mutex_of_pvr2_hdw(void) 
{ 


  {
#line 352
  ldv_mutex_lock_ctl_lock_mutex_of_pvr2_hdw((struct mutex *)0);
#line 353
  return;
}
}
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_ctl_lock_mutex_of_pvr2_hdw(void) 
{ 
  int tmp ;

  {
#line 358
  tmp = ldv_mutex_trylock_ctl_lock_mutex_of_pvr2_hdw((struct mutex *)0);
#line 358
  return (tmp);
}
}
#line 362 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_ctl_lock_mutex_of_pvr2_hdw(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 364
  tmp___0 = ldv_undef_int();
#line 364
  if (tmp___0 != 0) {
#line 366
    ldv_mutex_lock_ctl_lock_mutex_of_pvr2_hdw((struct mutex *)0);
#line 368
    return (0);
  } else {
#line 371
    tmp = ldv_undef_int_negative();
#line 371
    return (tmp);
  }
}
}
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_ctl_lock_mutex_of_pvr2_hdw(void) 
{ 


  {
#line 377
  ldv_mutex_unlock_ctl_lock_mutex_of_pvr2_hdw((struct mutex *)0);
#line 378
  return;
}
}
#line 380 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_i_mutex_of_inode  =    1;
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 388
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 388
    ldv_error();
  } else {

  }
#line 391
  nondetermined = ldv_undef_int();
#line 394
  if (nondetermined != 0) {
#line 397
    ldv_mutex_i_mutex_of_inode = 2;
#line 399
    return (0);
  } else {
#line 404
    return (-4);
  }
}
}
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 414
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 414
    ldv_error();
  } else {

  }
#line 417
  nondetermined = ldv_undef_int();
#line 420
  if (nondetermined != 0) {
#line 423
    ldv_mutex_i_mutex_of_inode = 2;
#line 425
    return (0);
  } else {
#line 430
    return (-4);
  }
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
#line 438
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 438
    ldv_error();
  } else {

  }
#line 440
  ldv_mutex_i_mutex_of_inode = 2;
#line 441
  return;
}
}
#line 444 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 449
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 449
    ldv_error();
  } else {

  }
#line 452
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 455
  if (is_mutex_held_by_another_thread != 0) {
#line 458
    return (0);
  } else {
#line 463
    ldv_mutex_i_mutex_of_inode = 2;
#line 465
    return (1);
  }
}
}
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_i_mutex_of_inode(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 475
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 475
    ldv_error();
  } else {

  }
#line 478
  atomic_value_after_dec = ldv_undef_int();
#line 481
  if (atomic_value_after_dec == 0) {
#line 484
    ldv_mutex_i_mutex_of_inode = 2;
#line 486
    return (1);
  } else {

  }
#line 490
  return (0);
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 499
  if (ldv_mutex_i_mutex_of_inode == 1) {
#line 502
    nondetermined = ldv_undef_int();
#line 505
    if (nondetermined != 0) {
#line 508
      return (0);
    } else {
#line 513
      return (1);
    }
  } else {
#line 519
    return (1);
  }
}
}
#line 524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
#line 527
  if (ldv_mutex_i_mutex_of_inode != 2) {
#line 527
    ldv_error();
  } else {

  }
#line 529
  ldv_mutex_i_mutex_of_inode = 1;
#line 530
  return;
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_i_mutex_of_inode(void) 
{ 


  {
#line 538
  ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
#line 539
  return;
}
}
#line 542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_i_mutex_of_inode(void) 
{ 
  int tmp ;

  {
#line 544
  tmp = ldv_mutex_trylock_i_mutex_of_inode((struct mutex *)0);
#line 544
  return (tmp);
}
}
#line 548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_i_mutex_of_inode(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 550
  tmp___0 = ldv_undef_int();
#line 550
  if (tmp___0 != 0) {
#line 552
    ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
#line 554
    return (0);
  } else {
#line 557
    tmp = ldv_undef_int_negative();
#line 557
    return (tmp);
  }
}
}
#line 561 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_i_mutex_of_inode(void) 
{ 


  {
#line 563
  ldv_mutex_unlock_i_mutex_of_inode((struct mutex *)0);
#line 564
  return;
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock  =    1;
#line 569 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 574
  if (ldv_mutex_lock != 1) {
#line 574
    ldv_error();
  } else {

  }
#line 577
  nondetermined = ldv_undef_int();
#line 580
  if (nondetermined != 0) {
#line 583
    ldv_mutex_lock = 2;
#line 585
    return (0);
  } else {
#line 590
    return (-4);
  }
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 600
  if (ldv_mutex_lock != 1) {
#line 600
    ldv_error();
  } else {

  }
#line 603
  nondetermined = ldv_undef_int();
#line 606
  if (nondetermined != 0) {
#line 609
    ldv_mutex_lock = 2;
#line 611
    return (0);
  } else {
#line 616
    return (-4);
  }
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
#line 624
  if (ldv_mutex_lock != 1) {
#line 624
    ldv_error();
  } else {

  }
#line 626
  ldv_mutex_lock = 2;
#line 627
  return;
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 635
  if (ldv_mutex_lock != 1) {
#line 635
    ldv_error();
  } else {

  }
#line 638
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 641
  if (is_mutex_held_by_another_thread != 0) {
#line 644
    return (0);
  } else {
#line 649
    ldv_mutex_lock = 2;
#line 651
    return (1);
  }
}
}
#line 656 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 661
  if (ldv_mutex_lock != 1) {
#line 661
    ldv_error();
  } else {

  }
#line 664
  atomic_value_after_dec = ldv_undef_int();
#line 667
  if (atomic_value_after_dec == 0) {
#line 670
    ldv_mutex_lock = 2;
#line 672
    return (1);
  } else {

  }
#line 676
  return (0);
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 685
  if (ldv_mutex_lock == 1) {
#line 688
    nondetermined = ldv_undef_int();
#line 691
    if (nondetermined != 0) {
#line 694
      return (0);
    } else {
#line 699
      return (1);
    }
  } else {
#line 705
    return (1);
  }
}
}
#line 710 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
#line 713
  if (ldv_mutex_lock != 2) {
#line 713
    ldv_error();
  } else {

  }
#line 715
  ldv_mutex_lock = 1;
#line 716
  return;
}
}
#line 721 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_lock(void) 
{ 


  {
#line 724
  ldv_mutex_lock_lock((struct mutex *)0);
#line 725
  return;
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_lock(void) 
{ 
  int tmp ;

  {
#line 730
  tmp = ldv_mutex_trylock_lock((struct mutex *)0);
#line 730
  return (tmp);
}
}
#line 734 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_lock(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 736
  tmp___0 = ldv_undef_int();
#line 736
  if (tmp___0 != 0) {
#line 738
    ldv_mutex_lock_lock((struct mutex *)0);
#line 740
    return (0);
  } else {
#line 743
    tmp = ldv_undef_int_negative();
#line 743
    return (tmp);
  }
}
}
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_lock(void) 
{ 


  {
#line 749
  ldv_mutex_unlock_lock((struct mutex *)0);
#line 750
  return;
}
}
#line 752 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock_of_pvr2_dvb_adapter  =    1;
#line 755 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock_of_pvr2_dvb_adapter(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 760
  if (ldv_mutex_lock_of_pvr2_dvb_adapter != 1) {
#line 760
    ldv_error();
  } else {

  }
#line 763
  nondetermined = ldv_undef_int();
#line 766
  if (nondetermined != 0) {
#line 769
    ldv_mutex_lock_of_pvr2_dvb_adapter = 2;
#line 771
    return (0);
  } else {
#line 776
    return (-4);
  }
}
}
#line 781 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock_of_pvr2_dvb_adapter(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 786
  if (ldv_mutex_lock_of_pvr2_dvb_adapter != 1) {
#line 786
    ldv_error();
  } else {

  }
#line 789
  nondetermined = ldv_undef_int();
#line 792
  if (nondetermined != 0) {
#line 795
    ldv_mutex_lock_of_pvr2_dvb_adapter = 2;
#line 797
    return (0);
  } else {
#line 802
    return (-4);
  }
}
}
#line 807 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock_of_pvr2_dvb_adapter(struct mutex *lock ) 
{ 


  {
#line 810
  if (ldv_mutex_lock_of_pvr2_dvb_adapter != 1) {
#line 810
    ldv_error();
  } else {

  }
#line 812
  ldv_mutex_lock_of_pvr2_dvb_adapter = 2;
#line 813
  return;
}
}
#line 816 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock_of_pvr2_dvb_adapter(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 821
  if (ldv_mutex_lock_of_pvr2_dvb_adapter != 1) {
#line 821
    ldv_error();
  } else {

  }
#line 824
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 827
  if (is_mutex_held_by_another_thread != 0) {
#line 830
    return (0);
  } else {
#line 835
    ldv_mutex_lock_of_pvr2_dvb_adapter = 2;
#line 837
    return (1);
  }
}
}
#line 842 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock_of_pvr2_dvb_adapter(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 847
  if (ldv_mutex_lock_of_pvr2_dvb_adapter != 1) {
#line 847
    ldv_error();
  } else {

  }
#line 850
  atomic_value_after_dec = ldv_undef_int();
#line 853
  if (atomic_value_after_dec == 0) {
#line 856
    ldv_mutex_lock_of_pvr2_dvb_adapter = 2;
#line 858
    return (1);
  } else {

  }
#line 862
  return (0);
}
}
#line 867 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock_of_pvr2_dvb_adapter(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 871
  if (ldv_mutex_lock_of_pvr2_dvb_adapter == 1) {
#line 874
    nondetermined = ldv_undef_int();
#line 877
    if (nondetermined != 0) {
#line 880
      return (0);
    } else {
#line 885
      return (1);
    }
  } else {
#line 891
    return (1);
  }
}
}
#line 896 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock_of_pvr2_dvb_adapter(struct mutex *lock ) 
{ 


  {
#line 899
  if (ldv_mutex_lock_of_pvr2_dvb_adapter != 2) {
#line 899
    ldv_error();
  } else {

  }
#line 901
  ldv_mutex_lock_of_pvr2_dvb_adapter = 1;
#line 902
  return;
}
}
#line 907 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_lock_of_pvr2_dvb_adapter(void) 
{ 


  {
#line 910
  ldv_mutex_lock_lock_of_pvr2_dvb_adapter((struct mutex *)0);
#line 911
  return;
}
}
#line 914 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_lock_of_pvr2_dvb_adapter(void) 
{ 
  int tmp ;

  {
#line 916
  tmp = ldv_mutex_trylock_lock_of_pvr2_dvb_adapter((struct mutex *)0);
#line 916
  return (tmp);
}
}
#line 920 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_lock_of_pvr2_dvb_adapter(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 922
  tmp___0 = ldv_undef_int();
#line 922
  if (tmp___0 != 0) {
#line 924
    ldv_mutex_lock_lock_of_pvr2_dvb_adapter((struct mutex *)0);
#line 926
    return (0);
  } else {
#line 929
    tmp = ldv_undef_int_negative();
#line 929
    return (tmp);
  }
}
}
#line 933 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_lock_of_pvr2_dvb_adapter(void) 
{ 


  {
#line 935
  ldv_mutex_unlock_lock_of_pvr2_dvb_adapter((struct mutex *)0);
#line 936
  return;
}
}
#line 938 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock_of_v4l2_ctrl_handler  =    1;
#line 941 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 946
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 1) {
#line 946
    ldv_error();
  } else {

  }
#line 949
  nondetermined = ldv_undef_int();
#line 952
  if (nondetermined != 0) {
#line 955
    ldv_mutex_lock_of_v4l2_ctrl_handler = 2;
#line 957
    return (0);
  } else {
#line 962
    return (-4);
  }
}
}
#line 967 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 972
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 1) {
#line 972
    ldv_error();
  } else {

  }
#line 975
  nondetermined = ldv_undef_int();
#line 978
  if (nondetermined != 0) {
#line 981
    ldv_mutex_lock_of_v4l2_ctrl_handler = 2;
#line 983
    return (0);
  } else {
#line 988
    return (-4);
  }
}
}
#line 993 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 


  {
#line 996
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 1) {
#line 996
    ldv_error();
  } else {

  }
#line 998
  ldv_mutex_lock_of_v4l2_ctrl_handler = 2;
#line 999
  return;
}
}
#line 1002 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1007
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 1) {
#line 1007
    ldv_error();
  } else {

  }
#line 1010
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 1013
  if (is_mutex_held_by_another_thread != 0) {
#line 1016
    return (0);
  } else {
#line 1021
    ldv_mutex_lock_of_v4l2_ctrl_handler = 2;
#line 1023
    return (1);
  }
}
}
#line 1028 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock_of_v4l2_ctrl_handler(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1033
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 1) {
#line 1033
    ldv_error();
  } else {

  }
#line 1036
  atomic_value_after_dec = ldv_undef_int();
#line 1039
  if (atomic_value_after_dec == 0) {
#line 1042
    ldv_mutex_lock_of_v4l2_ctrl_handler = 2;
#line 1044
    return (1);
  } else {

  }
#line 1048
  return (0);
}
}
#line 1053 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1057
  if (ldv_mutex_lock_of_v4l2_ctrl_handler == 1) {
#line 1060
    nondetermined = ldv_undef_int();
#line 1063
    if (nondetermined != 0) {
#line 1066
      return (0);
    } else {
#line 1071
      return (1);
    }
  } else {
#line 1077
    return (1);
  }
}
}
#line 1082 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 


  {
#line 1085
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 2) {
#line 1085
    ldv_error();
  } else {

  }
#line 1087
  ldv_mutex_lock_of_v4l2_ctrl_handler = 1;
#line 1088
  return;
}
}
#line 1093 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_lock_of_v4l2_ctrl_handler(void) 
{ 


  {
#line 1096
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler((struct mutex *)0);
#line 1097
  return;
}
}
#line 1100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_lock_of_v4l2_ctrl_handler(void) 
{ 
  int tmp ;

  {
#line 1102
  tmp = ldv_mutex_trylock_lock_of_v4l2_ctrl_handler((struct mutex *)0);
#line 1102
  return (tmp);
}
}
#line 1106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_lock_of_v4l2_ctrl_handler(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1108
  tmp___0 = ldv_undef_int();
#line 1108
  if (tmp___0 != 0) {
#line 1110
    ldv_mutex_lock_lock_of_v4l2_ctrl_handler((struct mutex *)0);
#line 1112
    return (0);
  } else {
#line 1115
    tmp = ldv_undef_int_negative();
#line 1115
    return (tmp);
  }
}
}
#line 1119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_lock_of_v4l2_ctrl_handler(void) 
{ 


  {
#line 1121
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler((struct mutex *)0);
#line 1122
  return;
}
}
#line 1124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_device  =    1;
#line 1127 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1132
  if (ldv_mutex_mutex_of_device != 1) {
#line 1132
    ldv_error();
  } else {

  }
#line 1135
  nondetermined = ldv_undef_int();
#line 1138
  if (nondetermined != 0) {
#line 1141
    ldv_mutex_mutex_of_device = 2;
#line 1143
    return (0);
  } else {
#line 1148
    return (-4);
  }
}
}
#line 1153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1158
  if (ldv_mutex_mutex_of_device != 1) {
#line 1158
    ldv_error();
  } else {

  }
#line 1161
  nondetermined = ldv_undef_int();
#line 1164
  if (nondetermined != 0) {
#line 1167
    ldv_mutex_mutex_of_device = 2;
#line 1169
    return (0);
  } else {
#line 1174
    return (-4);
  }
}
}
#line 1179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 1182
  if (ldv_mutex_mutex_of_device != 1) {
#line 1182
    ldv_error();
  } else {

  }
#line 1184
  ldv_mutex_mutex_of_device = 2;
#line 1185
  return;
}
}
#line 1188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1193
  if (ldv_mutex_mutex_of_device != 1) {
#line 1193
    ldv_error();
  } else {

  }
#line 1196
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 1199
  if (is_mutex_held_by_another_thread != 0) {
#line 1202
    return (0);
  } else {
#line 1207
    ldv_mutex_mutex_of_device = 2;
#line 1209
    return (1);
  }
}
}
#line 1214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1219
  if (ldv_mutex_mutex_of_device != 1) {
#line 1219
    ldv_error();
  } else {

  }
#line 1222
  atomic_value_after_dec = ldv_undef_int();
#line 1225
  if (atomic_value_after_dec == 0) {
#line 1228
    ldv_mutex_mutex_of_device = 2;
#line 1230
    return (1);
  } else {

  }
#line 1234
  return (0);
}
}
#line 1239 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1243
  if (ldv_mutex_mutex_of_device == 1) {
#line 1246
    nondetermined = ldv_undef_int();
#line 1249
    if (nondetermined != 0) {
#line 1252
      return (0);
    } else {
#line 1257
      return (1);
    }
  } else {
#line 1263
    return (1);
  }
}
}
#line 1268 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 1271
  if (ldv_mutex_mutex_of_device != 2) {
#line 1271
    ldv_error();
  } else {

  }
#line 1273
  ldv_mutex_mutex_of_device = 1;
#line 1274
  return;
}
}
#line 1279 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_mutex_of_device(void) 
{ 


  {
#line 1282
  ldv_mutex_lock_mutex_of_device((struct mutex *)0);
#line 1283
  return;
}
}
#line 1286 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_mutex_of_device(void) 
{ 
  int tmp ;

  {
#line 1288
  tmp = ldv_mutex_trylock_mutex_of_device((struct mutex *)0);
#line 1288
  return (tmp);
}
}
#line 1292 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_mutex_of_device(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1294
  tmp___0 = ldv_undef_int();
#line 1294
  if (tmp___0 != 0) {
#line 1296
    ldv_mutex_lock_mutex_of_device((struct mutex *)0);
#line 1298
    return (0);
  } else {
#line 1301
    tmp = ldv_undef_int_negative();
#line 1301
    return (tmp);
  }
}
}
#line 1305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_mutex_of_device(void) 
{ 


  {
#line 1307
  ldv_mutex_unlock_mutex_of_device((struct mutex *)0);
#line 1308
  return;
}
}
#line 1310 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_pvr2_context  =    1;
#line 1313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_pvr2_context(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1318
  if (ldv_mutex_mutex_of_pvr2_context != 1) {
#line 1318
    ldv_error();
  } else {

  }
#line 1321
  nondetermined = ldv_undef_int();
#line 1324
  if (nondetermined != 0) {
#line 1327
    ldv_mutex_mutex_of_pvr2_context = 2;
#line 1329
    return (0);
  } else {
#line 1334
    return (-4);
  }
}
}
#line 1339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_pvr2_context(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1344
  if (ldv_mutex_mutex_of_pvr2_context != 1) {
#line 1344
    ldv_error();
  } else {

  }
#line 1347
  nondetermined = ldv_undef_int();
#line 1350
  if (nondetermined != 0) {
#line 1353
    ldv_mutex_mutex_of_pvr2_context = 2;
#line 1355
    return (0);
  } else {
#line 1360
    return (-4);
  }
}
}
#line 1365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_pvr2_context(struct mutex *lock ) 
{ 


  {
#line 1368
  if (ldv_mutex_mutex_of_pvr2_context != 1) {
#line 1368
    ldv_error();
  } else {

  }
#line 1370
  ldv_mutex_mutex_of_pvr2_context = 2;
#line 1371
  return;
}
}
#line 1374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_pvr2_context(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1379
  if (ldv_mutex_mutex_of_pvr2_context != 1) {
#line 1379
    ldv_error();
  } else {

  }
#line 1382
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 1385
  if (is_mutex_held_by_another_thread != 0) {
#line 1388
    return (0);
  } else {
#line 1393
    ldv_mutex_mutex_of_pvr2_context = 2;
#line 1395
    return (1);
  }
}
}
#line 1400 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_pvr2_context(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1405
  if (ldv_mutex_mutex_of_pvr2_context != 1) {
#line 1405
    ldv_error();
  } else {

  }
#line 1408
  atomic_value_after_dec = ldv_undef_int();
#line 1411
  if (atomic_value_after_dec == 0) {
#line 1414
    ldv_mutex_mutex_of_pvr2_context = 2;
#line 1416
    return (1);
  } else {

  }
#line 1420
  return (0);
}
}
#line 1425 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_pvr2_context(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1429
  if (ldv_mutex_mutex_of_pvr2_context == 1) {
#line 1432
    nondetermined = ldv_undef_int();
#line 1435
    if (nondetermined != 0) {
#line 1438
      return (0);
    } else {
#line 1443
      return (1);
    }
  } else {
#line 1449
    return (1);
  }
}
}
#line 1454 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_pvr2_context(struct mutex *lock ) 
{ 


  {
#line 1457
  if (ldv_mutex_mutex_of_pvr2_context != 2) {
#line 1457
    ldv_error();
  } else {

  }
#line 1459
  ldv_mutex_mutex_of_pvr2_context = 1;
#line 1460
  return;
}
}
#line 1465 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_mutex_of_pvr2_context(void) 
{ 


  {
#line 1468
  ldv_mutex_lock_mutex_of_pvr2_context((struct mutex *)0);
#line 1469
  return;
}
}
#line 1472 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_mutex_of_pvr2_context(void) 
{ 
  int tmp ;

  {
#line 1474
  tmp = ldv_mutex_trylock_mutex_of_pvr2_context((struct mutex *)0);
#line 1474
  return (tmp);
}
}
#line 1478 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_mutex_of_pvr2_context(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1480
  tmp___0 = ldv_undef_int();
#line 1480
  if (tmp___0 != 0) {
#line 1482
    ldv_mutex_lock_mutex_of_pvr2_context((struct mutex *)0);
#line 1484
    return (0);
  } else {
#line 1487
    tmp = ldv_undef_int_negative();
#line 1487
    return (tmp);
  }
}
}
#line 1491 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_mutex_of_pvr2_context(void) 
{ 


  {
#line 1493
  ldv_mutex_unlock_mutex_of_pvr2_context((struct mutex *)0);
#line 1494
  return;
}
}
#line 1496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_pvr2_ioread  =    1;
#line 1499 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_pvr2_ioread(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1504
  if (ldv_mutex_mutex_of_pvr2_ioread != 1) {
#line 1504
    ldv_error();
  } else {

  }
#line 1507
  nondetermined = ldv_undef_int();
#line 1510
  if (nondetermined != 0) {
#line 1513
    ldv_mutex_mutex_of_pvr2_ioread = 2;
#line 1515
    return (0);
  } else {
#line 1520
    return (-4);
  }
}
}
#line 1525 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_pvr2_ioread(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1530
  if (ldv_mutex_mutex_of_pvr2_ioread != 1) {
#line 1530
    ldv_error();
  } else {

  }
#line 1533
  nondetermined = ldv_undef_int();
#line 1536
  if (nondetermined != 0) {
#line 1539
    ldv_mutex_mutex_of_pvr2_ioread = 2;
#line 1541
    return (0);
  } else {
#line 1546
    return (-4);
  }
}
}
#line 1551 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_pvr2_ioread(struct mutex *lock ) 
{ 


  {
#line 1554
  if (ldv_mutex_mutex_of_pvr2_ioread != 1) {
#line 1554
    ldv_error();
  } else {

  }
#line 1556
  ldv_mutex_mutex_of_pvr2_ioread = 2;
#line 1557
  return;
}
}
#line 1560 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_pvr2_ioread(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1565
  if (ldv_mutex_mutex_of_pvr2_ioread != 1) {
#line 1565
    ldv_error();
  } else {

  }
#line 1568
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 1571
  if (is_mutex_held_by_another_thread != 0) {
#line 1574
    return (0);
  } else {
#line 1579
    ldv_mutex_mutex_of_pvr2_ioread = 2;
#line 1581
    return (1);
  }
}
}
#line 1586 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_pvr2_ioread(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1591
  if (ldv_mutex_mutex_of_pvr2_ioread != 1) {
#line 1591
    ldv_error();
  } else {

  }
#line 1594
  atomic_value_after_dec = ldv_undef_int();
#line 1597
  if (atomic_value_after_dec == 0) {
#line 1600
    ldv_mutex_mutex_of_pvr2_ioread = 2;
#line 1602
    return (1);
  } else {

  }
#line 1606
  return (0);
}
}
#line 1611 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_pvr2_ioread(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1615
  if (ldv_mutex_mutex_of_pvr2_ioread == 1) {
#line 1618
    nondetermined = ldv_undef_int();
#line 1621
    if (nondetermined != 0) {
#line 1624
      return (0);
    } else {
#line 1629
      return (1);
    }
  } else {
#line 1635
    return (1);
  }
}
}
#line 1640 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_pvr2_ioread(struct mutex *lock ) 
{ 


  {
#line 1643
  if (ldv_mutex_mutex_of_pvr2_ioread != 2) {
#line 1643
    ldv_error();
  } else {

  }
#line 1645
  ldv_mutex_mutex_of_pvr2_ioread = 1;
#line 1646
  return;
}
}
#line 1651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_mutex_of_pvr2_ioread(void) 
{ 


  {
#line 1654
  ldv_mutex_lock_mutex_of_pvr2_ioread((struct mutex *)0);
#line 1655
  return;
}
}
#line 1658 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_mutex_of_pvr2_ioread(void) 
{ 
  int tmp ;

  {
#line 1660
  tmp = ldv_mutex_trylock_mutex_of_pvr2_ioread((struct mutex *)0);
#line 1660
  return (tmp);
}
}
#line 1664 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_mutex_of_pvr2_ioread(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1666
  tmp___0 = ldv_undef_int();
#line 1666
  if (tmp___0 != 0) {
#line 1668
    ldv_mutex_lock_mutex_of_pvr2_ioread((struct mutex *)0);
#line 1670
    return (0);
  } else {
#line 1673
    tmp = ldv_undef_int_negative();
#line 1673
    return (tmp);
  }
}
}
#line 1677 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_mutex_of_pvr2_ioread(void) 
{ 


  {
#line 1679
  ldv_mutex_unlock_mutex_of_pvr2_ioread((struct mutex *)0);
#line 1680
  return;
}
}
#line 1682 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_pvr2_stream  =    1;
#line 1685 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_pvr2_stream(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1690
  if (ldv_mutex_mutex_of_pvr2_stream != 1) {
#line 1690
    ldv_error();
  } else {

  }
#line 1693
  nondetermined = ldv_undef_int();
#line 1696
  if (nondetermined != 0) {
#line 1699
    ldv_mutex_mutex_of_pvr2_stream = 2;
#line 1701
    return (0);
  } else {
#line 1706
    return (-4);
  }
}
}
#line 1711 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_pvr2_stream(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1716
  if (ldv_mutex_mutex_of_pvr2_stream != 1) {
#line 1716
    ldv_error();
  } else {

  }
#line 1719
  nondetermined = ldv_undef_int();
#line 1722
  if (nondetermined != 0) {
#line 1725
    ldv_mutex_mutex_of_pvr2_stream = 2;
#line 1727
    return (0);
  } else {
#line 1732
    return (-4);
  }
}
}
#line 1737 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_pvr2_stream(struct mutex *lock ) 
{ 


  {
#line 1740
  if (ldv_mutex_mutex_of_pvr2_stream != 1) {
#line 1740
    ldv_error();
  } else {

  }
#line 1742
  ldv_mutex_mutex_of_pvr2_stream = 2;
#line 1743
  return;
}
}
#line 1746 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_pvr2_stream(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1751
  if (ldv_mutex_mutex_of_pvr2_stream != 1) {
#line 1751
    ldv_error();
  } else {

  }
#line 1754
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 1757
  if (is_mutex_held_by_another_thread != 0) {
#line 1760
    return (0);
  } else {
#line 1765
    ldv_mutex_mutex_of_pvr2_stream = 2;
#line 1767
    return (1);
  }
}
}
#line 1772 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_pvr2_stream(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1777
  if (ldv_mutex_mutex_of_pvr2_stream != 1) {
#line 1777
    ldv_error();
  } else {

  }
#line 1780
  atomic_value_after_dec = ldv_undef_int();
#line 1783
  if (atomic_value_after_dec == 0) {
#line 1786
    ldv_mutex_mutex_of_pvr2_stream = 2;
#line 1788
    return (1);
  } else {

  }
#line 1792
  return (0);
}
}
#line 1797 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_pvr2_stream(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1801
  if (ldv_mutex_mutex_of_pvr2_stream == 1) {
#line 1804
    nondetermined = ldv_undef_int();
#line 1807
    if (nondetermined != 0) {
#line 1810
      return (0);
    } else {
#line 1815
      return (1);
    }
  } else {
#line 1821
    return (1);
  }
}
}
#line 1826 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_pvr2_stream(struct mutex *lock ) 
{ 


  {
#line 1829
  if (ldv_mutex_mutex_of_pvr2_stream != 2) {
#line 1829
    ldv_error();
  } else {

  }
#line 1831
  ldv_mutex_mutex_of_pvr2_stream = 1;
#line 1832
  return;
}
}
#line 1837 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_mutex_of_pvr2_stream(void) 
{ 


  {
#line 1840
  ldv_mutex_lock_mutex_of_pvr2_stream((struct mutex *)0);
#line 1841
  return;
}
}
#line 1844 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_mutex_of_pvr2_stream(void) 
{ 
  int tmp ;

  {
#line 1846
  tmp = ldv_mutex_trylock_mutex_of_pvr2_stream((struct mutex *)0);
#line 1846
  return (tmp);
}
}
#line 1850 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_mutex_of_pvr2_stream(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1852
  tmp___0 = ldv_undef_int();
#line 1852
  if (tmp___0 != 0) {
#line 1854
    ldv_mutex_lock_mutex_of_pvr2_stream((struct mutex *)0);
#line 1856
    return (0);
  } else {
#line 1859
    tmp = ldv_undef_int_negative();
#line 1859
    return (tmp);
  }
}
}
#line 1863 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_mutex_of_pvr2_stream(void) 
{ 


  {
#line 1865
  ldv_mutex_unlock_mutex_of_pvr2_stream((struct mutex *)0);
#line 1866
  return;
}
}
#line 1868 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_pvr2_context_mutex  =    1;
#line 1871 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_pvr2_context_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1876
  if (ldv_mutex_pvr2_context_mutex != 1) {
#line 1876
    ldv_error();
  } else {

  }
#line 1879
  nondetermined = ldv_undef_int();
#line 1882
  if (nondetermined != 0) {
#line 1885
    ldv_mutex_pvr2_context_mutex = 2;
#line 1887
    return (0);
  } else {
#line 1892
    return (-4);
  }
}
}
#line 1897 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_pvr2_context_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1902
  if (ldv_mutex_pvr2_context_mutex != 1) {
#line 1902
    ldv_error();
  } else {

  }
#line 1905
  nondetermined = ldv_undef_int();
#line 1908
  if (nondetermined != 0) {
#line 1911
    ldv_mutex_pvr2_context_mutex = 2;
#line 1913
    return (0);
  } else {
#line 1918
    return (-4);
  }
}
}
#line 1923 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_pvr2_context_mutex(struct mutex *lock ) 
{ 


  {
#line 1926
  if (ldv_mutex_pvr2_context_mutex != 1) {
#line 1926
    ldv_error();
  } else {

  }
#line 1928
  ldv_mutex_pvr2_context_mutex = 2;
#line 1929
  return;
}
}
#line 1932 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_pvr2_context_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 1937
  if (ldv_mutex_pvr2_context_mutex != 1) {
#line 1937
    ldv_error();
  } else {

  }
#line 1940
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 1943
  if (is_mutex_held_by_another_thread != 0) {
#line 1946
    return (0);
  } else {
#line 1951
    ldv_mutex_pvr2_context_mutex = 2;
#line 1953
    return (1);
  }
}
}
#line 1958 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_pvr2_context_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 1963
  if (ldv_mutex_pvr2_context_mutex != 1) {
#line 1963
    ldv_error();
  } else {

  }
#line 1966
  atomic_value_after_dec = ldv_undef_int();
#line 1969
  if (atomic_value_after_dec == 0) {
#line 1972
    ldv_mutex_pvr2_context_mutex = 2;
#line 1974
    return (1);
  } else {

  }
#line 1978
  return (0);
}
}
#line 1983 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_pvr2_context_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 1987
  if (ldv_mutex_pvr2_context_mutex == 1) {
#line 1990
    nondetermined = ldv_undef_int();
#line 1993
    if (nondetermined != 0) {
#line 1996
      return (0);
    } else {
#line 2001
      return (1);
    }
  } else {
#line 2007
    return (1);
  }
}
}
#line 2012 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_pvr2_context_mutex(struct mutex *lock ) 
{ 


  {
#line 2015
  if (ldv_mutex_pvr2_context_mutex != 2) {
#line 2015
    ldv_error();
  } else {

  }
#line 2017
  ldv_mutex_pvr2_context_mutex = 1;
#line 2018
  return;
}
}
#line 2023 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_pvr2_context_mutex(void) 
{ 


  {
#line 2026
  ldv_mutex_lock_pvr2_context_mutex((struct mutex *)0);
#line 2027
  return;
}
}
#line 2030 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_pvr2_context_mutex(void) 
{ 
  int tmp ;

  {
#line 2032
  tmp = ldv_mutex_trylock_pvr2_context_mutex((struct mutex *)0);
#line 2032
  return (tmp);
}
}
#line 2036 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_pvr2_context_mutex(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2038
  tmp___0 = ldv_undef_int();
#line 2038
  if (tmp___0 != 0) {
#line 2040
    ldv_mutex_lock_pvr2_context_mutex((struct mutex *)0);
#line 2042
    return (0);
  } else {
#line 2045
    tmp = ldv_undef_int_negative();
#line 2045
    return (tmp);
  }
}
}
#line 2049 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_pvr2_context_mutex(void) 
{ 


  {
#line 2051
  ldv_mutex_unlock_pvr2_context_mutex((struct mutex *)0);
#line 2052
  return;
}
}
#line 2054 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_pvr2_unit_mtx  =    1;
#line 2057 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_pvr2_unit_mtx(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 2062
  if (ldv_mutex_pvr2_unit_mtx != 1) {
#line 2062
    ldv_error();
  } else {

  }
#line 2065
  nondetermined = ldv_undef_int();
#line 2068
  if (nondetermined != 0) {
#line 2071
    ldv_mutex_pvr2_unit_mtx = 2;
#line 2073
    return (0);
  } else {
#line 2078
    return (-4);
  }
}
}
#line 2083 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_pvr2_unit_mtx(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 2088
  if (ldv_mutex_pvr2_unit_mtx != 1) {
#line 2088
    ldv_error();
  } else {

  }
#line 2091
  nondetermined = ldv_undef_int();
#line 2094
  if (nondetermined != 0) {
#line 2097
    ldv_mutex_pvr2_unit_mtx = 2;
#line 2099
    return (0);
  } else {
#line 2104
    return (-4);
  }
}
}
#line 2109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_pvr2_unit_mtx(struct mutex *lock ) 
{ 


  {
#line 2112
  if (ldv_mutex_pvr2_unit_mtx != 1) {
#line 2112
    ldv_error();
  } else {

  }
#line 2114
  ldv_mutex_pvr2_unit_mtx = 2;
#line 2115
  return;
}
}
#line 2118 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_pvr2_unit_mtx(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 2123
  if (ldv_mutex_pvr2_unit_mtx != 1) {
#line 2123
    ldv_error();
  } else {

  }
#line 2126
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 2129
  if (is_mutex_held_by_another_thread != 0) {
#line 2132
    return (0);
  } else {
#line 2137
    ldv_mutex_pvr2_unit_mtx = 2;
#line 2139
    return (1);
  }
}
}
#line 2144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_pvr2_unit_mtx(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 2149
  if (ldv_mutex_pvr2_unit_mtx != 1) {
#line 2149
    ldv_error();
  } else {

  }
#line 2152
  atomic_value_after_dec = ldv_undef_int();
#line 2155
  if (atomic_value_after_dec == 0) {
#line 2158
    ldv_mutex_pvr2_unit_mtx = 2;
#line 2160
    return (1);
  } else {

  }
#line 2164
  return (0);
}
}
#line 2169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_pvr2_unit_mtx(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 2173
  if (ldv_mutex_pvr2_unit_mtx == 1) {
#line 2176
    nondetermined = ldv_undef_int();
#line 2179
    if (nondetermined != 0) {
#line 2182
      return (0);
    } else {
#line 2187
      return (1);
    }
  } else {
#line 2193
    return (1);
  }
}
}
#line 2198 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_pvr2_unit_mtx(struct mutex *lock ) 
{ 


  {
#line 2201
  if (ldv_mutex_pvr2_unit_mtx != 2) {
#line 2201
    ldv_error();
  } else {

  }
#line 2203
  ldv_mutex_pvr2_unit_mtx = 1;
#line 2204
  return;
}
}
#line 2209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_pvr2_unit_mtx(void) 
{ 


  {
#line 2212
  ldv_mutex_lock_pvr2_unit_mtx((struct mutex *)0);
#line 2213
  return;
}
}
#line 2216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_pvr2_unit_mtx(void) 
{ 
  int tmp ;

  {
#line 2218
  tmp = ldv_mutex_trylock_pvr2_unit_mtx((struct mutex *)0);
#line 2218
  return (tmp);
}
}
#line 2222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_pvr2_unit_mtx(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2224
  tmp___0 = ldv_undef_int();
#line 2224
  if (tmp___0 != 0) {
#line 2226
    ldv_mutex_lock_pvr2_unit_mtx((struct mutex *)0);
#line 2228
    return (0);
  } else {
#line 2231
    tmp = ldv_undef_int_negative();
#line 2231
    return (tmp);
  }
}
}
#line 2235 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_pvr2_unit_mtx(void) 
{ 


  {
#line 2237
  ldv_mutex_unlock_pvr2_unit_mtx((struct mutex *)0);
#line 2238
  return;
}
}
#line 2240 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_usb_dev_of_pvr2_hdw  =    1;
#line 2243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_usb_dev_of_pvr2_hdw(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 2248
  if (ldv_mutex_usb_dev_of_pvr2_hdw != 1) {
#line 2248
    ldv_error();
  } else {

  }
#line 2251
  nondetermined = ldv_undef_int();
#line 2254
  if (nondetermined != 0) {
#line 2257
    ldv_mutex_usb_dev_of_pvr2_hdw = 2;
#line 2259
    return (0);
  } else {
#line 2264
    return (-4);
  }
}
}
#line 2269 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_usb_dev_of_pvr2_hdw(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 2274
  if (ldv_mutex_usb_dev_of_pvr2_hdw != 1) {
#line 2274
    ldv_error();
  } else {

  }
#line 2277
  nondetermined = ldv_undef_int();
#line 2280
  if (nondetermined != 0) {
#line 2283
    ldv_mutex_usb_dev_of_pvr2_hdw = 2;
#line 2285
    return (0);
  } else {
#line 2290
    return (-4);
  }
}
}
#line 2295 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_usb_dev_of_pvr2_hdw(struct mutex *lock ) 
{ 


  {
#line 2298
  if (ldv_mutex_usb_dev_of_pvr2_hdw != 1) {
#line 2298
    ldv_error();
  } else {

  }
#line 2300
  ldv_mutex_usb_dev_of_pvr2_hdw = 2;
#line 2301
  return;
}
}
#line 2304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_usb_dev_of_pvr2_hdw(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 2309
  if (ldv_mutex_usb_dev_of_pvr2_hdw != 1) {
#line 2309
    ldv_error();
  } else {

  }
#line 2312
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 2315
  if (is_mutex_held_by_another_thread != 0) {
#line 2318
    return (0);
  } else {
#line 2323
    ldv_mutex_usb_dev_of_pvr2_hdw = 2;
#line 2325
    return (1);
  }
}
}
#line 2330 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_usb_dev_of_pvr2_hdw(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 2335
  if (ldv_mutex_usb_dev_of_pvr2_hdw != 1) {
#line 2335
    ldv_error();
  } else {

  }
#line 2338
  atomic_value_after_dec = ldv_undef_int();
#line 2341
  if (atomic_value_after_dec == 0) {
#line 2344
    ldv_mutex_usb_dev_of_pvr2_hdw = 2;
#line 2346
    return (1);
  } else {

  }
#line 2350
  return (0);
}
}
#line 2355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_usb_dev_of_pvr2_hdw(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 2359
  if (ldv_mutex_usb_dev_of_pvr2_hdw == 1) {
#line 2362
    nondetermined = ldv_undef_int();
#line 2365
    if (nondetermined != 0) {
#line 2368
      return (0);
    } else {
#line 2373
      return (1);
    }
  } else {
#line 2379
    return (1);
  }
}
}
#line 2384 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_usb_dev_of_pvr2_hdw(struct mutex *lock ) 
{ 


  {
#line 2387
  if (ldv_mutex_usb_dev_of_pvr2_hdw != 2) {
#line 2387
    ldv_error();
  } else {

  }
#line 2389
  ldv_mutex_usb_dev_of_pvr2_hdw = 1;
#line 2390
  return;
}
}
#line 2395 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_usb_dev_of_pvr2_hdw(void) 
{ 


  {
#line 2398
  ldv_mutex_lock_usb_dev_of_pvr2_hdw((struct mutex *)0);
#line 2399
  return;
}
}
#line 2402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_usb_dev_of_pvr2_hdw(void) 
{ 
  int tmp ;

  {
#line 2404
  tmp = ldv_mutex_trylock_usb_dev_of_pvr2_hdw((struct mutex *)0);
#line 2404
  return (tmp);
}
}
#line 2408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_usb_dev_of_pvr2_hdw(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2410
  tmp___0 = ldv_undef_int();
#line 2410
  if (tmp___0 != 0) {
#line 2412
    ldv_mutex_lock_usb_dev_of_pvr2_hdw((struct mutex *)0);
#line 2414
    return (0);
  } else {
#line 2417
    tmp = ldv_undef_int_negative();
#line 2417
    return (tmp);
  }
}
}
#line 2421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_usb_dev_of_pvr2_hdw(void) 
{ 


  {
#line 2423
  ldv_mutex_unlock_usb_dev_of_pvr2_hdw((struct mutex *)0);
#line 2424
  return;
}
}
#line 2428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3759/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 2431
  if (ldv_mutex_big_lock_mutex_of_pvr2_hdw != 1) {
#line 2431
    ldv_error();
  } else {

  }
#line 2433
  if (ldv_mutex_ctl_lock_mutex_of_pvr2_hdw != 1) {
#line 2433
    ldv_error();
  } else {

  }
#line 2435
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 2435
    ldv_error();
  } else {

  }
#line 2437
  if (ldv_mutex_lock != 1) {
#line 2437
    ldv_error();
  } else {

  }
#line 2439
  if (ldv_mutex_lock_of_pvr2_dvb_adapter != 1) {
#line 2439
    ldv_error();
  } else {

  }
#line 2441
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 1) {
#line 2441
    ldv_error();
  } else {

  }
#line 2443
  if (ldv_mutex_mutex_of_device != 1) {
#line 2443
    ldv_error();
  } else {

  }
#line 2445
  if (ldv_mutex_mutex_of_pvr2_context != 1) {
#line 2445
    ldv_error();
  } else {

  }
#line 2447
  if (ldv_mutex_mutex_of_pvr2_ioread != 1) {
#line 2447
    ldv_error();
  } else {

  }
#line 2449
  if (ldv_mutex_mutex_of_pvr2_stream != 1) {
#line 2449
    ldv_error();
  } else {

  }
#line 2451
  if (ldv_mutex_pvr2_context_mutex != 1) {
#line 2451
    ldv_error();
  } else {

  }
#line 2453
  if (ldv_mutex_pvr2_unit_mtx != 1) {
#line 2453
    ldv_error();
  } else {

  }
#line 2455
  if (ldv_mutex_usb_dev_of_pvr2_hdw != 1) {
#line 2455
    ldv_error();
  } else {

  }
#line 2459
  return;
}
}
