extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 32 "include/uapi/linux/types.h"
typedef __u16 __le16;
#line 33 "include/uapi/linux/types.h"
typedef __u16 __be16;
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 35 "include/uapi/linux/types.h"
typedef __u32 __be32;
#line 37 "include/uapi/linux/types.h"
typedef __u64 __be64;
#line 40 "include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 91 "include/linux/types.h"
typedef unsigned int uint;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 106 "include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 152 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 162 "include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 54
struct net_device;
#line 420 "include/linux/printk.h"
struct file_operations;
#line 432
struct completion;
#line 555 "./arch/x86/include/asm/percpu.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct timespec;
#line 103
struct compat_timespec;
#line 104 "include/linux/bug.h"
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 104 "include/linux/bug.h"
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 104
struct pollfd;
#line 104 "include/linux/bug.h"
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 104 "include/linux/bug.h"
union __anonunion____missing_field_name_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};
#line 104 "include/linux/bug.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_19 __annonCompField8 ;
};
#line 328 "include/linux/bitmap.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_29 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_28 {
   struct __anonstruct____missing_field_name_29 __annonCompField12 ;
   struct __anonstruct____missing_field_name_30 __annonCompField13 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_28 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_31 __annonCompField15 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 33 "include/linux/bottom_half.h"
struct lockdep_map;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_35 __annonCompField17 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_34 __annonCompField18 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_36 rwlock_t;
#line 426 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 598 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "include/linux/highuid.h"
struct user_namespace;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_46 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_46 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_47 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_47 kgid_t;
#line 139 "include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "include/linux/stat.h"
struct vm_area_struct;
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 177
struct rw_semaphore;
#line 178 "include/linux/mutex.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 172 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 296 "include/linux/rcupdate.h"
struct notifier_block;
#line 1121 "include/linux/rcupdate.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 238 "include/linux/timer.h"
struct hrtimer;
#line 239
enum hrtimer_restart;
#line 240 "include/linux/timer.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 837 "include/uapi/linux/sysctl.h"
struct ctl_table;
#line 838
struct nsproxy;
#line 839
struct ctl_table_root;
#line 840
struct ctl_table_header;
#line 841
struct ctl_dir;
#line 37 "include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 57 "include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 96 "include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 117 "include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 122 "include/linux/sysctl.h"
struct __anonstruct____missing_field_name_50 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 122 "include/linux/sysctl.h"
union __anonunion____missing_field_name_49 {
   struct __anonstruct____missing_field_name_50 __annonCompField19 ;
   struct callback_head rcu ;
};
#line 122
struct ctl_table_set;
#line 122 "include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion____missing_field_name_49 __annonCompField20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 143 "include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 149 "include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 154 "include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 141 "include/linux/workqueue.h"
struct execute_work {
   struct work_struct work ;
};
#line 51 "include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 64 "./arch/x86/include/asm/e820.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 172 "./arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 133 "./arch/x86/include/asm/topology.h"
struct pci_bus;
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_115 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_115 mm_context_t;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 17 "include/linux/smp.h"
struct call_single_data {
   struct llist_node llist ;
   void (*func)(void * ) ;
   void *info ;
   unsigned int flags ;
};
#line 37 "include/linux/kmod.h"
struct cred;
#line 19 "./arch/x86/include/asm/elf.h"
struct inode;
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_148 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_149 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_147 {
   struct __anonstruct____missing_field_name_148 __annonCompField33 ;
   struct __anonstruct____missing_field_name_149 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_147 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_152 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_156 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   union __anonunion____missing_field_name_155 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_154 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_151 {
   union __anonunion____missing_field_name_152 __annonCompField37 ;
   union __anonunion____missing_field_name_153 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_158 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_159 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_157 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_158 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_159 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32
struct kmem_cache;
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_160 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_150 __annonCompField36 ;
   struct __anonstruct____missing_field_name_151 __annonCompField42 ;
   union __anonunion____missing_field_name_157 __annonCompField45 ;
   union __anonunion____missing_field_name_160 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_161 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_161 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
union __anonunion____missing_field_name_166 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 53 "include/linux/elf.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_166 __annonCompField47 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct dentry;
#line 186
struct iattr;
#line 187
struct super_block;
#line 188
struct file_system_type;
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 213
struct kernfs_root;
#line 213 "include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_node;
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89
struct kernfs_ops;
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_171 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_171 __annonCompField48 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
struct kobject;
#line 479
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 485 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_172 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_172 __annonCompField49 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_180 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_180 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_182 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_183 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_184 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_187 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_186 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_187 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_188 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_189 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_181 {
   int _pad[28U] ;
   struct __anonstruct__kill_182 _kill ;
   struct __anonstruct__timer_183 _timer ;
   struct __anonstruct__rt_184 _rt ;
   struct __anonstruct__sigchld_185 _sigchld ;
   struct __anonstruct__sigfault_186 _sigfault ;
   struct __anonstruct__sigpoll_188 _sigpoll ;
   struct __anonstruct__sigsys_189 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_181 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_196 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_197 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_199 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_198 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_199 __annonCompField52 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_200 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_202 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_201 {
   union __anonunion_payload_202 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_196 __annonCompField50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_197 __annonCompField51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_198 __annonCompField53 ;
   union __anonunion_type_data_200 type_data ;
   union __anonunion____missing_field_name_201 __annonCompField54 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 72 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1161
struct uts_namespace;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769
struct ftrace_ret_stack;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
struct fc_lport;
#line 30
struct scsi_cmnd;
#line 40
struct cnic_dev;
#line 42
struct fc_rport;
#line 46
struct Scsi_Host;
#line 53
struct fcoe_ctlr_device;
#line 76
struct scsi_device;
#line 78
struct fc_frame;
#line 84
struct fcoe_fcf_device;
#line 91
struct fc_vport;
#line 158 "include/linux/kmemcheck.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 21 "include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion____missing_field_name_217 {
   struct iovec  const  *iov ;
   struct kvec  const  *kvec ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion____missing_field_name_217 __annonCompField58 ;
   unsigned long nr_segs ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 38
struct kiocb;
#line 41 "include/linux/random.h"
struct rnd_state {
   __u32 s1 ;
   __u32 s2 ;
   __u32 s3 ;
   __u32 s4 ;
};
#line 54 "include/uapi/linux/net.h"
struct poll_table_struct;
#line 55
struct net;
#line 72
struct fasync_struct;
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 161 "./arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 140 "include/net/checksum.h"
struct sk_buff;
#line 176
struct klist_node;
#line 177 "include/net/checksum.h"
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
};
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct path;
#line 68 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct fwnode_handle;
#line 22
struct iommu_ops;
#line 23
struct iommu_group;
#line 61 "include/linux/device.h"
struct device_attribute;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 139
struct device_type;
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203
struct of_device_id;
#line 203
struct acpi_device_id;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 1284 "include/linux/device.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 93 "include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 64 "include/linux/page_ext.h"
struct file_ra_state;
#line 65
struct writeback_control;
#line 66
struct bdi_writeback;
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 2242 "include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 21 "include/linux/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 380 "include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 15 "include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 66 "include/linux/netdev_features.h"
union __anonunion_in6_u_218 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 66 "include/linux/netdev_features.h"
struct in6_addr {
   union __anonunion_in6_u_218 in6_u ;
};
#line 41 "include/uapi/linux/in6.h"
struct sockaddr_in6 {
   unsigned short sin6_family ;
   __be16 sin6_port ;
   __be32 sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   __u32 sin6_scope_id ;
};
#line 46 "include/linux/in6.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 218 "include/net/flow_dissector.h"
struct pipe_buf_operations;
#line 218 "include/net/flow_dissector.h"
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations  const  *ops ;
   unsigned int flags ;
   unsigned long private ;
};
#line 27 "include/linux/pipe_fs_i.h"
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
   unsigned int curbuf ;
   unsigned int buffers ;
   unsigned int readers ;
   unsigned int writers ;
   unsigned int files ;
   unsigned int waiting_writers ;
   unsigned int r_counter ;
   unsigned int w_counter ;
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};
#line 61 "include/linux/pipe_fs_i.h"
struct pipe_buf_operations {
   int can_merge ;
   int (*confirm)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*release)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   int (*steal)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*get)(struct pipe_inode_info * , struct pipe_buffer * ) ;
};
#line 86 "include/linux/splice.h"
struct napi_struct;
#line 87 "include/linux/splice.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_223 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};
#line 172 "include/linux/skbuff.h"
union __anonunion____missing_field_name_224 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};
#line 172 "include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned char orig_proto ;
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
   struct net_device *physindev ;
   union __anonunion____missing_field_name_223 __annonCompField62 ;
   union __anonunion____missing_field_name_224 __annonCompField63 ;
};
#line 189 "include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 403 "include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 404 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_227 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
#line 404 "include/linux/skbuff.h"
union __anonunion____missing_field_name_226 {
   u64 v64 ;
   struct __anonstruct____missing_field_name_227 __annonCompField64 ;
};
#line 404 "include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion____missing_field_name_226 __annonCompField65 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_230 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_229 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion____missing_field_name_230 __annonCompField66 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_228 {
   struct __anonstruct____missing_field_name_229 __annonCompField67 ;
   struct rb_node rbnode ;
};
#line 457
struct sec_path;
#line 457 "include/linux/skbuff.h"
struct __anonstruct____missing_field_name_232 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_231 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_232 __annonCompField69 ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_233 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_234 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};
#line 457 "include/linux/skbuff.h"
union __anonunion____missing_field_name_235 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};
#line 457 "include/linux/skbuff.h"
struct sk_buff {
   union __anonunion____missing_field_name_228 __annonCompField68 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff * ) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   unsigned char cloned : 1 ;
   unsigned char nohdr : 1 ;
   unsigned char fclone : 2 ;
   unsigned char peeked : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   unsigned char pkt_type : 3 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ignore_df : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char nf_trace : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char sw_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   unsigned char csum_level : 2 ;
   unsigned char csum_bad : 1 ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char inner_protocol_type : 1 ;
   unsigned char remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion____missing_field_name_231 __annonCompField70 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion____missing_field_name_233 __annonCompField71 ;
   __u32 secmark ;
   union __anonunion____missing_field_name_234 __annonCompField72 ;
   union __anonunion____missing_field_name_235 __annonCompField73 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 718
struct dst_entry;
#line 1182 "include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_237 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_237 sync_serial_settings;
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_238 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_238 te1_settings;
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_239 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_239 raw_hdlc_proto;
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_240 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_240 fr_proto;
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_241 {
   unsigned int dlci ;
};
#line 69 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_241 fr_proto_pvc;
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_242 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_242 fr_proto_pvc_info;
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_243 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "./include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_243 cisco_proto;
#line 117 "./include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 177 "./include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_244 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 177 "./include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_244 ifs_ifsu ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_245 {
   char ifrn_name[16U] ;
};
#line 195 "./include/uapi/linux/if.h"
union __anonunion_ifr_ifru_246 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 195 "./include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_245 ifr_ifrn ;
   union __anonunion_ifr_ifru_246 ifr_ifru ;
};
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_node;
#line 91 "include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_251 {
   spinlock_t lock ;
   int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion____missing_field_name_250 {
   struct __anonstruct____missing_field_name_251 __annonCompField74 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_250 __annonCompField75 ;
};
#line 50 "include/linux/lockref.h"
struct vfsmount;
#line 51 "include/linux/lockref.h"
struct __anonstruct____missing_field_name_253 {
   u32 hash ;
   u32 len ;
};
#line 51 "include/linux/lockref.h"
union __anonunion____missing_field_name_252 {
   struct __anonstruct____missing_field_name_253 __annonCompField76 ;
   u64 hash_len ;
};
#line 51 "include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_252 __annonCompField77 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_254 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_254 d_u ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
#line 585 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_258 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion____missing_field_name_257 {
   struct __anonstruct____missing_field_name_258 __annonCompField78 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_257 __annonCompField79 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 44
struct bio_set;
#line 45
struct bio;
#line 46
struct bio_integrity_payload;
#line 47
struct block_device;
#line 17 "include/linux/blk_types.h"
typedef void bio_end_io_t(struct bio * , int  );
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 28 "include/linux/blk_types.h"
struct bvec_iter {
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned int bi_idx ;
   unsigned int bi_bvec_done ;
};
#line 40 "include/linux/blk_types.h"
union __anonunion____missing_field_name_261 {
   struct bio_integrity_payload *bi_integrity ;
};
#line 40 "include/linux/blk_types.h"
struct bio {
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   struct bvec_iter bi_iter ;
   unsigned int bi_phys_segments ;
   unsigned int bi_seg_front_size ;
   unsigned int bi_seg_back_size ;
   atomic_t __bi_remaining ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct io_context *bi_ioc ;
   struct cgroup_subsys_state *bi_css ;
   union __anonunion____missing_field_name_261 __annonCompField80 ;
   unsigned short bi_vcnt ;
   unsigned short bi_max_vecs ;
   atomic_t __bi_cnt ;
   struct bio_vec *bi_io_vec ;
   struct bio_set *bi_pool ;
   struct bio_vec bi_inline_vecs[0U] ;
};
#line 60 "include/uapi/linux/fs.h"
struct export_operations;
#line 61
struct hd_geometry;
#line 62
struct kstatfs;
#line 63
struct swap_info_struct;
#line 74 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 212 "./include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_262 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_262 kprojid_t;
#line 166 "include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 66 "include/linux/quota.h"
typedef long long qsize_t;
#line 67 "include/linux/quota.h"
union __anonunion____missing_field_name_263 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 67 "include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_263 __annonCompField81 ;
   enum quota_type type ;
};
#line 184 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 206
struct quota_format_type;
#line 207 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 272 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
#line 325 "include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 348 "include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 394 "include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 405 "include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 418 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 432 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 496 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
#line 526 "include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
#line 365 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 422 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 442
struct request_queue;
#line 443
struct hd_struct;
#line 443
struct gendisk;
#line 443 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 559
struct posix_acl;
#line 560
struct inode_operations;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_266 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_267 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 560
struct file_lock_context;
#line 560
struct cdev;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_268 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
#line 560 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_266 __annonCompField82 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_267 __annonCompField83 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_268 __annonCompField84 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 806 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 814 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 837 "include/linux/fs.h"
union __anonunion_f_u_269 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 837 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_269 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 922 "include/linux/fs.h"
typedef void *fl_owner_t;
#line 923
struct file_lock;
#line 924 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 930 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 951
struct nlm_lockowner;
#line 952 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_271 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_270 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_271 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_270 fl_u ;
};
#line 1004 "include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1062 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1240 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1271
struct super_operations;
#line 1271
struct xattr_handler;
#line 1271
struct mtd_info;
#line 1271 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1510 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1524
struct dir_context;
#line 1549 "include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1555
struct block_device_operations;
#line 1556 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1617 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1910 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 18 "./arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 39 "./arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "./arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 45 "./arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 276 "include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 280 "include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 34 "include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 125 "include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 189 "include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 233 "include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};
#line 245 "include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 267 "include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 293 "include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 322 "include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 339 "include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 438 "include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 475 "include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 503 "include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 605 "include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 637 "include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 679 "include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 712 "include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 728 "include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 748 "include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 759 "include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 778 "include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 828 "include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 999 "include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 1007 "include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1083 "include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 99 "include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * , u8 const    ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*get_tunable)(struct net_device * , struct ethtool_tunable  const  * , void * ) ;
   int (*set_tunable)(struct net_device * , struct ethtool_tunable  const  * , void const   * ) ;
};
#line 235 "include/net/flow.h"
struct prot_inuse;
#line 236 "include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "include/net/snmp.h"
struct u64_stats_sync {

};
#line 146 "include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 83 "include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 93 "include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};
#line 106 "include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[115U] ;
};
#line 112 "include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118
struct proc_dir_entry;
#line 118 "include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
#line 26 "include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 179 "include/net/inet_frag.h"
struct ipv4_devconf;
#line 180
struct fib_rules_ops;
#line 181
struct fib_table;
#line 182 "include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};
#line 24 "include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 29
struct inet_peer_base;
#line 29
struct xt_table;
#line 29 "include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_tcp_ecn_fallback ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   int sysctl_tcp_probe_threshold ;
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 113
struct neighbour;
#line 113 "include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 72 "include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
   int idgen_retries ;
   int idgen_delay ;
   int flowlabel_state_ranges ;
};
#line 39 "include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 39
struct rt6_info;
#line 39
struct rt6_statistics;
#line 39
struct fib6_table;
#line 39 "include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};
#line 85 "include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 91 "include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 14 "include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};
#line 20
struct sctp_mib;
#line 21 "include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 134 "include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 39 "include/net/netns/dccp.h"
struct in_addr {
   __be32 s_addr ;
};
#line 225 "include/uapi/linux/in.h"
struct sockaddr_in {
   __kernel_sa_family_t sin_family ;
   __be16 sin_port ;
   struct in_addr sin_addr ;
   unsigned char __pad[8U] ;
};
#line 79 "include/uapi/linux/netfilter.h"
struct nf_logger;
#line 80 "include/uapi/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 19 "include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 23 "include/net/netns/x_tables.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 25 "include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 30 "include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 44 "include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 49 "include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 54 "include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 65 "include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
#line 73
struct ip_conntrack_stat;
#line 73
struct nf_ct_event_notifier;
#line 73
struct nf_exp_event_notifier;
#line 73 "include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 115
struct nft_af_info;
#line 116 "include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
   u8 gencursor ;
};
#line 465 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 672 "include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
#line 16 "include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
#line 25 "include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};
#line 21 "include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};
#line 30 "include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
#line 88
struct mpls_route;
#line 89 "include/net/netns/xfrm.h"
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};
#line 16 "include/net/netns/mpls.h"
struct proc_ns_operations;
#line 17 "include/net/netns/mpls.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations  const  *ops ;
   unsigned int inum ;
};
#line 11 "include/linux/ns_common.h"
struct net_generic;
#line 12
struct netns_ipvs;
#line 13 "include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 241 "include/net/net_namespace.h"
struct __anonstruct_possible_net_t_302 {
   struct net *net ;
};
#line 241 "include/net/net_namespace.h"
typedef struct __anonstruct_possible_net_t_302 possible_net_t;
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 650
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
} ;
#line 657 "include/linux/mod_devicetable.h"
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};
#line 32 "include/linux/of.h"
typedef u32 phandle;
#line 34 "include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
#line 44 "include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 338 "include/linux/mii.h"
enum ldv_27782 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
} ;
#line 80 "include/linux/phy.h"
typedef enum ldv_27782 phy_interface_t;
#line 126
enum ldv_27836 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
} ;
#line 133
struct phy_device;
#line 133 "include/linux/phy.h"
struct mii_bus {
   char const   *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus * , int  , int  ) ;
   int (*write)(struct mii_bus * , int  , int  , u16  ) ;
   int (*reset)(struct mii_bus * ) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_27836 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};
#line 214
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
} ;
#line 229 "include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};
#line 323
struct phy_driver;
#line 323 "include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device * ) ;
};
#line 429 "include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const   *driver_data ;
   int (*soft_reset)(struct phy_device * ) ;
   int (*config_init)(struct phy_device * ) ;
   int (*probe)(struct phy_device * ) ;
   int (*suspend)(struct phy_device * ) ;
   int (*resume)(struct phy_device * ) ;
   int (*config_aneg)(struct phy_device * ) ;
   int (*aneg_done)(struct phy_device * ) ;
   int (*read_status)(struct phy_device * ) ;
   int (*ack_interrupt)(struct phy_device * ) ;
   int (*config_intr)(struct phy_device * ) ;
   int (*did_interrupt)(struct phy_device * ) ;
   void (*remove)(struct phy_device * ) ;
   int (*match_phy_device)(struct phy_device * ) ;
   int (*ts_info)(struct phy_device * , struct ethtool_ts_info * ) ;
   int (*hwtstamp)(struct phy_device * , struct ifreq * ) ;
   bool (*rxtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   void (*txtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   int (*set_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*get_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*link_change_notify)(struct phy_device * ) ;
   int (*read_mmd_indirect)(struct phy_device * , int  , int  , int  ) ;
   void (*write_mmd_indirect)(struct phy_device * , int  , int  , int  , u32  ) ;
   int (*module_info)(struct phy_device * , struct ethtool_modinfo * ) ;
   int (*module_eeprom)(struct phy_device * , struct ethtool_eeprom * , u8 * ) ;
   struct device_driver driver ;
};
#line 803 "include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};
#line 25 "include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
} ;
#line 33 "include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};
#line 68 "include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 84
struct packet_type;
#line 85
struct dsa_switch;
#line 85 "include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 123
struct dsa_switch_driver;
#line 123 "include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 194 "include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   u32 (*get_phy_flags)(struct dsa_switch * , int  ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*adjust_link)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*fixed_link_update)(struct dsa_switch * , int  , struct fixed_phy_status * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
   void (*get_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*suspend)(struct dsa_switch * ) ;
   int (*resume)(struct dsa_switch * ) ;
   int (*port_enable)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*port_disable)(struct dsa_switch * , int  , struct phy_device * ) ;
   int (*set_eee)(struct dsa_switch * , int  , struct phy_device * , struct ethtool_eee * ) ;
   int (*get_eee)(struct dsa_switch * , int  , struct ethtool_eee * ) ;
   int (*get_temp)(struct dsa_switch * , int * ) ;
   int (*get_temp_limit)(struct dsa_switch * , int * ) ;
   int (*set_temp_limit)(struct dsa_switch * , int  ) ;
   int (*get_temp_alarm)(struct dsa_switch * , bool * ) ;
   int (*get_eeprom_len)(struct dsa_switch * ) ;
   int (*get_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_regs_len)(struct dsa_switch * , int  ) ;
   void (*get_regs)(struct dsa_switch * , int  , struct ethtool_regs * , void * ) ;
   int (*port_join_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_leave_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_stp_update)(struct dsa_switch * , int  , u8  ) ;
   int (*fdb_add)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_del)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_getnext)(struct dsa_switch * , int  , unsigned char * , bool * ) ;
};
#line 320 "include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "./include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 87 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};
#line 132 "./include/uapi/linux/dcbnl.h"
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};
#line 144 "./include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 164 "./include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 187 "./include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 202 "./include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 236 "./include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_setqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_getqcnstats)(struct net_device * , struct ieee_qcn_stats * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   int (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   int (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 105 "include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 515 "include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 1628 "include/linux/security.h"
struct mnt_namespace;
#line 1629
struct ipc_namespace;
#line 1630 "include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 147 "include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 106 "include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 182 "include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 643 "include/uapi/linux/if_link.h"
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};
#line 16 "include/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};
#line 118 "include/uapi/linux/if_bonding.h"
struct netpoll_info;
#line 119
struct wireless_dev;
#line 120
struct wpan_dev;
#line 121
struct mpls_dev;
#line 65 "include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 110 "include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 129 "include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 190
struct neigh_parms;
#line 211 "include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 216 "include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 245 "include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 295 "include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 340
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 388 "include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 389 "include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 537
struct Qdisc;
#line 537 "include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
};
#line 607 "include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 619 "include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 631 "include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 683 "include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 706 "include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 719 "include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 730 "include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 741 "include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 757 "include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 770 "include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_get_vf_stats)(struct net_device * , int  , struct ifla_vf_stats * ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device * , int  , bool  ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  , u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       struct net_device * , int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  , int  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_item_id * ) ;
   int (*ndo_get_phys_port_name)(struct net_device * , char * , size_t  ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff * , struct net_device * ,
                                           netdev_features_t  ) ;
   int (*ndo_set_tx_maxrate)(struct net_device * , int  , u32  ) ;
   int (*ndo_get_iflink)(struct net_device  const  * ) ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_adj_list_315 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257 "include/linux/netdevice.h"
struct __anonstruct_all_adj_list_316 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1257
struct iw_handler_def;
#line 1257
struct iw_public_data;
#line 1257
struct switchdev_ops;
#line 1257
struct vlan_info;
#line 1257
struct tipc_bearer;
#line 1257
struct in_device;
#line 1257
struct dn_dev;
#line 1257
struct inet6_dev;
#line 1257
struct tcf_proto;
#line 1257
struct cpu_rmap;
#line 1257
struct pcpu_lstats;
#line 1257
struct pcpu_sw_netstats;
#line 1257
struct pcpu_dstats;
#line 1257
struct pcpu_vstats;
#line 1257 "include/linux/netdevice.h"
union __anonunion____missing_field_name_317 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1257
struct garp_port;
#line 1257
struct mrp_port;
#line 1257
struct rtnl_link_ops;
#line 1257 "include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_315 adj_list ;
   struct __anonstruct_all_adj_list_316 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct switchdev_ops  const  *switchdev_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion____missing_field_name_317 __annonCompField94 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};
#line 1978 "include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   bool (*id_match)(struct packet_type * , struct sock * ) ;
   void *af_packet_priv ;
   struct list_head list ;
};
#line 2025 "include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 70 "include/linux/resource_ext.h"
struct hotplug_slot;
#line 70 "include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 110 "include/linux/pci.h"
typedef int pci_power_t;
#line 137 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 138
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 163 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 190 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 247
struct pcie_link_state;
#line 248
struct pci_vpd;
#line 249
struct pci_sriov;
#line 250
struct pci_ats;
#line 251
struct pci_driver;
#line 251 "include/linux/pci.h"
union __anonunion____missing_field_name_330 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 251 "include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned char ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char no_64bit_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   unsigned char irq_managed : 1 ;
   unsigned char has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_330 __annonCompField95 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
#line 440
struct pci_ops;
#line 440
struct msi_controller;
#line 440 "include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 563 "include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus * , unsigned int  , int  ) ;
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 591 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 605 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 615 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*reset_notify)(struct pci_dev * , bool  ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 648 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 190 "include/scsi/scsi_proto.h"
struct scsi_lun {
   __u8 scsi_lun[8U] ;
};
#line 32 "include/scsi/scsi_common.h"
struct scsi_sense_hdr {
   u8 response_code ;
   u8 sense_key ;
   u8 asc ;
   u8 ascq ;
   u8 byte4 ;
   u8 byte5 ;
   u8 byte6 ;
   u8 additional_length ;
};
#line 80 "include/linux/genhd.h"
struct disk_stats {
   unsigned long sectors[2U] ;
   unsigned long ios[2U] ;
   unsigned long merges[2U] ;
   unsigned long ticks[2U] ;
   unsigned long io_ticks ;
   unsigned long time_in_queue ;
};
#line 89 "include/linux/genhd.h"
struct partition_meta_info {
   char uuid[37U] ;
   u8 volname[64U] ;
};
#line 101 "include/linux/genhd.h"
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   seqcount_t nr_sects_seq ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
   atomic_t in_flight[2U] ;
   struct disk_stats *dkstats ;
   atomic_t ref ;
   struct callback_head callback_head ;
};
#line 155 "include/linux/genhd.h"
struct disk_part_tbl {
   struct callback_head callback_head ;
   int len ;
   struct hd_struct *last_lookup ;
   struct hd_struct *part[] ;
};
#line 162
struct disk_events;
#line 163
struct timer_rand_state;
#line 163
struct blk_integrity;
#line 163 "include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32U] ;
   char *(*devnode)(struct gendisk * , umode_t * ) ;
   unsigned int events ;
   unsigned int async_events ;
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations  const  *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct blk_integrity *integrity ;
   int node_id ;
};
#line 72 "include/linux/flex_proportions.h"
struct fprop_local_percpu {
   struct percpu_counter events ;
   unsigned int period ;
   raw_spinlock_t lock ;
};
#line 32 "include/linux/backing-dev-defs.h"
typedef int congested_fn(void * , int  );
#line 41 "include/linux/backing-dev-defs.h"
struct bdi_writeback_congested {
   unsigned long state ;
   atomic_t refcnt ;
   struct backing_dev_info *bdi ;
   int blkcg_id ;
   struct rb_node rb_node ;
};
#line 60 "include/linux/backing-dev-defs.h"
union __anonunion____missing_field_name_331 {
   struct work_struct release_work ;
   struct callback_head rcu ;
};
#line 60 "include/linux/backing-dev-defs.h"
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned long state ;
   unsigned long last_old_flush ;
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   struct list_head b_dirty_time ;
   spinlock_t list_lock ;
   struct percpu_counter stat[4U] ;
   struct bdi_writeback_congested *congested ;
   unsigned long bw_time_stamp ;
   unsigned long dirtied_stamp ;
   unsigned long written_stamp ;
   unsigned long write_bandwidth ;
   unsigned long avg_write_bandwidth ;
   unsigned long dirty_ratelimit ;
   unsigned long balanced_dirty_ratelimit ;
   struct fprop_local_percpu completions ;
   int dirty_exceeded ;
   spinlock_t work_lock ;
   struct list_head work_list ;
   struct delayed_work dwork ;
   struct percpu_ref refcnt ;
   struct fprop_local_percpu memcg_completions ;
   struct cgroup_subsys_state *memcg_css ;
   struct cgroup_subsys_state *blkcg_css ;
   struct list_head memcg_node ;
   struct list_head blkcg_node ;
   union __anonunion____missing_field_name_331 __annonCompField96 ;
};
#line 132 "include/linux/backing-dev-defs.h"
struct backing_dev_info {
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned int capabilities ;
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   unsigned int min_ratio ;
   unsigned int max_ratio ;
   unsigned int max_prop_frac ;
   atomic_long_t tot_write_bandwidth ;
   struct bdi_writeback wb ;
   struct radix_tree_root cgwb_tree ;
   struct rb_root cgwb_congested_tree ;
   atomic_t usage_cnt ;
   wait_queue_head_t wb_waitq ;
   struct device *dev ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
   struct dentry *debug_stats ;
};
#line 11 "include/linux/mempool.h"
typedef void *mempool_alloc_t(gfp_t  , void * );
#line 12 "include/linux/mempool.h"
typedef void mempool_free_t(void * , void * );
#line 13 "include/linux/mempool.h"
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
   int curr_nr ;
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};
#line 24 "include/linux/mempool.h"
typedef struct mempool_s mempool_t;
#line 78 "include/linux/mempool.h"
union __anonunion____missing_field_name_332 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};
#line 78 "include/linux/mempool.h"
union __anonunion____missing_field_name_333 {
   struct hlist_node ioc_node ;
   struct callback_head __rcu_head ;
};
#line 78 "include/linux/mempool.h"
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion____missing_field_name_332 __annonCompField97 ;
   union __anonunion____missing_field_name_333 __annonCompField98 ;
   unsigned int flags ;
};
#line 92 "include/linux/iocontext.h"
struct io_context {
   atomic_long_t refcount ;
   atomic_t active_ref ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
   int nr_batch_requests ;
   unsigned long last_waited ;
   struct radix_tree_root icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};
#line 326 "include/linux/bio.h"
struct bio_integrity_payload {
   struct bio *bip_bio ;
   struct bvec_iter bip_iter ;
   bio_end_io_t *bip_end_io ;
   unsigned short bip_slab ;
   unsigned short bip_vcnt ;
   unsigned short bip_max_vcnt ;
   unsigned short bip_flags ;
   struct work_struct bip_work ;
   struct bio_vec *bip_vec ;
   struct bio_vec bip_inline_vecs[0U] ;
};
#line 541 "include/linux/bio.h"
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};
#line 662 "include/linux/bio.h"
struct bio_set {
   struct kmem_cache *bio_slab ;
   unsigned int front_pad ;
   mempool_t *bio_pool ;
   mempool_t *bvec_pool ;
   mempool_t *bio_integrity_pool ;
   mempool_t *bvec_integrity_pool ;
   spinlock_t rescue_lock ;
   struct bio_list rescue_list ;
   struct work_struct rescue_work ;
   struct workqueue_struct *rescue_workqueue ;
};
#line 64 "include/uapi/linux/bsg.h"
struct bsg_class_device {
   struct device *class_dev ;
   struct device *parent ;
   int minor ;
   struct request_queue *queue ;
   struct kref ref ;
   void (*release)(struct device * ) ;
};
#line 22 "include/linux/bsg.h"
struct elevator_queue;
#line 23
struct blk_trace;
#line 24
struct request;
#line 26
struct bsg_job;
#line 27
struct blkcg_gq;
#line 28
struct blk_flush_queue;
#line 49 "include/linux/blkdev.h"
typedef void rq_end_io_fn(struct request * , int  );
#line 50 "include/linux/blkdev.h"
struct request_list {
   struct request_queue *q ;
   struct blkcg_gq *blkg ;
   int count[2U] ;
   int starved[2U] ;
   mempool_t *rq_pool ;
   wait_queue_head_t wait[2U] ;
   unsigned int flags ;
};
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_334 {
   struct call_single_data csd ;
   unsigned long fifo_time ;
};
#line 75
struct blk_mq_ctx;
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_335 {
   struct hlist_node hash ;
   struct list_head ipi_list ;
};
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_336 {
   struct rb_node rb_node ;
   void *completion_data ;
};
#line 75 "include/linux/blkdev.h"
struct __anonstruct_elv_338 {
   struct io_cq *icq ;
   void *priv[2U] ;
};
#line 75 "include/linux/blkdev.h"
struct __anonstruct_flush_339 {
   unsigned int seq ;
   struct list_head list ;
   rq_end_io_fn *saved_end_io ;
};
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_337 {
   struct __anonstruct_elv_338 elv ;
   struct __anonstruct_flush_339 flush ;
};
#line 75 "include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   union __anonunion____missing_field_name_334 __annonCompField99 ;
   struct request_queue *q ;
   struct blk_mq_ctx *mq_ctx ;
   u64 cmd_flags ;
   unsigned int cmd_type ;
   unsigned long atomic_flags ;
   int cpu ;
   unsigned int __data_len ;
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   union __anonunion____missing_field_name_335 __annonCompField100 ;
   union __anonunion____missing_field_name_336 __annonCompField101 ;
   union __anonunion____missing_field_name_337 __annonCompField102 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   unsigned long start_time ;
   struct request_list *rl ;
   unsigned long long start_time_ns ;
   unsigned long long io_start_time_ns ;
   unsigned short nr_phys_segments ;
   unsigned short nr_integrity_segments ;
   unsigned short ioprio ;
   void *special ;
   int tag ;
   int errors ;
   unsigned char __cmd[16U] ;
   unsigned char *cmd ;
   unsigned short cmd_len ;
   unsigned int extra_len ;
   unsigned int sense_len ;
   unsigned int resid_len ;
   void *sense ;
   unsigned long deadline ;
   struct list_head timeout_list ;
   unsigned int timeout ;
   int retries ;
   rq_end_io_fn *end_io ;
   void *end_io_data ;
   struct request *next_rq ;
};
#line 113 "include/linux/hashtable.h"
struct elevator_type;
#line 12 "include/linux/elevator.h"
typedef int elevator_merge_fn(struct request_queue * , struct request ** , struct bio * );
#line 15 "include/linux/elevator.h"
typedef void elevator_merge_req_fn(struct request_queue * , struct request * , struct request * );
#line 17 "include/linux/elevator.h"
typedef void elevator_merged_fn(struct request_queue * , struct request * , int  );
#line 19 "include/linux/elevator.h"
typedef int elevator_allow_merge_fn(struct request_queue * , struct request * , struct bio * );
#line 21 "include/linux/elevator.h"
typedef void elevator_bio_merged_fn(struct request_queue * , struct request * , struct bio * );
#line 24 "include/linux/elevator.h"
typedef int elevator_dispatch_fn(struct request_queue * , int  );
#line 26 "include/linux/elevator.h"
typedef void elevator_add_req_fn(struct request_queue * , struct request * );
#line 27 "include/linux/elevator.h"
typedef struct request *elevator_request_list_fn(struct request_queue * , struct request * );
#line 28 "include/linux/elevator.h"
typedef void elevator_completed_req_fn(struct request_queue * , struct request * );
#line 29 "include/linux/elevator.h"
typedef int elevator_may_queue_fn(struct request_queue * , int  );
#line 31 "include/linux/elevator.h"
typedef void elevator_init_icq_fn(struct io_cq * );
#line 32 "include/linux/elevator.h"
typedef void elevator_exit_icq_fn(struct io_cq * );
#line 33 "include/linux/elevator.h"
typedef int elevator_set_req_fn(struct request_queue * , struct request * , struct bio * ,
                                gfp_t  );
#line 35 "include/linux/elevator.h"
typedef void elevator_put_req_fn(struct request * );
#line 36 "include/linux/elevator.h"
typedef void elevator_activate_req_fn(struct request_queue * , struct request * );
#line 37 "include/linux/elevator.h"
typedef void elevator_deactivate_req_fn(struct request_queue * , struct request * );
#line 39 "include/linux/elevator.h"
typedef int elevator_init_fn(struct request_queue * , struct elevator_type * );
#line 41 "include/linux/elevator.h"
typedef void elevator_exit_fn(struct elevator_queue * );
#line 42 "include/linux/elevator.h"
typedef void elevator_registered_fn(struct request_queue * );
#line 43 "include/linux/elevator.h"
struct elevator_ops {
   elevator_merge_fn *elevator_merge_fn ;
   elevator_merged_fn *elevator_merged_fn ;
   elevator_merge_req_fn *elevator_merge_req_fn ;
   elevator_allow_merge_fn *elevator_allow_merge_fn ;
   elevator_bio_merged_fn *elevator_bio_merged_fn ;
   elevator_dispatch_fn *elevator_dispatch_fn ;
   elevator_add_req_fn *elevator_add_req_fn ;
   elevator_activate_req_fn *elevator_activate_req_fn ;
   elevator_deactivate_req_fn *elevator_deactivate_req_fn ;
   elevator_completed_req_fn *elevator_completed_req_fn ;
   elevator_request_list_fn *elevator_former_req_fn ;
   elevator_request_list_fn *elevator_latter_req_fn ;
   elevator_init_icq_fn *elevator_init_icq_fn ;
   elevator_exit_icq_fn *elevator_exit_icq_fn ;
   elevator_set_req_fn *elevator_set_req_fn ;
   elevator_put_req_fn *elevator_put_req_fn ;
   elevator_may_queue_fn *elevator_may_queue_fn ;
   elevator_init_fn *elevator_init_fn ;
   elevator_exit_fn *elevator_exit_fn ;
   elevator_registered_fn *elevator_registered_fn ;
};
#line 74 "include/linux/elevator.h"
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue * , char * ) ;
   ssize_t (*store)(struct elevator_queue * , char const   * , size_t  ) ;
};
#line 82 "include/linux/elevator.h"
struct elevator_type {
   struct kmem_cache *icq_cache ;
   struct elevator_ops ops ;
   size_t icq_size ;
   size_t icq_align ;
   struct elv_fs_entry *elevator_attrs ;
   char elevator_name[16U] ;
   struct module *elevator_owner ;
   char icq_cache_name[21U] ;
   struct list_head list ;
};
#line 103 "include/linux/elevator.h"
struct elevator_queue {
   struct elevator_type *type ;
   void *elevator_data ;
   struct kobject kobj ;
   struct mutex sysfs_lock ;
   unsigned char registered : 1 ;
   struct hlist_head hash[64U] ;
};
#line 210 "include/linux/blkdev.h"
typedef void request_fn_proc(struct request_queue * );
#line 211 "include/linux/blkdev.h"
typedef void make_request_fn(struct request_queue * , struct bio * );
#line 212 "include/linux/blkdev.h"
typedef int prep_rq_fn(struct request_queue * , struct request * );
#line 213 "include/linux/blkdev.h"
typedef void unprep_rq_fn(struct request_queue * , struct request * );
#line 214 "include/linux/blkdev.h"
struct bvec_merge_data {
   struct block_device *bi_bdev ;
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned long bi_rw ;
};
#line 222 "include/linux/blkdev.h"
typedef int merge_bvec_fn(struct request_queue * , struct bvec_merge_data * , struct bio_vec * );
#line 224 "include/linux/blkdev.h"
typedef void softirq_done_fn(struct request * );
#line 225 "include/linux/blkdev.h"
typedef int dma_drain_needed_fn(struct request * );
#line 226 "include/linux/blkdev.h"
typedef int lld_busy_fn(struct request_queue * );
#line 227 "include/linux/blkdev.h"
typedef int bsg_job_fn(struct bsg_job * );
#line 228
enum blk_eh_timer_return {
    BLK_EH_NOT_HANDLED = 0,
    BLK_EH_HANDLED = 1,
    BLK_EH_RESET_TIMER = 2
} ;
#line 235 "include/linux/blkdev.h"
typedef enum blk_eh_timer_return rq_timed_out_fn(struct request * );
#line 241 "include/linux/blkdev.h"
struct blk_queue_tag {
   struct request **tag_index ;
   unsigned long *tag_map ;
   int busy ;
   int max_depth ;
   int real_max_depth ;
   atomic_t refcnt ;
   int alloc_policy ;
   int next_tag ;
};
#line 252 "include/linux/blkdev.h"
struct queue_limits {
   unsigned long bounce_pfn ;
   unsigned long seg_boundary_mask ;
   unsigned int max_hw_sectors ;
   unsigned int chunk_sectors ;
   unsigned int max_sectors ;
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
   unsigned int alignment_offset ;
   unsigned int io_min ;
   unsigned int io_opt ;
   unsigned int max_discard_sectors ;
   unsigned int max_write_same_sectors ;
   unsigned int discard_granularity ;
   unsigned int discard_alignment ;
   unsigned short logical_block_size ;
   unsigned short max_segments ;
   unsigned short max_integrity_segments ;
   unsigned char misaligned ;
   unsigned char discard_misaligned ;
   unsigned char cluster ;
   unsigned char discard_zeroes_data ;
   unsigned char raid_partial_stripes_expensive ;
};
#line 285
struct blk_mq_ops;
#line 285
struct blk_mq_hw_ctx;
#line 285
struct throtl_data;
#line 285
struct blk_mq_tag_set;
#line 285 "include/linux/blkdev.h"
struct request_queue {
   struct list_head queue_head ;
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   int nr_rqs[2U] ;
   int nr_rqs_elvpriv ;
   struct request_list root_rl ;
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   prep_rq_fn *prep_rq_fn ;
   unprep_rq_fn *unprep_rq_fn ;
   merge_bvec_fn *merge_bvec_fn ;
   softirq_done_fn *softirq_done_fn ;
   rq_timed_out_fn *rq_timed_out_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   lld_busy_fn *lld_busy_fn ;
   struct blk_mq_ops *mq_ops ;
   unsigned int *mq_map ;
   struct blk_mq_ctx *queue_ctx ;
   unsigned int nr_queues ;
   struct blk_mq_hw_ctx **queue_hw_ctx ;
   unsigned int nr_hw_queues ;
   sector_t end_sector ;
   struct request *boundary_rq ;
   struct delayed_work delay_work ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   int id ;
   gfp_t bounce_gfp ;
   spinlock_t __queue_lock ;
   spinlock_t *queue_lock ;
   struct kobject kobj ;
   struct kobject mq_kobj ;
   struct device *dev ;
   int rpm_status ;
   unsigned int nr_pending ;
   unsigned long nr_requests ;
   unsigned int nr_congestion_on ;
   unsigned int nr_congestion_off ;
   unsigned int nr_batching ;
   unsigned int dma_drain_size ;
   void *dma_drain_buffer ;
   unsigned int dma_pad_mask ;
   unsigned int dma_alignment ;
   struct blk_queue_tag *queue_tags ;
   struct list_head tag_busy_list ;
   unsigned int nr_sorted ;
   unsigned int in_flight[2U] ;
   unsigned int request_fn_active ;
   unsigned int rq_timeout ;
   struct timer_list timeout ;
   struct list_head timeout_list ;
   struct list_head icq_list ;
   unsigned long blkcg_pols[1U] ;
   struct blkcg_gq *root_blkg ;
   struct list_head blkg_list ;
   struct queue_limits limits ;
   unsigned int sg_timeout ;
   unsigned int sg_reserved_size ;
   int node ;
   struct blk_trace *blk_trace ;
   unsigned int flush_flags ;
   unsigned char flush_not_queueable : 1 ;
   struct blk_flush_queue *fq ;
   struct list_head requeue_list ;
   spinlock_t requeue_lock ;
   struct work_struct requeue_work ;
   struct mutex sysfs_lock ;
   int bypass_depth ;
   atomic_t mq_freeze_depth ;
   bsg_job_fn *bsg_job_fn ;
   int bsg_job_size ;
   struct bsg_class_device bsg_dev ;
   struct throtl_data *td ;
   struct callback_head callback_head ;
   wait_queue_head_t mq_freeze_wq ;
   struct percpu_ref mq_usage_counter ;
   struct list_head all_q_node ;
   struct blk_mq_tag_set *tag_set ;
   struct list_head tag_set_list ;
};
#line 1020 "include/linux/blkdev.h"
struct blk_plug {
   struct list_head list ;
   struct list_head mq_list ;
   struct list_head cb_list ;
};
#line 1398 "include/linux/blkdev.h"
struct blk_integrity_iter {
   void *prot_buf ;
   void *data_buf ;
   sector_t seed ;
   unsigned int data_size ;
   unsigned short interval ;
   char const   *disk_name ;
};
#line 1427 "include/linux/blkdev.h"
typedef int integrity_processing_fn(struct blk_integrity_iter * );
#line 1428 "include/linux/blkdev.h"
struct blk_integrity {
   integrity_processing_fn *generate_fn ;
   integrity_processing_fn *verify_fn ;
   unsigned short flags ;
   unsigned short tuple_size ;
   unsigned short interval ;
   unsigned short tag_size ;
   char const   *name ;
   struct kobject kobj ;
};
#line 1482 "include/linux/blkdev.h"
struct block_device_operations {
   int (*open)(struct block_device * , fmode_t  ) ;
   void (*release)(struct gendisk * , fmode_t  ) ;
   int (*rw_page)(struct block_device * , sector_t  , struct page * , int  ) ;
   int (*ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   long (*direct_access)(struct block_device * , sector_t  , void ** , unsigned long * ,
                         long  ) ;
   unsigned int (*check_events)(struct gendisk * , unsigned int  ) ;
   int (*media_changed)(struct gendisk * ) ;
   void (*unlock_native_capacity)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   void (*swap_slot_free_notify)(struct block_device * , unsigned long  ) ;
   struct module *owner ;
};
#line 1578
struct blk_mq_tags;
#line 1579 "include/linux/blkdev.h"
struct blk_mq_cpu_notifier {
   struct list_head list ;
   void *data ;
   int (*notify)(void * , unsigned long  , unsigned int  ) ;
};
#line 14 "include/linux/blk-mq.h"
struct blk_align_bitmap;
#line 14 "include/linux/blk-mq.h"
struct blk_mq_ctxmap {
   unsigned int size ;
   unsigned int bits_per_word ;
   struct blk_align_bitmap *map ;
};
#line 20 "include/linux/blk-mq.h"
struct __anonstruct____missing_field_name_341 {
   spinlock_t lock ;
   struct list_head dispatch ;
};
#line 20 "include/linux/blk-mq.h"
struct blk_mq_hw_ctx {
   struct __anonstruct____missing_field_name_341 __annonCompField103 ;
   unsigned long state ;
   struct delayed_work run_work ;
   struct delayed_work delay_work ;
   cpumask_var_t cpumask ;
   int next_cpu ;
   int next_cpu_batch ;
   unsigned long flags ;
   struct request_queue *queue ;
   struct blk_flush_queue *fq ;
   void *driver_data ;
   struct blk_mq_ctxmap ctx_map ;
   unsigned int nr_ctx ;
   struct blk_mq_ctx **ctxs ;
   atomic_t wait_index ;
   struct blk_mq_tags *tags ;
   unsigned long queued ;
   unsigned long run ;
   unsigned long dispatched[10U] ;
   unsigned int numa_node ;
   unsigned int queue_num ;
   atomic_t nr_active ;
   struct blk_mq_cpu_notifier cpu_notifier ;
   struct kobject kobj ;
};
#line 63 "include/linux/blk-mq.h"
struct blk_mq_tag_set {
   struct blk_mq_ops *ops ;
   unsigned int nr_hw_queues ;
   unsigned int queue_depth ;
   unsigned int reserved_tags ;
   unsigned int cmd_size ;
   int numa_node ;
   unsigned int timeout ;
   unsigned int flags ;
   void *driver_data ;
   struct blk_mq_tags **tags ;
   struct mutex tag_list_lock ;
   struct list_head tag_list ;
};
#line 80 "include/linux/blk-mq.h"
struct blk_mq_queue_data {
   struct request *rq ;
   struct list_head *list ;
   bool last ;
};
#line 87 "include/linux/blk-mq.h"
typedef int queue_rq_fn(struct blk_mq_hw_ctx * , struct blk_mq_queue_data  const  * );
#line 88 "include/linux/blk-mq.h"
typedef struct blk_mq_hw_ctx *map_queue_fn(struct request_queue * , int const    );
#line 89 "include/linux/blk-mq.h"
typedef enum blk_eh_timer_return timeout_fn(struct request * , bool  );
#line 90 "include/linux/blk-mq.h"
typedef int init_hctx_fn(struct blk_mq_hw_ctx * , void * , unsigned int  );
#line 91 "include/linux/blk-mq.h"
typedef void exit_hctx_fn(struct blk_mq_hw_ctx * , unsigned int  );
#line 92 "include/linux/blk-mq.h"
typedef int init_request_fn(void * , struct request * , unsigned int  , unsigned int  ,
                            unsigned int  );
#line 94 "include/linux/blk-mq.h"
typedef void exit_request_fn(void * , struct request * , unsigned int  , unsigned int  );
#line 100 "include/linux/blk-mq.h"
struct blk_mq_ops {
   queue_rq_fn *queue_rq ;
   map_queue_fn *map_queue ;
   timeout_fn *timeout ;
   softirq_done_fn *complete ;
   init_hctx_fn *init_hctx ;
   exit_hctx_fn *exit_hctx ;
   init_request_fn *init_request ;
   exit_request_fn *exit_request ;
};
#line 247
struct scsi_host_cmd_pool;
#line 248
struct scsi_target;
#line 249
struct scsi_transport_template;
#line 251 "include/linux/blk-mq.h"
struct scsi_host_template {
   struct module *module ;
   char const   *name ;
   int (*detect)(struct scsi_host_template * ) ;
   int (*release)(struct Scsi_Host * ) ;
   char const   *(*info)(struct Scsi_Host * ) ;
   int (*ioctl)(struct scsi_device * , int  , void * ) ;
   int (*compat_ioctl)(struct scsi_device * , int  , void * ) ;
   int (*queuecommand)(struct Scsi_Host * , struct scsi_cmnd * ) ;
   int (*eh_abort_handler)(struct scsi_cmnd * ) ;
   int (*eh_device_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_target_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_bus_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_host_reset_handler)(struct scsi_cmnd * ) ;
   int (*slave_alloc)(struct scsi_device * ) ;
   int (*slave_configure)(struct scsi_device * ) ;
   void (*slave_destroy)(struct scsi_device * ) ;
   int (*target_alloc)(struct scsi_target * ) ;
   void (*target_destroy)(struct scsi_target * ) ;
   int (*scan_finished)(struct Scsi_Host * , unsigned long  ) ;
   void (*scan_start)(struct Scsi_Host * ) ;
   int (*change_queue_depth)(struct scsi_device * , int  ) ;
   int (*bios_param)(struct scsi_device * , struct block_device * , sector_t  , int * ) ;
   void (*unlock_native_capacity)(struct scsi_device * ) ;
   int (*show_info)(struct seq_file * , struct Scsi_Host * ) ;
   int (*write_info)(struct Scsi_Host * , char * , int  ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   int (*host_reset)(struct Scsi_Host * , int  ) ;
   char const   *proc_name ;
   struct proc_dir_entry *proc_dir ;
   int can_queue ;
   int this_id ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned int max_sectors ;
   unsigned long dma_boundary ;
   short cmd_per_lun ;
   unsigned char present ;
   int tag_alloc_policy ;
   unsigned char use_blk_tags : 1 ;
   unsigned char track_queue_depth : 1 ;
   unsigned char supported_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char emulated : 1 ;
   unsigned char skip_settle_delay : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char no_async_abort : 1 ;
   unsigned int max_host_blocked ;
   struct device_attribute **shost_attrs ;
   struct device_attribute **sdev_attrs ;
   struct list_head legacy_hosts ;
   u64 vendor_id ;
   unsigned int cmd_size ;
   struct scsi_host_cmd_pool *cmd_pool ;
   bool disable_blk_mq ;
};
#line 507 "include/scsi/scsi_host.h"
enum scsi_host_state {
    SHOST_CREATED = 1,
    SHOST_RUNNING = 2,
    SHOST_CANCEL = 3,
    SHOST_DEL = 4,
    SHOST_RECOVERY = 5,
    SHOST_CANCEL_RECOVERY = 6,
    SHOST_DEL_RECOVERY = 7
} ;
#line 517 "include/scsi/scsi_host.h"
union __anonunion____missing_field_name_342 {
   struct blk_queue_tag *bqt ;
   struct blk_mq_tag_set tag_set ;
};
#line 517 "include/scsi/scsi_host.h"
struct Scsi_Host {
   struct list_head __devices ;
   struct list_head __targets ;
   struct scsi_host_cmd_pool *cmd_pool ;
   spinlock_t free_list_lock ;
   struct list_head free_list ;
   struct list_head starved_list ;
   spinlock_t default_lock ;
   spinlock_t *host_lock ;
   struct mutex scan_mutex ;
   struct list_head eh_cmd_q ;
   struct task_struct *ehandler ;
   struct completion *eh_action ;
   wait_queue_head_t host_wait ;
   struct scsi_host_template *hostt ;
   struct scsi_transport_template *transportt ;
   union __anonunion____missing_field_name_342 __annonCompField104 ;
   atomic_t host_busy ;
   atomic_t host_blocked ;
   unsigned int host_failed ;
   unsigned int host_eh_scheduled ;
   unsigned int host_no ;
   int eh_deadline ;
   unsigned long last_reset ;
   unsigned int max_channel ;
   unsigned int max_id ;
   u64 max_lun ;
   unsigned int unique_id ;
   unsigned short max_cmd_len ;
   int this_id ;
   int can_queue ;
   short cmd_per_lun ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned int max_sectors ;
   unsigned long dma_boundary ;
   unsigned int nr_hw_queues ;
   unsigned long cmd_serial_number ;
   unsigned char active_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char host_self_blocked : 1 ;
   unsigned char reverse_ordering : 1 ;
   unsigned char tmf_in_progress : 1 ;
   unsigned char async_scan : 1 ;
   unsigned char eh_noresume : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char use_blk_mq : 1 ;
   unsigned char use_cmd_list : 1 ;
   char work_q_name[20U] ;
   struct workqueue_struct *work_q ;
   struct workqueue_struct *tmf_work_q ;
   unsigned char no_scsi2_lun_in_cdb : 1 ;
   unsigned int max_host_blocked ;
   unsigned int prot_capabilities ;
   unsigned char prot_guard_type ;
   struct request_queue *uspace_req_q ;
   unsigned long base ;
   unsigned long io_port ;
   unsigned char n_io_port ;
   unsigned char dma_channel ;
   unsigned int irq ;
   enum scsi_host_state shost_state ;
   struct device shost_gendev ;
   struct device shost_dev ;
   struct list_head sht_legacy_list ;
   void *shost_data ;
   struct device *dma_dev ;
   unsigned long hostdata[0U] ;
};
#line 25 "include/scsi/scsi_device.h"
enum scsi_device_state {
    SDEV_CREATED = 1,
    SDEV_RUNNING = 2,
    SDEV_CANCEL = 3,
    SDEV_DEL = 4,
    SDEV_QUIESCE = 5,
    SDEV_OFFLINE = 6,
    SDEV_TRANSPORT_OFFLINE = 7,
    SDEV_BLOCK = 8,
    SDEV_CREATED_BLOCK = 9
} ;
#line 71
struct scsi_dh_data;
#line 71 "include/scsi/scsi_device.h"
struct scsi_device {
   struct Scsi_Host *host ;
   struct request_queue *request_queue ;
   struct list_head siblings ;
   struct list_head same_target_siblings ;
   atomic_t device_busy ;
   atomic_t device_blocked ;
   spinlock_t list_lock ;
   struct list_head cmd_list ;
   struct list_head starved_entry ;
   struct scsi_cmnd *current_cmnd ;
   unsigned short queue_depth ;
   unsigned short max_queue_depth ;
   unsigned short last_queue_full_depth ;
   unsigned short last_queue_full_count ;
   unsigned long last_queue_full_time ;
   unsigned long queue_ramp_up_period ;
   unsigned long last_queue_ramp_up ;
   unsigned int id ;
   unsigned int channel ;
   u64 lun ;
   unsigned int manufacturer ;
   unsigned int sector_size ;
   void *hostdata ;
   char type ;
   char scsi_level ;
   char inq_periph_qual ;
   unsigned char inquiry_len ;
   unsigned char *inquiry ;
   char const   *vendor ;
   char const   *model ;
   char const   *rev ;
   int vpd_pg83_len ;
   unsigned char *vpd_pg83 ;
   int vpd_pg80_len ;
   unsigned char *vpd_pg80 ;
   unsigned char current_tag ;
   struct scsi_target *sdev_target ;
   unsigned int sdev_bflags ;
   unsigned int eh_timeout ;
   unsigned char removable : 1 ;
   unsigned char changed : 1 ;
   unsigned char busy : 1 ;
   unsigned char lockable : 1 ;
   unsigned char locked : 1 ;
   unsigned char borken : 1 ;
   unsigned char disconnect : 1 ;
   unsigned char soft_reset : 1 ;
   unsigned char sdtr : 1 ;
   unsigned char wdtr : 1 ;
   unsigned char ppr : 1 ;
   unsigned char tagged_supported : 1 ;
   unsigned char simple_tags : 1 ;
   unsigned char was_reset : 1 ;
   unsigned char expecting_cc_ua : 1 ;
   unsigned char use_10_for_rw : 1 ;
   unsigned char use_10_for_ms : 1 ;
   unsigned char no_report_opcodes : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char use_16_for_rw : 1 ;
   unsigned char skip_ms_page_8 : 1 ;
   unsigned char skip_ms_page_3f : 1 ;
   unsigned char skip_vpd_pages : 1 ;
   unsigned char try_vpd_pages : 1 ;
   unsigned char use_192_bytes_for_3f : 1 ;
   unsigned char no_start_on_add : 1 ;
   unsigned char allow_restart : 1 ;
   unsigned char manage_start_stop : 1 ;
   unsigned char start_stop_pwr_cond : 1 ;
   unsigned char no_uld_attach : 1 ;
   unsigned char select_no_atn : 1 ;
   unsigned char fix_capacity : 1 ;
   unsigned char guess_capacity : 1 ;
   unsigned char retry_hwerror : 1 ;
   unsigned char last_sector_bug : 1 ;
   unsigned char no_read_disc_info : 1 ;
   unsigned char no_read_capacity_16 : 1 ;
   unsigned char try_rc_10_first : 1 ;
   unsigned char is_visible : 1 ;
   unsigned char wce_default_on : 1 ;
   unsigned char no_dif : 1 ;
   unsigned char broken_fua : 1 ;
   unsigned char lun_in_cdb : 1 ;
   atomic_t disk_events_disable_depth ;
   unsigned long supported_events[1U] ;
   unsigned long pending_events[1U] ;
   struct list_head event_list ;
   struct work_struct event_work ;
   unsigned int max_device_blocked ;
   atomic_t iorequest_cnt ;
   atomic_t iodone_cnt ;
   atomic_t ioerr_cnt ;
   struct device sdev_gendev ;
   struct device sdev_dev ;
   struct execute_work ew ;
   struct work_struct requeue_work ;
   struct scsi_dh_data *scsi_dh_data ;
   enum scsi_device_state sdev_state ;
   unsigned long sdev_data[0U] ;
};
#line 204 "include/scsi/scsi_device.h"
struct scsi_device_handler {
   struct list_head list ;
   struct module *module ;
   char const   *name ;
   int (*check_sense)(struct scsi_device * , struct scsi_sense_hdr * ) ;
   struct scsi_dh_data *(*attach)(struct scsi_device * ) ;
   void (*detach)(struct scsi_device * ) ;
   int (*activate)(struct scsi_device * , void (*)(void * , int  ) , void * ) ;
   int (*prep_fn)(struct scsi_device * , struct request * ) ;
   int (*set_params)(struct scsi_device * , char const   * ) ;
   bool (*match)(struct scsi_device * ) ;
};
#line 219 "include/scsi/scsi_device.h"
struct scsi_dh_data {
   struct scsi_device_handler *scsi_dh ;
   struct scsi_device *sdev ;
   struct kref kref ;
};
#line 249
enum scsi_target_state {
    STARGET_CREATED = 1,
    STARGET_RUNNING = 2,
    STARGET_DEL = 3
} ;
#line 255 "include/scsi/scsi_device.h"
struct scsi_target {
   struct scsi_device *starget_sdev_user ;
   struct list_head siblings ;
   struct list_head devices ;
   struct device dev ;
   struct kref reap_ref ;
   unsigned int channel ;
   unsigned int id ;
   unsigned char create : 1 ;
   unsigned char single_lun : 1 ;
   unsigned char pdt_1f_for_no_lun : 1 ;
   unsigned char no_report_luns : 1 ;
   unsigned char expecting_lun_change : 1 ;
   atomic_t target_busy ;
   atomic_t target_blocked ;
   unsigned int can_queue ;
   unsigned int max_target_blocked ;
   char scsi_level ;
   enum scsi_target_state state ;
   void *hostdata ;
   unsigned long starget_data[0U] ;
};
#line 533 "include/scsi/scsi_device.h"
struct scsi_data_buffer {
   struct sg_table table ;
   unsigned int length ;
   int resid ;
};
#line 39 "include/scsi/scsi_cmnd.h"
struct scsi_pointer {
   char *ptr ;
   int this_residual ;
   struct scatterlist *buffer ;
   int buffers_residual ;
   dma_addr_t dma_handle ;
   int volatile   Status ;
   int volatile   Message ;
   int volatile   have_data_in ;
   int volatile   sent_command ;
   int volatile   phase ;
};
#line 55 "include/scsi/scsi_cmnd.h"
struct scsi_cmnd {
   struct scsi_device *device ;
   struct list_head list ;
   struct list_head eh_entry ;
   struct delayed_work abort_work ;
   int eh_eflags ;
   unsigned long serial_number ;
   unsigned long jiffies_at_alloc ;
   int retries ;
   int allowed ;
   unsigned char prot_op ;
   unsigned char prot_type ;
   unsigned char prot_flags ;
   unsigned short cmd_len ;
   enum dma_data_direction sc_data_direction ;
   unsigned char *cmnd ;
   struct scsi_data_buffer sdb ;
   struct scsi_data_buffer *prot_sdb ;
   unsigned int underflow ;
   unsigned int transfersize ;
   struct request *request ;
   unsigned char *sense_buffer ;
   void (*scsi_done)(struct scsi_cmnd * ) ;
   struct scsi_pointer SCp ;
   unsigned char *host_scribble ;
   int result ;
   int flags ;
   unsigned char tag ;
};
#line 99 "include/scsi/scsi_tcq.h"
struct attribute_container {
   struct list_head node ;
   struct klist containers ;
   struct class *class ;
   struct attribute_group  const  *grp ;
   struct device_attribute **attrs ;
   int (*match)(struct attribute_container * , struct device * ) ;
   unsigned long flags ;
};
#line 71 "include/linux/attribute_container.h"
struct transport_container;
#line 43 "include/linux/transport_class.h"
struct transport_container {
   struct attribute_container ac ;
   struct attribute_group  const  *statistics ;
};
#line 100 "include/linux/transport_class.h"
struct scsi_transport_template {
   struct transport_container host_attrs ;
   struct transport_container target_attrs ;
   struct transport_container device_attrs ;
   int (*user_scan)(struct Scsi_Host * , uint  , uint  , u64  ) ;
   int device_size ;
   int device_private_offset ;
   int target_size ;
   int target_private_offset ;
   int host_size ;
   unsigned char create_work_queue : 1 ;
   void (*eh_strategy_handler)(struct Scsi_Host * ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   int (*it_nexus_response)(struct Scsi_Host * , u64  , int  ) ;
   int (*tsk_mgmt_response)(struct Scsi_Host * , u64  , u64  , int  ) ;
};
#line 96 "./include/uapi/scsi/scsi_netlink.h"
enum fc_port_type {
    FC_PORTTYPE_UNKNOWN = 0,
    FC_PORTTYPE_OTHER = 1,
    FC_PORTTYPE_NOTPRESENT = 2,
    FC_PORTTYPE_NPORT = 3,
    FC_PORTTYPE_NLPORT = 4,
    FC_PORTTYPE_LPORT = 5,
    FC_PORTTYPE_PTP = 6,
    FC_PORTTYPE_NPIV = 7
} ;
#line 107
enum fc_port_state {
    FC_PORTSTATE_UNKNOWN = 0,
    FC_PORTSTATE_NOTPRESENT = 1,
    FC_PORTSTATE_ONLINE = 2,
    FC_PORTSTATE_OFFLINE = 3,
    FC_PORTSTATE_BLOCKED = 4,
    FC_PORTSTATE_BYPASSED = 5,
    FC_PORTSTATE_DIAGNOSTICS = 6,
    FC_PORTSTATE_LINKDOWN = 7,
    FC_PORTSTATE_ERROR = 8,
    FC_PORTSTATE_LOOPBACK = 9,
    FC_PORTSTATE_DELETED = 10
} ;
#line 121
enum fc_vport_state {
    FC_VPORT_UNKNOWN = 0,
    FC_VPORT_ACTIVE = 1,
    FC_VPORT_DISABLED = 2,
    FC_VPORT_LINKDOWN = 3,
    FC_VPORT_INITIALIZING = 4,
    FC_VPORT_NO_FABRIC_SUPP = 5,
    FC_VPORT_NO_FABRIC_RSCS = 6,
    FC_VPORT_FABRIC_LOGOUT = 7,
    FC_VPORT_FABRIC_REJ_WWN = 8,
    FC_VPORT_FAILED = 9
} ;
#line 195 "include/scsi/scsi_transport_fc.h"
struct fc_vport {
   enum fc_vport_state vport_state ;
   enum fc_vport_state vport_last_state ;
   u64 node_name ;
   u64 port_name ;
   u32 roles ;
   u32 vport_id ;
   enum fc_port_type vport_type ;
   char symbolic_name[64U] ;
   void *dd_data ;
   struct Scsi_Host *shost ;
   unsigned int channel ;
   u32 number ;
   u8 flags ;
   struct list_head peers ;
   struct device dev ;
   struct work_struct vport_delete_work ;
};
#line 252 "include/scsi/scsi_transport_fc.h"
struct fc_rport_identifiers {
   u64 node_name ;
   u64 port_name ;
   u32 port_id ;
   u32 roles ;
};
#line 294 "include/scsi/scsi_transport_fc.h"
struct fc_rport {
   u32 maxframe_size ;
   u32 supported_classes ;
   u32 dev_loss_tmo ;
   u64 node_name ;
   u64 port_name ;
   u32 port_id ;
   u32 roles ;
   enum fc_port_state port_state ;
   u32 scsi_target_id ;
   u32 fast_io_fail_tmo ;
   void *dd_data ;
   unsigned int channel ;
   u32 number ;
   u8 flags ;
   struct list_head peers ;
   struct device dev ;
   struct delayed_work dev_loss_work ;
   struct work_struct scan_work ;
   struct delayed_work fail_io_work ;
   struct work_struct stgt_delete_work ;
   struct work_struct rport_delete_work ;
   struct request_queue *rqst_q ;
};
#line 394 "include/scsi/scsi_transport_fc.h"
struct fc_host_statistics {
   u64 seconds_since_last_reset ;
   u64 tx_frames ;
   u64 tx_words ;
   u64 rx_frames ;
   u64 rx_words ;
   u64 lip_count ;
   u64 nos_count ;
   u64 error_frames ;
   u64 dumped_frames ;
   u64 link_failure_count ;
   u64 loss_of_sync_count ;
   u64 loss_of_signal_count ;
   u64 prim_seq_protocol_err_count ;
   u64 invalid_tx_word_count ;
   u64 invalid_crc_count ;
   u64 fcp_input_requests ;
   u64 fcp_output_requests ;
   u64 fcp_control_requests ;
   u64 fcp_input_megabytes ;
   u64 fcp_output_megabytes ;
   u64 fcp_packet_alloc_failures ;
   u64 fcp_packet_aborts ;
   u64 fcp_frame_alloc_failures ;
   u64 fc_no_free_exch ;
   u64 fc_no_free_exch_xid ;
   u64 fc_xid_not_found ;
   u64 fc_xid_busy ;
   u64 fc_seq_not_found ;
   u64 fc_non_bls_resp ;
};
#line 317 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fcp_cmnd {
   struct scsi_lun fc_lun ;
   __u8 fc_cmdref ;
   __u8 fc_pri_ta ;
   __u8 fc_tm_flags ;
   __u8 fc_flags ;
   __u8 fc_cdb[16U] ;
   __be32 fc_dl ;
};
#line 179 "include/scsi/fc/fc_fcp.h"
struct fcp_srr {
   __u8 srr_op ;
   __u8 srr_resvd[3U] ;
   __be16 srr_ox_id ;
   __be16 srr_rx_id ;
   __be32 srr_rel_off ;
   __u8 srr_r_ctl ;
   __u8 srr_resvd2[3U] ;
};
#line 87 "./include/uapi/scsi/fc/fc_ns.h"
struct fc_ns_fts {
   __be32 ff_type_map[8U] ;
};
#line 129 "./include/uapi/scsi/fc/fc_ns.h"
struct fc_gpn_ft_resp {
   __u8 fp_flags ;
   __u8 fp_fid[3U] ;
   __be32 fp_resvd ;
   __be64 fp_wwpn ;
};
#line 212 "include/scsi/fc/fc_ms.h"
enum fc_els_cmd {
    ELS_LS_RJT = 1,
    ELS_LS_ACC = 2,
    ELS_PLOGI = 3,
    ELS_FLOGI = 4,
    ELS_LOGO = 5,
    ELS_ABTX = 6,
    ELS_RCS = 7,
    ELS_RES = 8,
    ELS_RSS = 9,
    ELS_RSI = 10,
    ELS_ESTS = 11,
    ELS_ESTC = 12,
    ELS_ADVC = 13,
    ELS_RTV = 14,
    ELS_RLS = 15,
    ELS_ECHO = 16,
    ELS_TEST = 17,
    ELS_RRQ = 18,
    ELS_REC = 19,
    ELS_SRR = 20,
    ELS_PRLI = 32,
    ELS_PRLO = 33,
    ELS_SCN = 34,
    ELS_TPLS = 35,
    ELS_TPRLO = 36,
    ELS_LCLM = 37,
    ELS_GAID = 48,
    ELS_FACT = 49,
    ELS_FDACDT = 50,
    ELS_NACT = 51,
    ELS_NDACT = 52,
    ELS_QOSR = 64,
    ELS_RVCS = 65,
    ELS_PDISC = 80,
    ELS_FDISC = 81,
    ELS_ADISC = 82,
    ELS_RNC = 83,
    ELS_FARP_REQ = 84,
    ELS_FARP_REPL = 85,
    ELS_RPS = 86,
    ELS_RPL = 87,
    ELS_RPBC = 88,
    ELS_FAN = 96,
    ELS_RSCN = 97,
    ELS_SCR = 98,
    ELS_RNFT = 99,
    ELS_CSR = 104,
    ELS_CSU = 105,
    ELS_LINIT = 112,
    ELS_LSTS = 114,
    ELS_RNID = 120,
    ELS_RLIR = 121,
    ELS_LIRR = 122,
    ELS_SRL = 123,
    ELS_SBRP = 124,
    ELS_RPSC = 125,
    ELS_QSA = 126,
    ELS_EVFP = 127,
    ELS_LKA = 128,
    ELS_AUTH_ELS = 144
} ;
#line 170 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_ls_rjt {
   __u8 er_cmd ;
   __u8 er_resv[4U] ;
   __u8 er_reason ;
   __u8 er_explan ;
   __u8 er_vendor ;
};
#line 181
enum fc_els_rjt_reason {
    ELS_RJT_NONE = 0,
    ELS_RJT_INVAL = 1,
    ELS_RJT_LOGIC = 3,
    ELS_RJT_BUSY = 5,
    ELS_RJT_PROT = 7,
    ELS_RJT_UNAB = 9,
    ELS_RJT_UNSUP = 11,
    ELS_RJT_INPROG = 14,
    ELS_RJT_FIP = 32,
    ELS_RJT_VENDOR = 255
} ;
#line 194
enum fc_els_rjt_explan {
    ELS_EXPL_NONE = 0,
    ELS_EXPL_SPP_OPT_ERR = 1,
    ELS_EXPL_SPP_ICTL_ERR = 3,
    ELS_EXPL_AH = 17,
    ELS_EXPL_AH_REQ = 19,
    ELS_EXPL_SID = 21,
    ELS_EXPL_OXID_RXID = 23,
    ELS_EXPL_INPROG = 25,
    ELS_EXPL_PLOGI_REQD = 30,
    ELS_EXPL_INSUF_RES = 41,
    ELS_EXPL_UNAB_DATA = 42,
    ELS_EXPL_UNSUPR = 44,
    ELS_EXPL_INV_LEN = 45,
    ELS_EXPL_NOT_NEIGHBOR = 98
} ;
#line 347 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_rrq {
   __u8 rrq_cmd ;
   __u8 rrq_zero[3U] ;
   __u8 rrq_resvd ;
   __u8 rrq_s_id[3U] ;
   __be16 rrq_ox_id ;
   __be16 rrq_rx_id ;
};
#line 370 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_rec {
   __u8 rec_cmd ;
   __u8 rec_zero[3U] ;
   __u8 rec_resvd ;
   __u8 rec_s_id[3U] ;
   __be16 rec_ox_id ;
   __be16 rec_rx_id ;
};
#line 382 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_rec_acc {
   __u8 reca_cmd ;
   __u8 reca_zero[3U] ;
   __be16 reca_ox_id ;
   __be16 reca_rx_id ;
   __u8 reca_resvd1 ;
   __u8 reca_ofid[3U] ;
   __u8 reca_resvd2 ;
   __u8 reca_rfid[3U] ;
   __be32 reca_fc4value ;
   __be32 reca_e_stat ;
};
#line 417 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_adisc {
   __u8 adisc_cmd ;
   __u8 adisc_resv[3U] ;
   __u8 adisc_resv1 ;
   __u8 adisc_hard_addr[3U] ;
   __be64 adisc_wwpn ;
   __be64 adisc_wwnn ;
   __u8 adisc_resv2 ;
   __u8 adisc_port_id[3U] ;
};
#line 431 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_logo {
   __u8 fl_cmd ;
   __u8 fl_zero[3U] ;
   __u8 fl_resvd ;
   __u8 fl_n_port_id[3U] ;
   __be64 fl_n_port_wwn ;
};
#line 555 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_rnid_gen {
   __u8 rnid_vend_id[16U] ;
   __be32 rnid_atype ;
   __be32 rnid_phys_port ;
   __be32 rnid_att_nodes ;
   __u8 rnid_node_mgmt ;
   __u8 rnid_ip_ver ;
   __be16 rnid_prot_port ;
   __be32 rnid_ip_addr[4U] ;
   __u8 rnid_resvd[2U] ;
   __be16 rnid_vend_spec ;
};
#line 647 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_lesb {
   __be32 lesb_link_fail ;
   __be32 lesb_sync_loss ;
   __be32 lesb_sig_loss ;
   __be32 lesb_prim_err ;
   __be32 lesb_inv_word ;
   __be32 lesb_inv_crc ;
};
#line 734 "./include/uapi/scsi/fc/fc_els.h"
struct fc_els_rls {
   __u8 rls_cmd ;
   __u8 rls_resv[4U] ;
   __u8 rls_port_id[3U] ;
};
#line 80 "./include/uapi/scsi/fc/fc_gs.h"
struct fc_frame_header {
   __u8 fh_r_ctl ;
   __u8 fh_d_id[3U] ;
   __u8 fh_cs_ctl ;
   __u8 fh_s_id[3U] ;
   __u8 fh_type ;
   __u8 fh_f_ctl[3U] ;
   __u8 fh_seq_id ;
   __u8 fh_df_ctl ;
   __be16 fh_seq_cnt ;
   __be16 fh_ox_id ;
   __be16 fh_rx_id ;
   __be32 fh_parm_offset ;
};
#line 51 "./include/uapi/scsi/fc/fc_fs.h"
enum fc_rctl {
    FC_RCTL_DD_UNCAT = 0,
    FC_RCTL_DD_SOL_DATA = 1,
    FC_RCTL_DD_UNSOL_CTL = 2,
    FC_RCTL_DD_SOL_CTL = 3,
    FC_RCTL_DD_UNSOL_DATA = 4,
    FC_RCTL_DD_DATA_DESC = 5,
    FC_RCTL_DD_UNSOL_CMD = 6,
    FC_RCTL_DD_CMD_STATUS = 7,
    FC_RCTL_ELS_REQ = 34,
    FC_RCTL_ELS_REP = 35,
    FC_RCTL_ELS4_REQ = 50,
    FC_RCTL_ELS4_REP = 51,
    FC_RCTL_VFTH = 80,
    FC_RCTL_IFRH = 81,
    FC_RCTL_ENCH = 82,
    FC_RCTL_BA_NOP = 128,
    FC_RCTL_BA_ABTS = 129,
    FC_RCTL_BA_RMC = 130,
    FC_RCTL_BA_ACC = 132,
    FC_RCTL_BA_RJT = 133,
    FC_RCTL_BA_PRMT = 134,
    FC_RCTL_ACK_1 = 192,
    FC_RCTL_ACK_0 = 193,
    FC_RCTL_P_RJT = 194,
    FC_RCTL_F_RJT = 195,
    FC_RCTL_P_BSY = 196,
    FC_RCTL_F_BSY = 197,
    FC_RCTL_F_BSYL = 198,
    FC_RCTL_LCR = 199,
    FC_RCTL_END = 201
} ;
#line 99
enum fc_fh_type {
    FC_TYPE_BLS = 0,
    FC_TYPE_ELS = 1,
    FC_TYPE_IP = 5,
    FC_TYPE_FCP = 8,
    FC_TYPE_CT = 32,
    FC_TYPE_ILS = 34
} ;
#line 75 "include/scsi/fc/fc_encaps.h"
enum fc_class {
    FC_CLASS_NONE = 0,
    FC_CLASS_2 = 45,
    FC_CLASS_3 = 46,
    FC_CLASS_4 = 41,
    FC_CLASS_F = 40
} ;
#line 49 "include/scsi/fc_frame.h"
struct fc_frame {
   struct sk_buff skb ;
};
#line 79
struct fc_seq;
#line 79
struct fc_fcp_pkt;
#line 79 "include/scsi/fc_frame.h"
struct fcoe_rcv_info {
   struct fc_lport *fr_dev ;
   struct fc_seq *fr_seq ;
   struct fc_fcp_pkt *fr_fsp ;
   u32 fr_crc ;
   u16 fr_max_payload ;
   u8 fr_sof ;
   u8 fr_eof ;
   u8 fr_flags ;
   u8 fr_encaps ;
   u8 granted_mac[6U] ;
};
#line 260
enum fc_lport_state {
    LPORT_ST_DISABLED = 0,
    LPORT_ST_FLOGI = 1,
    LPORT_ST_DNS = 2,
    LPORT_ST_RNN_ID = 3,
    LPORT_ST_RSNN_NN = 4,
    LPORT_ST_RSPN_ID = 5,
    LPORT_ST_RFT_ID = 6,
    LPORT_ST_RFF_ID = 7,
    LPORT_ST_FDMI = 8,
    LPORT_ST_RHBA = 9,
    LPORT_ST_RPA = 10,
    LPORT_ST_DHBA = 11,
    LPORT_ST_DPRT = 12,
    LPORT_ST_SCR = 13,
    LPORT_ST_READY = 14,
    LPORT_ST_LOGO = 15,
    LPORT_ST_RESET = 16
} ;
#line 280
enum fc_disc_event {
    DISC_EV_NONE = 0,
    DISC_EV_SUCCESS = 1,
    DISC_EV_FAILED = 2
} ;
#line 286
enum fc_rport_state {
    RPORT_ST_INIT = 0,
    RPORT_ST_FLOGI = 1,
    RPORT_ST_PLOGI_WAIT = 2,
    RPORT_ST_PLOGI = 3,
    RPORT_ST_PRLI = 4,
    RPORT_ST_RTV = 5,
    RPORT_ST_READY = 6,
    RPORT_ST_ADISC = 7,
    RPORT_ST_DELETE = 8
} ;
#line 126 "include/scsi/libfc.h"
enum fc_rport_event {
    RPORT_EV_NONE = 0,
    RPORT_EV_READY = 1,
    RPORT_EV_FAILED = 2,
    RPORT_EV_STOP = 3,
    RPORT_EV_LOGO = 4
} ;
#line 134
struct fc_rport_priv;
#line 135 "include/scsi/libfc.h"
struct fc_rport_operations {
   void (*event_callback)(struct fc_lport * , struct fc_rport_priv * , enum fc_rport_event  ) ;
};
#line 173 "include/scsi/libfc.h"
struct fc_rport_priv {
   struct fc_lport *local_port ;
   struct fc_rport *rport ;
   struct kref kref ;
   enum fc_rport_state rp_state ;
   struct fc_rport_identifiers ids ;
   u16 flags ;
   u16 max_seq ;
   u16 disc_id ;
   u16 maxframe_size ;
   unsigned int retries ;
   unsigned int major_retries ;
   unsigned int e_d_tov ;
   unsigned int r_a_tov ;
   struct mutex rp_mutex ;
   struct delayed_work retry_work ;
   enum fc_rport_event event ;
   struct fc_rport_operations *ops ;
   struct list_head peers ;
   struct work_struct event_work ;
   u32 supported_classes ;
   u16 prli_count ;
   struct callback_head rcu ;
   u16 sp_features ;
   u8 spp_type ;
   void (*lld_event_callback)(struct fc_lport * , struct fc_rport_priv * , enum fc_rport_event  ) ;
};
#line 223 "include/scsi/libfc.h"
struct fc_stats {
   u64 SecondsSinceLastReset ;
   u64 TxFrames ;
   u64 TxWords ;
   u64 RxFrames ;
   u64 RxWords ;
   u64 ErrorFrames ;
   u64 DumpedFrames ;
   u64 FcpPktAllocFails ;
   u64 FcpPktAborts ;
   u64 FcpFrameAllocFails ;
   u64 LinkFailureCount ;
   u64 LossOfSignalCount ;
   u64 InvalidTxWordCount ;
   u64 InvalidCRCCount ;
   u64 InputRequests ;
   u64 OutputRequests ;
   u64 ControlRequests ;
   u64 InputBytes ;
   u64 OutputBytes ;
   u64 VLinkFailureCount ;
   u64 MissDiscAdvCount ;
};
#line 273 "include/scsi/libfc.h"
struct fc_seq_els_data {
   enum fc_els_rjt_reason reason ;
   enum fc_els_rjt_explan explan ;
};
#line 285 "include/scsi/libfc.h"
struct fc_fcp_pkt {
   spinlock_t scsi_pkt_lock ;
   atomic_t ref_cnt ;
   u32 data_len ;
   struct scsi_cmnd *cmd ;
   struct list_head list ;
   struct fc_lport *lp ;
   u8 state ;
   u8 cdb_status ;
   u8 status_code ;
   u8 scsi_comp_flags ;
   u32 io_status ;
   u32 req_flags ;
   u32 scsi_resid ;
   size_t xfer_len ;
   struct fcp_cmnd cdb_cmd ;
   u32 xfer_contig_end ;
   u16 max_payload ;
   u16 xfer_ddp ;
   struct fc_rport *rport ;
   struct fc_seq *seq_ptr ;
   struct timer_list timer ;
   int wait_for_comp ;
   u32 recov_retry ;
   struct fc_seq *recov_seq ;
   struct completion tm_done ;
};
#line 358
struct fc_exch_mgr;
#line 371 "include/scsi/libfc.h"
struct fc_seq {
   u8 id ;
   u16 ssb_stat ;
   u16 cnt ;
   u32 rec_data ;
};
#line 385
struct fc_exch_pool;
#line 385 "include/scsi/libfc.h"
struct fc_exch {
   spinlock_t ex_lock ;
   atomic_t ex_refcnt ;
   enum fc_class class ;
   struct fc_exch_mgr *em ;
   struct fc_exch_pool *pool ;
   struct list_head ex_list ;
   struct fc_lport *lp ;
   u32 esb_stat ;
   u8 state ;
   u8 fh_type ;
   u8 seq_id ;
   u8 encaps ;
   u16 xid ;
   u16 oxid ;
   u16 rxid ;
   u32 oid ;
   u32 sid ;
   u32 did ;
   u32 r_a_tov ;
   u32 f_ctl ;
   struct fc_seq seq ;
   int resp_active ;
   struct task_struct *resp_task ;
   wait_queue_head_t resp_wq ;
   void (*resp)(struct fc_seq * , struct fc_frame * , void * ) ;
   void *arg ;
   void (*destructor)(struct fc_seq * , void * ) ;
   struct delayed_work timeout_work ;
};
#line 458 "include/scsi/libfc.h"
struct libfc_function_template {
   int (*frame_send)(struct fc_lport * , struct fc_frame * ) ;
   struct fc_seq *(*elsct_send)(struct fc_lport * , u32  , struct fc_frame * , unsigned int  ,
                                void (*)(struct fc_seq * , struct fc_frame * , void * ) ,
                                void * , u32  ) ;
   struct fc_seq *(*exch_seq_send)(struct fc_lport * , struct fc_frame * , void (*)(struct fc_seq * ,
                                                                                    struct fc_frame * ,
                                                                                    void * ) ,
                                   void (*)(struct fc_seq * , void * ) , void * ,
                                   unsigned int  ) ;
   int (*ddp_setup)(struct fc_lport * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ddp_done)(struct fc_lport * , u16  ) ;
   int (*ddp_target)(struct fc_lport * , u16  , struct scatterlist * , unsigned int  ) ;
   void (*get_lesb)(struct fc_lport * , struct fc_els_lesb * ) ;
   int (*seq_send)(struct fc_lport * , struct fc_seq * , struct fc_frame * ) ;
   void (*seq_els_rsp_send)(struct fc_frame * , enum fc_els_cmd  , struct fc_seq_els_data * ) ;
   int (*seq_exch_abort)(struct fc_seq  const  * , unsigned int  ) ;
   void (*exch_done)(struct fc_seq * ) ;
   struct fc_seq *(*seq_start_next)(struct fc_seq * ) ;
   void (*seq_set_resp)(struct fc_seq * , void (*)(struct fc_seq * , struct fc_frame * ,
                                                   void * ) , void * ) ;
   struct fc_seq *(*seq_assign)(struct fc_lport * , struct fc_frame * ) ;
   void (*seq_release)(struct fc_seq * ) ;
   void (*exch_mgr_reset)(struct fc_lport * , u32  , u32  ) ;
   void (*rport_flush_queue)(void) ;
   void (*lport_recv)(struct fc_lport * , struct fc_frame * ) ;
   int (*lport_reset)(struct fc_lport * ) ;
   void (*lport_set_port_id)(struct fc_lport * , u32  , struct fc_frame * ) ;
   struct fc_rport_priv *(*rport_create)(struct fc_lport * , u32  ) ;
   int (*rport_login)(struct fc_rport_priv * ) ;
   int (*rport_logoff)(struct fc_rport_priv * ) ;
   void (*rport_recv_req)(struct fc_lport * , struct fc_frame * ) ;
   struct fc_rport_priv *(*rport_lookup)(struct fc_lport  const  * , u32  ) ;
   void (*rport_destroy)(struct kref * ) ;
   void (*rport_event_callback)(struct fc_lport * , struct fc_rport_priv * , enum fc_rport_event  ) ;
   int (*fcp_cmd_send)(struct fc_lport * , struct fc_fcp_pkt * , void (*)(struct fc_seq * ,
                                                                          struct fc_frame * ,
                                                                          void * ) ) ;
   void (*fcp_cleanup)(struct fc_lport * ) ;
   void (*fcp_abort_io)(struct fc_lport * ) ;
   void (*disc_recv_req)(struct fc_lport * , struct fc_frame * ) ;
   void (*disc_start)(void (*)(struct fc_lport * , enum fc_disc_event  ) , struct fc_lport * ) ;
   void (*disc_stop)(struct fc_lport * ) ;
   void (*disc_stop_final)(struct fc_lport * ) ;
};
#line 774 "include/scsi/libfc.h"
struct fc_disc {
   unsigned char retry_count ;
   unsigned char pending ;
   unsigned char requested ;
   unsigned short seq_count ;
   unsigned char buf_len ;
   u16 disc_id ;
   struct list_head rports ;
   void *priv ;
   struct mutex disc_mutex ;
   struct fc_gpn_ft_resp partial_buf ;
   struct delayed_work disc_work ;
   void (*disc_callback)(struct fc_lport * , enum fc_disc_event  ) ;
};
#line 818 "include/scsi/libfc.h"
struct fc_lport {
   struct Scsi_Host *host ;
   struct list_head ema_list ;
   struct fc_rport_priv *dns_rdata ;
   struct fc_rport_priv *ms_rdata ;
   struct fc_rport_priv *ptp_rdata ;
   void *scsi_priv ;
   struct fc_disc disc ;
   struct list_head vports ;
   struct fc_vport *vport ;
   struct libfc_function_template tt ;
   u8 link_up ;
   u8 qfull ;
   enum fc_lport_state state ;
   unsigned long boot_time ;
   struct fc_host_statistics host_stats ;
   struct fc_stats *stats ;
   u8 retry_count ;
   u32 port_id ;
   u64 wwpn ;
   u64 wwnn ;
   unsigned int service_params ;
   unsigned int e_d_tov ;
   unsigned int r_a_tov ;
   struct fc_els_rnid_gen rnid_gen ;
   unsigned char sg_supp : 1 ;
   unsigned char seq_offload : 1 ;
   unsigned char crc_offload : 1 ;
   unsigned char lro_enabled : 1 ;
   unsigned char does_npiv : 1 ;
   unsigned char npiv_enabled : 1 ;
   unsigned char point_to_multipoint : 1 ;
   unsigned char fdmi_enabled : 1 ;
   u32 mfs ;
   u8 max_retry_count ;
   u8 max_rport_retry_count ;
   u16 rport_priv_size ;
   u16 link_speed ;
   u16 link_supported_speeds ;
   u16 lro_xid ;
   unsigned int lso_max ;
   struct fc_ns_fts fcts ;
   struct mutex lp_mutex ;
   struct list_head list ;
   struct delayed_work retry_work ;
   void *prov[9U] ;
   struct list_head lport_list ;
};
#line 68 "include/scsi/fc/fc_fcoe.h"
struct fcoe_fc_els_lesb {
   __be32 lesb_link_fail ;
   __be32 lesb_vlink_fail ;
   __be32 lesb_miss_fka ;
   __be32 lesb_symb_err ;
   __be32 lesb_err_block ;
   __be32 lesb_fcs_error ;
};
#line 107 "include/scsi/fc/fc_fcoe.h"
struct fcoe_sysfs_function_template {
   void (*get_fcoe_ctlr_link_fail)(struct fcoe_ctlr_device * ) ;
   void (*get_fcoe_ctlr_vlink_fail)(struct fcoe_ctlr_device * ) ;
   void (*get_fcoe_ctlr_miss_fka)(struct fcoe_ctlr_device * ) ;
   void (*get_fcoe_ctlr_symb_err)(struct fcoe_ctlr_device * ) ;
   void (*get_fcoe_ctlr_err_block)(struct fcoe_ctlr_device * ) ;
   void (*get_fcoe_ctlr_fcs_error)(struct fcoe_ctlr_device * ) ;
   void (*set_fcoe_ctlr_mode)(struct fcoe_ctlr_device * ) ;
   int (*set_fcoe_ctlr_enabled)(struct fcoe_ctlr_device * ) ;
   void (*get_fcoe_fcf_selected)(struct fcoe_fcf_device * ) ;
   void (*get_fcoe_fcf_vlan_id)(struct fcoe_fcf_device * ) ;
};
#line 42 "include/scsi/fcoe_sysfs.h"
enum fip_conn_type {
    FIP_CONN_TYPE_UNKNOWN = 0,
    FIP_CONN_TYPE_FABRIC = 1,
    FIP_CONN_TYPE_VN2VN = 2
} ;
#line 48
enum ctlr_enabled_state {
    FCOE_CTLR_ENABLED = 0,
    FCOE_CTLR_DISABLED = 1,
    FCOE_CTLR_UNUSED = 2
} ;
#line 54 "include/scsi/fcoe_sysfs.h"
struct fcoe_ctlr_device {
   u32 id ;
   struct device dev ;
   struct fcoe_sysfs_function_template *f ;
   struct list_head fcfs ;
   char work_q_name[20U] ;
   struct workqueue_struct *work_q ;
   char devloss_work_q_name[20U] ;
   struct workqueue_struct *devloss_work_q ;
   struct mutex lock ;
   int fcf_dev_loss_tmo ;
   enum fip_conn_type mode ;
   enum ctlr_enabled_state enabled ;
   struct fcoe_fc_els_lesb lesb ;
};
#line 84
enum fcf_state {
    FCOE_FCF_STATE_UNKNOWN = 0,
    FCOE_FCF_STATE_DISCONNECTED = 1,
    FCOE_FCF_STATE_CONNECTED = 2,
    FCOE_FCF_STATE_DELETED = 3
} ;
#line 91 "include/scsi/fcoe_sysfs.h"
struct fcoe_fcf_device {
   u32 id ;
   struct device dev ;
   struct list_head peers ;
   struct work_struct delete_work ;
   struct delayed_work dev_loss_work ;
   u32 dev_loss_tmo ;
   void *priv ;
   enum fcf_state state ;
   u64 fabric_name ;
   u64 switch_name ;
   u32 fc_map ;
   u16 vfid ;
   u8 mac[6U] ;
   u8 priority ;
   u32 fka_period ;
   u8 selected ;
   u16 vlan_id ;
};
#line 132
enum fip_state {
    FIP_ST_DISABLED = 0,
    FIP_ST_LINK_WAIT = 1,
    FIP_ST_AUTO = 2,
    FIP_ST_NON_FIP = 3,
    FIP_ST_ENABLED = 4,
    FIP_ST_VNMP_START = 5,
    FIP_ST_VNMP_PROBE1 = 6,
    FIP_ST_VNMP_PROBE2 = 7,
    FIP_ST_VNMP_CLAIM = 8,
    FIP_ST_VNMP_UP = 9
} ;
#line 145
struct fcoe_fcf;
#line 145 "include/scsi/fcoe_sysfs.h"
struct fcoe_ctlr {
   enum fip_state state ;
   enum fip_state mode ;
   struct fc_lport *lp ;
   struct fcoe_fcf *sel_fcf ;
   struct list_head fcfs ;
   struct fcoe_ctlr_device *cdev ;
   u16 fcf_count ;
   unsigned long sol_time ;
   unsigned long sel_time ;
   unsigned long port_ka_time ;
   unsigned long ctlr_ka_time ;
   struct timer_list timer ;
   struct work_struct timer_work ;
   struct work_struct recv_work ;
   struct sk_buff_head fip_recv_list ;
   struct sk_buff *flogi_req ;
   struct rnd_state rnd_state ;
   u32 port_id ;
   u16 user_mfs ;
   u16 flogi_oxid ;
   u8 flogi_req_send ;
   u8 flogi_count ;
   u8 map_dest ;
   u8 spma ;
   u8 probe_tries ;
   u8 priority ;
   u8 dest_addr[6U] ;
   u8 ctl_src_addr[6U] ;
   void (*send)(struct fcoe_ctlr * , struct sk_buff * ) ;
   void (*update_mac)(struct fc_lport * , u8 * ) ;
   u8 *(*get_src_addr)(struct fc_lport * ) ;
   struct mutex ctlr_mutex ;
   spinlock_t ctlr_lock ;
};
#line 172 "include/scsi/libfcoe.h"
struct fcoe_fcf {
   struct list_head list ;
   struct work_struct event_work ;
   struct fcoe_ctlr *fip ;
   struct fcoe_fcf_device *fcf_dev ;
   unsigned long time ;
   u64 switch_name ;
   u64 fabric_name ;
   u32 fc_map ;
   u16 vfid ;
   u8 fcf_mac[6U] ;
   u8 fcoe_mac[6U] ;
   u8 pri ;
   u8 flogi_sent ;
   u16 flags ;
   u32 fka_period ;
   unsigned char fd_flags : 1 ;
};
#line 334 "include/scsi/libfcoe.h"
struct fcoe_port {
   void *priv ;
   struct fc_lport *lport ;
   struct sk_buff_head fcoe_pending_queue ;
   u8 fcoe_pending_queue_active ;
   u32 max_queue_depth ;
   u32 min_queue_depth ;
   struct timer_list timer ;
   struct work_struct destroy_work ;
   u8 data_src_addr[6U] ;
   struct net_device *(*get_netdev)(struct fc_lport  const  * ) ;
};
#line 23 "include/uapi/linux/utsname.h"
struct new_utsname {
   char sysname[65U] ;
   char nodename[65U] ;
   char release[65U] ;
   char version[65U] ;
   char machine[65U] ;
   char domainname[65U] ;
};
#line 22 "include/linux/utsname.h"
struct uts_namespace {
   struct kref kref ;
   struct new_utsname name ;
   struct user_namespace *user_ns ;
   struct ns_common ns ;
};
#line 96 "include/scsi/fc/fc_fc2.h"
struct b577xx_doorbell_hdr {
   u8 header ;
};
#line 45 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct b577xx_doorbell_set_prod {
   struct b577xx_doorbell_hdr header ;
   u8 zero_fill1 ;
   u16 prod ;
};
#line 62 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct regpair {
   __le32 lo ;
   __le32 hi ;
};
#line 69 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_abts_info {
   __le16 aborted_task_id ;
   __le16 reserved0 ;
   __le32 reserved1 ;
};
#line 79 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_abts_rsp_union {
   u8 r_ctl ;
   u8 rsrv[3U] ;
   __le32 abts_rsp_payload[7U] ;
};
#line 90 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_bd_ctx {
   __le32 buf_addr_hi ;
   __le32 buf_addr_lo ;
   __le16 buf_len ;
   __le16 rsrv0 ;
   __le16 flags ;
   __le16 rsrv1 ;
};
#line 103 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_cached_sge_ctx {
   struct regpair cur_buf_addr ;
   __le16 cur_buf_rem ;
   __le16 second_buf_rem ;
   struct regpair second_buf_addr ;
};
#line 114 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_cleanup_info {
   __le16 cleaned_task_id ;
   __le16 rolled_tx_seq_cnt ;
   __le32 rolled_tx_data_offset ;
};
#line 124 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_fcp_rsp_flags {
   u8 flags ;
};
#line 132 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_fcp_rsp_payload {
   struct regpair reserved0 ;
   __le32 fcp_resid ;
   u8 scsi_status_code ;
   struct fcoe_fcp_rsp_flags fcp_flags ;
   __le16 retry_delay_timer ;
   __le32 fcp_rsp_len ;
   __le32 fcp_sns_len ;
};
#line 157 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_fcp_rsp_union {
   struct fcoe_fcp_rsp_payload payload ;
   struct regpair reserved0 ;
};
#line 166 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_fc_hdr {
   u8 s_id[3U] ;
   u8 cs_ctl ;
   u8 d_id[3U] ;
   u8 r_ctl ;
   __le16 seq_cnt ;
   u8 df_ctl ;
   u8 seq_id ;
   u8 f_ctl[3U] ;
   u8 type ;
   __le32 parameters ;
   __le16 rx_id ;
   __le16 ox_id ;
};
#line 184 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_mp_rsp_union {
   struct fcoe_fc_hdr fc_hdr ;
   __le32 mp_payload_len ;
   __le32 rsrv ;
};
#line 193 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
union fcoe_comp_flow_info {
   struct fcoe_fcp_rsp_union fcp_rsp ;
   struct fcoe_abts_rsp_union abts_rsp ;
   struct fcoe_mp_rsp_union mp_rsp ;
   __le32 opaque[8U] ;
};
#line 203 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_ext_abts_info {
   __le32 rsrv0[6U] ;
   struct fcoe_abts_info ctx ;
};
#line 212 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_ext_cleanup_info {
   __le32 rsrv0[6U] ;
   struct fcoe_cleanup_info ctx ;
};
#line 221 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_fw_tx_seq_ctx {
   __le32 data_offset ;
   __le16 seq_cnt ;
   __le16 rsrv0 ;
};
#line 231 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_ext_fw_tx_seq_ctx {
   __le32 rsrv0[6U] ;
   struct fcoe_fw_tx_seq_ctx ctx ;
};
#line 239 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_mul_sges_ctx {
   struct regpair cur_sge_addr ;
   __le16 cur_sge_off ;
   u8 cur_sge_idx ;
   u8 sgl_size ;
};
#line 250 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_ext_mul_sges_ctx {
   struct fcoe_mul_sges_ctx mul_sgl ;
   struct regpair rsrv0 ;
};
#line 258 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_fcp_cmd_payload {
   __le32 opaque[8U] ;
};
#line 266 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_fcp_xfr_rdy_payload {
   __le32 burst_len ;
   __le32 data_ro ;
};
#line 278 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_fc_frame {
   struct fcoe_fc_hdr fc_hdr ;
   __le32 reserved0[2U] ;
};
#line 557 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
union fcoe_sgl_union_ctx {
   struct fcoe_cached_sge_ctx cached_sge ;
   struct fcoe_ext_mul_sges_ctx sgl ;
   __le32 opaque[5U] ;
};
#line 581 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_read_flow_info {
   union fcoe_sgl_union_ctx sgl_ctx ;
   __le32 rsrv0[3U] ;
};
#line 589 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_s_stat_ctx {
   u8 flags ;
};
#line 597 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_rx_seq_ctx {
   u8 seq_id ;
   struct fcoe_s_stat_ctx s_stat ;
   __le16 seq_cnt ;
   __le32 low_exp_ro ;
   __le32 high_exp_ro ;
};
#line 622 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
union fcoe_rx_wr_union_ctx {
   struct fcoe_read_flow_info read_info ;
   union fcoe_comp_flow_info comp_info ;
   __le32 opaque[8U] ;
};
#line 632 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_sqe {
   __le16 wqe ;
};
#line 641 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_tce_tx_only {
   union fcoe_sgl_union_ctx sgl_ctx ;
   __le32 rsrv0 ;
};
#line 655 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
union fcoe_tx_wr_rx_rd_union_ctx {
   struct fcoe_fc_frame tx_frame ;
   struct fcoe_fcp_cmd_payload fcp_cmd ;
   struct fcoe_ext_cleanup_info cleanup ;
   struct fcoe_ext_abts_info abts ;
   struct fcoe_ext_fw_tx_seq_ctx tx_seq ;
   __le32 opaque[8U] ;
};
#line 667 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_tce_tx_wr_rx_rd_const {
   u8 init_flags ;
   u8 tx_flags ;
   __le16 rsrv3 ;
   __le32 verify_tx_seq ;
};
#line 697 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_tce_tx_wr_rx_rd {
   union fcoe_tx_wr_rx_rd_union_ctx union_ctx ;
   struct fcoe_tce_tx_wr_rx_rd_const const_ctx ;
};
#line 705 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_tce_rx_wr_tx_rd_const {
   __le32 data_2_trns ;
   __le32 init_flags ;
};
#line 713 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_tce_rx_wr_tx_rd_var {
   __le16 rx_flags ;
   __le16 rx_id ;
   struct fcoe_fcp_xfr_rdy_payload fcp_xfr_rdy ;
};
#line 742 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_tce_rx_wr_tx_rd {
   struct fcoe_tce_rx_wr_tx_rd_const const_ctx ;
   struct fcoe_tce_rx_wr_tx_rd_var var_ctx ;
};
#line 750 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_tce_rx_only {
   struct fcoe_rx_seq_ctx rx_seq_ctx ;
   union fcoe_rx_wr_union_ctx union_ctx ;
};
#line 758 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_task_ctx_entry {
   struct fcoe_tce_tx_only txwr_only ;
   struct fcoe_tce_tx_wr_rx_rd txwr_rxrd ;
   struct fcoe_tce_rx_wr_tx_rd rxwr_txrd ;
   struct fcoe_tce_rx_only rxwr_only ;
};
#line 768 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_xfrqe {
   __le16 wqe ;
};
#line 784 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct b577xx_fcoe_rx_doorbell {
   struct b577xx_doorbell_hdr hdr ;
   u8 params ;
   __le16 doorbell_cq_cons ;
};
#line 802 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_confqe {
   __le16 ox_id ;
   __le16 rx_id ;
   __le32 param ;
};
#line 812 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_conn_db {
   u16 rq_prod ;
   u16 rsrv0 ;
   u32 rsrv1 ;
   struct regpair cq_arm ;
};
#line 828 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_cqe {
   __le16 wqe ;
};
#line 836 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_partial_err_report_entry {
   __le32 err_warn_bitmap_lo ;
   __le32 err_warn_bitmap_hi ;
   __le32 tx_buf_off ;
   __le32 rx_buf_off ;
};
#line 853 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_err_report_entry {
   struct fcoe_partial_err_report_entry data ;
   struct fcoe_fc_hdr fc_hdr ;
};
#line 861 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_hash_table_entry {
   u8 s_id_0 ;
   u8 s_id_1 ;
   u8 s_id_2 ;
   u8 d_id_0 ;
   u8 d_id_1 ;
   u8 d_id_2 ;
   __le16 dst_mac_addr_hi ;
   __le16 dst_mac_addr_mid ;
   __le16 dst_mac_addr_lo ;
   __le16 src_mac_addr_hi ;
   __le16 vlan_id ;
   __le16 src_mac_addr_lo ;
   __le16 src_mac_addr_mid ;
   u8 vlan_flag ;
   u8 reserved0 ;
   __le16 reserved1 ;
   __le32 reserved2 ;
   __le32 field_id ;
};
#line 915 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_rx_stat_params_section0 {
   __le32 fcoe_rx_pkt_cnt ;
   __le32 fcoe_rx_byte_cnt ;
};
#line 930 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_rx_stat_params_section1 {
   __le32 fcoe_ver_cnt ;
   __le32 fcoe_rx_drop_pkt_cnt ;
};
#line 939 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_rx_stat_params_section2 {
   __le32 fc_crc_cnt ;
   __le32 eofa_del_cnt ;
   __le32 miss_frame_cnt ;
   __le32 seq_timeout_cnt ;
   __le32 drop_seq_cnt ;
   __le32 fcoe_rx_drop_pkt_cnt ;
   __le32 fcp_rx_pkt_cnt ;
   __le32 reserved0 ;
};
#line 954 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_tx_stat_params {
   __le32 fcoe_tx_pkt_cnt ;
   __le32 fcoe_tx_byte_cnt ;
   __le32 fcp_tx_pkt_cnt ;
   __le32 reserved0 ;
};
#line 965 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_statistics_params {
   struct fcoe_tx_stat_params tx_stat ;
   struct fcoe_rx_stat_params_section0 rx_stat0 ;
   struct fcoe_rx_stat_params_section1 rx_stat1 ;
   struct fcoe_rx_stat_params_section2 rx_stat2 ;
};
#line 975 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_t2_hash_table_entry {
   struct fcoe_hash_table_entry data ;
   struct regpair next ;
   struct regpair reserved0[3U] ;
};
#line 994 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_capabilities {
   u32 capability1 ;
   u32 capability2 ;
   u32 capability3 ;
   u32 capability4 ;
};
#line 61 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/../../net/ethernet/broadcom/bnx2x/bnx2x_mfw_req.h"
struct eth_stats_info {
   u8 version[12U] ;
   u8 mac_local[8U] ;
   u8 mac_add1[8U] ;
   u8 mac_add2[8U] ;
   u32 mtu_size ;
   u32 feature_flags ;
   u32 lso_max_size ;
   u32 lso_min_seg_cnt ;
   u32 ipv4_ofld_cnt ;
   u32 ipv6_ofld_cnt ;
   u32 promiscuous_mode ;
   u32 txq_size ;
   u32 rxq_size ;
   u32 txq_avg_depth ;
   u32 rxq_avg_depth ;
   u32 iov_offload ;
   u32 netq_cnt ;
   u32 vf_cnt ;
};
#line 105 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/../../net/ethernet/broadcom/bnx2x/bnx2x_mfw_req.h"
struct fcoe_stats_info {
   u8 version[12U] ;
   u8 mac_local[8U] ;
   u8 mac_add1[8U] ;
   u8 mac_add2[8U] ;
   u32 qos_priority ;
   u32 txq_size ;
   u32 rxq_size ;
   u32 txq_avg_depth ;
   u32 rxq_avg_depth ;
   u32 rx_frames_lo ;
   u32 rx_frames_hi ;
   u32 rx_bytes_lo ;
   u32 rx_bytes_hi ;
   u32 tx_frames_lo ;
   u32 tx_frames_hi ;
   u32 tx_bytes_lo ;
   u32 tx_bytes_hi ;
};
#line 129 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/../../net/ethernet/broadcom/bnx2x/bnx2x_mfw_req.h"
struct iscsi_stats_info {
   u8 version[12U] ;
   u8 mac_local[8U] ;
   u8 mac_add1[8U] ;
   u32 qos_priority ;
   u8 initiator_name[64U] ;
   u8 ww_port_name[64U] ;
   u8 boot_target_name[64U] ;
   u8 boot_target_ip[16U] ;
   u32 boot_target_portal ;
   u8 boot_init_ip[16U] ;
   u32 max_frame_size ;
   u32 txq_size ;
   u32 rxq_size ;
   u32 txq_avg_depth ;
   u32 rxq_avg_depth ;
   u32 rx_pdus_lo ;
   u32 rx_pdus_hi ;
   u32 rx_bytes_lo ;
   u32 rx_bytes_hi ;
   u32 tx_pdus_lo ;
   u32 tx_pdus_hi ;
   u32 tx_bytes_lo ;
   u32 tx_bytes_hi ;
   u32 pcp_prior_map_tbl ;
};
#line 158 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/../../net/ethernet/broadcom/bnx2x/bnx2x_mfw_req.h"
union drv_info_to_mcp {
   struct eth_stats_info ether_stat ;
   struct fcoe_stats_info fcoe_stat ;
   struct iscsi_stats_info iscsi_stat ;
};
#line 168 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/../../net/ethernet/broadcom/bnx2x/bnx2x_mfw_req.h"
struct kwqe {
   u32 kwqe_op_flag ;
   u32 kwqe_info0 ;
   u32 kwqe_info1 ;
   u32 kwqe_info2 ;
   u32 kwqe_info3 ;
   u32 kwqe_info4 ;
   u32 kwqe_info5 ;
   u32 kwqe_info6 ;
};
#line 62 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/../../net/ethernet/broadcom/cnic_if.h"
struct kwqe_16 {
   u32 kwqe_info0 ;
   u32 kwqe_info1 ;
   u32 kwqe_info2 ;
   u32 kwqe_info3 ;
};
#line 232 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/../../net/ethernet/broadcom/cnic_if.h"
union __anonunion_local_358 {
   struct sockaddr_in v4 ;
   struct sockaddr_in6 v6 ;
};
#line 232 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/../../net/ethernet/broadcom/cnic_if.h"
union __anonunion_remote_359 {
   struct sockaddr_in v4 ;
   struct sockaddr_in6 v6 ;
};
#line 232 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/../../net/ethernet/broadcom/cnic_if.h"
struct cnic_sockaddr {
   union __anonunion_local_358 local ;
   union __anonunion_remote_359 remote ;
};
#line 243 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/../../net/ethernet/broadcom/cnic_if.h"
struct cnic_sock {
   struct cnic_dev *dev ;
   void *context ;
   u32 src_ip[4U] ;
   u32 dst_ip[4U] ;
   u16 src_port ;
   u16 dst_port ;
   u16 vlan_id ;
   unsigned char old_ha[6U] ;
   unsigned char ha[6U] ;
   u32 mtu ;
   u32 cid ;
   u32 l5_cid ;
   u32 pg_cid ;
   int ulp_type ;
   u32 ka_timeout ;
   u32 ka_interval ;
   u8 ka_max_probe_count ;
   u8 tos ;
   u8 ttl ;
   u8 snd_seq_scale ;
   u32 rcv_buf ;
   u32 snd_buf ;
   u32 seed ;
   unsigned long tcp_flags ;
   unsigned long flags ;
   atomic_t ref_count ;
   u32 state ;
   struct kwqe kwqe1 ;
   struct kwqe kwqe2 ;
   struct kwqe kwqe3 ;
};
#line 293 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/../../net/ethernet/broadcom/cnic_if.h"
struct cnic_dev {
   struct net_device *netdev ;
   struct pci_dev *pcidev ;
   void *regview ;
   struct list_head list ;
   int (*register_device)(struct cnic_dev * , int  , void * ) ;
   int (*unregister_device)(struct cnic_dev * , int  ) ;
   int (*submit_kwqes)(struct cnic_dev * , struct kwqe ** , u32  ) ;
   int (*submit_kwqes_16)(struct cnic_dev * , struct kwqe_16 ** , u32  ) ;
   int (*cm_create)(struct cnic_dev * , int  , u32  , u32  , struct cnic_sock ** ,
                    void * ) ;
   int (*cm_destroy)(struct cnic_sock * ) ;
   int (*cm_connect)(struct cnic_sock * , struct cnic_sockaddr * ) ;
   int (*cm_abort)(struct cnic_sock * ) ;
   int (*cm_close)(struct cnic_sock * ) ;
   struct cnic_dev *(*cm_select_dev)(struct sockaddr_in * , int  ) ;
   int (*iscsi_nl_msg_recv)(struct cnic_dev * , u32  , char * , u16  ) ;
   unsigned long flags ;
   atomic_t ref_count ;
   u8 mac_addr[6U] ;
   int max_iscsi_conn ;
   int max_fcoe_conn ;
   int max_rdma_conn ;
   int max_fcoe_exchanges ;
   union drv_info_to_mcp *stats_addr ;
   struct fcoe_capabilities *fcoe_cap ;
   void *cnic_priv ;
};
#line 175 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc.h"
struct bnx2fc_fw_stats {
   u64 fc_crc_cnt ;
   u64 fcoe_tx_pkt_cnt ;
   u64 fcoe_rx_pkt_cnt ;
   u64 fcoe_tx_byte_cnt ;
   u64 fcoe_rx_byte_cnt ;
};
#line 183
struct bnx2fc_cmd_mgr;
#line 183
struct bnx2fc_rport;
#line 183 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc.h"
struct bnx2fc_hba {
   struct list_head list ;
   struct cnic_dev *cnic ;
   struct pci_dev *pcidev ;
   struct net_device *phys_dev ;
   unsigned long reg_with_cnic ;
   struct bnx2fc_cmd_mgr *cmd_mgr ;
   spinlock_t hba_lock ;
   struct mutex hba_mutex ;
   unsigned long adapter_state ;
   unsigned long flags ;
   u32 next_conn_id ;
   u16 max_xid ;
   u32 max_tasks ;
   u32 max_outstanding_cmds ;
   u32 elstm_xids ;
   struct fcoe_task_ctx_entry **task_ctx ;
   dma_addr_t *task_ctx_dma ;
   struct regpair *task_ctx_bd_tbl ;
   dma_addr_t task_ctx_bd_dma ;
   int hash_tbl_segment_count ;
   void **hash_tbl_segments ;
   void *hash_tbl_pbl ;
   dma_addr_t hash_tbl_pbl_dma ;
   struct fcoe_t2_hash_table_entry *t2_hash_tbl ;
   dma_addr_t t2_hash_tbl_dma ;
   char *t2_hash_tbl_ptr ;
   dma_addr_t t2_hash_tbl_ptr_dma ;
   char *dummy_buffer ;
   dma_addr_t dummy_buf_dma ;
   struct bnx2fc_rport **tgt_ofld_list ;
   struct bnx2fc_fw_stats bfw_stats ;
   struct fcoe_statistics_params prev_stats ;
   struct fcoe_statistics_params *stats_buffer ;
   dma_addr_t stats_buf_dma ;
   struct completion stat_req_done ;
   struct fcoe_capabilities fcoe_cap ;
   struct timer_list destroy_timer ;
   wait_queue_head_t destroy_wait ;
   wait_queue_head_t shutdown_wait ;
   int wait_for_link_down ;
   int num_ofld_sess ;
   struct list_head vports ;
   char chip_num[16U] ;
};
#line 250 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc.h"
struct bnx2fc_interface {
   struct list_head list ;
   unsigned long if_flags ;
   struct bnx2fc_hba *hba ;
   struct net_device *netdev ;
   struct packet_type fcoe_packet_type ;
   struct packet_type fip_packet_type ;
   struct workqueue_struct *timer_work_queue ;
   struct kref kref ;
   u8 vlan_enabled ;
   int vlan_id ;
   bool enabled ;
};
#line 276
struct io_bdt;
#line 276
struct bnx2fc_cmd;
#line 276 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc.h"
struct bnx2fc_cmd_mgr {
   struct bnx2fc_hba *hba ;
   u16 next_idx ;
   struct list_head *free_list ;
   spinlock_t *free_list_lock ;
   struct io_bdt **io_bdt_pool ;
   struct bnx2fc_cmd **cmds ;
};
#line 285 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc.h"
struct bnx2fc_rport {
   struct fcoe_port *port ;
   struct fc_rport *rport ;
   struct fc_rport_priv *rdata ;
   void *ctx_base ;
   u32 io_timeout ;
   u32 fcoe_conn_id ;
   u32 context_id ;
   u32 sid ;
   int dev_type ;
   unsigned long flags ;
   u8 src_addr[6U] ;
   u32 max_sqes ;
   u32 max_rqes ;
   u32 max_cqes ;
   atomic_t free_sqes ;
   struct b577xx_doorbell_set_prod sq_db ;
   struct b577xx_fcoe_rx_doorbell rx_db ;
   struct fcoe_sqe *sq ;
   dma_addr_t sq_dma ;
   u16 sq_prod_idx ;
   u8 sq_curr_toggle_bit ;
   u32 sq_mem_size ;
   struct fcoe_cqe *cq ;
   dma_addr_t cq_dma ;
   u16 cq_cons_idx ;
   u8 cq_curr_toggle_bit ;
   u32 cq_mem_size ;
   void *rq ;
   dma_addr_t rq_dma ;
   u32 rq_prod_idx ;
   u32 rq_cons_idx ;
   u32 rq_mem_size ;
   void *rq_pbl ;
   dma_addr_t rq_pbl_dma ;
   u32 rq_pbl_size ;
   struct fcoe_xfrqe *xferq ;
   dma_addr_t xferq_dma ;
   u32 xferq_mem_size ;
   struct fcoe_confqe *confq ;
   dma_addr_t confq_dma ;
   u32 confq_mem_size ;
   void *confq_pbl ;
   dma_addr_t confq_pbl_dma ;
   u32 confq_pbl_size ;
   struct fcoe_conn_db *conn_db ;
   dma_addr_t conn_db_dma ;
   u32 conn_db_mem_size ;
   struct fcoe_sqe *lcq ;
   dma_addr_t lcq_dma ;
   u32 lcq_mem_size ;
   void *ofld_req[4U] ;
   dma_addr_t ofld_req_dma[4U] ;
   void *enbl_req ;
   dma_addr_t enbl_req_dma ;
   spinlock_t tgt_lock ;
   spinlock_t cq_lock ;
   atomic_t num_active_ios ;
   u32 flush_in_prog ;
   unsigned long timestamp ;
   unsigned long retry_delay_timestamp ;
   struct list_head free_task_list ;
   struct bnx2fc_cmd *pending_queue[257U] ;
   struct list_head active_cmd_queue ;
   struct list_head els_queue ;
   struct list_head io_retire_queue ;
   struct list_head active_tm_queue ;
   struct timer_list ofld_timer ;
   wait_queue_head_t ofld_wait ;
   struct timer_list upld_timer ;
   wait_queue_head_t upld_wait ;
};
#line 385 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc.h"
struct bnx2fc_mp_req {
   u8 tm_flags ;
   u32 req_len ;
   void *req_buf ;
   dma_addr_t req_buf_dma ;
   struct fcoe_bd_ctx *mp_req_bd ;
   dma_addr_t mp_req_bd_dma ;
   struct fc_frame_header req_fc_hdr ;
   u32 resp_len ;
   void *resp_buf ;
   dma_addr_t resp_buf_dma ;
   struct fcoe_bd_ctx *mp_resp_bd ;
   dma_addr_t mp_resp_bd_dma ;
   struct fc_frame_header resp_fc_hdr ;
};
#line 403 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc.h"
struct bnx2fc_els_cb_arg {
   struct bnx2fc_cmd *aborted_io_req ;
   struct bnx2fc_cmd *io_req ;
   u16 l2_oxid ;
   u32 offset ;
   enum fc_rctl r_ctl ;
};
#line 411
struct fcp_rsp;
#line 411 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc.h"
struct bnx2fc_cmd {
   struct list_head link ;
   u8 on_active_queue ;
   u8 on_tmf_queue ;
   u8 cmd_type ;
   u8 io_req_flags ;
   struct kref refcount ;
   struct fcoe_port *port ;
   struct bnx2fc_rport *tgt ;
   struct scsi_cmnd *sc_cmd ;
   struct bnx2fc_cmd_mgr *cmd_mgr ;
   struct bnx2fc_mp_req mp_req ;
   void (*cb_func)(struct bnx2fc_els_cb_arg * ) ;
   struct bnx2fc_els_cb_arg *cb_arg ;
   struct delayed_work timeout_work ;
   struct completion tm_done ;
   int wait_for_comp ;
   u16 xid ;
   struct fcoe_err_report_entry err_entry ;
   struct fcoe_task_ctx_entry *task ;
   struct io_bdt *bd_tbl ;
   struct fcp_rsp *rsp ;
   size_t data_xfer_len ;
   unsigned long req_flags ;
   u8 rec_retry ;
   u8 srr_retry ;
   u32 srr_offset ;
   u8 srr_rctl ;
   u32 fcp_resid ;
   u32 fcp_rsp_len ;
   u32 fcp_sns_len ;
   u8 cdb_status ;
   u8 fcp_status ;
   u8 fcp_rsp_code ;
   u8 scsi_comp_flags ;
};
#line 468 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc.h"
struct io_bdt {
   struct bnx2fc_cmd *io_req ;
   struct fcoe_bd_ctx *bd_tbl ;
   dma_addr_t bd_tbl_dma ;
   u16 bd_valid ;
};
#line 179 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
typedef bool ldv_func_ret_type;
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
typedef bool ldv_func_ret_type___0;
#line 201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
typedef bool ldv_func_ret_type___1;
#line 220 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
typedef bool ldv_func_ret_type___2;
#line 231 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
typedef int ldv_func_ret_type___3;
#line 245 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
typedef struct Scsi_Host *ldv_func_ret_type___4;
#line 259 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
typedef bool ldv_func_ret_type___5;
#line 92 "include/linux/types.h"
typedef unsigned long ulong;
#line 489 "./arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_33 {
   unsigned long seg ;
};
#line 489 "./arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_33 mm_segment_t;
#line 131 "include/asm-generic/atomic-long.h"
struct thread_info {
   struct task_struct *task ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int saved_preempt_count ;
   mm_segment_t addr_limit ;
   void *sysenter_return ;
   unsigned char sig_on_uaccess_error : 1 ;
   unsigned char uaccess_err : 1 ;
};
#line 72 "./arch/x86/include/asm/preempt.h"
typedef int pao_T__;
#line 77 "./arch/x86/include/asm/preempt.h"
typedef int pao_T_____0;
#line 12 "include/linux/wait.h"
struct __wait_queue;
#line 12 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 247 "include/linux/timer.h"
enum hrtimer_restart;
#line 215 "include/linux/skbuff.h"
struct skb_frag_struct;
#line 215 "include/linux/skbuff.h"
typedef struct skb_frag_struct skb_frag_t;
#line 216 "include/linux/skbuff.h"
struct __anonstruct_page_225 {
   struct page *p ;
};
#line 216 "include/linux/skbuff.h"
struct skb_frag_struct {
   struct __anonstruct_page_225 page ;
   __u32 page_offset ;
   __u32 size ;
};
#line 249 "include/linux/skbuff.h"
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
};
#line 319 "include/linux/skbuff.h"
struct skb_shared_info {
   unsigned char nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   unsigned short gso_type ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   u32 tskey ;
   __be32 ip6_frag_id ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};
#line 191 "include/linux/netdevice.h"
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};
#line 3005 "include/linux/netdevice.h"
typedef int pao_T_____33;
#line 3005 "include/linux/netdevice.h"
typedef int pao_T_____34;
#line 3005 "include/linux/netdevice.h"
typedef int pao_T_____35;
#line 3005 "include/linux/netdevice.h"
typedef int pao_T_____36;
#line 3016 "include/linux/netdevice.h"
typedef int pao_T_____37;
#line 3016 "include/linux/netdevice.h"
typedef int pao_T_____38;
#line 3016 "include/linux/netdevice.h"
typedef int pao_T_____39;
#line 3016 "include/linux/netdevice.h"
typedef int pao_T_____40;
#line 134 "./include/uapi/scsi/scsi_netlink.h"
enum fc_tgtid_binding_type {
    FC_TGTID_BIND_NONE = 0,
    FC_TGTID_BIND_BY_WWPN = 1,
    FC_TGTID_BIND_BY_WWNN = 2,
    FC_TGTID_BIND_BY_ID = 3
} ;
#line 462 "include/scsi/scsi_transport_fc.h"
struct fc_host_attrs {
   u64 node_name ;
   u64 port_name ;
   u64 permanent_port_name ;
   u32 supported_classes ;
   u8 supported_fc4s[32U] ;
   u32 supported_speeds ;
   u32 maxframe_size ;
   u16 max_npiv_vports ;
   char serial_number[80U] ;
   char manufacturer[80U] ;
   char model[256U] ;
   char model_description[256U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char firmware_version[64U] ;
   char optionrom_version[64U] ;
   u32 port_id ;
   enum fc_port_type port_type ;
   enum fc_port_state port_state ;
   u8 active_fc4s[32U] ;
   u32 speed ;
   u64 fabric_name ;
   char symbolic_name[256U] ;
   char system_hostname[256U] ;
   u32 dev_loss_tmo ;
   enum fc_tgtid_binding_type tgtid_bind_type ;
   struct list_head rports ;
   struct list_head rport_bindings ;
   struct list_head vports ;
   u32 next_rport_number ;
   u32 next_target_id ;
   u32 next_vport_number ;
   u16 npiv_vports_inuse ;
   char work_q_name[20U] ;
   struct workqueue_struct *work_q ;
   char devloss_work_q_name[20U] ;
   struct workqueue_struct *devloss_work_q ;
   struct request_queue *rqst_q ;
};
#line 547 "include/scsi/scsi_transport_fc.h"
struct fc_bsg_buffer {
   unsigned int payload_len ;
   int sg_cnt ;
   struct scatterlist *sg_list ;
};
#line 632
struct fc_bsg_request;
#line 632
struct fc_bsg_reply;
#line 632 "include/scsi/scsi_transport_fc.h"
struct fc_bsg_job {
   struct Scsi_Host *shost ;
   struct fc_rport *rport ;
   struct device *dev ;
   struct request *req ;
   spinlock_t job_lock ;
   unsigned int state_flags ;
   unsigned int ref_cnt ;
   void (*job_done)(struct fc_bsg_job * ) ;
   struct fc_bsg_request *request ;
   struct fc_bsg_reply *reply ;
   unsigned int request_len ;
   unsigned int reply_len ;
   struct fc_bsg_buffer request_payload ;
   struct fc_bsg_buffer reply_payload ;
   void *dd_data ;
};
#line 666 "include/scsi/scsi_transport_fc.h"
struct fc_function_template {
   void (*get_rport_dev_loss_tmo)(struct fc_rport * ) ;
   void (*set_rport_dev_loss_tmo)(struct fc_rport * , u32  ) ;
   void (*get_starget_node_name)(struct scsi_target * ) ;
   void (*get_starget_port_name)(struct scsi_target * ) ;
   void (*get_starget_port_id)(struct scsi_target * ) ;
   void (*get_host_port_id)(struct Scsi_Host * ) ;
   void (*get_host_port_type)(struct Scsi_Host * ) ;
   void (*get_host_port_state)(struct Scsi_Host * ) ;
   void (*get_host_active_fc4s)(struct Scsi_Host * ) ;
   void (*get_host_speed)(struct Scsi_Host * ) ;
   void (*get_host_fabric_name)(struct Scsi_Host * ) ;
   void (*get_host_symbolic_name)(struct Scsi_Host * ) ;
   void (*set_host_system_hostname)(struct Scsi_Host * ) ;
   struct fc_host_statistics *(*get_fc_host_stats)(struct Scsi_Host * ) ;
   void (*reset_fc_host_stats)(struct Scsi_Host * ) ;
   int (*issue_fc_host_lip)(struct Scsi_Host * ) ;
   void (*dev_loss_tmo_callbk)(struct fc_rport * ) ;
   void (*terminate_rport_io)(struct fc_rport * ) ;
   void (*set_vport_symbolic_name)(struct fc_vport * ) ;
   int (*vport_create)(struct fc_vport * , bool  ) ;
   int (*vport_disable)(struct fc_vport * , bool  ) ;
   int (*vport_delete)(struct fc_vport * ) ;
   int (*tsk_mgmt_response)(struct Scsi_Host * , u64  , u64  , int  ) ;
   int (*it_nexus_response)(struct Scsi_Host * , u64  , int  ) ;
   int (*bsg_request)(struct fc_bsg_job * ) ;
   int (*bsg_timeout)(struct fc_bsg_job * ) ;
   u32 dd_fcrport_size ;
   u32 dd_fcvport_size ;
   u32 dd_bsg_size ;
   unsigned char show_rport_maxframe_size : 1 ;
   unsigned char show_rport_supported_classes : 1 ;
   unsigned char show_rport_dev_loss_tmo : 1 ;
   unsigned char show_starget_node_name : 1 ;
   unsigned char show_starget_port_name : 1 ;
   unsigned char show_starget_port_id : 1 ;
   unsigned char show_host_node_name : 1 ;
   unsigned char show_host_port_name : 1 ;
   unsigned char show_host_permanent_port_name : 1 ;
   unsigned char show_host_supported_classes : 1 ;
   unsigned char show_host_supported_fc4s : 1 ;
   unsigned char show_host_supported_speeds : 1 ;
   unsigned char show_host_maxframe_size : 1 ;
   unsigned char show_host_serial_number : 1 ;
   unsigned char show_host_manufacturer : 1 ;
   unsigned char show_host_model : 1 ;
   unsigned char show_host_model_description : 1 ;
   unsigned char show_host_hardware_version : 1 ;
   unsigned char show_host_driver_version : 1 ;
   unsigned char show_host_firmware_version : 1 ;
   unsigned char show_host_optionrom_version : 1 ;
   unsigned char show_host_port_id : 1 ;
   unsigned char show_host_port_type : 1 ;
   unsigned char show_host_port_state : 1 ;
   unsigned char show_host_active_fc4s : 1 ;
   unsigned char show_host_speed : 1 ;
   unsigned char show_host_fabric_name : 1 ;
   unsigned char show_host_symbolic_name : 1 ;
   unsigned char show_host_system_hostname : 1 ;
   unsigned char disable_target_scan : 1 ;
};
#line 860 "include/scsi/scsi_transport_fc.h"
struct fc_bsg_host_add_rport {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
};
#line 88 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_del_rport {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
};
#line 109 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_els {
   uint8_t command_code ;
   uint8_t port_id[3U] ;
};
#line 133 "./include/uapi/scsi/scsi_bsg_fc.h"
struct __anonstruct_rjt_data_345 {
   uint8_t action ;
   uint8_t reason_code ;
   uint8_t reason_explanation ;
   uint8_t vendor_unique ;
};
#line 133 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_ctels_reply {
   uint32_t status ;
   struct __anonstruct_rjt_data_345 rjt_data ;
};
#line 178 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_ct {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
   uint32_t preamble_word0 ;
   uint32_t preamble_word1 ;
   uint32_t preamble_word2 ;
};
#line 203 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_vendor {
   uint64_t vendor_id ;
   uint32_t vendor_cmd[0U] ;
};
#line 226 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_host_vendor_reply {
   uint32_t vendor_rsp[0U] ;
};
#line 233 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_rport_els {
   uint8_t els_code ;
};
#line 252 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_rport_ct {
   uint32_t preamble_word0 ;
   uint32_t preamble_word1 ;
   uint32_t preamble_word2 ;
};
#line 272 "./include/uapi/scsi/scsi_bsg_fc.h"
union __anonunion_rqst_data_346 {
   struct fc_bsg_host_add_rport h_addrport ;
   struct fc_bsg_host_del_rport h_delrport ;
   struct fc_bsg_host_els h_els ;
   struct fc_bsg_host_ct h_ct ;
   struct fc_bsg_host_vendor h_vendor ;
   struct fc_bsg_rport_els r_els ;
   struct fc_bsg_rport_ct r_ct ;
};
#line 272 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_request {
   uint32_t msgcode ;
   union __anonunion_rqst_data_346 rqst_data ;
};
#line 294 "./include/uapi/scsi/scsi_bsg_fc.h"
union __anonunion_reply_data_347 {
   struct fc_bsg_host_vendor_reply vendor_reply ;
   struct fc_bsg_ctels_reply ctels_reply ;
};
#line 294 "./include/uapi/scsi/scsi_bsg_fc.h"
struct fc_bsg_reply {
   uint32_t result ;
   uint32_t reply_payload_rcv_len ;
   union __anonunion_reply_data_347 reply_data ;
};
#line 1152 "include/scsi/libfc.h"
struct fcoe_hdr {
   __u8 fcoe_ver ;
   __u8 fcoe_resvd[12U] ;
   __u8 fcoe_sof ;
};
#line 56 "include/scsi/fc/fc_fcoe.h"
struct fcoe_crc_eof {
   __le32 fcoe_crc32 ;
   __u8 fcoe_eof ;
   __u8 fcoe_resvd[3U] ;
};
#line 280 "include/scsi/libfcoe.h"
struct fcoe_transport {
   char name[16U] ;
   bool attached ;
   struct list_head list ;
   bool (*match)(struct net_device * ) ;
   int (*alloc)(struct net_device * ) ;
   int (*create)(struct net_device * , enum fip_state  ) ;
   int (*destroy)(struct net_device * ) ;
   int (*enable)(struct net_device * ) ;
   int (*disable)(struct net_device * ) ;
};
#line 319 "include/scsi/libfcoe.h"
struct fcoe_percpu_s {
   struct task_struct *thread ;
   struct sk_buff_head fcoe_rx_list ;
   struct page *crc_eof_page ;
   int crc_eof_offset ;
};
#line 69 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/../../net/ethernet/broadcom/cnic_if.h"
struct kcqe {
   u32 kcqe_info0 ;
   u32 kcqe_info1 ;
   u32 kcqe_info2 ;
   u32 kcqe_info3 ;
   u32 kcqe_info4 ;
   u32 kcqe_info5 ;
   u32 kcqe_info6 ;
   u32 kcqe_op_flag ;
};
#line 335 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/../../net/ethernet/broadcom/cnic_if.h"
struct cnic_ulp_ops {
   void (*cnic_init)(struct cnic_dev * ) ;
   void (*cnic_exit)(struct cnic_dev * ) ;
   void (*cnic_start)(void * ) ;
   void (*cnic_stop)(void * ) ;
   void (*indicate_kcqes)(void * , struct kcqe ** , u32  ) ;
   void (*indicate_netevent)(void * , unsigned long  , u16  ) ;
   void (*cm_connect_complete)(struct cnic_sock * ) ;
   void (*cm_close_complete)(struct cnic_sock * ) ;
   void (*cm_abort_complete)(struct cnic_sock * ) ;
   void (*cm_remote_close)(struct cnic_sock * ) ;
   void (*cm_remote_abort)(struct cnic_sock * ) ;
   int (*iscsi_nl_send_msg)(void * , u32  , char * , u16  ) ;
   int (*cnic_get_stats)(void * ) ;
   struct module *owner ;
   atomic_t ref_count ;
};
#line 169 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc.h"
struct bnx2fc_percpu_s {
   struct task_struct *iothread ;
   struct list_head work_list ;
   spinlock_t fp_work_lock ;
};
#line 265 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc.h"
struct bnx2fc_lport {
   struct list_head list ;
   struct fc_lport *lport ;
};
#line 475 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc.h"
struct bnx2fc_work {
   struct list_head list ;
   struct bnx2fc_rport *tgt ;
   u16 wqe ;
};
#line 1178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
union __anonunion___u_361 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 1178 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
union __anonunion___u_363 {
   struct list_head *__val ;
   char __c[1U] ;
};
#line 2120
enum bnx2fc_create_link_state {
    BNX2FC_CREATE_LINK_DOWN = 0,
    BNX2FC_CREATE_LINK_UP = 1
} ;
#line 1448 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
typedef int ldv_func_ret_type___6;
#line 1475 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
typedef int ldv_func_ret_type___7;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 287 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
union fcoe_kcqe_params {
   __le32 reserved0[4U] ;
};
#line 297 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_kcqe {
   __le32 fcoe_conn_id ;
   __le32 completion_status ;
   __le32 fcoe_conn_context_id ;
   union fcoe_kcqe_params params ;
   __le16 qe_self_seq ;
   u8 op_code ;
   u8 flags ;
};
#line 310 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_kwqe_header {
   u8 op_code ;
   u8 flags ;
};
#line 328 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_kwqe_init1 {
   __le16 num_tasks ;
   struct fcoe_kwqe_header hdr ;
   __le32 task_list_pbl_addr_lo ;
   __le32 task_list_pbl_addr_hi ;
   __le32 dummy_buffer_addr_lo ;
   __le32 dummy_buffer_addr_hi ;
   __le16 sq_num_wqes ;
   __le16 rq_num_wqes ;
   __le16 rq_buffer_log_size ;
   __le16 cq_num_wqes ;
   __le16 mtu ;
   u8 num_sessions_log ;
   u8 flags ;
};
#line 353 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_kwqe_init2 {
   u8 hsi_major_version ;
   u8 hsi_minor_version ;
   struct fcoe_kwqe_header hdr ;
   __le32 hash_tbl_pbl_addr_lo ;
   __le32 hash_tbl_pbl_addr_hi ;
   __le32 t2_hash_tbl_addr_lo ;
   __le32 t2_hash_tbl_addr_hi ;
   __le32 t2_ptr_hash_tbl_addr_lo ;
   __le32 t2_ptr_hash_tbl_addr_hi ;
   __le32 free_list_count ;
};
#line 375 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_kwqe_init3 {
   __le16 reserved0 ;
   struct fcoe_kwqe_header hdr ;
   __le32 error_bit_map_lo ;
   __le32 error_bit_map_hi ;
   u8 perf_config ;
   u8 reserved21[3U] ;
   __le32 reserved2[4U] ;
};
#line 388 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_kwqe_conn_offload1 {
   __le16 fcoe_conn_id ;
   struct fcoe_kwqe_header hdr ;
   __le32 sq_addr_lo ;
   __le32 sq_addr_hi ;
   __le32 rq_pbl_addr_lo ;
   __le32 rq_pbl_addr_hi ;
   __le32 rq_first_pbe_addr_lo ;
   __le32 rq_first_pbe_addr_hi ;
   __le16 rq_prod ;
   __le16 reserved0 ;
};
#line 404 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_kwqe_conn_offload2 {
   __le16 tx_max_fc_pay_len ;
   struct fcoe_kwqe_header hdr ;
   __le32 cq_addr_lo ;
   __le32 cq_addr_hi ;
   __le32 xferq_addr_lo ;
   __le32 xferq_addr_hi ;
   __le32 conn_db_addr_lo ;
   __le32 conn_db_addr_hi ;
   __le32 reserved1 ;
};
#line 419 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_kwqe_conn_offload3 {
   __le16 vlan_tag ;
   struct fcoe_kwqe_header hdr ;
   u8 s_id[3U] ;
   u8 tx_max_conc_seqs_c3 ;
   u8 d_id[3U] ;
   u8 flags ;
   __le32 reserved ;
   __le32 confq_first_pbe_addr_lo ;
   __le32 confq_first_pbe_addr_hi ;
   __le16 tx_total_conc_seqs ;
   __le16 rx_max_fc_pay_len ;
   __le16 rx_total_conc_seqs ;
   u8 rx_max_conc_seqs_c3 ;
   u8 rx_open_seqs_exch_c3 ;
};
#line 461 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_kwqe_conn_offload4 {
   u8 e_d_tov_timer_val ;
   u8 reserved2 ;
   struct fcoe_kwqe_header hdr ;
   u8 src_mac_addr_lo[2U] ;
   u8 src_mac_addr_mid[2U] ;
   u8 src_mac_addr_hi[2U] ;
   u8 dst_mac_addr_hi[2U] ;
   u8 dst_mac_addr_lo[2U] ;
   u8 dst_mac_addr_mid[2U] ;
   __le32 lcq_addr_lo ;
   __le32 lcq_addr_hi ;
   __le32 confq_pbl_base_addr_lo ;
   __le32 confq_pbl_base_addr_hi ;
};
#line 480 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_kwqe_conn_enable_disable {
   __le16 reserved0 ;
   struct fcoe_kwqe_header hdr ;
   u8 src_mac_addr_lo[2U] ;
   u8 src_mac_addr_mid[2U] ;
   u8 src_mac_addr_hi[2U] ;
   u16 vlan_tag ;
   u8 dst_mac_addr_lo[2U] ;
   u8 dst_mac_addr_mid[2U] ;
   u8 dst_mac_addr_hi[2U] ;
   __le16 reserved1 ;
   u8 s_id[3U] ;
   u8 vlan_flag ;
   u8 d_id[3U] ;
   u8 reserved3 ;
   __le32 context_id ;
   __le32 conn_id ;
   __le32 reserved4 ;
};
#line 509 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_kwqe_conn_destroy {
   __le16 reserved0 ;
   struct fcoe_kwqe_header hdr ;
   __le32 context_id ;
   __le32 conn_id ;
   __le32 reserved1[5U] ;
};
#line 520 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_kwqe_destroy {
   __le16 reserved0 ;
   struct fcoe_kwqe_header hdr ;
   __le32 reserved1[7U] ;
};
#line 529 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/57xx_hsi_bnx2fc.h"
struct fcoe_kwqe_stat {
   __le16 reserved0 ;
   struct fcoe_kwqe_header hdr ;
   __le32 stat_params_addr_lo ;
   __le32 stat_params_addr_hi ;
   __le32 reserved1[5U] ;
};
#line 481 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc.h"
struct bnx2fc_unsol_els {
   struct fc_lport *lport ;
   struct fc_frame *fp ;
   struct bnx2fc_hba *hba ;
   struct work_struct unsol_els_work ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 152 "include/scsi/libfc.h"
struct fc_rport_libfc_priv {
   struct fc_lport *local_port ;
   enum fc_rport_state rp_state ;
   u16 flags ;
   unsigned int e_d_tov ;
   unsigned int r_a_tov ;
};
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
typedef bool ldv_func_ret_type___8;
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
typedef bool ldv_func_ret_type___9;
#line 432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
typedef bool ldv_func_ret_type___10;
#line 443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
typedef bool ldv_func_ret_type___11;
#line 454 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
typedef bool ldv_func_ret_type___12;
#line 247 "include/linux/timer.h"
enum hrtimer_restart;
#line 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
typedef int ldv_func_ret_type___13;
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
typedef int ldv_func_ret_type___14;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_debug.o.c"
struct va_list;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_debug.o.c"

#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 63 "include/linux/printk.h"
struct va_format {
   char const   *fmt ;
   va_list *va ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 72 "./arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 204 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 206
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 206
  return ((int )((signed char )c) != 0);
}
}
#line 250 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_clear_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 252
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 252
  return ((int )((signed char )c) != 0);
}
}
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 7 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
#line 9
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
#line 10
  return (val);
}
}
#line 14 "./arch/x86/include/uapi/asm/swab.h"
__inline static __u64 __arch_swab64(__u64 val ) 
{ 


  {
#line 30
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
#line 31
  return (val);
}
}
#line 46 "include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 57 "include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  __u32 tmp ;

  {
#line 62
  tmp = __arch_swab32(val);
#line 62
  return (tmp);
}
}
#line 68 "include/uapi/linux/swab.h"
__inline static __u64 __fswab64(__u64 val ) 
{ 
  __u64 tmp ;

  {
#line 73
  tmp = __arch_swab64(val);
#line 73
  return (tmp);
}
}
#line 142 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 3 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
bool ldv_is_err(void const   *ptr ) ;
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 48
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 75 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 77
  __list_add(new, head->prev, head);
#line 78
  return;
}
}
#line 112
extern void __list_del_entry(struct list_head * ) ;
#line 143 "include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
#line 145
  __list_del_entry(entry);
#line 146
  INIT_LIST_HEAD(entry);
#line 147
  return;
}
}
#line 71 "include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 57
extern void *memset(void * , int  , size_t  ) ;
#line 41 "include/linux/err.h"
__inline static bool IS_ERR(void const   *ptr ) ;
#line 15 "./arch/x86/include/asm/cmpxchg.h"
extern void __xadd_wrong_size(void) ;
#line 79 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ 
  char c ;

  {
#line 81
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; subl %2, %0; sete %1": "+m" (v->counter),
                       "=qm" (c): "er" (i): "memory");
#line 81
  return ((int )((signed char )c) != 0);
}
}
#line 155 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
#line 157
  __ret = i;
#line 157
  switch (4UL) {
  case 1UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5659;
  case 2UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5659;
  case 4UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5659;
  case 8UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5659;
  default: 
#line 157
  __xadd_wrong_size();
  }
  ldv_5659: ;
#line 157
  return (__ret + i);
}
}
#line 30 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_bh(raw_spinlock_t * ) ;
#line 42
extern void _raw_spin_unlock_bh(raw_spinlock_t * ) ;
#line 315 "include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) 
{ 


  {
#line 317
  _raw_spin_lock_bh(& lock->__annonCompField18.rlock);
#line 318
  return;
}
}
#line 360 "include/linux/spinlock.h"
__inline static void spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
#line 362
  _raw_spin_unlock_bh(& lock->__annonCompField18.rlock);
#line 363
  return;
}
}
#line 78 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 429 "include/linux/workqueue.h"
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 433
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 439
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 443
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 452
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 455
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) ;
#line 467
extern bool cancel_delayed_work(struct delayed_work * ) ;
#line 470
bool ldv_cancel_delayed_work_12(struct delayed_work *ldv_func_arg1 ) ;
#line 41 "include/linux/kref.h"
__inline static void kref_get(struct kref *kref ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 47
  tmp = atomic_add_return(1, & kref->refcount);
#line 47
  __ret_warn_once = tmp <= 1;
#line 47
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 47
  if (tmp___2 != 0L) {
#line 47
    __ret_warn_on = ! __warned;
#line 47
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___0 != 0L) {
#line 47
      warn_slowpath_null("include/linux/kref.h", 47);
    } else {

    }
#line 47
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___1 != 0L) {
#line 47
      __warned = 1;
    } else {

    }
  } else {

  }
#line 47
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 49
  return;
}
}
#line 68 "include/linux/kref.h"
__inline static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
#line 71
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
#line 71
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 71
  if (tmp != 0L) {
#line 71
    warn_slowpath_null("include/linux/kref.h", 71);
  } else {

  }
#line 71
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 73
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
#line 73
  if (tmp___0 != 0) {
#line 74
    (*release)(kref);
#line 75
    return (1);
  } else {

  }
#line 77
  return (0);
}
}
#line 97 "include/linux/kref.h"
__inline static int kref_put(struct kref *kref , void (*release)(struct kref * ) ) 
{ 
  int tmp ;

  {
#line 99
  tmp = kref_sub(kref, 1U, release);
#line 99
  return (tmp);
}
}
#line 143 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 289
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 418 "include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 435
  tmp___2 = __kmalloc(size, flags);
#line 435
  return (tmp___2);
}
}
#line 581 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 583
  tmp = kmalloc(size, flags | 32768U);
#line 583
  return (tmp);
}
}
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 32 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
int ldv_timer_state_7  =    0;
#line 56 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 85
int ldv_state_variable_10 ;
#line 109
void call_and_disable_all_2(int state ) ;
#line 130
void ldv_initialize_scsi_host_template_10(void) ;
#line 131
void activate_work_2(struct work_struct *work , int state ) ;
#line 138
void disable_work_2(struct work_struct *work ) ;
#line 772 "include/linux/skbuff.h"
extern void kfree_skb(struct sk_buff * ) ;
#line 46 "include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 93 "include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 const   *addr ) 
{ 


  {
#line 96
  return (((unsigned int )*((u32 const   *)addr) | (unsigned int )*((u16 const   *)addr + 4U)) == 0U);
}
}
#line 789 "include/scsi/scsi_host.h"
extern struct Scsi_Host *scsi_host_alloc(struct scsi_host_template * , int  ) ;
#line 792
struct Scsi_Host *ldv_scsi_host_alloc_11(struct scsi_host_template *sht , int privsize ) ;
#line 794
extern int scsi_add_host_with_dma(struct Scsi_Host * , struct device * , struct device * ) ;
#line 799
int ldv_scsi_add_host_with_dma_10(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 772 "include/scsi/scsi_transport_fc.h"
__inline static int fc_remote_port_chkready(struct fc_rport *rport ) 
{ 
  int result ;

  {
#line 776
  switch ((unsigned int )rport->port_state) {
  case 2U: ;
#line 778
  if ((int )rport->roles & 1) {
#line 779
    result = 0;
  } else
#line 780
  if ((int )rport->flags & 1) {
#line 781
    result = 786432;
  } else {
#line 783
    result = 65536;
  }
#line 784
  goto ldv_51207;
  case 4U: ;
#line 786
  if (((int )rport->flags & 4) != 0) {
#line 787
    result = 983040;
  } else {
#line 789
    result = 786432;
  }
#line 790
  goto ldv_51207;
  default: 
#line 792
  result = 65536;
#line 793
  goto ldv_51207;
  }
  ldv_51207: ;
#line 795
  return (result);
}
}
#line 858
extern int fc_vport_terminate(struct fc_vport * ) ;
#line 38 "include/scsi/fc_frame.h"
__inline static u32 ntoh24(u8 const   *p ) 
{ 


  {
#line 40
  return ((u32 )((((int )*p << 16) | ((int )*(p + 1UL) << 8)) | (int )*(p + 2UL)));
}
}
#line 43 "include/scsi/fc_frame.h"
__inline static void hton24(u8 *p , u32 v ) 
{ 


  {
#line 45
  *p = (u8 )(v >> 16);
#line 46
  *(p + 1UL) = (u8 )(v >> 8);
#line 47
  *(p + 2UL) = (u8 )v;
#line 48
  return;
}
}
#line 121
extern struct fc_frame *fc_frame_alloc_fill(struct fc_lport * , size_t  ) ;
#line 122
extern struct fc_frame *_fc_frame_alloc(size_t  ) ;
#line 128 "include/scsi/fc_frame.h"
__inline static struct fc_frame *fc_frame_alloc(struct fc_lport *dev , size_t len ) 
{ 
  struct fc_frame *fp ;

  {
#line 136
  if (len != 0UL && (len & 3UL) != 0UL) {
#line 137
    fp = fc_frame_alloc_fill(dev, len);
  } else {
#line 139
    fp = _fc_frame_alloc(len);
  }
#line 140
  return (fp);
}
}
#line 146 "include/scsi/fc_frame.h"
__inline static void fc_frame_free(struct fc_frame *fp ) 
{ 


  {
#line 148
  kfree_skb(& fp->skb);
#line 149
  return;
}
}
#line 161 "include/scsi/fc_frame.h"
__inline static struct fc_frame_header *__fc_frame_header_get(struct fc_frame  const  *fp ) 
{ 


  {
#line 163
  return ((struct fc_frame_header *)fp->skb.data);
}
}
#line 171 "include/scsi/fc_frame.h"
__inline static struct fc_frame_header *fc_frame_header_get(struct fc_frame  const  *fp ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  struct fc_frame_header *tmp___0 ;

  {
#line 173
  __ret_warn_on = (unsigned int )fp->skb.len <= 23U;
#line 173
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 173
  if (tmp != 0L) {
#line 173
    warn_slowpath_null("include/scsi/fc_frame.h", 173);
  } else {

  }
#line 173
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 174
  tmp___0 = __fc_frame_header_get(fp);
#line 174
  return (tmp___0);
}
}
#line 203 "include/scsi/fc_frame.h"
__inline static void *fc_frame_payload_get(struct fc_frame  const  *fp , size_t len ) 
{ 
  void *pp ;
  struct fc_frame_header *tmp ;

  {
#line 206
  pp = (void *)0;
#line 208
  if ((unsigned long )fp->skb.len >= len + 24UL) {
#line 209
    tmp = fc_frame_header_get(fp);
#line 209
    pp = (void *)tmp + 1U;
  } else {

  }
#line 210
  return (pp);
}
}
#line 218 "include/scsi/fc_frame.h"
__inline static u8 fc_frame_payload_op(struct fc_frame  const  *fp ) 
{ 
  u8 *cp ;
  void *tmp ;

  {
#line 222
  tmp = fc_frame_payload_get(fp, 1UL);
#line 222
  cp = (u8 *)tmp;
#line 223
  if ((unsigned long )cp == (unsigned long )((u8 *)0U)) {
#line 224
    return (0U);
  } else {

  }
#line 225
  return (*cp);
}
}
#line 1016 "include/scsi/libfc.h"
__inline static void *lport_priv(struct fc_lport  const  *lport ) 
{ 


  {
#line 1018
  return ((void *)lport + 1U);
}
}
#line 1113
extern struct fc_seq *fc_elsct_send(struct fc_lport * , u32  , struct fc_frame * ,
                                    unsigned int  , void (*)(struct fc_seq * , struct fc_frame * ,
                                                             void * ) , void * , u32  ) ;
#line 1120
extern void fc_lport_flogi_resp(struct fc_seq * , struct fc_frame * , void * ) ;
#line 1121
extern void fc_lport_logo_resp(struct fc_seq * , struct fc_frame * , void * ) ;
#line 254 "include/scsi/libfcoe.h"
extern int fcoe_ctlr_recv_flogi(struct fcoe_ctlr * , struct fc_lport * , struct fc_frame * ) ;
#line 54 "include/scsi/fc_encode.h"
__inline static void __fc_fill_fc_hdr(struct fc_frame_header *fh , enum fc_rctl r_ctl ,
                                      u32 did , u32 sid , enum fc_fh_type type , u32 f_ctl ,
                                      u32 parm_offset ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  __u32 tmp___0 ;

  {
#line 59
  __ret_warn_on = (unsigned int )r_ctl == 0U;
#line 59
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 59
  if (tmp != 0L) {
#line 59
    warn_slowpath_null("include/scsi/fc_encode.h", 59);
  } else {

  }
#line 59
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 60
  fh->fh_r_ctl = (__u8 )r_ctl;
#line 61
  hton24((u8 *)(& fh->fh_d_id), did);
#line 62
  hton24((u8 *)(& fh->fh_s_id), sid);
#line 63
  fh->fh_type = (__u8 )type;
#line 64
  hton24((u8 *)(& fh->fh_f_ctl), f_ctl);
#line 65
  fh->fh_cs_ctl = 0U;
#line 66
  fh->fh_df_ctl = 0U;
#line 67
  tmp___0 = __fswab32(parm_offset);
#line 67
  fh->fh_parm_offset = tmp___0;
#line 68
  return;
}
}
#line 490 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc.h"
struct bnx2fc_cmd *bnx2fc_cmd_alloc(struct bnx2fc_rport *tgt ) ;
#line 491
struct bnx2fc_cmd *bnx2fc_elstm_alloc(struct bnx2fc_rport *tgt , int type ) ;
#line 492
void bnx2fc_cmd_release(struct kref *ref ) ;
#line 517
int bnx2fc_send_rrq(struct bnx2fc_cmd *aborted_io_req ) ;
#line 518
int bnx2fc_send_adisc(struct bnx2fc_rport *tgt , struct fc_frame *fp ) ;
#line 519
int bnx2fc_send_logo(struct bnx2fc_rport *tgt , struct fc_frame *fp ) ;
#line 520
int bnx2fc_send_rls(struct bnx2fc_rport *tgt , struct fc_frame *fp ) ;
#line 521
int bnx2fc_initiate_cleanup(struct bnx2fc_cmd *io_req ) ;
#line 522
int bnx2fc_initiate_abts(struct bnx2fc_cmd *io_req ) ;
#line 523
void bnx2fc_cmd_timer_set(struct bnx2fc_cmd *io_req , unsigned int timer_msec ) ;
#line 525
int bnx2fc_init_mp_req(struct bnx2fc_cmd *io_req ) ;
#line 533
void bnx2fc_init_mp_task(struct bnx2fc_cmd *io_req , struct fcoe_task_ctx_entry *task ) ;
#line 537
void bnx2fc_add_2_sq(struct bnx2fc_rport *tgt , u16 xid ) ;
#line 538
void bnx2fc_ring_doorbell(struct bnx2fc_rport *tgt ) ;
#line 558
void bnx2fc_process_els_compl(struct bnx2fc_cmd *els_req , struct fcoe_task_ctx_entry *task ,
                              u8 num_rq ) ;
#line 567
struct fc_seq *bnx2fc_elsct_send(struct fc_lport *lport , u32 did , struct fc_frame *fp ,
                                 unsigned int op , void (*resp)(struct fc_seq * ,
                                                                struct fc_frame * ,
                                                                void * ) , void *arg ,
                                 u32 timeout ) ;
#line 578
void bnx2fc_process_l2_frame_compl(struct bnx2fc_rport *tgt , unsigned char *buf ,
                                   u32 frame_len , u16 l2_oxid ) ;
#line 582
int bnx2fc_post_io_req(struct bnx2fc_rport *tgt , struct bnx2fc_cmd *io_req ) ;
#line 583
int bnx2fc_send_rec(struct bnx2fc_cmd *orig_io_req ) ;
#line 584
int bnx2fc_send_srr(struct bnx2fc_cmd *orig_io_req , u32 offset , u8 r_ctl ) ;
#line 588
int bnx2fc_initiate_seq_cleanup(struct bnx2fc_cmd *orig_io_req , u32 offset , enum fc_rctl r_ctl ) ;
#line 25 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc_debug.h"
unsigned int bnx2fc_debug_level ;
#line 40
void BNX2FC_IO_DBG(struct bnx2fc_cmd  const  *io_req , char const   *fmt  , ...) ;
#line 18 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"
static void bnx2fc_logo_resp(struct fc_seq *seq , struct fc_frame *fp , void *arg ) ;
#line 20
static void bnx2fc_flogi_resp(struct fc_seq *seq , struct fc_frame *fp , void *arg ) ;
#line 22
static int bnx2fc_initiate_els(struct bnx2fc_rport *tgt , unsigned int op , void *data ,
                               u32 data_len , void (*cb_func)(struct bnx2fc_els_cb_arg * ) ,
                               struct bnx2fc_els_cb_arg *cb_arg , u32 timer_msec ) ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"
static void bnx2fc_rrq_compl(struct bnx2fc_els_cb_arg *cb_arg ) 
{ 
  struct bnx2fc_cmd *orig_io_req ;
  struct bnx2fc_cmd *rrq_req ;
  int rc ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;

  {
#line 31
  rc = 0;
#line 33
  tmp = ldv__builtin_expect((unsigned long )cb_arg == (unsigned long )((struct bnx2fc_els_cb_arg *)0),
                         0L);
#line 33
  if (tmp != 0L) {
#line 33
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"),
                         "i" (33), "i" (12UL));
    ldv_54595: ;
#line 33
    goto ldv_54595;
  } else {

  }
#line 34
  rrq_req = cb_arg->io_req;
#line 35
  orig_io_req = cb_arg->aborted_io_req;
#line 36
  tmp___0 = ldv__builtin_expect((unsigned long )orig_io_req == (unsigned long )((struct bnx2fc_cmd *)0),
                             0L);
#line 36
  if (tmp___0 != 0L) {
#line 36
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"),
                         "i" (36), "i" (12UL));
    ldv_54596: ;
#line 36
    goto ldv_54596;
  } else {

  }
#line 37
  tmp___1 = ldv__builtin_expect((bnx2fc_debug_level & 8U) != 0U, 0L);
#line 37
  if (tmp___1 != 0L) {
#line 37
    printk("\016bnx2fc: rrq_compl: orig xid = 0x%x, rrq_xid = 0x%x\n", (int )orig_io_req->xid,
           (int )rrq_req->xid);
  } else {

  }
#line 40
  kref_put(& orig_io_req->refcount, & bnx2fc_cmd_release);
#line 42
  tmp___4 = test_and_clear_bit(11L, (unsigned long volatile   *)(& rrq_req->req_flags));
#line 42
  if (tmp___4 != 0) {
#line 47
    tmp___2 = ldv__builtin_expect((bnx2fc_debug_level & 8U) != 0U, 0L);
#line 47
    if (tmp___2 != 0L) {
#line 47
      printk("\016bnx2fc: rrq xid - 0x%x timed out, clean it up\n", (int )rrq_req->xid);
    } else {

    }
#line 50
    if ((unsigned int )rrq_req->on_active_queue != 0U) {
#line 51
      list_del_init(& rrq_req->link);
#line 52
      rrq_req->on_active_queue = 0U;
#line 53
      rc = bnx2fc_initiate_cleanup(rrq_req);
#line 54
      tmp___3 = ldv__builtin_expect(rc != 0, 0L);
#line 54
      if (tmp___3 != 0L) {
#line 54
        __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"),
                             "i" (54), "i" (12UL));
        ldv_54597: ;
#line 54
        goto ldv_54597;
      } else {

      }
    } else {

    }
  } else {

  }
#line 57
  kfree((void const   *)cb_arg);
#line 58
  return;
}
}
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"
int bnx2fc_send_rrq(struct bnx2fc_cmd *aborted_io_req ) 
{ 
  struct fc_els_rrq rrq ;
  struct bnx2fc_rport *tgt ;
  struct fc_lport *lport ;
  struct bnx2fc_els_cb_arg *cb_arg ;
  u32 sid ;
  u32 r_a_tov ;
  unsigned long start ;
  int rc ;
  long tmp ;
  void *tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 63
  tgt = aborted_io_req->tgt;
#line 64
  lport = (tgt->rdata)->local_port;
#line 65
  cb_arg = (struct bnx2fc_els_cb_arg *)0;
#line 66
  sid = tgt->sid;
#line 67
  r_a_tov = lport->r_a_tov;
#line 68
  start = jiffies;
#line 71
  tmp = ldv__builtin_expect((bnx2fc_debug_level & 8U) != 0U, 0L);
#line 71
  if (tmp != 0L) {
#line 71
    printk("\016bnx2fc: Sending RRQ orig_xid = 0x%x\n", (int )aborted_io_req->xid);
  } else {

  }
#line 73
  memset((void *)(& rrq), 0, 12UL);
#line 75
  tmp___0 = kzalloc(32UL, 16U);
#line 75
  cb_arg = (struct bnx2fc_els_cb_arg *)tmp___0;
#line 76
  if ((unsigned long )cb_arg == (unsigned long )((struct bnx2fc_els_cb_arg *)0)) {
#line 77
    printk("\vbnx2fc: Unable to allocate cb_arg for RRQ\n");
#line 78
    rc = -12;
#line 79
    goto rrq_err;
  } else {

  }
#line 82
  cb_arg->aborted_io_req = aborted_io_req;
#line 84
  rrq.rrq_cmd = 18U;
#line 85
  hton24((u8 *)(& rrq.rrq_s_id), sid);
#line 86
  tmp___1 = __fswab16((int )aborted_io_req->xid);
#line 86
  rrq.rrq_ox_id = tmp___1;
#line 87
  tmp___2 = __fswab16((int )(aborted_io_req->task)->rxwr_txrd.var_ctx.rx_id);
#line 87
  rrq.rrq_rx_id = tmp___2;
  retry_rrq: 
#line 90
  rc = bnx2fc_initiate_els(tgt, 18U, (void *)(& rrq), 12U, & bnx2fc_rrq_compl, cb_arg,
                           r_a_tov);
#line 93
  if (rc == -12) {
#line 94
    if ((long )((start - (unsigned long )jiffies) + 2500UL) < 0L) {
#line 95
      tmp___3 = ldv__builtin_expect((bnx2fc_debug_level & 8U) != 0U, 0L);
#line 95
      if (tmp___3 != 0L) {
#line 95
        printk("\016bnx2fc: rrq Failed\n");
      } else {

      }
#line 96
      rc = 8195;
#line 97
      goto rrq_err;
    } else {

    }
#line 99
    msleep(20U);
#line 100
    goto retry_rrq;
  } else {

  }
  rrq_err: ;
#line 103
  if (rc != 0) {
#line 104
    tmp___4 = ldv__builtin_expect((bnx2fc_debug_level & 8U) != 0U, 0L);
#line 104
    if (tmp___4 != 0L) {
#line 104
      printk("\016bnx2fc: RRQ failed - release orig io req 0x%x\n", (int )aborted_io_req->xid);
    } else {

    }
#line 106
    kfree((void const   *)cb_arg);
#line 107
    spin_lock_bh(& tgt->tgt_lock);
#line 108
    kref_put(& aborted_io_req->refcount, & bnx2fc_cmd_release);
#line 109
    spin_unlock_bh(& tgt->tgt_lock);
  } else {

  }
#line 111
  return (rc);
}
}
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"
static void bnx2fc_l2_els_compl(struct bnx2fc_els_cb_arg *cb_arg ) 
{ 
  struct bnx2fc_cmd *els_req ;
  struct bnx2fc_rport *tgt ;
  struct bnx2fc_mp_req *mp_req ;
  struct fc_frame_header *fc_hdr ;
  unsigned char *buf ;
  void *resp_buf ;
  u32 resp_len ;
  u32 hdr_len ;
  u16 l2_oxid ;
  int frame_len ;
  int rc ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 125
  rc = 0;
#line 127
  l2_oxid = cb_arg->l2_oxid;
#line 128
  tmp = ldv__builtin_expect((bnx2fc_debug_level & 8U) != 0U, 0L);
#line 128
  if (tmp != 0L) {
#line 128
    printk("\016bnx2fc: ELS COMPL - l2_oxid = 0x%x\n", (int )l2_oxid);
  } else {

  }
#line 130
  els_req = cb_arg->io_req;
#line 131
  tmp___1 = test_and_clear_bit(11L, (unsigned long volatile   *)(& els_req->req_flags));
#line 131
  if (tmp___1 != 0) {
#line 136
    if ((unsigned int )els_req->on_active_queue != 0U) {
#line 137
      list_del_init(& els_req->link);
#line 138
      els_req->on_active_queue = 0U;
#line 139
      rc = bnx2fc_initiate_cleanup(els_req);
#line 140
      tmp___0 = ldv__builtin_expect(rc != 0, 0L);
#line 140
      if (tmp___0 != 0L) {
#line 140
        __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"),
                             "i" (140), "i" (12UL));
        ldv_54631: ;
#line 140
        goto ldv_54631;
      } else {

      }
    } else {

    }
#line 142
    goto free_arg;
  } else {

  }
#line 145
  tgt = els_req->tgt;
#line 146
  mp_req = & els_req->mp_req;
#line 147
  fc_hdr = & mp_req->resp_fc_hdr;
#line 148
  resp_len = mp_req->resp_len;
#line 149
  resp_buf = mp_req->resp_buf;
#line 151
  tmp___2 = kzalloc(4096UL, 32U);
#line 151
  buf = (unsigned char *)tmp___2;
#line 152
  if ((unsigned long )buf == (unsigned long )((unsigned char *)0U)) {
#line 153
    printk("\vbnx2fc: Unable to alloc mp buf\n");
#line 154
    goto free_arg;
  } else {

  }
#line 156
  hdr_len = 24U;
#line 157
  if (hdr_len + resp_len > 4096U) {
#line 158
    printk("\vbnx2fc: l2_els_compl: resp len is beyond page size\n");
#line 160
    goto free_buf;
  } else {

  }
#line 162
  memcpy((void *)buf, (void const   *)fc_hdr, (size_t )hdr_len);
#line 163
  memcpy((void *)buf + (unsigned long )hdr_len, (void const   *)resp_buf, (size_t )resp_len);
#line 164
  frame_len = (int )(hdr_len + resp_len);
#line 166
  bnx2fc_process_l2_frame_compl(tgt, buf, (u32 )frame_len, (int )l2_oxid);
  free_buf: 
#line 169
  kfree((void const   *)buf);
  free_arg: 
#line 171
  kfree((void const   *)cb_arg);
#line 172
  return;
}
}
#line 174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"
int bnx2fc_send_adisc(struct bnx2fc_rport *tgt , struct fc_frame *fp ) 
{ 
  struct fc_els_adisc *adisc ;
  struct fc_frame_header *fh ;
  struct bnx2fc_els_cb_arg *cb_arg ;
  struct fc_lport *lport ;
  u32 r_a_tov ;
  int rc ;
  void *tmp ;
  __u16 tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;

  {
#line 179
  lport = (tgt->rdata)->local_port;
#line 180
  r_a_tov = lport->r_a_tov;
#line 183
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 184
  tmp = kzalloc(32UL, 32U);
#line 184
  cb_arg = (struct bnx2fc_els_cb_arg *)tmp;
#line 185
  if ((unsigned long )cb_arg == (unsigned long )((struct bnx2fc_els_cb_arg *)0)) {
#line 186
    printk("\vbnx2fc: Unable to allocate cb_arg for ADISC\n");
#line 187
    return (-12);
  } else {

  }
#line 190
  tmp___0 = __fswab16((int )fh->fh_ox_id);
#line 190
  cb_arg->l2_oxid = tmp___0;
#line 192
  tmp___1 = ldv__builtin_expect((bnx2fc_debug_level & 8U) != 0U, 0L);
#line 192
  if (tmp___1 != 0L) {
#line 192
    printk("\016bnx2fc: send ADISC: l2_oxid = 0x%x\n", (int )cb_arg->l2_oxid);
  } else {

  }
#line 193
  tmp___2 = fc_frame_payload_get((struct fc_frame  const  *)fp, 28UL);
#line 193
  adisc = (struct fc_els_adisc *)tmp___2;
#line 195
  rc = bnx2fc_initiate_els(tgt, 82U, (void *)adisc, 28U, & bnx2fc_l2_els_compl, cb_arg,
                           r_a_tov * 2U);
#line 197
  if (rc != 0) {
#line 198
    kfree((void const   *)cb_arg);
  } else {

  }
#line 199
  return (rc);
}
}
#line 202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"
int bnx2fc_send_logo(struct bnx2fc_rport *tgt , struct fc_frame *fp ) 
{ 
  struct fc_els_logo *logo ;
  struct fc_frame_header *fh ;
  struct bnx2fc_els_cb_arg *cb_arg ;
  struct fc_lport *lport ;
  u32 r_a_tov ;
  int rc ;
  void *tmp ;
  __u16 tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;

  {
#line 207
  lport = (tgt->rdata)->local_port;
#line 208
  r_a_tov = lport->r_a_tov;
#line 211
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 212
  tmp = kzalloc(32UL, 32U);
#line 212
  cb_arg = (struct bnx2fc_els_cb_arg *)tmp;
#line 213
  if ((unsigned long )cb_arg == (unsigned long )((struct bnx2fc_els_cb_arg *)0)) {
#line 214
    printk("\vbnx2fc: Unable to allocate cb_arg for LOGO\n");
#line 215
    return (-12);
  } else {

  }
#line 218
  tmp___0 = __fswab16((int )fh->fh_ox_id);
#line 218
  cb_arg->l2_oxid = tmp___0;
#line 220
  tmp___1 = ldv__builtin_expect((bnx2fc_debug_level & 8U) != 0U, 0L);
#line 220
  if (tmp___1 != 0L) {
#line 220
    printk("\016bnx2fc: Send LOGO: l2_oxid = 0x%x\n", (int )cb_arg->l2_oxid);
  } else {

  }
#line 221
  tmp___2 = fc_frame_payload_get((struct fc_frame  const  *)fp, 16UL);
#line 221
  logo = (struct fc_els_logo *)tmp___2;
#line 223
  rc = bnx2fc_initiate_els(tgt, 5U, (void *)logo, 16U, & bnx2fc_l2_els_compl, cb_arg,
                           r_a_tov * 2U);
#line 225
  if (rc != 0) {
#line 226
    kfree((void const   *)cb_arg);
  } else {

  }
#line 227
  return (rc);
}
}
#line 230 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"
int bnx2fc_send_rls(struct bnx2fc_rport *tgt , struct fc_frame *fp ) 
{ 
  struct fc_els_rls *rls ;
  struct fc_frame_header *fh ;
  struct bnx2fc_els_cb_arg *cb_arg ;
  struct fc_lport *lport ;
  u32 r_a_tov ;
  int rc ;
  void *tmp ;
  __u16 tmp___0 ;
  void *tmp___1 ;

  {
#line 235
  lport = (tgt->rdata)->local_port;
#line 236
  r_a_tov = lport->r_a_tov;
#line 239
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 240
  tmp = kzalloc(32UL, 32U);
#line 240
  cb_arg = (struct bnx2fc_els_cb_arg *)tmp;
#line 241
  if ((unsigned long )cb_arg == (unsigned long )((struct bnx2fc_els_cb_arg *)0)) {
#line 242
    printk("\vbnx2fc: Unable to allocate cb_arg for LOGO\n");
#line 243
    return (-12);
  } else {

  }
#line 246
  tmp___0 = __fswab16((int )fh->fh_ox_id);
#line 246
  cb_arg->l2_oxid = tmp___0;
#line 248
  tmp___1 = fc_frame_payload_get((struct fc_frame  const  *)fp, 8UL);
#line 248
  rls = (struct fc_els_rls *)tmp___1;
#line 250
  rc = bnx2fc_initiate_els(tgt, 15U, (void *)rls, 8U, & bnx2fc_l2_els_compl, cb_arg,
                           r_a_tov * 2U);
#line 252
  if (rc != 0) {
#line 253
    kfree((void const   *)cb_arg);
  } else {

  }
#line 254
  return (rc);
}
}
#line 257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"
void bnx2fc_srr_compl(struct bnx2fc_els_cb_arg *cb_arg ) 
{ 
  struct bnx2fc_mp_req *mp_req ;
  struct fc_frame_header *fc_hdr ;
  struct fc_frame_header *fh ;
  struct bnx2fc_cmd *srr_req ;
  struct bnx2fc_cmd *orig_io_req ;
  struct fc_frame *fp ;
  unsigned char *buf ;
  void *resp_buf ;
  u32 resp_len ;
  u32 hdr_len ;
  u8 opcode ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  struct bnx2fc_rport *tgt ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
#line 268
  rc = 0;
#line 270
  orig_io_req = cb_arg->aborted_io_req;
#line 271
  srr_req = cb_arg->io_req;
#line 272
  tmp___1 = test_and_clear_bit(11L, (unsigned long volatile   *)(& srr_req->req_flags));
#line 272
  if (tmp___1 != 0) {
#line 274
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)srr_req, "srr timed out, abort orig_io - 0x%x\n",
                  (int )orig_io_req->xid);
#line 277
    rc = bnx2fc_initiate_abts(srr_req);
#line 278
    if (rc != 8194) {
#line 279
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)srr_req, "srr_compl: initiate_abts failed. issue cleanup\n");
#line 281
      bnx2fc_initiate_cleanup(srr_req);
    } else {

    }
#line 283
    tmp = constant_test_bit(9L, (unsigned long const volatile   *)(& orig_io_req->req_flags));
#line 283
    if (tmp != 0) {
#line 285
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)srr_req, "srr_compl:xid 0x%x flags = %lx",
                    (int )orig_io_req->xid, orig_io_req->req_flags);
#line 287
      goto srr_compl_done;
    } else {
#line 283
      tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& orig_io_req->req_flags));
#line 283
      if (tmp___0 != 0) {
#line 285
        BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)srr_req, "srr_compl:xid 0x%x flags = %lx",
                      (int )orig_io_req->xid, orig_io_req->req_flags);
#line 287
        goto srr_compl_done;
      } else {

      }
    }
#line 289
    orig_io_req->srr_retry = (u8 )((int )orig_io_req->srr_retry + 1);
#line 290
    if ((unsigned int )orig_io_req->srr_retry <= 5U) {
#line 291
      tgt = orig_io_req->tgt;
#line 292
      spin_unlock_bh(& tgt->tgt_lock);
#line 293
      rc = bnx2fc_send_srr(orig_io_req, orig_io_req->srr_offset, (int )orig_io_req->srr_rctl);
#line 296
      spin_lock_bh(& tgt->tgt_lock);
#line 297
      if (rc == 0) {
#line 298
        goto srr_compl_done;
      } else {

      }
    } else {

    }
#line 301
    rc = bnx2fc_initiate_abts(orig_io_req);
#line 302
    if (rc != 8194) {
#line 303
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)srr_req, "srr_compl: initiate_abts failed xid = 0x%x. issue cleanup\n",
                    (int )orig_io_req->xid);
#line 306
      bnx2fc_initiate_cleanup(orig_io_req);
    } else {

    }
#line 308
    goto srr_compl_done;
  } else {

  }
#line 310
  tmp___2 = constant_test_bit(9L, (unsigned long const volatile   *)(& orig_io_req->req_flags));
#line 310
  if (tmp___2 != 0) {
#line 312
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)srr_req, "srr_compl:xid - 0x%x flags = %lx",
                  (int )orig_io_req->xid, orig_io_req->req_flags);
#line 314
    goto srr_compl_done;
  } else {
#line 310
    tmp___3 = constant_test_bit(2L, (unsigned long const volatile   *)(& orig_io_req->req_flags));
#line 310
    if (tmp___3 != 0) {
#line 312
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)srr_req, "srr_compl:xid - 0x%x flags = %lx",
                    (int )orig_io_req->xid, orig_io_req->req_flags);
#line 314
      goto srr_compl_done;
    } else {

    }
  }
#line 316
  mp_req = & srr_req->mp_req;
#line 317
  fc_hdr = & mp_req->resp_fc_hdr;
#line 318
  resp_len = mp_req->resp_len;
#line 319
  resp_buf = mp_req->resp_buf;
#line 321
  hdr_len = 24U;
#line 322
  tmp___4 = kzalloc(4096UL, 32U);
#line 322
  buf = (unsigned char *)tmp___4;
#line 323
  if ((unsigned long )buf == (unsigned long )((unsigned char *)0U)) {
#line 324
    printk("\vbnx2fc: srr buf: mem alloc failure\n");
#line 325
    goto srr_compl_done;
  } else {

  }
#line 327
  memcpy((void *)buf, (void const   *)fc_hdr, (size_t )hdr_len);
#line 328
  memcpy((void *)buf + (unsigned long )hdr_len, (void const   *)resp_buf, (size_t )resp_len);
#line 330
  fp = fc_frame_alloc((struct fc_lport *)0, (size_t )resp_len);
#line 331
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 332
    printk("\vbnx2fc: fc_frame_alloc failure\n");
#line 333
    goto free_buf;
  } else {

  }
#line 336
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 338
  memcpy((void *)fh, (void const   *)buf, (size_t )(hdr_len + resp_len));
#line 340
  opcode = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 341
  switch ((int )opcode) {
  case 2: 
#line 343
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)srr_req, "SRR success\n");
#line 344
  goto ldv_54683;
  case 1: 
#line 346
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)srr_req, "SRR rejected\n");
#line 347
  rc = bnx2fc_initiate_abts(orig_io_req);
#line 348
  if (rc != 8194) {
#line 349
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)srr_req, "srr_compl: initiate_abts failed xid = 0x%x. issue cleanup\n",
                  (int )orig_io_req->xid);
#line 352
    bnx2fc_initiate_cleanup(orig_io_req);
  } else {

  }
#line 354
  goto ldv_54683;
  default: 
#line 356
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)srr_req, "srr compl - invalid opcode = %d\n",
                (int )opcode);
#line 358
  goto ldv_54683;
  }
  ldv_54683: 
#line 360
  fc_frame_free(fp);
  free_buf: 
#line 362
  kfree((void const   *)buf);
  srr_compl_done: 
#line 364
  kref_put(& orig_io_req->refcount, & bnx2fc_cmd_release);
#line 365
  return;
}
}
#line 367 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"
void bnx2fc_rec_compl(struct bnx2fc_els_cb_arg *cb_arg ) 
{ 
  struct bnx2fc_cmd *orig_io_req ;
  struct bnx2fc_cmd *new_io_req ;
  struct bnx2fc_cmd *rec_req ;
  struct bnx2fc_mp_req *mp_req ;
  struct fc_frame_header *fc_hdr ;
  struct fc_frame_header *fh ;
  struct fc_els_ls_rjt *rjt ;
  struct fc_els_rec_acc *acc ;
  struct bnx2fc_rport *tgt ;
  struct fcoe_err_report_entry *err_entry ;
  struct scsi_cmnd *sc_cmd ;
  enum fc_rctl r_ctl ;
  unsigned char *buf ;
  void *resp_buf ;
  struct fc_frame *fp ;
  u8 opcode ;
  u32 offset ;
  u32 e_stat ;
  u32 resp_len ;
  u32 hdr_len ;
  int rc ;
  bool send_seq_clnp ;
  bool abort_io ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 386
  rc = 0;
#line 387
  send_seq_clnp = 0;
#line 388
  abort_io = 0;
#line 390
  tmp = ldv__builtin_expect((bnx2fc_debug_level & 16U) != 0U, 0L);
#line 390
  if (tmp != 0L) {
#line 390
    printk("\016bnx2fc: Entered rec_compl callback\n");
  } else {

  }
#line 391
  rec_req = cb_arg->io_req;
#line 392
  orig_io_req = cb_arg->aborted_io_req;
#line 393
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "rec_compl: orig xid = 0x%x",
                (int )orig_io_req->xid);
#line 394
  tgt = orig_io_req->tgt;
#line 397
  tmp___0 = test_and_clear_bit(11L, (unsigned long volatile   *)(& rec_req->req_flags));
#line 397
  if (tmp___0 != 0) {
#line 398
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "timed out, abort orig_io - 0x%x\n",
                  (int )orig_io_req->xid);
#line 402
    rc = bnx2fc_initiate_abts(rec_req);
#line 403
    if (rc != 8194) {
#line 404
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "rec_compl: initiate_abts failed. issue cleanup\n");
#line 406
      bnx2fc_initiate_cleanup(rec_req);
    } else {

    }
#line 408
    orig_io_req->rec_retry = (u8 )((int )orig_io_req->rec_retry + 1);
#line 410
    if ((unsigned int )orig_io_req->rec_retry <= 1U) {
#line 411
      spin_unlock_bh(& tgt->tgt_lock);
#line 412
      rc = bnx2fc_send_rec(orig_io_req);
#line 413
      spin_lock_bh(& tgt->tgt_lock);
#line 414
      if (rc == 0) {
#line 415
        goto rec_compl_done;
      } else {

      }
    } else {

    }
#line 417
    rc = bnx2fc_initiate_abts(orig_io_req);
#line 418
    if (rc != 8194) {
#line 419
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "rec_compl: initiate_abts failed xid = 0x%x. issue cleanup\n",
                    (int )orig_io_req->xid);
#line 422
      bnx2fc_initiate_cleanup(orig_io_req);
    } else {

    }
#line 424
    goto rec_compl_done;
  } else {

  }
#line 427
  tmp___1 = constant_test_bit(9L, (unsigned long const volatile   *)(& orig_io_req->req_flags));
#line 427
  if (tmp___1 != 0) {
#line 428
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "completedorig_io - 0x%x\n",
                  (int )orig_io_req->xid);
#line 431
    goto rec_compl_done;
  } else {

  }
#line 433
  tmp___2 = constant_test_bit(2L, (unsigned long const volatile   *)(& orig_io_req->req_flags));
#line 433
  if (tmp___2 != 0) {
#line 434
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "abts in prog orig_io - 0x%x\n",
                  (int )orig_io_req->xid);
#line 437
    goto rec_compl_done;
  } else {

  }
#line 440
  mp_req = & rec_req->mp_req;
#line 441
  fc_hdr = & mp_req->resp_fc_hdr;
#line 442
  resp_len = mp_req->resp_len;
#line 443
  resp_buf = mp_req->resp_buf;
#line 443
  acc = (struct fc_els_rec_acc *)resp_buf;
#line 445
  hdr_len = 24U;
#line 447
  tmp___3 = kzalloc(4096UL, 32U);
#line 447
  buf = (unsigned char *)tmp___3;
#line 448
  if ((unsigned long )buf == (unsigned long )((unsigned char *)0U)) {
#line 449
    printk("\vbnx2fc: rec buf: mem alloc failure\n");
#line 450
    goto rec_compl_done;
  } else {

  }
#line 452
  memcpy((void *)buf, (void const   *)fc_hdr, (size_t )hdr_len);
#line 453
  memcpy((void *)buf + (unsigned long )hdr_len, (void const   *)resp_buf, (size_t )resp_len);
#line 455
  fp = fc_frame_alloc((struct fc_lport *)0, (size_t )resp_len);
#line 456
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 457
    printk("\vbnx2fc: fc_frame_alloc failure\n");
#line 458
    goto free_buf;
  } else {

  }
#line 461
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 463
  memcpy((void *)fh, (void const   *)buf, (size_t )(hdr_len + resp_len));
#line 465
  opcode = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 466
  if ((unsigned int )opcode == 1U) {
#line 467
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "opcode is RJT\n");
#line 468
    tmp___4 = fc_frame_payload_get((struct fc_frame  const  *)fp, 8UL);
#line 468
    rjt = (struct fc_els_ls_rjt *)tmp___4;
#line 469
    if (((unsigned int )rjt->er_reason == 3U || (unsigned int )rjt->er_reason == 9U) && (unsigned int )rjt->er_explan == 23U) {
#line 472
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "handle CMD LOST case\n");
#line 473
      new_io_req = bnx2fc_cmd_alloc(tgt);
#line 474
      if ((unsigned long )new_io_req == (unsigned long )((struct bnx2fc_cmd *)0)) {
#line 475
        goto abort_io;
      } else {

      }
#line 476
      new_io_req->sc_cmd = orig_io_req->sc_cmd;
#line 478
      set_bit(12L, (unsigned long volatile   *)(& orig_io_req->req_flags));
#line 480
      bnx2fc_initiate_cleanup(orig_io_req);
#line 482
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "Post IO request again\n");
#line 483
      rc = bnx2fc_post_io_req(tgt, new_io_req);
#line 484
      if (rc == 0) {
#line 485
        goto free_frame;
      } else {

      }
#line 486
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "REC: io post err\n");
    } else {

    }
    abort_io: 
#line 489
    rc = bnx2fc_initiate_abts(orig_io_req);
#line 490
    if (rc != 8194) {
#line 491
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "rec_compl: initiate_abts failed. issue cleanup\n");
#line 493
      bnx2fc_initiate_cleanup(orig_io_req);
    } else {

    }
  } else
#line 495
  if ((unsigned int )opcode == 2U) {
#line 497
    tmp___5 = __fswab32(acc->reca_fc4value);
#line 497
    offset = tmp___5;
#line 498
    tmp___6 = __fswab32(acc->reca_e_stat);
#line 498
    e_stat = tmp___6;
#line 499
    if ((e_stat & 1073741824U) != 0U) {
#line 500
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "target has the seq init\n");
#line 501
      goto free_frame;
    } else {

    }
#line 503
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "e_stat = 0x%x, offset = 0x%x\n",
                  e_stat, offset);
#line 506
    err_entry = & orig_io_req->err_entry;
#line 508
    sc_cmd = orig_io_req->sc_cmd;
#line 509
    if ((unsigned int )sc_cmd->sc_data_direction == 1U) {
#line 511
      if ((size_t )offset == orig_io_req->data_xfer_len) {
#line 512
        BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "WRITE - resp lost\n");
#line 514
        r_ctl = 7;
#line 515
        offset = 0U;
      } else {
#line 518
        BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "XFER_RDY/DATA lost\n");
#line 519
        send_seq_clnp = 1;
#line 520
        r_ctl = 5;
#line 521
        tmp___7 = bnx2fc_initiate_seq_cleanup(orig_io_req, offset, r_ctl);
#line 521
        if (tmp___7 != 0) {
#line 523
          abort_io = 1;
        } else {

        }
      }
    } else
#line 528
    if ((size_t )err_entry->data.rx_buf_off == orig_io_req->data_xfer_len) {
#line 531
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "READ - resp lost\n");
#line 532
      r_ctl = 7;
#line 533
      offset = 0U;
    } else {
#line 536
      send_seq_clnp = 1;
#line 537
      offset = err_entry->data.rx_buf_off;
#line 538
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "RD DATA lost\n");
#line 540
      r_ctl = 1;
#line 541
      tmp___8 = bnx2fc_initiate_seq_cleanup(orig_io_req, offset, r_ctl);
#line 541
      if (tmp___8 != 0) {
#line 543
        abort_io = 1;
      } else {

      }
    }
#line 546
    if ((int )abort_io) {
#line 547
      rc = bnx2fc_initiate_abts(orig_io_req);
#line 548
      if (rc != 8194) {
#line 549
        BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "rec_compl:initiate_abts failed. issue cleanup\n");
#line 551
        bnx2fc_initiate_cleanup(orig_io_req);
      } else {

      }
    } else
#line 553
    if (! send_seq_clnp) {
#line 554
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "Send SRR - FCP_RSP\n");
#line 555
      spin_unlock_bh(& tgt->tgt_lock);
#line 556
      rc = bnx2fc_send_srr(orig_io_req, offset, (int )((u8 )r_ctl));
#line 557
      spin_lock_bh(& tgt->tgt_lock);
#line 559
      if (rc != 0) {
#line 560
        BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)rec_req, "Unable to send SRR IO will abort\n");
      } else {

      }
    } else {

    }
  } else {

  }
  free_frame: 
#line 566
  fc_frame_free(fp);
  free_buf: 
#line 568
  kfree((void const   *)buf);
  rec_compl_done: 
#line 570
  kref_put(& orig_io_req->refcount, & bnx2fc_cmd_release);
#line 571
  kfree((void const   *)cb_arg);
#line 572
  return;
}
}
#line 574 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"
int bnx2fc_send_rec(struct bnx2fc_cmd *orig_io_req ) 
{ 
  struct fc_els_rec rec ;
  struct bnx2fc_rport *tgt ;
  struct fc_lport *lport ;
  struct bnx2fc_els_cb_arg *cb_arg ;
  u32 sid ;
  u32 r_a_tov ;
  int rc ;
  void *tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;

  {
#line 577
  tgt = orig_io_req->tgt;
#line 578
  lport = (tgt->rdata)->local_port;
#line 579
  cb_arg = (struct bnx2fc_els_cb_arg *)0;
#line 580
  sid = tgt->sid;
#line 581
  r_a_tov = lport->r_a_tov;
#line 584
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)orig_io_req, "Sending REC\n");
#line 585
  memset((void *)(& rec), 0, 12UL);
#line 587
  tmp = kzalloc(32UL, 32U);
#line 587
  cb_arg = (struct bnx2fc_els_cb_arg *)tmp;
#line 588
  if ((unsigned long )cb_arg == (unsigned long )((struct bnx2fc_els_cb_arg *)0)) {
#line 589
    printk("\vbnx2fc: Unable to allocate cb_arg for REC\n");
#line 590
    rc = -12;
#line 591
    goto rec_err;
  } else {

  }
#line 593
  kref_get(& orig_io_req->refcount);
#line 595
  cb_arg->aborted_io_req = orig_io_req;
#line 597
  rec.rec_cmd = 19U;
#line 598
  hton24((u8 *)(& rec.rec_s_id), sid);
#line 599
  tmp___0 = __fswab16((int )orig_io_req->xid);
#line 599
  rec.rec_ox_id = tmp___0;
#line 600
  tmp___1 = __fswab16((int )(orig_io_req->task)->rxwr_txrd.var_ctx.rx_id);
#line 600
  rec.rec_rx_id = tmp___1;
#line 602
  rc = bnx2fc_initiate_els(tgt, 19U, (void *)(& rec), 12U, & bnx2fc_rec_compl, cb_arg,
                           r_a_tov);
  rec_err: ;
#line 606
  if (rc != 0) {
#line 607
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)orig_io_req, "REC failed - release\n");
#line 608
    spin_lock_bh(& tgt->tgt_lock);
#line 609
    kref_put(& orig_io_req->refcount, & bnx2fc_cmd_release);
#line 610
    spin_unlock_bh(& tgt->tgt_lock);
#line 611
    kfree((void const   *)cb_arg);
  } else {

  }
#line 613
  return (rc);
}
}
#line 616 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"
int bnx2fc_send_srr(struct bnx2fc_cmd *orig_io_req , u32 offset , u8 r_ctl ) 
{ 
  struct fcp_srr srr ;
  struct bnx2fc_rport *tgt ;
  struct fc_lport *lport ;
  struct bnx2fc_els_cb_arg *cb_arg ;
  u32 r_a_tov ;
  int rc ;
  void *tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u32 tmp___2 ;

  {
#line 619
  tgt = orig_io_req->tgt;
#line 620
  lport = (tgt->rdata)->local_port;
#line 621
  cb_arg = (struct bnx2fc_els_cb_arg *)0;
#line 622
  r_a_tov = lport->r_a_tov;
#line 625
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)orig_io_req, "Sending SRR\n");
#line 626
  memset((void *)(& srr), 0, 16UL);
#line 628
  tmp = kzalloc(32UL, 32U);
#line 628
  cb_arg = (struct bnx2fc_els_cb_arg *)tmp;
#line 629
  if ((unsigned long )cb_arg == (unsigned long )((struct bnx2fc_els_cb_arg *)0)) {
#line 630
    printk("\vbnx2fc: Unable to allocate cb_arg for SRR\n");
#line 631
    rc = -12;
#line 632
    goto srr_err;
  } else {

  }
#line 634
  kref_get(& orig_io_req->refcount);
#line 636
  cb_arg->aborted_io_req = orig_io_req;
#line 638
  srr.srr_op = 20U;
#line 639
  tmp___0 = __fswab16((int )orig_io_req->xid);
#line 639
  srr.srr_ox_id = tmp___0;
#line 640
  tmp___1 = __fswab16((int )(orig_io_req->task)->rxwr_txrd.var_ctx.rx_id);
#line 640
  srr.srr_rx_id = tmp___1;
#line 641
  tmp___2 = __fswab32(offset);
#line 641
  srr.srr_rel_off = tmp___2;
#line 642
  srr.srr_r_ctl = r_ctl;
#line 643
  orig_io_req->srr_offset = offset;
#line 644
  orig_io_req->srr_rctl = r_ctl;
#line 646
  rc = bnx2fc_initiate_els(tgt, 20U, (void *)(& srr), 16U, & bnx2fc_srr_compl, cb_arg,
                           r_a_tov);
  srr_err: ;
#line 650
  if (rc != 0) {
#line 651
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)orig_io_req, "SRR failed - release\n");
#line 652
    spin_lock_bh(& tgt->tgt_lock);
#line 653
    kref_put(& orig_io_req->refcount, & bnx2fc_cmd_release);
#line 654
    spin_unlock_bh(& tgt->tgt_lock);
#line 655
    kfree((void const   *)cb_arg);
  } else {
#line 657
    set_bit(13L, (unsigned long volatile   *)(& orig_io_req->req_flags));
  }
#line 659
  return (rc);
}
}
#line 662 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"
static int bnx2fc_initiate_els(struct bnx2fc_rport *tgt , unsigned int op , void *data ,
                               u32 data_len , void (*cb_func)(struct bnx2fc_els_cb_arg * ) ,
                               struct bnx2fc_els_cb_arg *cb_arg , u32 timer_msec ) 
{ 
  struct fcoe_port *port ;
  struct bnx2fc_interface *interface ;
  struct fc_rport *rport ;
  struct fc_lport *lport ;
  struct bnx2fc_cmd *els_req ;
  struct bnx2fc_mp_req *mp_req ;
  struct fc_frame_header *fc_hdr ;
  struct fcoe_task_ctx_entry *task ;
  struct fcoe_task_ctx_entry *task_page ;
  int rc ;
  int task_idx ;
  int index ;
  u32 did ;
  u32 sid ;
  u16 xid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 667
  port = tgt->port;
#line 668
  interface = (struct bnx2fc_interface *)port->priv;
#line 669
  rport = tgt->rport;
#line 670
  lport = port->lport;
#line 676
  rc = 0;
#line 681
  rc = fc_remote_port_chkready(rport);
#line 682
  if (rc != 0) {
#line 683
    printk("\vbnx2fc: els 0x%x: rport not ready\n", op);
#line 684
    rc = -22;
#line 685
    goto els_err;
  } else {

  }
#line 687
  if ((unsigned int )lport->state != 14U || (unsigned int )lport->link_up == 0U) {
#line 688
    printk("\vbnx2fc: els 0x%x: link is not ready\n", op);
#line 689
    rc = -22;
#line 690
    goto els_err;
  } else {

  }
#line 692
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& tgt->flags));
#line 692
  if (tmp == 0) {
#line 694
    printk("\vbnx2fc: els 0x%x: tgt not ready\n", op);
#line 695
    rc = -22;
#line 696
    goto els_err;
  } else {
#line 692
    tmp___0 = constant_test_bit(8L, (unsigned long const volatile   *)(& tgt->flags));
#line 692
    if (tmp___0 != 0) {
#line 694
      printk("\vbnx2fc: els 0x%x: tgt not ready\n", op);
#line 695
      rc = -22;
#line 696
      goto els_err;
    } else {

    }
  }
#line 698
  els_req = bnx2fc_elstm_alloc(tgt, 4);
#line 699
  if ((unsigned long )els_req == (unsigned long )((struct bnx2fc_cmd *)0)) {
#line 700
    rc = -12;
#line 701
    goto els_err;
  } else {

  }
#line 704
  els_req->sc_cmd = (struct scsi_cmnd *)0;
#line 705
  els_req->port = port;
#line 706
  els_req->tgt = tgt;
#line 707
  els_req->cb_func = cb_func;
#line 708
  cb_arg->io_req = els_req;
#line 709
  els_req->cb_arg = cb_arg;
#line 711
  mp_req = & els_req->mp_req;
#line 712
  rc = bnx2fc_init_mp_req(els_req);
#line 713
  if (rc == 8195) {
#line 714
    printk("\vbnx2fc: ELS MP request init failed\n");
#line 715
    spin_lock_bh(& tgt->tgt_lock);
#line 716
    kref_put(& els_req->refcount, & bnx2fc_cmd_release);
#line 717
    spin_unlock_bh(& tgt->tgt_lock);
#line 718
    rc = -12;
#line 719
    goto els_err;
  } else {
#line 722
    rc = 0;
  }
#line 726
  mp_req->req_len = data_len;
#line 727
  els_req->data_xfer_len = (size_t )mp_req->req_len;
#line 730
  if (op != 0U && op <= 144U) {
#line 731
    memcpy(mp_req->req_buf, (void const   *)data, (size_t )data_len);
  } else {
#line 733
    printk("\vbnx2fc: Invalid ELS op 0x%x\n", op);
#line 734
    els_req->cb_func = (void (*)(struct bnx2fc_els_cb_arg * ))0;
#line 735
    els_req->cb_arg = (struct bnx2fc_els_cb_arg *)0;
#line 736
    spin_lock_bh(& tgt->tgt_lock);
#line 737
    kref_put(& els_req->refcount, & bnx2fc_cmd_release);
#line 738
    spin_unlock_bh(& tgt->tgt_lock);
#line 739
    rc = -22;
  }
#line 742
  if (rc != 0) {
#line 743
    goto els_err;
  } else {

  }
#line 746
  fc_hdr = & mp_req->req_fc_hdr;
#line 748
  did = (tgt->rport)->port_id;
#line 749
  sid = tgt->sid;
#line 751
  if (op == 20U) {
#line 752
    __fc_fill_fc_hdr(fc_hdr, 50, did, sid, 8, 2686976U, 0U);
  } else {
#line 756
    __fc_fill_fc_hdr(fc_hdr, 34, did, sid, 1, 2686976U, 0U);
  }
#line 761
  xid = els_req->xid;
#line 762
  task_idx = (int )((unsigned int )xid / 32U);
#line 763
  index = (int )xid & 31;
#line 766
  task_page = *((interface->hba)->task_ctx + (unsigned long )task_idx);
#line 768
  task = task_page + (unsigned long )index;
#line 769
  bnx2fc_init_mp_task(els_req, task);
#line 771
  spin_lock_bh(& tgt->tgt_lock);
#line 773
  tmp___1 = constant_test_bit(1L, (unsigned long const volatile   *)(& tgt->flags));
#line 773
  if (tmp___1 == 0) {
#line 774
    printk("\vbnx2fc: initiate_els.. session not ready\n");
#line 775
    els_req->cb_func = (void (*)(struct bnx2fc_els_cb_arg * ))0;
#line 776
    els_req->cb_arg = (struct bnx2fc_els_cb_arg *)0;
#line 777
    kref_put(& els_req->refcount, & bnx2fc_cmd_release);
#line 778
    spin_unlock_bh(& tgt->tgt_lock);
#line 779
    return (-22);
  } else {

  }
#line 782
  if (timer_msec != 0U) {
#line 783
    bnx2fc_cmd_timer_set(els_req, timer_msec);
  } else {

  }
#line 784
  bnx2fc_add_2_sq(tgt, (int )xid);
#line 786
  els_req->on_active_queue = 1U;
#line 787
  list_add_tail(& els_req->link, & tgt->els_queue);
#line 790
  bnx2fc_ring_doorbell(tgt);
#line 791
  spin_unlock_bh(& tgt->tgt_lock);
  els_err: ;
#line 794
  return (rc);
}
}
#line 797 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"
void bnx2fc_process_els_compl(struct bnx2fc_cmd *els_req , struct fcoe_task_ctx_entry *task ,
                              u8 num_rq ) 
{ 
  struct bnx2fc_mp_req *mp_req ;
  struct fc_frame_header *fc_hdr ;
  u64 *hdr ;
  u64 *temp_hdr ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  __u64 tmp___3 ;
  __u64 tmp___4 ;
  __u64 tmp___5 ;

  {
#line 805
  tmp = ldv__builtin_expect((bnx2fc_debug_level & 8U) != 0U, 0L);
#line 805
  if (tmp != 0L) {
#line 805
    printk("\016bnx2fc: Entered process_els_compl xid = 0x%xcmd_type = %d\n", (int )els_req->xid,
           (int )els_req->cmd_type);
  } else {

  }
#line 808
  tmp___1 = test_and_set_bit(10L, (unsigned long volatile   *)(& els_req->req_flags));
#line 808
  if (tmp___1 != 0) {
#line 810
    tmp___0 = ldv__builtin_expect((bnx2fc_debug_level & 8U) != 0U, 0L);
#line 810
    if (tmp___0 != 0L) {
#line 810
      printk("\016bnx2fc: Timer context finished processing this els - 0x%x\n", (int )els_req->xid);
    } else {

    }
#line 813
    kref_put(& els_req->refcount, & bnx2fc_cmd_release);
#line 814
    return;
  } else {

  }
#line 818
  tmp___2 = ldv_cancel_delayed_work_12(& els_req->timeout_work);
#line 818
  if ((int )tmp___2) {
#line 819
    kref_put(& els_req->refcount, & bnx2fc_cmd_release);
  } else {

  }
#line 822
  if ((unsigned int )els_req->on_active_queue != 0U) {
#line 823
    list_del_init(& els_req->link);
#line 824
    els_req->on_active_queue = 0U;
  } else {

  }
#line 827
  mp_req = & els_req->mp_req;
#line 828
  fc_hdr = & mp_req->resp_fc_hdr;
#line 830
  hdr = (u64 *)fc_hdr;
#line 831
  temp_hdr = (u64 *)(& task->rxwr_only.union_ctx.comp_info.mp_rsp.fc_hdr);
#line 833
  tmp___3 = __fswab64(*temp_hdr);
#line 833
  *hdr = tmp___3;
#line 834
  tmp___4 = __fswab64(*(temp_hdr + 1UL));
#line 834
  *(hdr + 1UL) = tmp___4;
#line 835
  tmp___5 = __fswab64(*(temp_hdr + 2UL));
#line 835
  *(hdr + 2UL) = tmp___5;
#line 837
  mp_req->resp_len = task->rxwr_only.union_ctx.comp_info.mp_rsp.mp_payload_len;
#line 841
  if ((unsigned long )els_req->cb_func != (unsigned long )((void (*)(struct bnx2fc_els_cb_arg * ))0) && (unsigned long )els_req->cb_arg != (unsigned long )((struct bnx2fc_els_cb_arg *)0)) {
#line 842
    (*(els_req->cb_func))(els_req->cb_arg);
#line 843
    els_req->cb_arg = (struct bnx2fc_els_cb_arg *)0;
  } else {

  }
#line 846
  kref_put(& els_req->refcount, & bnx2fc_cmd_release);
#line 847
  return;
}
}
#line 849 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"
static void bnx2fc_flogi_resp(struct fc_seq *seq , struct fc_frame *fp , void *arg ) 
{ 
  struct fcoe_ctlr *fip ;
  struct fc_exch *exch ;
  struct fc_seq  const  *__mptr ;
  struct fc_lport *lport ;
  u8 *mac ;
  u8 op ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 852
  fip = (struct fcoe_ctlr *)arg;
#line 853
  __mptr = (struct fc_seq  const  *)seq;
#line 853
  exch = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 854
  lport = exch->lp;
#line 858
  tmp = IS_ERR((void const   *)fp);
#line 858
  if ((int )tmp) {
#line 859
    goto done;
  } else {

  }
#line 861
  mac = (u8 *)(& ((struct fcoe_rcv_info *)(& fp->skb.cb))->granted_mac);
#line 862
  tmp___0 = is_zero_ether_addr((u8 const   *)mac);
#line 862
  if ((int )tmp___0) {
#line 863
    op = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 864
    if ((unsigned long )lport->vport != (unsigned long )((struct fc_vport *)0)) {
#line 865
      if ((unsigned int )op == 1U) {
#line 866
        printk("\vbnx2fc: bnx2fc_flogi_resp is LS_RJT\n");
#line 867
        fc_vport_terminate(lport->vport);
#line 868
        fc_frame_free(fp);
#line 869
        return;
      } else {

      }
    } else {

    }
#line 872
    fcoe_ctlr_recv_flogi(fip, lport, fp);
  } else {

  }
#line 874
  tmp___1 = is_zero_ether_addr((u8 const   *)mac);
#line 874
  if (tmp___1) {
#line 874
    tmp___2 = 0;
  } else {
#line 874
    tmp___2 = 1;
  }
#line 874
  if (tmp___2) {
#line 875
    (*(fip->update_mac))(lport, mac);
  } else {

  }
  done: 
#line 877
  fc_lport_flogi_resp(seq, fp, (void *)lport);
#line 878
  return;
}
}
#line 880 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"
static void bnx2fc_logo_resp(struct fc_seq *seq , struct fc_frame *fp , void *arg ) 
{ 
  struct fcoe_ctlr *fip ;
  struct fc_exch *exch ;
  struct fc_seq  const  *__mptr ;
  struct fc_lport *lport ;
  u8 zero_mac[6U] ;
  unsigned int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 883
  fip = (struct fcoe_ctlr *)arg;
#line 884
  __mptr = (struct fc_seq  const  *)seq;
#line 884
  exch = (struct fc_exch *)__mptr + 0xffffffffffffff64UL;
#line 885
  lport = exch->lp;
#line 886
  zero_mac[0] = 0U;
#line 886
  tmp = 1U;
#line 886
  while (1) {
#line 886
    if (tmp >= 6U) {
#line 886
      break;
    } else {

    }
#line 886
    zero_mac[tmp] = (unsigned char)0;
#line 886
    tmp = tmp + 1U;
  }
#line 888
  tmp___0 = IS_ERR((void const   *)fp);
#line 888
  if (tmp___0) {
#line 888
    tmp___1 = 0;
  } else {
#line 888
    tmp___1 = 1;
  }
#line 888
  if (tmp___1) {
#line 889
    (*(fip->update_mac))(lport, (u8 *)(& zero_mac));
  } else {

  }
#line 890
  fc_lport_logo_resp(seq, fp, (void *)lport);
#line 891
  return;
}
}
#line 893 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.c"
struct fc_seq *bnx2fc_elsct_send(struct fc_lport *lport , u32 did , struct fc_frame *fp ,
                                 unsigned int op , void (*resp)(struct fc_seq * ,
                                                                struct fc_frame * ,
                                                                void * ) , void *arg ,
                                 u32 timeout ) 
{ 
  struct fcoe_port *port ;
  void *tmp ;
  struct bnx2fc_interface *interface ;
  struct fcoe_ctlr *fip ;
  struct fc_frame_header *fh ;
  struct fc_frame_header *tmp___0 ;
  struct fc_seq *tmp___1 ;
  u32 tmp___2 ;
  struct fc_seq *tmp___3 ;
  struct fc_seq *tmp___4 ;

  {
#line 900
  tmp = lport_priv((struct fc_lport  const  *)lport);
#line 900
  port = (struct fcoe_port *)tmp;
#line 901
  interface = (struct bnx2fc_interface *)port->priv;
#line 902
  fip = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 903
  tmp___0 = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 903
  fh = tmp___0;
#line 905
  switch (op) {
  case 4U: ;
  case 81U: 
#line 908
  tmp___1 = fc_elsct_send(lport, did, fp, op, & bnx2fc_flogi_resp, (void *)fip, timeout);
#line 908
  return (tmp___1);
  case 5U: 
#line 912
  tmp___2 = ntoh24((u8 const   *)(& fh->fh_d_id));
#line 912
  if (tmp___2 != 16777214U) {
#line 913
    goto ldv_54817;
  } else {

  }
#line 914
  tmp___3 = fc_elsct_send(lport, did, fp, op, & bnx2fc_logo_resp, (void *)fip, timeout);
#line 914
  return (tmp___3);
  }
  ldv_54817: 
#line 917
  tmp___4 = fc_elsct_send(lport, did, fp, op, resp, arg, timeout);
#line 917
  return (tmp___4);
}
}
#line 165 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  bool tmp ;

  {
#line 168
  tmp = ldv_is_err(ptr);
#line 168
  return (tmp);
}
}
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 181
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 181
  ldv_func_res = tmp;
#line 183
  activate_work_2(ldv_func_arg3, 2);
#line 185
  return (ldv_func_res);
}
}
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 192
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 192
  ldv_func_res = tmp;
#line 194
  activate_work_2(& ldv_func_arg3->work, 2);
#line 196
  return (ldv_func_res);
}
}
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 203
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 203
  ldv_func_res = tmp;
#line 205
  activate_work_2(ldv_func_arg3, 2);
#line 207
  return (ldv_func_res);
}
}
#line 210 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 213
  flush_workqueue(ldv_func_arg1);
#line 215
  call_and_disable_all_2(2);
#line 216
  return;
}
}
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 222
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 222
  ldv_func_res = tmp;
#line 224
  activate_work_2(& ldv_func_arg3->work, 2);
#line 226
  return (ldv_func_res);
}
}
#line 229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
int ldv_scsi_add_host_with_dma_10(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 233
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 233
  ldv_func_res = tmp;
#line 235
  if (ldv_func_res == 0) {
#line 236
    ldv_state_variable_10 = 1;
#line 236
    ldv_initialize_scsi_host_template_10();
  } else {

  }
#line 240
  return (ldv_func_res);
}
}
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
struct Scsi_Host *ldv_scsi_host_alloc_11(struct scsi_host_template *sht , int privsize ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  struct Scsi_Host *tmp ;

  {
#line 247
  tmp = scsi_host_alloc(sht, privsize);
#line 247
  ldv_func_res = tmp;
#line 249
  if ((unsigned long )ldv_func_res != (unsigned long )((ldv_func_ret_type___4 )0)) {
#line 250
    ldv_state_variable_10 = 1;
#line 250
    ldv_initialize_scsi_host_template_10();
  } else {

  }
#line 254
  return (ldv_func_res);
}
}
#line 257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_els.o.c.prepared"
bool ldv_cancel_delayed_work_12(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 261
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 261
  ldv_func_res = tmp;
#line 263
  disable_work_2(& ldv_func_arg1->work);
#line 265
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 201 "include/linux/compiler.h"
__inline static void __read_once_size(void const volatile   *p , void *res , int size ) 
{ 


  {
#line 203
  switch (size) {
  case 1: 
#line 204
  *((__u8 *)res) = *((__u8 volatile   *)p);
#line 204
  goto ldv_880;
  case 2: 
#line 205
  *((__u16 *)res) = *((__u16 volatile   *)p);
#line 205
  goto ldv_880;
  case 4: 
#line 206
  *((__u32 *)res) = *((__u32 volatile   *)p);
#line 206
  goto ldv_880;
  case 8: 
#line 207
  *((__u64 *)res) = *((__u64 volatile   *)p);
#line 207
  goto ldv_880;
  default: 
#line 209
  __asm__  volatile   ("": : : "memory");
#line 210
  __builtin_memcpy(res, (void const   *)p, (unsigned long )size);
#line 211
  __asm__  volatile   ("": : : "memory");
  }
  ldv_880: ;
#line 214
  return;
}
}
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 110 "./arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 314 "./arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 318
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 323
  return (oldbit);
}
}
#line 14 "include/asm-generic/bitops/find.h"
extern unsigned long find_next_bit(unsigned long const   * , unsigned long  , unsigned long  ) ;
#line 178 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 405
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
long ldv_ptr_err(void const   *ptr ) ;
#line 113 "include/linux/list.h"
extern void list_del(struct list_head * ) ;
#line 187 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 189
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 274 "include/linux/list.h"
__inline static void __list_splice(struct list_head  const  *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ 
  struct list_head *first ;
  struct list_head *last ;

  {
#line 278
  first = list->next;
#line 279
  last = list->prev;
#line 281
  first->prev = prev;
#line 282
  prev->next = first;
#line 284
  last->next = next;
#line 285
  next->prev = last;
#line 286
  return;
}
}
#line 293 "include/linux/list.h"
__inline static void list_splice(struct list_head  const  *list , struct list_head *head ) 
{ 
  int tmp ;

  {
#line 296
  tmp = list_empty(list);
#line 296
  if (tmp == 0) {
#line 297
    __list_splice(list, head, head->next);
  } else {

  }
#line 298
  return;
}
}
#line 319 "include/linux/list.h"
__inline static void list_splice_init(struct list_head *list , struct list_head *head ) 
{ 
  int tmp ;

  {
#line 322
  tmp = list_empty((struct list_head  const  *)list);
#line 322
  if (tmp == 0) {
#line 323
    __list_splice((struct list_head  const  *)list, head, head->next);
#line 324
    INIT_LIST_HEAD(list);
  } else {

  }
#line 326
  return;
}
}
#line 87 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 295 "include/linux/percpu-defs.h"
extern void __bad_size_call_parameter(void) ;
#line 18 "include/asm-generic/percpu.h"
extern unsigned long __per_cpu_offset[8192U] ;
#line 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "./arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3129;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_3129: ;
#line 14
  return (pfo_ret__);
}
}
#line 64 "./arch/x86/include/asm/string_64.h"
extern size_t strlen(char const   * ) ;
#line 23 "include/linux/string.h"
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
#line 41
extern int strncmp(char const   * , char const   * , __kernel_size_t  ) ;
#line 37 "include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 88
extern struct cpumask  const  * const  cpu_possible_mask ;
#line 89
extern struct cpumask  const  * const  cpu_online_mask ;
#line 114 "include/linux/cpumask.h"
__inline static unsigned int cpumask_check(unsigned int cpu ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 117
  __ret_warn_once = (unsigned int )nr_cpu_ids <= cpu;
#line 117
  tmp___1 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 117
  if (tmp___1 != 0L) {
#line 117
    __ret_warn_on = ! __warned;
#line 117
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 117
    if (tmp != 0L) {
#line 117
      warn_slowpath_null("include/linux/cpumask.h", 117);
    } else {

    }
#line 117
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 117
    if (tmp___0 != 0L) {
#line 117
      __warned = 1;
    } else {

    }
  } else {

  }
#line 117
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 119
  return (cpu);
}
}
#line 184 "include/linux/cpumask.h"
__inline static unsigned int cpumask_next(int n , struct cpumask  const  *srcp ) 
{ 
  unsigned long tmp ;

  {
#line 187
  if (n != -1) {
#line 188
    cpumask_check((unsigned int )n);
  } else {

  }
#line 189
  tmp = find_next_bit((unsigned long const   *)(& srcp->bits), (unsigned long )nr_cpu_ids,
                      (unsigned long )(n + 1));
#line 189
  return ((unsigned int )tmp);
}
}
#line 32 "include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 11 "./arch/x86/include/asm/cmpxchg.h"
extern void __xchg_wrong_size(void) ;
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 37 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 89 "include/linux/thread_info.h"
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 
  int tmp ;

  {
#line 91
  tmp = variable_test_bit((long )flag, (unsigned long const volatile   *)(& ti->flags));
#line 91
  return (tmp);
}
}
#line 8 "./arch/x86/include/asm/preempt.h"
extern int __preempt_count ;
#line 70 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
#line 72
  switch (4UL) {
  case 1UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_6059;
  case 2UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6059;
  case 4UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6059;
  case 8UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_6059;
  default: 
#line 72
  __bad_percpu_size();
  }
  ldv_6059: ;
#line 74
  return;
}
}
#line 75 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
#line 77
  switch (4UL) {
  case 1UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_6071;
  case 2UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6071;
  case 4UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6071;
  case 8UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_6071;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_6071: ;
#line 79
  return;
}
}
#line 280 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 333
extern void lock_acquire(struct lockdep_map * , unsigned int  , int  , int  , int  ,
                         struct lockdep_map * , unsigned long  ) ;
#line 337
extern void lock_release(struct lockdep_map * , int  , unsigned long  ) ;
#line 545
extern void lockdep_rcu_suspicious(char const   * , int const    , char const   * ) ;
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 299 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField18.rlock);
}
}
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 312
  _raw_spin_lock(& lock->__annonCompField18.rlock);
#line 313
  return;
}
}
#line 355 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 357
  _raw_spin_unlock(& lock->__annonCompField18.rlock);
#line 358
  return;
}
}
#line 72 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 149
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 926
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 927
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 119 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 138
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 174
extern void mutex_unlock(struct mutex * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 95
extern unsigned long wait_for_completion_timeout(struct completion * , unsigned long  ) ;
#line 268 "include/linux/rcupdate.h"
__inline static void __rcu_read_lock(void) 
{ 


  {
#line 270
  __preempt_count_add(1);
#line 270
  __asm__  volatile   ("": : : "memory");
#line 271
  return;
}
}
#line 273 "include/linux/rcupdate.h"
__inline static void __rcu_read_unlock(void) 
{ 


  {
#line 275
  __asm__  volatile   ("": : : "memory");
#line 275
  __preempt_count_sub(1);
#line 276
  return;
}
}
#line 104 "include/linux/rcutree.h"
extern bool rcu_is_watching(void) ;
#line 447 "include/linux/rcupdate.h"
__inline static void rcu_lock_acquire(struct lockdep_map *map ) 
{ 


  {
#line 449
  lock_acquire(map, 0U, 0, 2, 0, (struct lockdep_map *)0, 0UL);
#line 450
  return;
}
}
#line 452 "include/linux/rcupdate.h"
__inline static void rcu_lock_release(struct lockdep_map *map ) 
{ 


  {
#line 454
  lock_release(map, 1, 0UL);
#line 455
  return;
}
}
#line 457
extern struct lockdep_map rcu_lock_map ;
#line 461
extern int debug_lockdep_rcu_enabled(void) ;
#line 843 "include/linux/rcupdate.h"
__inline static void rcu_read_lock(void) 
{ 
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 845
  __rcu_read_lock();
#line 847
  rcu_lock_acquire(& rcu_lock_map);
#line 848
  tmp = debug_lockdep_rcu_enabled();
#line 848
  if (tmp != 0 && ! __warned) {
#line 848
    tmp___0 = rcu_is_watching();
#line 848
    if (tmp___0) {
#line 848
      tmp___1 = 0;
    } else {
#line 848
      tmp___1 = 1;
    }
#line 848
    if (tmp___1) {
#line 848
      __warned = 1;
#line 848
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 849, "rcu_read_lock() used illegally while idle");
    } else {

    }
  } else {

  }
#line 851
  return;
}
}
#line 897 "include/linux/rcupdate.h"
__inline static void rcu_read_unlock(void) 
{ 
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 899
  tmp = debug_lockdep_rcu_enabled();
#line 899
  if (tmp != 0 && ! __warned) {
#line 899
    tmp___0 = rcu_is_watching();
#line 899
    if (tmp___0) {
#line 899
      tmp___1 = 0;
    } else {
#line 899
      tmp___1 = 1;
    }
#line 899
    if (tmp___1) {
#line 899
      __warned = 1;
#line 899
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 900, "rcu_read_unlock() used illegally while idle");
    } else {

    }
  } else {

  }
#line 902
  __rcu_read_unlock();
#line 903
  rcu_lock_release(& rcu_lock_map);
#line 904
  return;
}
}
#line 224 "include/linux/timer.h"
extern void add_timer(struct timer_list * ) ;
#line 229
extern int del_timer_sync(struct timer_list * ) ;
#line 232
int ldv_del_timer_sync_35(struct timer_list *ldv_func_arg1 ) ;
#line 236
int ldv_del_timer_sync_38(struct timer_list *ldv_func_arg1 ) ;
#line 181 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 361
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
#line 421
extern void destroy_workqueue(struct workqueue_struct * ) ;
#line 424
void ldv_destroy_workqueue_37(struct workqueue_struct *ldv_func_arg1 ) ;
#line 428
void ldv_destroy_workqueue_40(struct workqueue_struct *ldv_func_arg1 ) ;
#line 432
void ldv_destroy_workqueue_43(struct workqueue_struct *ldv_func_arg1 ) ;
#line 436
void ldv_destroy_workqueue_44(struct workqueue_struct *ldv_func_arg1 ) ;
#line 449
bool ldv_queue_work_on_25(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 453
bool ldv_queue_work_on_27(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 459
bool ldv_queue_delayed_work_on_26(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 463
bool ldv_queue_delayed_work_on_29(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 471
void ldv_flush_workqueue_28(struct workqueue_struct *ldv_func_arg1 ) ;
#line 475
void ldv_flush_workqueue_32(struct workqueue_struct *ldv_func_arg1 ) ;
#line 479
void ldv_flush_workqueue_42(struct workqueue_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_25(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 57 "./arch/x86/include/asm/topology.h"
extern int __cpu_to_node(int  ) ;
#line 38 "./arch/x86/include/asm/smp.h"
extern int cpu_number ;
#line 127 "include/linux/percpu.h"
extern void *__alloc_percpu(size_t  , size_t  ) ;
#line 128
extern void free_percpu(void * ) ;
#line 32 "include/linux/kref.h"
__inline static void kref_init(struct kref *kref ) 
{ 


  {
#line 34
  atomic_set(& kref->refcount, 1);
#line 35
  return;
}
}
#line 41 "include/linux/kref.h"
__inline static void kref_get___0(struct kref *kref ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 47
  tmp = atomic_add_return(1, & kref->refcount);
#line 47
  __ret_warn_once = tmp <= 1;
#line 47
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 47
  if (tmp___2 != 0L) {
#line 47
    __ret_warn_on = ! __warned;
#line 47
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___0 != 0L) {
#line 47
      warn_slowpath_null("include/linux/kref.h", 47);
    } else {

    }
#line 47
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___1 != 0L) {
#line 47
      __warned = 1;
    } else {

    }
  } else {

  }
#line 47
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 49
  return;
}
}
#line 68 "include/linux/kref.h"
__inline static int kref_sub___0(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
#line 71
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
#line 71
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 71
  if (tmp != 0L) {
#line 71
    warn_slowpath_null("include/linux/kref.h", 71);
  } else {

  }
#line 71
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 73
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
#line 73
  if (tmp___0 != 0) {
#line 74
    (*release)(kref);
#line 75
    return (1);
  } else {

  }
#line 77
  return (0);
}
}
#line 97 "include/linux/kref.h"
__inline static int kref_put___0(struct kref *kref , void (*release)(struct kref * ) ) 
{ 
  int tmp ;

  {
#line 99
  tmp = kref_sub___0(kref, 1U, release);
#line 99
  return (tmp);
}
}
#line 505 "include/linux/module.h"
bool ldv_try_module_get_39(struct module *ldv_func_arg1 ) ;
#line 511
void ldv_module_put_33(struct module *ldv_func_arg1 ) ;
#line 515
void ldv_module_put_41(struct module *ldv_func_arg1 ) ;
#line 9 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_try_module_get(struct module *module ) ;
#line 11
void ldv_module_put(struct module *module ) ;
#line 425 "include/linux/sched.h"
extern void schedule(void) ;
#line 2322
extern void set_user_nice(struct task_struct * , long  ) ;
#line 2410
extern int wake_up_process(struct task_struct * ) ;
#line 2421
extern void flush_signals(struct task_struct * ) ;
#line 2821 "include/linux/sched.h"
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 
  int tmp ;

  {
#line 2823
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
#line 2823
  return (tmp);
}
}
#line 2847 "include/linux/sched.h"
__inline static int signal_pending(struct task_struct *p ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 2849
  tmp = test_tsk_thread_flag(p, 2);
#line 2849
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 2849
  return ((int )tmp___0);
}
}
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct fc_lport *bnx2fc_libfc_fcn_templ_group1  ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct work_struct *ldv_work_struct_3_1  ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_state_variable_0  ;
#line 23 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_timer_5_2  ;
#line 24 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_work_1_1  ;
#line 25 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_state_variable_12  ;
#line 26 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct timer_list *ldv_timer_list_5_0  ;
#line 27 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_state_variable_14  ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_timer_6_2  ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct timer_list *ldv_timer_list_5_3  ;
#line 30 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct scsi_cmnd *bnx2fc_shost_template_group0  ;
#line 31 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct work_struct *ldv_work_struct_2_0  ;
#line 33 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_timer_4_3  ;
#line 34 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_state_variable_9  ;
#line 35 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_timer_6_0  ;
#line 36 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct work_struct *ldv_work_struct_2_2  ;
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct timer_list *ldv_timer_list_5_1  ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ref_cnt  ;
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_work_3_3  ;
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct cnic_dev *bnx2fc_cnic_cb_group0  ;
#line 41 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_state_variable_7  ;
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct fc_rport *bnx2fc_vport_xport_function_group1  ;
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct work_struct *ldv_work_struct_3_3  ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct timer_list *ldv_timer_list_6_3  ;
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct timer_list *ldv_timer_list_6_2  ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct Scsi_Host *bnx2fc_transport_function_group0  ;
#line 47 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct work_struct *ldv_work_struct_1_1  ;
#line 48 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct timer_list *ldv_timer_list_4_0  ;
#line 49 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_work_1_3  ;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct work_struct *ldv_work_struct_2_1  ;
#line 51 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct work_struct *ldv_work_struct_3_2  ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_state_variable_6  ;
#line 53 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct fcoe_ctlr_device *bnx2fc_fcoe_sysfs_templ_group0  ;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct timer_list *ldv_timer_list_6_0  ;
#line 55 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct timer_list *ldv_timer_list_4_3  ;
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_timer_5_3  ;
#line 58 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_state_variable_3  ;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_timer_4_1  ;
#line 60 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_work_1_0  ;
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct timer_list *ldv_timer_list_4_1  ;
#line 62 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_state_variable_4  ;
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_work_2_1  ;
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_state_variable_8  ;
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_state_variable_15  ;
#line 66 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_timer_4_0  ;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct work_struct *ldv_work_struct_1_3  ;
#line 68 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct timer_list *ldv_timer_list_5_2  ;
#line 69 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_state_variable_5  ;
#line 70 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_state_variable_13  ;
#line 71 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_work_3_2  ;
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_timer_5_1  ;
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_work_3_0  ;
#line 74 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct work_struct *ldv_work_struct_2_3  ;
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct timer_list *ldv_timer_list_6_1  ;
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct scsi_device *bnx2fc_shost_template_group1  ;
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct net_device *bnx2fc_transport_group0  ;
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct fc_frame *bnx2fc_libfc_fcn_templ_group0  ;
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_state_variable_1  ;
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_timer_6_3  ;
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct timer_list *ldv_timer_list_7  ;
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_timer_4_2  ;
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct work_struct *ldv_work_struct_1_0  ;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct fcoe_fcf_device *bnx2fc_fcoe_sysfs_templ_group1  ;
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_state_variable_10  ;
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_work_3_1  ;
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_state_variable_2  ;
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_work_2_0  ;
#line 89 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_timer_5_0  ;
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct Scsi_Host *bnx2fc_vport_xport_function_group0  ;
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct fc_vport *bnx2fc_transport_function_group1  ;
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct work_struct *ldv_work_struct_3_0  ;
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_state_variable_11  ;
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_work_1_2  ;
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct timer_list *ldv_timer_list_4_2  ;
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct work_struct *ldv_work_struct_1_2  ;
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_timer_6_1  ;
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_work_2_2  ;
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct fc_rport *bnx2fc_transport_function_group2  ;
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_work_2_3  ;
#line 102
void work_init_3(void) ;
#line 104
void call_and_disable_work_1(struct work_struct *work ) ;
#line 105
int reg_timer_7(struct timer_list *timer ) ;
#line 108
void ldv_initialize_fc_function_template_11(void) ;
#line 109
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 111
void timer_init_4(void) ;
#line 113
void activate_work_1(struct work_struct *work , int state ) ;
#line 115
void timer_init_6(void) ;
#line 117
void disable_work_1(struct work_struct *work ) ;
#line 118
void timer_init_5(void) ;
#line 119
void work_init_1(void) ;
#line 120
void ldv_initialize_fcoe_sysfs_function_template_13(void) ;
#line 121
void ldv_initialize_cnic_ulp_ops_8(void) ;
#line 122
void disable_suitable_timer_6(struct timer_list *timer ) ;
#line 125
void activate_suitable_timer_4(struct timer_list *timer , unsigned long data ) ;
#line 127
void work_init_2(void) ;
#line 128
void disable_suitable_timer_7(struct timer_list *timer ) ;
#line 129
void call_and_disable_all_1(int state ) ;
#line 133
int reg_timer_6(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 134
void ldv_initialize_libfc_function_template_9(void) ;
#line 135
void ldv_initialize_fc_function_template_12(void) ;
#line 137
void choose_timer_4(void) ;
#line 138
void disable_suitable_timer_4(struct timer_list *timer ) ;
#line 140
int reg_timer_4(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 142
void invoke_work_1(void) ;
#line 145
void choose_timer_7(struct timer_list *timer ) ;
#line 147
void ldv_initialize_fcoe_transport_14(void) ;
#line 149
void ldv_timer_4(int state , struct timer_list *timer ) ;
#line 151
void activate_pending_timer_7(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 924 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 926
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 775 "include/linux/skbuff.h"
extern void consume_skb(struct sk_buff * ) ;
#line 842
extern struct sk_buff *skb_clone(struct sk_buff * , gfp_t  ) ;
#line 976 "include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff  const  *skb ) 
{ 


  {
#line 978
  return ((unsigned char *)skb->head + (unsigned long )skb->end);
}
}
#line 1176 "include/linux/skbuff.h"
__inline static int skb_shared(struct sk_buff  const  *skb ) 
{ 
  int tmp ;

  {
#line 1178
  tmp = atomic_read(& skb->users);
#line 1178
  return (tmp != 1);
}
}
#line 1194 "include/linux/skbuff.h"
__inline static struct sk_buff *skb_share_check(struct sk_buff *skb , gfp_t pri ) 
{ 
  struct sk_buff *nskb ;
  struct sk_buff *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 1196
  if ((pri & 16U) != 0U) {
#line 1196
    __might_sleep("include/linux/skbuff.h", 1196, 0);
  } else {

  }
#line 1197
  tmp___1 = skb_shared((struct sk_buff  const  *)skb);
#line 1197
  if (tmp___1 != 0) {
#line 1198
    tmp = skb_clone(skb, pri);
#line 1198
    nskb = tmp;
#line 1200
    tmp___0 = ldv__builtin_expect((unsigned long )nskb != (unsigned long )((struct sk_buff *)0),
                               1L);
#line 1200
    if (tmp___0 != 0L) {
#line 1201
      consume_skb(skb);
    } else {
#line 1203
      kfree_skb(skb);
    }
#line 1204
    skb = nskb;
  } else {

  }
#line 1206
  return (skb);
}
}
#line 1259 "include/linux/skbuff.h"
__inline static struct sk_buff *skb_peek(struct sk_buff_head  const  *list_ ) 
{ 
  struct sk_buff *skb ;

  {
#line 1261
  skb = list_->next;
#line 1263
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)list_)) {
#line 1264
    skb = (struct sk_buff *)0;
  } else {

  }
#line 1265
  return (skb);
}
}
#line 1331 "include/linux/skbuff.h"
__inline static void __skb_queue_head_init(struct sk_buff_head *list ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1333
  tmp = (struct sk_buff *)list;
#line 1333
  list->next = tmp;
#line 1333
  list->prev = tmp;
#line 1334
  list->qlen = 0U;
#line 1335
  return;
}
}
#line 1345 "include/linux/skbuff.h"
__inline static void skb_queue_head_init(struct sk_buff_head *list ) 
{ 
  struct lock_class_key __key ;

  {
#line 1347
  spinlock_check(& list->lock);
#line 1347
  __raw_spin_lock_init(& list->lock.__annonCompField18.rlock, "&(&list->lock)->rlock",
                       & __key);
#line 1348
  __skb_queue_head_init(list);
#line 1349
  return;
}
}
#line 1366 "include/linux/skbuff.h"
__inline static void __skb_insert(struct sk_buff *newsk , struct sk_buff *prev , struct sk_buff *next ,
                                  struct sk_buff_head *list ) 
{ 
  struct sk_buff *tmp ;

  {
#line 1370
  newsk->__annonCompField68.__annonCompField67.next = next;
#line 1371
  newsk->__annonCompField68.__annonCompField67.prev = prev;
#line 1372
  tmp = newsk;
#line 1372
  prev->__annonCompField68.__annonCompField67.next = tmp;
#line 1372
  next->__annonCompField68.__annonCompField67.prev = tmp;
#line 1373
  list->qlen = list->qlen + 1U;
#line 1374
  return;
}
}
#line 1474 "include/linux/skbuff.h"
__inline static void __skb_queue_before(struct sk_buff_head *list , struct sk_buff *next ,
                                        struct sk_buff *newsk ) 
{ 


  {
#line 1478
  __skb_insert(newsk, next->__annonCompField68.__annonCompField67.prev, next, list);
#line 1479
  return;
}
}
#line 1509 "include/linux/skbuff.h"
__inline static void __skb_queue_tail(struct sk_buff_head *list , struct sk_buff *newsk ) 
{ 


  {
#line 1512
  __skb_queue_before(list, (struct sk_buff *)list, newsk);
#line 1513
  return;
}
}
#line 1520 "include/linux/skbuff.h"
__inline static void __skb_unlink(struct sk_buff *skb , struct sk_buff_head *list ) 
{ 
  struct sk_buff *next ;
  struct sk_buff *prev ;
  struct sk_buff *tmp ;

  {
#line 1524
  list->qlen = list->qlen - 1U;
#line 1525
  next = skb->__annonCompField68.__annonCompField67.next;
#line 1526
  prev = skb->__annonCompField68.__annonCompField67.prev;
#line 1527
  tmp = (struct sk_buff *)0;
#line 1527
  skb->__annonCompField68.__annonCompField67.prev = tmp;
#line 1527
  skb->__annonCompField68.__annonCompField67.next = tmp;
#line 1528
  next->__annonCompField68.__annonCompField67.prev = prev;
#line 1529
  prev->__annonCompField68.__annonCompField67.next = next;
#line 1530
  return;
}
}
#line 1541 "include/linux/skbuff.h"
__inline static struct sk_buff *__skb_dequeue(struct sk_buff_head *list ) 
{ 
  struct sk_buff *skb ;
  struct sk_buff *tmp ;

  {
#line 1543
  tmp = skb_peek((struct sk_buff_head  const  *)list);
#line 1543
  skb = tmp;
#line 1544
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 1545
    __skb_unlink(skb, list);
  } else {

  }
#line 1546
  return (skb);
}
}
#line 1567 "include/linux/skbuff.h"
__inline static bool skb_is_nonlinear(struct sk_buff  const  *skb ) 
{ 


  {
#line 1569
  return ((unsigned int )skb->data_len != 0U);
}
}
#line 1572 "include/linux/skbuff.h"
__inline static unsigned int skb_headlen(struct sk_buff  const  *skb ) 
{ 


  {
#line 1574
  return ((unsigned int )skb->len - (unsigned int )skb->data_len);
}
}
#line 1659 "include/linux/skbuff.h"
__inline static void skb_reset_tail_pointer(struct sk_buff *skb ) 
{ 


  {
#line 1661
  skb->tail = (sk_buff_data_t )((long )skb->data) - (sk_buff_data_t )((long )skb->head);
#line 1662
  return;
}
}
#line 1664 "include/linux/skbuff.h"
__inline static void skb_set_tail_pointer(struct sk_buff *skb , int const   offset ) 
{ 


  {
#line 1666
  skb_reset_tail_pointer(skb);
#line 1667
  skb->tail = skb->tail + (sk_buff_data_t )offset;
#line 1668
  return;
}
}
#line 1692
extern unsigned char *skb_put(struct sk_buff * , unsigned int  ) ;
#line 1702
extern unsigned char *skb_push(struct sk_buff * , unsigned int  ) ;
#line 1710
extern unsigned char *skb_pull(struct sk_buff * , unsigned int  ) ;
#line 1723
extern unsigned char *__pskb_pull_tail(struct sk_buff * , int  ) ;
#line 1739 "include/linux/skbuff.h"
__inline static int pskb_may_pull(struct sk_buff *skb , unsigned int len ) 
{ 
  unsigned int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned int tmp___2 ;
  unsigned char *tmp___3 ;

  {
#line 1741
  tmp = skb_headlen((struct sk_buff  const  *)skb);
#line 1741
  tmp___0 = ldv__builtin_expect(tmp >= len, 1L);
#line 1741
  if (tmp___0 != 0L) {
#line 1742
    return (1);
  } else {

  }
#line 1743
  tmp___1 = ldv__builtin_expect(skb->len < len, 0L);
#line 1743
  if (tmp___1 != 0L) {
#line 1744
    return (0);
  } else {

  }
#line 1745
  tmp___2 = skb_headlen((struct sk_buff  const  *)skb);
#line 1745
  tmp___3 = __pskb_pull_tail(skb, (int )(len - tmp___2));
#line 1745
  return ((unsigned long )tmp___3 != (unsigned long )((unsigned char *)0U));
}
}
#line 1884 "include/linux/skbuff.h"
__inline static unsigned char *skb_transport_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1886
  return ((unsigned char *)skb->head + (unsigned long )skb->transport_header);
}
}
#line 1889 "include/linux/skbuff.h"
__inline static void skb_reset_transport_header(struct sk_buff *skb ) 
{ 


  {
#line 1891
  skb->transport_header = (int )((__u16 )((long )skb->data)) - (int )((__u16 )((long )skb->head));
#line 1892
  return;
}
}
#line 1894 "include/linux/skbuff.h"
__inline static void skb_set_transport_header(struct sk_buff *skb , int const   offset ) 
{ 


  {
#line 1897
  skb_reset_transport_header(skb);
#line 1898
  skb->transport_header = (int )skb->transport_header + (int )((__u16 )offset);
#line 1899
  return;
}
}
#line 1901 "include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1903
  return ((unsigned char *)skb->head + (unsigned long )skb->network_header);
}
}
#line 1906 "include/linux/skbuff.h"
__inline static void skb_reset_network_header(struct sk_buff *skb ) 
{ 


  {
#line 1908
  skb->network_header = (int )((__u16 )((long )skb->data)) - (int )((__u16 )((long )skb->head));
#line 1909
  return;
}
}
#line 1917 "include/linux/skbuff.h"
__inline static unsigned char *skb_mac_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1919
  return ((unsigned char *)skb->head + (unsigned long )skb->mac_header);
}
}
#line 1927 "include/linux/skbuff.h"
__inline static void skb_reset_mac_header(struct sk_buff *skb ) 
{ 


  {
#line 1929
  skb->mac_header = (int )((__u16 )((long )skb->data)) - (int )((__u16 )((long )skb->head));
#line 1930
  return;
}
}
#line 2049
extern int ___pskb_trim(struct sk_buff * , unsigned int  ) ;
#line 2051 "include/linux/skbuff.h"
__inline static void __skb_trim(struct sk_buff *skb , unsigned int len ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  bool tmp___0 ;
  long tmp___1 ;

  {
#line 2053
  tmp___0 = skb_is_nonlinear((struct sk_buff  const  *)skb);
#line 2053
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 2053
  if (tmp___1 != 0L) {
#line 2054
    __ret_warn_on = 1;
#line 2054
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 2054
    if (tmp != 0L) {
#line 2054
      warn_slowpath_null("include/linux/skbuff.h", 2054);
    } else {

    }
#line 2054
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 2055
    return;
  } else {

  }
#line 2057
  skb->len = len;
#line 2058
  skb_set_tail_pointer(skb, (int const   )len);
#line 2059
  return;
}
}
#line 2063 "include/linux/skbuff.h"
__inline static int __pskb_trim(struct sk_buff *skb , unsigned int len ) 
{ 
  int tmp ;

  {
#line 2065
  if (skb->data_len != 0U) {
#line 2066
    tmp = ___pskb_trim(skb, len);
#line 2066
    return (tmp);
  } else {

  }
#line 2067
  __skb_trim(skb, len);
#line 2068
  return (0);
}
}
#line 2071 "include/linux/skbuff.h"
__inline static int pskb_trim(struct sk_buff *skb , unsigned int len ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2073
  if (skb->len > len) {
#line 2073
    tmp = __pskb_trim(skb, len);
#line 2073
    tmp___0 = tmp;
  } else {
#line 2073
    tmp___0 = 0;
  }
#line 2073
  return (tmp___0);
}
}
#line 2276 "include/linux/skbuff.h"
__inline static struct page *skb_frag_page(skb_frag_t const   *frag ) 
{ 


  {
#line 2278
  return ((struct page *)frag->page.p);
}
}
#line 2549 "include/linux/skbuff.h"
__inline static int __skb_linearize(struct sk_buff *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 2551
  tmp = __pskb_pull_tail(skb, (int )skb->data_len);
#line 2551
  return ((unsigned long )tmp != (unsigned long )((unsigned char *)0U) ? 0 : -12);
}
}
#line 2561 "include/linux/skbuff.h"
__inline static int skb_linearize(struct sk_buff *skb ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;

  {
#line 2563
  tmp___2 = skb_is_nonlinear((struct sk_buff  const  *)skb);
#line 2563
  if ((int )tmp___2) {
#line 2563
    tmp___0 = __skb_linearize(skb);
#line 2563
    tmp___1 = tmp___0;
  } else {
#line 2563
    tmp___1 = 0;
  }
#line 2563
  return (tmp___1);
}
}
#line 2704
extern int skb_copy_bits(struct sk_buff  const  * , int  , void * , int  ) ;
#line 26 "include/linux/if_ether.h"
__inline static struct ethhdr *eth_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
#line 28
  tmp = skb_mac_header(skb);
#line 28
  return ((struct ethhdr *)tmp);
}
}
#line 2169 "include/linux/netdevice.h"
extern void dev_add_pack(struct packet_type * ) ;
#line 2171
extern void __dev_remove_pack(struct packet_type * ) ;
#line 2187
extern int dev_queue_xmit_sk(struct sock * , struct sk_buff * ) ;
#line 2188 "include/linux/netdevice.h"
__inline static int dev_queue_xmit(struct sk_buff *skb ) 
{ 
  int tmp ;

  {
#line 2190
  tmp = dev_queue_xmit_sk(skb->sk, skb);
#line 2190
  return (tmp);
}
}
#line 2204
extern void synchronize_net(void) ;
#line 3003 "include/linux/netdevice.h"
__inline static void dev_put(struct net_device *dev ) 
{ 
  void const   *__vpp_verify ;
  int pao_ID__ ;
  int pao_ID_____0 ;
  int pao_ID_____1 ;
  int pao_ID_____2 ;

  {
#line 3005
  __vpp_verify = (void const   *)0;
#line 3005
  switch (4UL) {
  case 1UL: 
#line 3005
  pao_ID__ = -1;
#line 3005
  switch (4UL) {
  case 1UL: ;
#line 3005
  if (pao_ID__ == 1) {
#line 3005
    __asm__  ("incb %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3005
  if (pao_ID__ == -1) {
#line 3005
    __asm__  ("decb %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3005
    __asm__  ("addb %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "qi" (-1));
  }
#line 3005
  goto ldv_42933;
  case 2UL: ;
#line 3005
  if (pao_ID__ == 1) {
#line 3005
    __asm__  ("incw %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3005
  if (pao_ID__ == -1) {
#line 3005
    __asm__  ("decw %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3005
    __asm__  ("addw %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "ri" (-1));
  }
#line 3005
  goto ldv_42933;
  case 4UL: ;
#line 3005
  if (pao_ID__ == 1) {
#line 3005
    __asm__  ("incl %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3005
  if (pao_ID__ == -1) {
#line 3005
    __asm__  ("decl %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3005
    __asm__  ("addl %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "ri" (-1));
  }
#line 3005
  goto ldv_42933;
  case 8UL: ;
#line 3005
  if (pao_ID__ == 1) {
#line 3005
    __asm__  ("incq %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3005
  if (pao_ID__ == -1) {
#line 3005
    __asm__  ("decq %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3005
    __asm__  ("addq %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "re" (-1));
  }
#line 3005
  goto ldv_42933;
  default: 
#line 3005
  __bad_percpu_size();
  }
  ldv_42933: ;
#line 3005
  goto ldv_42938;
  case 2UL: 
#line 3005
  pao_ID_____0 = -1;
#line 3005
  switch (4UL) {
  case 1UL: ;
#line 3005
  if (pao_ID_____0 == 1) {
#line 3005
    __asm__  ("incb %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3005
  if (pao_ID_____0 == -1) {
#line 3005
    __asm__  ("decb %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3005
    __asm__  ("addb %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "qi" (-1));
  }
#line 3005
  goto ldv_42944;
  case 2UL: ;
#line 3005
  if (pao_ID_____0 == 1) {
#line 3005
    __asm__  ("incw %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3005
  if (pao_ID_____0 == -1) {
#line 3005
    __asm__  ("decw %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3005
    __asm__  ("addw %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "ri" (-1));
  }
#line 3005
  goto ldv_42944;
  case 4UL: ;
#line 3005
  if (pao_ID_____0 == 1) {
#line 3005
    __asm__  ("incl %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3005
  if (pao_ID_____0 == -1) {
#line 3005
    __asm__  ("decl %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3005
    __asm__  ("addl %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "ri" (-1));
  }
#line 3005
  goto ldv_42944;
  case 8UL: ;
#line 3005
  if (pao_ID_____0 == 1) {
#line 3005
    __asm__  ("incq %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3005
  if (pao_ID_____0 == -1) {
#line 3005
    __asm__  ("decq %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3005
    __asm__  ("addq %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "re" (-1));
  }
#line 3005
  goto ldv_42944;
  default: 
#line 3005
  __bad_percpu_size();
  }
  ldv_42944: ;
#line 3005
  goto ldv_42938;
  case 4UL: 
#line 3005
  pao_ID_____1 = -1;
#line 3005
  switch (4UL) {
  case 1UL: ;
#line 3005
  if (pao_ID_____1 == 1) {
#line 3005
    __asm__  ("incb %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3005
  if (pao_ID_____1 == -1) {
#line 3005
    __asm__  ("decb %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3005
    __asm__  ("addb %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "qi" (-1));
  }
#line 3005
  goto ldv_42954;
  case 2UL: ;
#line 3005
  if (pao_ID_____1 == 1) {
#line 3005
    __asm__  ("incw %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3005
  if (pao_ID_____1 == -1) {
#line 3005
    __asm__  ("decw %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3005
    __asm__  ("addw %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "ri" (-1));
  }
#line 3005
  goto ldv_42954;
  case 4UL: ;
#line 3005
  if (pao_ID_____1 == 1) {
#line 3005
    __asm__  ("incl %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3005
  if (pao_ID_____1 == -1) {
#line 3005
    __asm__  ("decl %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3005
    __asm__  ("addl %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "ri" (-1));
  }
#line 3005
  goto ldv_42954;
  case 8UL: ;
#line 3005
  if (pao_ID_____1 == 1) {
#line 3005
    __asm__  ("incq %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3005
  if (pao_ID_____1 == -1) {
#line 3005
    __asm__  ("decq %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3005
    __asm__  ("addq %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "re" (-1));
  }
#line 3005
  goto ldv_42954;
  default: 
#line 3005
  __bad_percpu_size();
  }
  ldv_42954: ;
#line 3005
  goto ldv_42938;
  case 8UL: 
#line 3005
  pao_ID_____2 = -1;
#line 3005
  switch (4UL) {
  case 1UL: ;
#line 3005
  if (pao_ID_____2 == 1) {
#line 3005
    __asm__  ("incb %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3005
  if (pao_ID_____2 == -1) {
#line 3005
    __asm__  ("decb %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3005
    __asm__  ("addb %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "qi" (-1));
  }
#line 3005
  goto ldv_42964;
  case 2UL: ;
#line 3005
  if (pao_ID_____2 == 1) {
#line 3005
    __asm__  ("incw %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3005
  if (pao_ID_____2 == -1) {
#line 3005
    __asm__  ("decw %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3005
    __asm__  ("addw %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "ri" (-1));
  }
#line 3005
  goto ldv_42964;
  case 4UL: ;
#line 3005
  if (pao_ID_____2 == 1) {
#line 3005
    __asm__  ("incl %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3005
  if (pao_ID_____2 == -1) {
#line 3005
    __asm__  ("decl %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3005
    __asm__  ("addl %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "ri" (-1));
  }
#line 3005
  goto ldv_42964;
  case 8UL: ;
#line 3005
  if (pao_ID_____2 == 1) {
#line 3005
    __asm__  ("incq %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3005
  if (pao_ID_____2 == -1) {
#line 3005
    __asm__  ("decq %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3005
    __asm__  ("addq %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "re" (-1));
  }
#line 3005
  goto ldv_42964;
  default: 
#line 3005
  __bad_percpu_size();
  }
  ldv_42964: ;
#line 3005
  goto ldv_42938;
  default: 
#line 3005
  __bad_size_call_parameter();
#line 3005
  goto ldv_42938;
  }
  ldv_42938: ;
#line 3006
  return;
}
}
#line 3014 "include/linux/netdevice.h"
__inline static void dev_hold(struct net_device *dev ) 
{ 
  void const   *__vpp_verify ;
  int pao_ID__ ;
  int pao_ID_____0 ;
  int pao_ID_____1 ;
  int pao_ID_____2 ;

  {
#line 3016
  __vpp_verify = (void const   *)0;
#line 3016
  switch (4UL) {
  case 1UL: 
#line 3016
  pao_ID__ = 1;
#line 3016
  switch (4UL) {
  case 1UL: ;
#line 3016
  if (pao_ID__ == 1) {
#line 3016
    __asm__  ("incb %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3016
  if (pao_ID__ == -1) {
#line 3016
    __asm__  ("decb %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3016
    __asm__  ("addb %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "qi" (1));
  }
#line 3016
  goto ldv_42979;
  case 2UL: ;
#line 3016
  if (pao_ID__ == 1) {
#line 3016
    __asm__  ("incw %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3016
  if (pao_ID__ == -1) {
#line 3016
    __asm__  ("decw %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3016
    __asm__  ("addw %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "ri" (1));
  }
#line 3016
  goto ldv_42979;
  case 4UL: ;
#line 3016
  if (pao_ID__ == 1) {
#line 3016
    __asm__  ("incl %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3016
  if (pao_ID__ == -1) {
#line 3016
    __asm__  ("decl %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3016
    __asm__  ("addl %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "ri" (1));
  }
#line 3016
  goto ldv_42979;
  case 8UL: ;
#line 3016
  if (pao_ID__ == 1) {
#line 3016
    __asm__  ("incq %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3016
  if (pao_ID__ == -1) {
#line 3016
    __asm__  ("decq %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3016
    __asm__  ("addq %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "re" (1));
  }
#line 3016
  goto ldv_42979;
  default: 
#line 3016
  __bad_percpu_size();
  }
  ldv_42979: ;
#line 3016
  goto ldv_42984;
  case 2UL: 
#line 3016
  pao_ID_____0 = 1;
#line 3016
  switch (4UL) {
  case 1UL: ;
#line 3016
  if (pao_ID_____0 == 1) {
#line 3016
    __asm__  ("incb %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3016
  if (pao_ID_____0 == -1) {
#line 3016
    __asm__  ("decb %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3016
    __asm__  ("addb %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "qi" (1));
  }
#line 3016
  goto ldv_42990;
  case 2UL: ;
#line 3016
  if (pao_ID_____0 == 1) {
#line 3016
    __asm__  ("incw %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3016
  if (pao_ID_____0 == -1) {
#line 3016
    __asm__  ("decw %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3016
    __asm__  ("addw %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "ri" (1));
  }
#line 3016
  goto ldv_42990;
  case 4UL: ;
#line 3016
  if (pao_ID_____0 == 1) {
#line 3016
    __asm__  ("incl %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3016
  if (pao_ID_____0 == -1) {
#line 3016
    __asm__  ("decl %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3016
    __asm__  ("addl %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "ri" (1));
  }
#line 3016
  goto ldv_42990;
  case 8UL: ;
#line 3016
  if (pao_ID_____0 == 1) {
#line 3016
    __asm__  ("incq %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3016
  if (pao_ID_____0 == -1) {
#line 3016
    __asm__  ("decq %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3016
    __asm__  ("addq %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "re" (1));
  }
#line 3016
  goto ldv_42990;
  default: 
#line 3016
  __bad_percpu_size();
  }
  ldv_42990: ;
#line 3016
  goto ldv_42984;
  case 4UL: 
#line 3016
  pao_ID_____1 = 1;
#line 3016
  switch (4UL) {
  case 1UL: ;
#line 3016
  if (pao_ID_____1 == 1) {
#line 3016
    __asm__  ("incb %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3016
  if (pao_ID_____1 == -1) {
#line 3016
    __asm__  ("decb %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3016
    __asm__  ("addb %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "qi" (1));
  }
#line 3016
  goto ldv_43000;
  case 2UL: ;
#line 3016
  if (pao_ID_____1 == 1) {
#line 3016
    __asm__  ("incw %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3016
  if (pao_ID_____1 == -1) {
#line 3016
    __asm__  ("decw %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3016
    __asm__  ("addw %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "ri" (1));
  }
#line 3016
  goto ldv_43000;
  case 4UL: ;
#line 3016
  if (pao_ID_____1 == 1) {
#line 3016
    __asm__  ("incl %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3016
  if (pao_ID_____1 == -1) {
#line 3016
    __asm__  ("decl %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3016
    __asm__  ("addl %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "ri" (1));
  }
#line 3016
  goto ldv_43000;
  case 8UL: ;
#line 3016
  if (pao_ID_____1 == 1) {
#line 3016
    __asm__  ("incq %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3016
  if (pao_ID_____1 == -1) {
#line 3016
    __asm__  ("decq %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3016
    __asm__  ("addq %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "re" (1));
  }
#line 3016
  goto ldv_43000;
  default: 
#line 3016
  __bad_percpu_size();
  }
  ldv_43000: ;
#line 3016
  goto ldv_42984;
  case 8UL: 
#line 3016
  pao_ID_____2 = 1;
#line 3016
  switch (4UL) {
  case 1UL: ;
#line 3016
  if (pao_ID_____2 == 1) {
#line 3016
    __asm__  ("incb %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3016
  if (pao_ID_____2 == -1) {
#line 3016
    __asm__  ("decb %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3016
    __asm__  ("addb %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "qi" (1));
  }
#line 3016
  goto ldv_43010;
  case 2UL: ;
#line 3016
  if (pao_ID_____2 == 1) {
#line 3016
    __asm__  ("incw %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3016
  if (pao_ID_____2 == -1) {
#line 3016
    __asm__  ("decw %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3016
    __asm__  ("addw %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "ri" (1));
  }
#line 3016
  goto ldv_43010;
  case 4UL: ;
#line 3016
  if (pao_ID_____2 == 1) {
#line 3016
    __asm__  ("incl %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3016
  if (pao_ID_____2 == -1) {
#line 3016
    __asm__  ("decl %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3016
    __asm__  ("addl %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "ri" (1));
  }
#line 3016
  goto ldv_43010;
  case 8UL: ;
#line 3016
  if (pao_ID_____2 == 1) {
#line 3016
    __asm__  ("incq %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else
#line 3016
  if (pao_ID_____2 == -1) {
#line 3016
    __asm__  ("decq %%gs:%0": "+m" (*(dev->pcpu_refcnt)));
  } else {
#line 3016
    __asm__  ("addq %1, %%gs:%0": "+m" (*(dev->pcpu_refcnt)): "re" (1));
  }
#line 3016
  goto ldv_43010;
  default: 
#line 3016
  __bad_percpu_size();
  }
  ldv_43010: ;
#line 3016
  goto ldv_42984;
  default: 
#line 3016
  __bad_size_call_parameter();
#line 3016
  goto ldv_42984;
  }
  ldv_42984: ;
#line 3017
  return;
}
}
#line 3038 "include/linux/netdevice.h"
__inline static bool netif_carrier_ok(struct net_device  const  *dev ) 
{ 
  int tmp ;

  {
#line 3040
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& dev->state));
#line 3040
  return (tmp == 0);
}
}
#line 111 "include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const   *addr ) 
{ 
  u32 a ;

  {
#line 114
  a = *((u32 const   *)addr);
#line 121
  return ((a & 1U) != 0U);
}
}
#line 186 "include/linux/etherdevice.h"
__inline static bool is_valid_ether_addr(u8 const   *addr ) 
{ 
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 190
  tmp = is_multicast_ether_addr(addr);
#line 190
  if (tmp) {
#line 190
    tmp___0 = 0;
  } else {
#line 190
    tmp___0 = 1;
  }
#line 190
  if (tmp___0) {
#line 190
    tmp___1 = is_zero_ether_addr(addr);
#line 190
    if (tmp___1) {
#line 190
      tmp___2 = 0;
    } else {
#line 190
      tmp___2 = 1;
    }
#line 190
    if (tmp___2) {
#line 190
      tmp___3 = 1;
    } else {
#line 190
      tmp___3 = 0;
    }
  } else {
#line 190
    tmp___3 = 0;
  }
#line 190
  return ((bool )tmp___3);
}
}
#line 310 "include/linux/etherdevice.h"
__inline static bool ether_addr_equal(u8 const   *addr1 , u8 const   *addr2 ) 
{ 
  u32 fold ;

  {
#line 313
  fold = ((unsigned int )*((u32 const   *)addr1) ^ (unsigned int )*((u32 const   *)addr2)) | (unsigned int )((int )((unsigned short )*((u16 const   *)addr1 + 4U)) ^ (int )((unsigned short )*((u16 const   *)addr2 + 4U)));
#line 316
  return (fold == 0U);
}
}
#line 27 "include/linux/rtnetlink.h"
extern void rtnl_lock(void) ;
#line 28
extern void rtnl_unlock(void) ;
#line 111 "include/linux/if_vlan.h"
extern struct net_device *vlan_dev_real_dev(struct net_device  const  * ) ;
#line 112
extern u16 vlan_dev_vlan_id(struct net_device  const  * ) ;
#line 8 "include/linux/kthread.h"
extern struct task_struct *kthread_create_on_node(int (*)(void * ) , void * , int  ,
                                                  char const   *  , ...) ;
#line 40
extern void kthread_bind(struct task_struct * , unsigned int  ) ;
#line 41
extern int kthread_stop(struct task_struct * ) ;
#line 42
extern bool kthread_should_stop(void) ;
#line 11 "include/linux/crc32.h"
extern u32 crc32_le(u32  , unsigned char const   * , size_t  ) ;
#line 140 "include/linux/cpu.h"
extern int __register_cpu_notifier(struct notifier_block * ) ;
#line 142
extern void __unregister_cpu_notifier(struct notifier_block * ) ;
#line 172
extern void cpu_maps_update_begin(void) ;
#line 173
extern void cpu_maps_update_done(void) ;
#line 811 "include/linux/pci.h"
extern struct pci_dev *pci_dev_get(struct pci_dev * ) ;
#line 812
extern void pci_dev_put(struct pci_dev * ) ;
#line 7 "include/linux/uaccess.h"
__inline static void pagefault_disabled_inc(void) 
{ 
  struct task_struct *tmp ;

  {
#line 9
  tmp = get_current();
#line 9
  tmp->pagefault_disabled = tmp->pagefault_disabled + 1;
#line 10
  return;
}
}
#line 12 "include/linux/uaccess.h"
__inline static void pagefault_disabled_dec(void) 
{ 
  struct task_struct *tmp ;
  int __ret_warn_on ;
  struct task_struct *tmp___0 ;
  long tmp___1 ;

  {
#line 14
  tmp = get_current();
#line 14
  tmp->pagefault_disabled = tmp->pagefault_disabled - 1;
#line 15
  tmp___0 = get_current();
#line 15
  __ret_warn_on = tmp___0->pagefault_disabled < 0;
#line 15
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 15
  if (tmp___1 != 0L) {
#line 15
    warn_slowpath_null("include/linux/uaccess.h", 15);
  } else {

  }
#line 15
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 17
  return;
}
}
#line 25 "include/linux/uaccess.h"
__inline static void pagefault_disable(void) 
{ 


  {
#line 27
  pagefault_disabled_inc();
#line 32
  __asm__  volatile   ("": : : "memory");
#line 33
  return;
}
}
#line 35 "include/linux/uaccess.h"
__inline static void pagefault_enable(void) 
{ 


  {
#line 41
  __asm__  volatile   ("": : : "memory");
#line 42
  pagefault_disabled_dec();
#line 43
  return;
}
}
#line 66 "include/linux/highmem.h"
__inline static void *kmap_atomic(struct page *page ) 
{ 
  void *tmp ;

  {
#line 68
  __preempt_count_add(1);
#line 68
  __asm__  volatile   ("": : : "memory");
#line 69
  pagefault_disable();
#line 70
  tmp = lowmem_page_address((struct page  const  *)page);
#line 70
  return (tmp);
}
}
#line 74 "include/linux/highmem.h"
__inline static void __kunmap_atomic(void *addr ) 
{ 


  {
#line 76
  pagefault_enable();
#line 77
  __asm__  volatile   ("": : : "memory");
#line 77
  __preempt_count_sub(1);
#line 78
  return;
}
}
#line 754 "include/scsi/scsi_host.h"
__inline static void *shost_priv(struct Scsi_Host *shost ) 
{ 


  {
#line 756
  return ((void *)(& shost->hostdata));
}
}
#line 792
struct Scsi_Host *ldv_scsi_host_alloc_31(struct scsi_host_template *sht , int privsize ) ;
#line 799
int ldv_scsi_add_host_with_dma_30(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 803
extern void scsi_remove_host(struct Scsi_Host * ) ;
#line 806
void ldv_scsi_remove_host_34(struct Scsi_Host *shost ) ;
#line 810
void ldv_scsi_remove_host_36(struct Scsi_Host *shost ) ;
#line 813
extern void scsi_host_put(struct Scsi_Host * ) ;
#line 818 "include/scsi/scsi_host.h"
__inline static int scsi_add_host(struct Scsi_Host *host , struct device *dev ) 
{ 
  int tmp ;

  {
#line 821
  tmp = ldv_scsi_add_host_with_dma_30(host, dev, dev);
#line 821
  return (tmp);
}
}
#line 379 "include/scsi/scsi_device.h"
extern int scsi_change_queue_depth(struct scsi_device * , int  ) ;
#line 830 "include/scsi/scsi_transport_fc.h"
__inline static void fc_vport_set_state(struct fc_vport *vport , enum fc_vport_state new_state ) 
{ 


  {
#line 832
  if ((unsigned int )new_state != 0U && (unsigned int )new_state != 4U) {
#line 834
    vport->vport_last_state = vport->vport_state;
  } else {

  }
#line 835
  vport->vport_state = new_state;
#line 836
  return;
}
}
#line 838
extern struct scsi_transport_template *fc_attach_transport(struct fc_function_template * ) ;
#line 840
extern void fc_release_transport(struct scsi_transport_template * ) ;
#line 841
extern void fc_remove_host(struct Scsi_Host * ) ;
#line 97 "include/scsi/fc_frame.h"
__inline static struct fcoe_rcv_info *fcoe_dev_from_skb(struct sk_buff  const  *skb ) 
{ 


  {
#line 100
  return ((struct fcoe_rcv_info *)(& skb->cb));
}
}
#line 113 "include/scsi/fc_frame.h"
__inline static void fc_frame_init(struct fc_frame *fp ) 
{ 


  {
#line 115
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_dev = (struct fc_lport *)0;
#line 116
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_seq = (struct fc_seq *)0;
#line 117
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_flags = 0U;
#line 118
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_encaps = 0U;
#line 119
  return;
}
}
#line 963 "include/scsi/libfc.h"
__inline static void fc_set_wwnn(struct fc_lport *lport , u64 wwnn ) 
{ 


  {
#line 965
  lport->wwnn = wwnn;
#line 966
  return;
}
}
#line 973 "include/scsi/libfc.h"
__inline static void fc_set_wwpn(struct fc_lport *lport , u64 wwnn ) 
{ 


  {
#line 975
  lport->wwpn = wwnn;
#line 976
  return;
}
}
#line 995 "include/scsi/libfc.h"
__inline static int fc_lport_init_stats(struct fc_lport *lport ) 
{ 
  void *tmp ;

  {
#line 997
  tmp = __alloc_percpu(168UL, 8UL);
#line 997
  lport->stats = (struct fc_stats *)tmp;
#line 998
  if ((unsigned long )lport->stats == (unsigned long )((struct fc_stats *)0)) {
#line 999
    return (-12);
  } else {

  }
#line 1000
  return (0);
}
}
#line 1007 "include/scsi/libfc.h"
__inline static void fc_lport_free_stats(struct fc_lport *lport ) 
{ 


  {
#line 1009
  free_percpu((void *)lport->stats);
#line 1010
  return;
}
}
#line 1030 "include/scsi/libfc.h"
__inline static struct fc_lport *libfc_host_alloc(struct scsi_host_template *sht ,
                                                  int priv_size ) 
{ 
  struct fc_lport *lport ;
  struct Scsi_Host *shost ;
  void *tmp ;

  {
#line 1035
  shost = ldv_scsi_host_alloc_31(sht, (int )((unsigned int )priv_size + 1688U));
#line 1036
  if ((unsigned long )shost == (unsigned long )((struct Scsi_Host *)0)) {
#line 1037
    return ((struct fc_lport *)0);
  } else {

  }
#line 1038
  tmp = shost_priv(shost);
#line 1038
  lport = (struct fc_lport *)tmp;
#line 1039
  lport->host = shost;
#line 1040
  INIT_LIST_HEAD(& lport->ema_list);
#line 1041
  INIT_LIST_HEAD(& lport->vports);
#line 1042
  return (lport);
}
}
#line 1058
extern int fc_lport_init(struct fc_lport * ) ;
#line 1059
extern int fc_lport_destroy(struct fc_lport * ) ;
#line 1060
extern int fc_fabric_logoff(struct fc_lport * ) ;
#line 1061
extern int fc_fabric_login(struct fc_lport * ) ;
#line 1066
extern void fc_vport_setlink(struct fc_lport * ) ;
#line 1068
extern int fc_lport_config(struct fc_lport * ) ;
#line 1069
extern int fc_lport_reset(struct fc_lport * ) ;
#line 1070
extern int fc_set_mfs(struct fc_lport * , u32  ) ;
#line 1071
extern struct fc_lport *libfc_vport_create(struct fc_vport * , int  ) ;
#line 1072
extern struct fc_lport *fc_vport_id_lookup(struct fc_lport * , u32  ) ;
#line 1073
extern int fc_lport_bsg_request(struct fc_bsg_job * ) ;
#line 1080
extern int fc_rport_init(struct fc_lport * ) ;
#line 1081
extern void fc_rport_terminate_io(struct fc_rport * ) ;
#line 1086
extern void fc_disc_init(struct fc_lport * ) ;
#line 1087
extern void fc_disc_config(struct fc_lport * , void * ) ;
#line 1106
extern int fc_eh_host_reset(struct scsi_cmnd * ) ;
#line 1107
extern int fc_slave_alloc(struct scsi_device * ) ;
#line 1112
extern int fc_elsct_init(struct fc_lport * ) ;
#line 1131
extern int fc_exch_init(struct fc_lport * ) ;
#line 1137
extern int fc_exch_mgr_list_clone(struct fc_lport * , struct fc_lport * ) ;
#line 1138
extern struct fc_exch_mgr *fc_exch_mgr_alloc(struct fc_lport * , enum fc_class  ,
                                             u16  , u16  , bool (*)(struct fc_frame * ) ) ;
#line 1141
extern void fc_exch_mgr_free(struct fc_lport * ) ;
#line 1142
extern void fc_exch_recv(struct fc_lport * , struct fc_frame * ) ;
#line 1148
extern void fc_get_host_speed(struct Scsi_Host * ) ;
#line 1149
extern void fc_get_host_port_state(struct Scsi_Host * ) ;
#line 1150
extern void fc_set_rport_loss_tmo(struct fc_rport * , u32  ) ;
#line 1151
extern struct fc_host_statistics *fc_get_host_stats(struct Scsi_Host * ) ;
#line 98 "include/scsi/fc/fc_fcoe.h"
__inline static void fc_fcoe_set_mac(u8 *mac , u8 *did ) 
{ 


  {
#line 100
  *mac = 14U;
#line 101
  *(mac + 1UL) = 252U;
#line 102
  *(mac + 2UL) = 0U;
#line 103
  *(mac + 3UL) = *did;
#line 104
  *(mac + 4UL) = *(did + 1UL);
#line 105
  *(mac + 5UL) = *(did + 2UL);
#line 106
  return;
}
}
#line 80 "include/scsi/fcoe_sysfs.h"
__inline static void *fcoe_ctlr_device_priv(struct fcoe_ctlr_device  const  *ctlr ) 
{ 


  {
#line 82
  return ((void *)ctlr + 1U);
}
}
#line 122
extern struct fcoe_ctlr_device *fcoe_ctlr_device_add(struct device * , struct fcoe_sysfs_function_template * ,
                                                     int  ) ;
#line 125
extern void fcoe_ctlr_device_delete(struct fcoe_ctlr_device * ) ;
#line 168 "include/scsi/libfcoe.h"
__inline static void *fcoe_ctlr_priv(struct fcoe_ctlr  const  *ctlr ) 
{ 


  {
#line 170
  return ((void *)ctlr + 1U);
}
}
#line 248
extern void fcoe_ctlr_init(struct fcoe_ctlr * , enum fip_state  ) ;
#line 249
extern void fcoe_ctlr_destroy(struct fcoe_ctlr * ) ;
#line 250
extern void fcoe_ctlr_link_up(struct fcoe_ctlr * ) ;
#line 251
extern int fcoe_ctlr_link_down(struct fcoe_ctlr * ) ;
#line 252
extern int fcoe_ctlr_els_send(struct fcoe_ctlr * , struct fc_lport * , struct sk_buff * ) ;
#line 253
extern void fcoe_ctlr_recv(struct fcoe_ctlr * , struct sk_buff * ) ;
#line 258
extern u64 fcoe_wwn_from_mac(unsigned char * , unsigned int  , unsigned int  ) ;
#line 261
extern u32 fcoe_fc_crc(struct fc_frame * ) ;
#line 262
extern int fcoe_start_io(struct sk_buff * ) ;
#line 263
extern int fcoe_get_wwn(struct net_device * , u64 * , int  ) ;
#line 266
extern void fcoe_wwn_to_str(u64  , char * , int  ) ;
#line 267
extern int fcoe_validate_vport_create(struct fc_vport * ) ;
#line 268
extern int fcoe_link_speed_update(struct fc_lport * ) ;
#line 269
extern void fcoe_get_lesb(struct fc_lport * , struct fc_els_lesb * ) ;
#line 270
extern void fcoe_ctlr_get_lesb(struct fcoe_ctlr_device * ) ;
#line 376
extern void fcoe_clean_pending_queue(struct fc_lport * ) ;
#line 377
extern void fcoe_check_wait_queue(struct fc_lport * , struct sk_buff * ) ;
#line 378
extern void fcoe_queue_timer(ulong  ) ;
#line 379
extern int fcoe_get_paged_crc_eof(struct sk_buff * , int  , struct fcoe_percpu_s * ) ;
#line 383
extern void fcoe_fcf_get_selected(struct fcoe_fcf_device * ) ;
#line 397
extern int fcoe_transport_attach(struct fcoe_transport * ) ;
#line 398
extern int fcoe_transport_detach(struct fcoe_transport * ) ;
#line 367 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/../../net/ethernet/broadcom/cnic_if.h"
extern int cnic_register_driver(int  , struct cnic_ulp_ops * ) ;
#line 369
extern int cnic_unregister_driver(int  ) ;
#line 166 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc.h"
struct fcoe_percpu_s bnx2fc_global  ;
#line 168 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc.h"
struct workqueue_struct *bnx2fc_wq  ;
#line 493
int bnx2fc_queuecommand(struct Scsi_Host *host , struct scsi_cmnd *sc_cmd ) ;
#line 494
int bnx2fc_send_fw_fcoe_init_msg(struct bnx2fc_hba *hba ) ;
#line 495
int bnx2fc_send_fw_fcoe_destroy_msg(struct bnx2fc_hba *hba ) ;
#line 505
void bnx2fc_indicate_kcqe(void *context , struct kcqe **kcq , u32 num_cqe ) ;
#line 507
int bnx2fc_setup_task_ctx(struct bnx2fc_hba *hba ) ;
#line 508
void bnx2fc_free_task_ctx(struct bnx2fc_hba *hba ) ;
#line 509
int bnx2fc_setup_fw_resc(struct bnx2fc_hba *hba ) ;
#line 510
void bnx2fc_free_fw_resc(struct bnx2fc_hba *hba ) ;
#line 511
struct bnx2fc_cmd_mgr *bnx2fc_cmd_mgr_alloc(struct bnx2fc_hba *hba ) ;
#line 512
void bnx2fc_cmd_mgr_free(struct bnx2fc_cmd_mgr *cmgr ) ;
#line 513
void bnx2fc_get_link_state(struct bnx2fc_hba *hba ) ;
#line 516
int bnx2fc_get_paged_crc_eof(struct sk_buff *skb , int tlen ) ;
#line 539
int bnx2fc_eh_abort(struct scsi_cmnd *sc_cmd ) ;
#line 541
int bnx2fc_eh_target_reset(struct scsi_cmnd *sc_cmd ) ;
#line 542
int bnx2fc_eh_device_reset(struct scsi_cmnd *sc_cmd ) ;
#line 543
void bnx2fc_rport_event_handler(struct fc_lport *lport , struct fc_rport_priv *rdata ,
                                enum fc_rport_event event ) ;
#line 566
void bnx2fc_flush_active_ios(struct bnx2fc_rport *tgt ) ;
#line 575
void bnx2fc_process_cq_compl(struct bnx2fc_rport *tgt , u16 wqe ) ;
#line 576
struct bnx2fc_rport *bnx2fc_tgt_lookup(struct fcoe_port *port , u32 port_id ) ;
#line 581
int bnx2fc_send_stat_req(struct bnx2fc_hba *hba ) ;
#line 25 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc_debug.h"
unsigned int bnx2fc_debug_level  ;
#line 42
void BNX2FC_TGT_DBG(struct bnx2fc_rport  const  *tgt , char const   *fmt  , ...) ;
#line 44
void BNX2FC_HBA_DBG(struct fc_lport  const  *lport , char const   *fmt  , ...) ;
#line 18 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct list_head adapter_list  ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct list_head if_list  ;
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static u32 adapter_count  ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct mutex bnx2fc_dev_lock  =    {{1}, {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "bnx2fc_dev_lock.wait_lock",
                                                          0, 0UL}}}}, {& bnx2fc_dev_lock.wait_list,
                                                                       & bnx2fc_dev_lock.wait_list},
    0, (void *)(& bnx2fc_dev_lock), {0, {0, 0}, "bnx2fc_dev_lock", 0, 0UL}};
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
char __pcpu_scope_bnx2fc_percpu  ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
char __pcpu_unique_bnx2fc_percpu  ;
#line 22 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
struct bnx2fc_percpu_s bnx2fc_percpu  ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static char version[62U]  = 
#line 29
  {      'Q',      'L',      'o',      'g', 
        'i',      'c',      ' ',      'N', 
        'e',      't',      'X',      't', 
        'r',      'e',      'm',      'e', 
        ' ',      'I',      'I',      ' ', 
        'F',      'C',      'o',      'E', 
        ' ',      'D',      'r',      'i', 
        'v',      'e',      'r',      ' ', 
        'b',      'n',      'x',      '2', 
        'f',      'c',      ' ',      'v', 
        '2',      '.',      '4',      '.', 
        '2',      ' ',      '(',      'D', 
        'e',      'c',      ' ',      '1', 
        '1',      ',',      ' ',      '2', 
        '0',      '1',      '3',      ')', 
        '\n',      '\000'};
#line 43 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct scsi_transport_template *bnx2fc_transport_template  ;
#line 44 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct scsi_transport_template *bnx2fc_vport_xport_template  ;
#line 52 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
spinlock_t bnx2fc_global_lock  =    {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "bnx2fc_global_lock",
                                                    0, 0UL}}}};
#line 54
static struct cnic_ulp_ops bnx2fc_cnic_cb ;
#line 55
static struct libfc_function_template bnx2fc_libfc_fcn_templ ;
#line 56
static struct scsi_host_template bnx2fc_shost_template ;
#line 57
static struct fc_function_template bnx2fc_transport_function ;
#line 58
static struct fcoe_sysfs_function_template bnx2fc_fcoe_sysfs_templ ;
#line 59
static struct fc_function_template bnx2fc_vport_xport_function ;
#line 60
static int bnx2fc_create(struct net_device *netdev , enum fip_state fip_mode ) ;
#line 61
static void __bnx2fc_destroy(struct bnx2fc_interface *interface ) ;
#line 62
static int bnx2fc_destroy(struct net_device *netdev ) ;
#line 63
static int bnx2fc_enable(struct net_device *netdev ) ;
#line 64
static int bnx2fc_disable(struct net_device *netdev ) ;
#line 67
static int bnx2fc_ctlr_alloc(struct net_device *netdev ) ;
#line 68
static int bnx2fc_ctlr_enabled(struct fcoe_ctlr_device *cdev ) ;
#line 70
static void bnx2fc_recv_frame(struct sk_buff *skb ) ;
#line 72
static void bnx2fc_start_disc(struct bnx2fc_interface *interface ) ;
#line 73
static int bnx2fc_shost_config(struct fc_lport *lport , struct device *dev ) ;
#line 74
static int bnx2fc_lport_config(struct fc_lport *lport ) ;
#line 75
static int bnx2fc_em_config(struct fc_lport *lport , struct bnx2fc_hba *hba ) ;
#line 76
static int bnx2fc_bind_adapter_devices(struct bnx2fc_hba *hba ) ;
#line 77
static void bnx2fc_unbind_adapter_devices(struct bnx2fc_hba *hba ) ;
#line 78
static int bnx2fc_bind_pcidev(struct bnx2fc_hba *hba ) ;
#line 79
static void bnx2fc_unbind_pcidev(struct bnx2fc_hba *hba ) ;
#line 80
static struct fc_lport *bnx2fc_if_create(struct bnx2fc_interface *interface , struct device *parent ,
                                         int npiv ) ;
#line 82
static void bnx2fc_destroy_work(struct work_struct *work ) ;
#line 84
static struct bnx2fc_hba *bnx2fc_hba_lookup(struct net_device *phys_dev ) ;
#line 85
static struct bnx2fc_interface *bnx2fc_interface_lookup(struct net_device *netdev ) ;
#line 87
__inline static void bnx2fc_interface_put(struct bnx2fc_interface *interface ) ;
#line 88
static struct bnx2fc_hba *bnx2fc_find_hba_for_cnic(struct cnic_dev *cnic ) ;
#line 90
static int bnx2fc_fw_init(struct bnx2fc_hba *hba ) ;
#line 91
static void bnx2fc_fw_destroy(struct bnx2fc_hba *hba ) ;
#line 93
static void bnx2fc_port_shutdown(struct fc_lport *lport ) ;
#line 94
static void bnx2fc_stop(struct bnx2fc_interface *interface ) ;
#line 95
static int bnx2fc_mod_init(void) ;
#line 96
static void bnx2fc_mod_exit(void) ;
#line 101
static int bnx2fc_cpu_callback(struct notifier_block *nfb , unsigned long action ,
                               void *hcpu ) ;
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct notifier_block bnx2fc_cpu_notifier  =    {& bnx2fc_cpu_callback, 0, 0};
#line 108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
__inline static struct net_device *bnx2fc_netdev(struct fc_lport  const  *lport ) 
{ 
  void *tmp ;

  {
#line 110
  tmp = lport_priv(lport);
#line 110
  return (((struct bnx2fc_interface *)((struct fcoe_port *)tmp)->priv)->netdev);
}
}
#line 114 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_fcf_get_vlan_id(struct fcoe_fcf_device *fcf_dev ) 
{ 
  struct fcoe_ctlr_device *ctlr_dev ;
  struct device  const  *__mptr ;
  struct fcoe_ctlr *ctlr ;
  void *tmp ;
  struct bnx2fc_interface *fcoe ;
  void *tmp___0 ;

  {
#line 117
  __mptr = (struct device  const  *)fcf_dev->dev.parent;
#line 117
  ctlr_dev = (struct fcoe_ctlr_device *)__mptr + 0xfffffffffffffff8UL;
#line 118
  tmp = fcoe_ctlr_device_priv((struct fcoe_ctlr_device  const  *)ctlr_dev);
#line 118
  ctlr = (struct fcoe_ctlr *)tmp;
#line 119
  tmp___0 = fcoe_ctlr_priv((struct fcoe_ctlr  const  *)ctlr);
#line 119
  fcoe = (struct bnx2fc_interface *)tmp___0;
#line 121
  fcf_dev->vlan_id = (u16 )fcoe->vlan_id;
#line 122
  return;
}
}
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_clean_rx_queue(struct fc_lport *lp ) 
{ 
  struct fcoe_percpu_s *bg ;
  struct fcoe_rcv_info *fr ;
  struct sk_buff_head *list ;
  struct sk_buff *skb ;
  struct sk_buff *next ;
  struct sk_buff *head ;

  {
#line 132
  bg = & bnx2fc_global;
#line 133
  spin_lock_bh(& bg->fcoe_rx_list.lock);
#line 134
  list = & bg->fcoe_rx_list;
#line 135
  head = list->next;
#line 136
  skb = head;
#line 136
  goto ldv_54755;
  ldv_54754: 
#line 138
  next = skb->__annonCompField68.__annonCompField67.next;
#line 139
  fr = fcoe_dev_from_skb((struct sk_buff  const  *)skb);
#line 140
  if ((unsigned long )fr->fr_dev == (unsigned long )lp) {
#line 141
    __skb_unlink(skb, list);
#line 142
    kfree_skb(skb);
  } else {

  }
#line 137
  skb = next;
  ldv_54755: ;
#line 136
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)list)) {
#line 138
    goto ldv_54754;
  } else {

  }
#line 145
  spin_unlock_bh(& bg->fcoe_rx_list.lock);
#line 146
  return;
}
}
#line 148 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
int bnx2fc_get_paged_crc_eof(struct sk_buff *skb , int tlen ) 
{ 
  int rc ;

  {
#line 151
  spin_lock(& bnx2fc_global_lock);
#line 152
  rc = fcoe_get_paged_crc_eof(skb, tlen, & bnx2fc_global);
#line 153
  spin_unlock(& bnx2fc_global_lock);
#line 155
  return (rc);
}
}
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_abort_io(struct fc_lport *lport ) 
{ 


  {
#line 160
  return;
}
}
#line 168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_cleanup(struct fc_lport *lport ) 
{ 
  struct fcoe_port *port ;
  void *tmp ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_hba *hba ;
  struct bnx2fc_rport *tgt ;
  int i ;
  long tmp___0 ;

  {
#line 170
  tmp = lport_priv((struct fc_lport  const  *)lport);
#line 170
  port = (struct fcoe_port *)tmp;
#line 171
  interface = (struct bnx2fc_interface *)port->priv;
#line 172
  hba = interface->hba;
#line 176
  tmp___0 = ldv__builtin_expect((bnx2fc_debug_level & 16U) != 0U, 0L);
#line 176
  if (tmp___0 != 0L) {
#line 176
    printk("\016bnx2fc: Entered %s\n", "bnx2fc_cleanup");
  } else {

  }
#line 177
  mutex_lock_nested(& hba->hba_mutex, 0U);
#line 178
  spin_lock_bh(& hba->hba_lock);
#line 179
  i = 0;
#line 179
  goto ldv_54775;
  ldv_54774: 
#line 180
  tgt = *(hba->tgt_ofld_list + (unsigned long )i);
#line 181
  if ((unsigned long )tgt != (unsigned long )((struct bnx2fc_rport *)0)) {
#line 183
    if ((unsigned long )tgt->port == (unsigned long )port) {
#line 184
      spin_unlock_bh(& hba->hba_lock);
#line 185
      BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "flush/cleanup\n");
#line 186
      bnx2fc_flush_active_ios(tgt);
#line 187
      spin_lock_bh(& hba->hba_lock);
    } else {

    }
  } else {

  }
#line 179
  i = i + 1;
  ldv_54775: ;
#line 179
  if (i <= 1023) {
#line 181
    goto ldv_54774;
  } else {

  }
#line 191
  spin_unlock_bh(& hba->hba_lock);
#line 192
  mutex_unlock(& hba->hba_mutex);
#line 193
  return;
}
}
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_xmit_l2_frame(struct bnx2fc_rport *tgt , struct fc_frame *fp ) 
{ 
  struct fc_rport_priv *rdata ;
  struct fc_frame_header *fh ;
  int rc ;
  __u16 tmp ;
  u8 tmp___0 ;

  {
#line 198
  rdata = tgt->rdata;
#line 200
  rc = 0;
#line 202
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 203
  tmp = __fswab16((int )fh->fh_ox_id);
#line 203
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "Xmit L2 frame rport = 0x%x, oxid = 0x%x, r_ctl = 0x%x\n",
                 rdata->ids.port_id, (int )tmp, (int )fh->fh_r_ctl);
#line 206
  if ((unsigned int )fh->fh_type == 1U && (unsigned int )fh->fh_r_ctl == 34U) {
#line 209
    tmp___0 = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 209
    switch ((int )tmp___0) {
    case 82: 
#line 211
    rc = bnx2fc_send_adisc(tgt, fp);
#line 212
    goto ldv_54785;
    case 5: 
#line 214
    rc = bnx2fc_send_logo(tgt, fp);
#line 215
    goto ldv_54785;
    case 15: 
#line 217
    rc = bnx2fc_send_rls(tgt, fp);
#line 218
    goto ldv_54785;
    default: ;
#line 220
    goto ldv_54785;
    }
    ldv_54785: ;
  } else
#line 222
  if ((unsigned int )fh->fh_type == 0U && (unsigned int )fh->fh_r_ctl == 129U) {
#line 224
    BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "ABTS frame\n");
  } else {
#line 226
    BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "Send L2 frame type 0x%x rctl 0x%x thru non-offload path\n",
                   (int )fh->fh_type, (int )fh->fh_r_ctl);
#line 229
    return (-19);
  }
#line 231
  if (rc != 0) {
#line 232
    return (-12);
  } else {
#line 234
    return (0);
  }
}
}
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_xmit(struct fc_lport *lport , struct fc_frame *fp ) 
{ 
  struct ethhdr *eh ;
  struct fcoe_crc_eof *cp ;
  struct sk_buff *skb ;
  struct fc_frame_header *fh ;
  struct bnx2fc_interface *interface ;
  struct fcoe_ctlr *ctlr ;
  struct bnx2fc_hba *hba ;
  struct fcoe_port *port ;
  struct fcoe_hdr *hp ;
  struct bnx2fc_rport *tgt ;
  struct fc_stats *stats ;
  u8 sof ;
  u8 eof ;
  u32 crc ;
  unsigned int hlen ;
  unsigned int tlen ;
  unsigned int elen ;
  int wlen ;
  int rc ;
  void *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  int tmp___4 ;
  skb_frag_t *frag ;
  int tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  struct page *tmp___8 ;
  void *tmp___9 ;
  unsigned char *tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;
  long tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  int pscr_ret__ ;
  void const   *__vpp_verify___0 ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___18 ;

  {
#line 259
  rc = 0;
#line 261
  tmp = lport_priv((struct fc_lport  const  *)lport);
#line 261
  port = (struct fcoe_port *)tmp;
#line 262
  interface = (struct bnx2fc_interface *)port->priv;
#line 263
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 264
  hba = interface->hba;
#line 266
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 268
  skb = & fp->skb;
#line 269
  if ((unsigned int )lport->link_up == 0U) {
#line 270
    BNX2FC_HBA_DBG((struct fc_lport  const  *)lport, "bnx2fc_xmit link down\n");
#line 271
    kfree_skb(skb);
#line 272
    return (0);
  } else {

  }
#line 275
  tmp___1 = ldv__builtin_expect((unsigned int )fh->fh_r_ctl == 34U, 0L);
#line 275
  if (tmp___1 != 0L) {
#line 276
    if ((unsigned long )ctlr->sel_fcf == (unsigned long )((struct fcoe_fcf *)0)) {
#line 277
      BNX2FC_HBA_DBG((struct fc_lport  const  *)lport, "FCF not selected yet!\n");
#line 278
      kfree_skb(skb);
#line 279
      return (-22);
    } else {

    }
#line 281
    tmp___0 = fcoe_ctlr_els_send(ctlr, lport, skb);
#line 281
    if (tmp___0 != 0) {
#line 282
      return (0);
    } else {

    }
  } else {

  }
#line 285
  sof = ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_sof;
#line 286
  eof = ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_eof;
#line 298
  spin_lock_bh(& hba->hba_lock);
#line 299
  tmp___2 = ntoh24((u8 const   *)(& fh->fh_d_id));
#line 299
  tgt = bnx2fc_tgt_lookup(port, tmp___2);
#line 300
  if ((unsigned long )tgt != (unsigned long )((struct bnx2fc_rport *)0)) {
#line 300
    tmp___4 = constant_test_bit(1L, (unsigned long const volatile   *)(& tgt->flags));
#line 300
    if (tmp___4 != 0) {
#line 302
      tmp___3 = ntoh24((u8 const   *)(& fh->fh_d_id));
#line 302
      BNX2FC_HBA_DBG((struct fc_lport  const  *)lport, "xmit: Frame is for offloaded session port_id = 0x%x\n",
                     tmp___3);
#line 304
      spin_unlock_bh(& hba->hba_lock);
#line 305
      rc = bnx2fc_xmit_l2_frame(tgt, fp);
#line 306
      if (rc != -19) {
#line 307
        kfree_skb(skb);
#line 308
        return (rc);
      } else {

      }
    } else {
#line 311
      spin_unlock_bh(& hba->hba_lock);
    }
  } else {
#line 311
    spin_unlock_bh(& hba->hba_lock);
  }
#line 314
  elen = 14U;
#line 315
  hlen = 14U;
#line 316
  tlen = 8U;
#line 317
  wlen = (int )(((unsigned long )(skb->len - tlen) + 4UL) / 4UL);
#line 319
  skb->ip_summed = 0U;
#line 320
  crc = fcoe_fc_crc(fp);
#line 323
  tmp___11 = skb_is_nonlinear((struct sk_buff  const  *)skb);
#line 323
  if ((int )tmp___11) {
#line 325
    tmp___5 = bnx2fc_get_paged_crc_eof(skb, (int )tlen);
#line 325
    if (tmp___5 != 0) {
#line 326
      kfree_skb(skb);
#line 327
      return (-12);
    } else {

    }
#line 329
    tmp___6 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 329
    tmp___7 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 329
    frag = (skb_frag_t *)(& ((struct skb_shared_info *)tmp___6)->frags) + ((unsigned long )((struct skb_shared_info *)tmp___7)->nr_frags + 0xffffffffffffffffUL);
#line 330
    tmp___8 = skb_frag_page((skb_frag_t const   *)frag);
#line 330
    tmp___9 = kmap_atomic(tmp___8);
#line 330
    cp = (struct fcoe_crc_eof *)tmp___9 + (unsigned long )frag->page_offset;
  } else {
#line 332
    tmp___10 = skb_put(skb, tlen);
#line 332
    cp = (struct fcoe_crc_eof *)tmp___10;
  }
#line 335
  memset((void *)cp, 0, 8UL);
#line 336
  cp->fcoe_eof = eof;
#line 337
  cp->fcoe_crc32 = ~ crc;
#line 338
  tmp___12 = skb_is_nonlinear((struct sk_buff  const  *)skb);
#line 338
  if ((int )tmp___12) {
#line 339
    __kunmap_atomic((void *)cp);
#line 340
    cp = (struct fcoe_crc_eof *)0;
  } else {

  }
#line 344
  skb_push(skb, elen + hlen);
#line 345
  skb_reset_mac_header(skb);
#line 346
  skb_reset_network_header(skb);
#line 347
  skb->mac_len = (__u16 )elen;
#line 348
  skb->protocol = 1673U;
#line 349
  skb->dev = interface->netdev;
#line 352
  eh = eth_hdr((struct sk_buff  const  *)skb);
#line 353
  eh->h_proto = 1673U;
#line 354
  if ((unsigned int )ctlr->map_dest != 0U) {
#line 355
    fc_fcoe_set_mac((u8 *)(& eh->h_dest), (u8 *)(& fh->fh_d_id));
  } else {
#line 358
    memcpy((void *)(& eh->h_dest), (void const   *)(& ctlr->dest_addr), 6UL);
  }
#line 360
  tmp___13 = ldv__builtin_expect((unsigned int )ctlr->flogi_oxid != 65535U, 0L);
#line 360
  if (tmp___13 != 0L) {
#line 361
    memcpy((void *)(& eh->h_source), (void const   *)(& ctlr->ctl_src_addr), 6UL);
  } else {
#line 363
    memcpy((void *)(& eh->h_source), (void const   *)(& port->data_src_addr), 6UL);
  }
#line 365
  hp = (struct fcoe_hdr *)eh + 1U;
#line 366
  memset((void *)hp, 0, 14UL);
#line 369
  hp->fcoe_sof = sof;
#line 372
  if ((unsigned int )*((unsigned char *)lport + 1144UL) != 0U && (unsigned int )((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_max_payload != 0U) {
#line 373
    tmp___14 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 373
    ((struct skb_shared_info *)tmp___14)->gso_type = 32U;
#line 374
    tmp___15 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 374
    ((struct skb_shared_info *)tmp___15)->gso_size = ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_max_payload;
  } else {
#line 376
    tmp___16 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 376
    ((struct skb_shared_info *)tmp___16)->gso_type = 0U;
#line 377
    tmp___17 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 377
    ((struct skb_shared_info *)tmp___17)->gso_size = 0U;
  }
#line 381
  __vpp_verify = (void const   *)0;
#line 381
  __asm__  ("": "=r" (__ptr): "0" (lport->stats));
#line 381
  __preempt_count_add(1);
#line 381
  __asm__  volatile   ("": : : "memory");
#line 381
  __vpp_verify___0 = (void const   *)0;
#line 381
  switch (4UL) {
  case 1UL: ;
#line 381
  switch (4UL) {
  case 1UL: 
#line 381
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 381
  goto ldv_54820;
  case 2UL: 
#line 381
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 381
  goto ldv_54820;
  case 4UL: 
#line 381
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 381
  goto ldv_54820;
  case 8UL: 
#line 381
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 381
  goto ldv_54820;
  default: 
#line 381
  __bad_percpu_size();
  }
  ldv_54820: 
#line 381
  pscr_ret__ = pfo_ret__;
#line 381
  goto ldv_54826;
  case 2UL: ;
#line 381
  switch (4UL) {
  case 1UL: 
#line 381
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 381
  goto ldv_54830;
  case 2UL: 
#line 381
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 381
  goto ldv_54830;
  case 4UL: 
#line 381
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 381
  goto ldv_54830;
  case 8UL: 
#line 381
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 381
  goto ldv_54830;
  default: 
#line 381
  __bad_percpu_size();
  }
  ldv_54830: 
#line 381
  pscr_ret__ = pfo_ret_____0;
#line 381
  goto ldv_54826;
  case 4UL: ;
#line 381
  switch (4UL) {
  case 1UL: 
#line 381
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 381
  goto ldv_54839;
  case 2UL: 
#line 381
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 381
  goto ldv_54839;
  case 4UL: 
#line 381
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 381
  goto ldv_54839;
  case 8UL: 
#line 381
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 381
  goto ldv_54839;
  default: 
#line 381
  __bad_percpu_size();
  }
  ldv_54839: 
#line 381
  pscr_ret__ = pfo_ret_____1;
#line 381
  goto ldv_54826;
  case 8UL: ;
#line 381
  switch (4UL) {
  case 1UL: 
#line 381
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 381
  goto ldv_54848;
  case 2UL: 
#line 381
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 381
  goto ldv_54848;
  case 4UL: 
#line 381
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 381
  goto ldv_54848;
  case 8UL: 
#line 381
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 381
  goto ldv_54848;
  default: 
#line 381
  __bad_percpu_size();
  }
  ldv_54848: 
#line 381
  pscr_ret__ = pfo_ret_____2;
#line 381
  goto ldv_54826;
  default: 
#line 381
  __bad_size_call_parameter();
#line 381
  goto ldv_54826;
  }
  ldv_54826: 
#line 381
  stats = (struct fc_stats *)(__per_cpu_offset[pscr_ret__] + __ptr);
#line 382
  stats->TxFrames = stats->TxFrames + 1ULL;
#line 383
  stats->TxWords = stats->TxWords + (u64 )wlen;
#line 384
  __asm__  volatile   ("": : : "memory");
#line 384
  __preempt_count_sub(1);
#line 387
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_dev = lport;
#line 388
  if (port->fcoe_pending_queue.qlen != 0U) {
#line 389
    fcoe_check_wait_queue(lport, skb);
  } else {
#line 390
    tmp___18 = fcoe_start_io(skb);
#line 390
    if (tmp___18 != 0) {
#line 391
      fcoe_check_wait_queue(lport, skb);
    } else {

    }
  }
#line 393
  return (0);
}
}
#line 406 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_rcv(struct sk_buff *skb , struct net_device *dev , struct packet_type *ptype ,
                      struct net_device *olddev ) 
{ 
  struct fc_lport *lport ;
  struct bnx2fc_interface *interface ;
  struct fcoe_ctlr *ctlr ;
  struct fc_frame_header *fh ;
  struct fcoe_rcv_info *fr ;
  struct fcoe_percpu_s *bg ;
  struct sk_buff *tmp_skb ;
  unsigned short oxid ;
  struct packet_type  const  *__mptr ;
  long tmp ;
  struct ethhdr *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned char *tmp___5 ;
  __u16 tmp___6 ;

  {
#line 418
  __mptr = (struct packet_type  const  *)ptype;
#line 418
  interface = (struct bnx2fc_interface *)__mptr + 0xffffffffffffffd8UL;
#line 420
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 421
  lport = ctlr->lp;
#line 423
  tmp = ldv__builtin_expect((unsigned long )lport == (unsigned long )((struct fc_lport *)0),
                         0L);
#line 423
  if (tmp != 0L) {
#line 424
    printk("\vbnx2fc: bnx2fc_rcv: lport is NULL\n");
#line 425
    goto err;
  } else {

  }
#line 428
  tmp_skb = skb_share_check(skb, 32U);
#line 429
  if ((unsigned long )tmp_skb == (unsigned long )((struct sk_buff *)0)) {
#line 430
    goto err;
  } else {

  }
#line 432
  skb = tmp_skb;
#line 434
  tmp___0 = eth_hdr((struct sk_buff  const  *)skb);
#line 434
  tmp___1 = ldv__builtin_expect((unsigned int )tmp___0->h_proto != 1673U, 0L);
#line 434
  if (tmp___1 != 0L) {
#line 435
    printk("\vbnx2fc: bnx2fc_rcv: Wrong FC type frame\n");
#line 436
    goto err;
  } else {

  }
#line 443
  if (skb->len <= 45U) {
#line 443
    tmp___3 = 1;
  } else {
#line 443
    tmp___2 = pskb_may_pull(skb, 38U);
#line 443
    if (tmp___2 == 0) {
#line 443
      tmp___3 = 1;
    } else {
#line 443
      tmp___3 = 0;
    }
  }
#line 443
  tmp___4 = ldv__builtin_expect((long )tmp___3, 0L);
#line 443
  if (tmp___4 != 0L) {
#line 445
    goto err;
  } else {

  }
#line 447
  skb_set_transport_header(skb, 14);
#line 448
  tmp___5 = skb_transport_header((struct sk_buff  const  *)skb);
#line 448
  fh = (struct fc_frame_header *)tmp___5;
#line 450
  tmp___6 = __fswab16((int )fh->fh_ox_id);
#line 450
  oxid = tmp___6;
#line 452
  fr = fcoe_dev_from_skb((struct sk_buff  const  *)skb);
#line 453
  fr->fr_dev = lport;
#line 455
  bg = & bnx2fc_global;
#line 456
  spin_lock(& bg->fcoe_rx_list.lock);
#line 458
  __skb_queue_tail(& bg->fcoe_rx_list, skb);
#line 459
  if (bg->fcoe_rx_list.qlen == 1U) {
#line 460
    wake_up_process(bg->thread);
  } else {

  }
#line 462
  spin_unlock(& bg->fcoe_rx_list.lock);
#line 464
  return (0);
  err: 
#line 466
  kfree_skb(skb);
#line 467
  return (-1);
}
}
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_l2_rcv_thread(void *arg ) 
{ 
  struct fcoe_percpu_s *bg ;
  struct sk_buff *skb ;
  struct task_struct *tmp ;
  struct task_struct *tmp___0 ;
  long volatile   __ret ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  struct task_struct *tmp___5 ;
  struct task_struct *tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  struct task_struct *tmp___9 ;
  struct task_struct *tmp___10 ;

  {
#line 472
  bg = (struct fcoe_percpu_s *)arg;
#line 475
  tmp = get_current();
#line 475
  set_user_nice(tmp, -20L);
#line 476
  tmp___0 = get_current();
#line 476
  tmp___0->task_state_change = 0UL;
#line 476
  __ret = 1L;
#line 476
  switch (8UL) {
  case 1UL: 
#line 476
  tmp___1 = get_current();
#line 476
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
#line 476
  goto ldv_54883;
  case 2UL: 
#line 476
  tmp___2 = get_current();
#line 476
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
#line 476
  goto ldv_54883;
  case 4UL: 
#line 476
  tmp___3 = get_current();
#line 476
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
#line 476
  goto ldv_54883;
  case 8UL: 
#line 476
  tmp___4 = get_current();
#line 476
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                       "cc");
#line 476
  goto ldv_54883;
  default: 
#line 476
  __xchg_wrong_size();
  }
  ldv_54883: ;
#line 477
  goto ldv_54893;
  ldv_54892: 
#line 478
  schedule();
#line 479
  spin_lock_bh(& bg->fcoe_rx_list.lock);
#line 480
  goto ldv_54890;
  ldv_54889: 
#line 481
  spin_unlock_bh(& bg->fcoe_rx_list.lock);
#line 482
  bnx2fc_recv_frame(skb);
#line 483
  spin_lock_bh(& bg->fcoe_rx_list.lock);
  ldv_54890: 
#line 480
  skb = __skb_dequeue(& bg->fcoe_rx_list);
#line 480
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 482
    goto ldv_54889;
  } else {

  }
#line 485
  tmp___5 = get_current();
#line 485
  tmp___5->task_state_change = 0UL;
#line 485
  tmp___6 = get_current();
#line 485
  tmp___6->state = 1L;
#line 486
  spin_unlock_bh(& bg->fcoe_rx_list.lock);
  ldv_54893: 
#line 477
  tmp___7 = kthread_should_stop();
#line 477
  if (tmp___7) {
#line 477
    tmp___8 = 0;
  } else {
#line 477
    tmp___8 = 1;
  }
#line 477
  if (tmp___8) {
#line 479
    goto ldv_54892;
  } else {

  }
#line 488
  tmp___9 = get_current();
#line 488
  tmp___9->task_state_change = 0UL;
#line 488
  tmp___10 = get_current();
#line 488
  tmp___10->state = 0L;
#line 489
  return (0);
}
}
#line 493 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_recv_frame(struct sk_buff *skb ) 
{ 
  u32 fr_len ;
  struct fc_lport *lport ;
  struct fcoe_rcv_info *fr ;
  struct fc_stats *stats ;
  struct fc_frame_header *fh ;
  struct fcoe_crc_eof crc_eof ;
  struct fc_frame *fp ;
  struct fc_lport *vn_port ;
  struct fcoe_port *port ;
  u8 *mac ;
  u8 *dest_mac ;
  struct fcoe_hdr *hp ;
  long tmp ;
  bool tmp___0 ;
  struct ethhdr *tmp___1 ;
  struct ethhdr *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  u32 tmp___7 ;
  void *tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  u8 tmp___11 ;
  u32 tmp___12 ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  int pscr_ret__ ;
  void const   *__vpp_verify___0 ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  u32 tmp___13 ;

  {
#line 504
  mac = (u8 *)0U;
#line 505
  dest_mac = (u8 *)0U;
#line 508
  fr = fcoe_dev_from_skb((struct sk_buff  const  *)skb);
#line 509
  lport = fr->fr_dev;
#line 510
  tmp = ldv__builtin_expect((unsigned long )lport == (unsigned long )((struct fc_lport *)0),
                         0L);
#line 510
  if (tmp != 0L) {
#line 511
    printk("\vbnx2fc: Invalid lport struct\n");
#line 512
    kfree_skb(skb);
#line 513
    return;
  } else {

  }
#line 516
  tmp___0 = skb_is_nonlinear((struct sk_buff  const  *)skb);
#line 516
  if ((int )tmp___0) {
#line 517
    skb_linearize(skb);
  } else {

  }
#line 518
  tmp___1 = eth_hdr((struct sk_buff  const  *)skb);
#line 518
  mac = (u8 *)(& tmp___1->h_source);
#line 519
  tmp___2 = eth_hdr((struct sk_buff  const  *)skb);
#line 519
  dest_mac = (u8 *)(& tmp___2->h_dest);
#line 522
  tmp___3 = skb_network_header((struct sk_buff  const  *)skb);
#line 522
  hp = (struct fcoe_hdr *)tmp___3;
#line 523
  tmp___4 = skb_transport_header((struct sk_buff  const  *)skb);
#line 523
  fh = (struct fc_frame_header *)tmp___4;
#line 524
  skb_pull(skb, 14U);
#line 525
  fr_len = skb->len - 8U;
#line 527
  fp = (struct fc_frame *)skb;
#line 528
  fc_frame_init(fp);
#line 529
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_dev = lport;
#line 530
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_sof = hp->fcoe_sof;
#line 531
  tmp___5 = skb_copy_bits((struct sk_buff  const  *)skb, (int )fr_len, (void *)(& crc_eof),
                          8);
#line 531
  if (tmp___5 != 0) {
#line 532
    kfree_skb(skb);
#line 533
    return;
  } else {

  }
#line 535
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_eof = crc_eof.fcoe_eof;
#line 536
  ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_crc = crc_eof.fcoe_crc32;
#line 537
  tmp___6 = pskb_trim(skb, fr_len);
#line 537
  if (tmp___6 != 0) {
#line 538
    kfree_skb(skb);
#line 539
    return;
  } else {

  }
#line 542
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 544
  tmp___7 = ntoh24((u8 const   *)(& fh->fh_d_id));
#line 544
  vn_port = fc_vport_id_lookup(lport, tmp___7);
#line 545
  if ((unsigned long )vn_port != (unsigned long )((struct fc_lport *)0)) {
#line 546
    tmp___8 = lport_priv((struct fc_lport  const  *)vn_port);
#line 546
    port = (struct fcoe_port *)tmp___8;
#line 547
    tmp___9 = ether_addr_equal((u8 const   *)(& port->data_src_addr), (u8 const   *)dest_mac);
#line 547
    if (tmp___9) {
#line 547
      tmp___10 = 0;
    } else {
#line 547
      tmp___10 = 1;
    }
#line 547
    if (tmp___10) {
#line 548
      BNX2FC_HBA_DBG((struct fc_lport  const  *)lport, "fpma mismatch\n");
#line 549
      kfree_skb(skb);
#line 550
      return;
    } else {

    }
  } else {

  }
#line 553
  if ((unsigned int )fh->fh_r_ctl == 1U && (unsigned int )fh->fh_type == 8U) {
#line 556
    kfree_skb(skb);
#line 557
    return;
  } else {

  }
#line 559
  if ((unsigned int )fh->fh_r_ctl == 34U && (unsigned int )fh->fh_type == 1U) {
#line 561
    tmp___11 = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 561
    switch ((int )tmp___11) {
    case 5: 
#line 563
    tmp___12 = ntoh24((u8 const   *)(& fh->fh_s_id));
#line 563
    if (tmp___12 == 16777214U) {
#line 565
      kfree_skb(skb);
#line 566
      return;
    } else {

    }
#line 568
    goto ldv_54911;
    }
    ldv_54911: ;
  } else {

  }
#line 572
  if ((unsigned int )fh->fh_r_ctl == 129U) {
#line 574
    kfree_skb(skb);
#line 575
    return;
  } else {

  }
#line 578
  __vpp_verify = (void const   *)0;
#line 578
  __asm__  ("": "=r" (__ptr): "0" (lport->stats));
#line 578
  __vpp_verify___0 = (void const   *)0;
#line 578
  switch (4UL) {
  case 1UL: ;
#line 578
  switch (4UL) {
  case 1UL: 
#line 578
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 578
  goto ldv_54919;
  case 2UL: 
#line 578
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 578
  goto ldv_54919;
  case 4UL: 
#line 578
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 578
  goto ldv_54919;
  case 8UL: 
#line 578
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 578
  goto ldv_54919;
  default: 
#line 578
  __bad_percpu_size();
  }
  ldv_54919: 
#line 578
  pscr_ret__ = pfo_ret__;
#line 578
  goto ldv_54925;
  case 2UL: ;
#line 578
  switch (4UL) {
  case 1UL: 
#line 578
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 578
  goto ldv_54929;
  case 2UL: 
#line 578
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 578
  goto ldv_54929;
  case 4UL: 
#line 578
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 578
  goto ldv_54929;
  case 8UL: 
#line 578
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 578
  goto ldv_54929;
  default: 
#line 578
  __bad_percpu_size();
  }
  ldv_54929: 
#line 578
  pscr_ret__ = pfo_ret_____0;
#line 578
  goto ldv_54925;
  case 4UL: ;
#line 578
  switch (4UL) {
  case 1UL: 
#line 578
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 578
  goto ldv_54938;
  case 2UL: 
#line 578
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 578
  goto ldv_54938;
  case 4UL: 
#line 578
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 578
  goto ldv_54938;
  case 8UL: 
#line 578
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 578
  goto ldv_54938;
  default: 
#line 578
  __bad_percpu_size();
  }
  ldv_54938: 
#line 578
  pscr_ret__ = pfo_ret_____1;
#line 578
  goto ldv_54925;
  case 8UL: ;
#line 578
  switch (4UL) {
  case 1UL: 
#line 578
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 578
  goto ldv_54947;
  case 2UL: 
#line 578
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 578
  goto ldv_54947;
  case 4UL: 
#line 578
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 578
  goto ldv_54947;
  case 8UL: 
#line 578
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 578
  goto ldv_54947;
  default: 
#line 578
  __bad_percpu_size();
  }
  ldv_54947: 
#line 578
  pscr_ret__ = pfo_ret_____2;
#line 578
  goto ldv_54925;
  default: 
#line 578
  __bad_size_call_parameter();
#line 578
  goto ldv_54925;
  }
  ldv_54925: 
#line 578
  stats = (struct fc_stats *)(__per_cpu_offset[pscr_ret__] + __ptr);
#line 579
  stats->RxFrames = stats->RxFrames + 1ULL;
#line 580
  stats->RxWords = stats->RxWords + (u64 )(fr_len / 4U);
#line 582
  tmp___13 = crc32_le(4294967295U, (unsigned char const   *)skb->data, (size_t )fr_len);
#line 582
  if (((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_crc != ~ tmp___13) {
#line 584
    if (stats->InvalidCRCCount <= 4ULL) {
#line 585
      printk("\fbnx2fc: dropping frame with CRC error\n");
    } else {

    }
#line 587
    stats->InvalidCRCCount = stats->InvalidCRCCount + 1ULL;
#line 588
    kfree_skb(skb);
#line 589
    return;
  } else {

  }
#line 591
  fc_exch_recv(lport, fp);
#line 592
  return;
}
}
#line 599 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
int bnx2fc_percpu_io_thread(void *arg ) 
{ 
  struct bnx2fc_percpu_s *p ;
  struct bnx2fc_work *work ;
  struct bnx2fc_work *tmp ;
  struct list_head work_list ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  long volatile   __ret ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  struct task_struct *tmp___5 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___6 ;
  struct task_struct *tmp___7 ;
  struct task_struct *tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  struct task_struct *tmp___11 ;
  struct task_struct *tmp___12 ;

  {
#line 601
  p = (struct bnx2fc_percpu_s *)arg;
#line 603
  work_list.next = & work_list;
#line 603
  work_list.prev = & work_list;
#line 605
  tmp___0 = get_current();
#line 605
  set_user_nice(tmp___0, -20L);
#line 606
  tmp___1 = get_current();
#line 606
  tmp___1->task_state_change = 0UL;
#line 606
  __ret = 1L;
#line 606
  switch (8UL) {
  case 1UL: 
#line 606
  tmp___2 = get_current();
#line 606
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
#line 606
  goto ldv_54966;
  case 2UL: 
#line 606
  tmp___3 = get_current();
#line 606
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
#line 606
  goto ldv_54966;
  case 4UL: 
#line 606
  tmp___4 = get_current();
#line 606
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                       "cc");
#line 606
  goto ldv_54966;
  case 8UL: 
#line 606
  tmp___5 = get_current();
#line 606
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___5->state): : "memory",
                       "cc");
#line 606
  goto ldv_54966;
  default: 
#line 606
  __xchg_wrong_size();
  }
  ldv_54966: ;
#line 607
  goto ldv_54985;
  ldv_54984: 
#line 608
  schedule();
#line 609
  spin_lock_bh(& p->fp_work_lock);
#line 610
  goto ldv_54982;
  ldv_54981: 
#line 611
  list_splice_init(& p->work_list, & work_list);
#line 612
  spin_unlock_bh(& p->fp_work_lock);
#line 614
  __mptr = (struct list_head  const  *)work_list.next;
#line 614
  work = (struct bnx2fc_work *)__mptr;
#line 614
  __mptr___0 = (struct list_head  const  *)work->list.next;
#line 614
  tmp = (struct bnx2fc_work *)__mptr___0;
#line 614
  goto ldv_54979;
  ldv_54978: 
#line 615
  list_del_init(& work->list);
#line 616
  bnx2fc_process_cq_compl(work->tgt, (int )work->wqe);
#line 617
  kfree((void const   *)work);
#line 614
  work = tmp;
#line 614
  __mptr___1 = (struct list_head  const  *)tmp->list.next;
#line 614
  tmp = (struct bnx2fc_work *)__mptr___1;
  ldv_54979: ;
#line 614
  if ((unsigned long )(& work->list) != (unsigned long )(& work_list)) {
#line 616
    goto ldv_54978;
  } else {

  }
#line 620
  spin_lock_bh(& p->fp_work_lock);
  ldv_54982: 
#line 610
  tmp___6 = list_empty((struct list_head  const  *)(& p->work_list));
#line 610
  if (tmp___6 == 0) {
#line 612
    goto ldv_54981;
  } else {

  }
#line 622
  tmp___7 = get_current();
#line 622
  tmp___7->task_state_change = 0UL;
#line 622
  tmp___8 = get_current();
#line 622
  tmp___8->state = 1L;
#line 623
  spin_unlock_bh(& p->fp_work_lock);
  ldv_54985: 
#line 607
  tmp___9 = kthread_should_stop();
#line 607
  if (tmp___9) {
#line 607
    tmp___10 = 0;
  } else {
#line 607
    tmp___10 = 1;
  }
#line 607
  if (tmp___10) {
#line 609
    goto ldv_54984;
  } else {

  }
#line 625
  tmp___11 = get_current();
#line 625
  tmp___11->task_state_change = 0UL;
#line 625
  tmp___12 = get_current();
#line 625
  tmp___12->state = 0L;
#line 627
  return (0);
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct fc_host_statistics *bnx2fc_get_host_stats(struct Scsi_Host *shost ) 
{ 
  struct fc_host_statistics *bnx2fc_stats ;
  struct fc_lport *lport ;
  void *tmp ;
  struct fcoe_port *port ;
  void *tmp___0 ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_hba *hba ;
  struct fcoe_statistics_params *fw_stats ;
  int rc ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  u32 val ;
  u32 val___0 ;
  u32 val___1 ;
  u32 val___2 ;
  u32 val___3 ;

  {
#line 633
  tmp = shost_priv(shost);
#line 633
  lport = (struct fc_lport *)tmp;
#line 634
  tmp___0 = lport_priv((struct fc_lport  const  *)lport);
#line 634
  port = (struct fcoe_port *)tmp___0;
#line 635
  interface = (struct bnx2fc_interface *)port->priv;
#line 636
  hba = interface->hba;
#line 638
  rc = 0;
#line 640
  fw_stats = hba->stats_buffer;
#line 641
  if ((unsigned long )fw_stats == (unsigned long )((struct fcoe_statistics_params *)0)) {
#line 642
    return ((struct fc_host_statistics *)0);
  } else {

  }
#line 644
  bnx2fc_stats = fc_get_host_stats(shost);
#line 646
  init_completion(& hba->stat_req_done);
#line 647
  tmp___1 = bnx2fc_send_stat_req(hba);
#line 647
  if (tmp___1 != 0) {
#line 648
    return (bnx2fc_stats);
  } else {

  }
#line 649
  tmp___2 = wait_for_completion_timeout(& hba->stat_req_done, 500UL);
#line 649
  rc = (int )tmp___2;
#line 650
  if (rc == 0) {
#line 651
    BNX2FC_HBA_DBG((struct fc_lport  const  *)lport, "FW stat req timed out\n");
#line 652
    return (bnx2fc_stats);
  } else {

  }
#line 654
  val = fw_stats->rx_stat2.fc_crc_cnt;
#line 654
  if (hba->prev_stats.rx_stat2.fc_crc_cnt <= val) {
#line 654
    val = val - hba->prev_stats.rx_stat2.fc_crc_cnt;
  } else {
#line 654
    val = (val - hba->prev_stats.rx_stat2.fc_crc_cnt) + 268435455U;
  }
#line 654
  hba->bfw_stats.fc_crc_cnt = hba->bfw_stats.fc_crc_cnt + (u64 )val;
#line 655
  bnx2fc_stats->invalid_crc_count = bnx2fc_stats->invalid_crc_count + hba->bfw_stats.fc_crc_cnt;
#line 656
  val___0 = fw_stats->tx_stat.fcoe_tx_pkt_cnt;
#line 656
  if (hba->prev_stats.tx_stat.fcoe_tx_pkt_cnt <= val___0) {
#line 656
    val___0 = val___0 - hba->prev_stats.tx_stat.fcoe_tx_pkt_cnt;
  } else {
#line 656
    val___0 = (val___0 - hba->prev_stats.tx_stat.fcoe_tx_pkt_cnt) + 268435455U;
  }
#line 656
  hba->bfw_stats.fcoe_tx_pkt_cnt = hba->bfw_stats.fcoe_tx_pkt_cnt + (u64 )val___0;
#line 657
  bnx2fc_stats->tx_frames = bnx2fc_stats->tx_frames + hba->bfw_stats.fcoe_tx_pkt_cnt;
#line 658
  val___1 = fw_stats->tx_stat.fcoe_tx_byte_cnt;
#line 658
  if (hba->prev_stats.tx_stat.fcoe_tx_byte_cnt <= val___1) {
#line 658
    val___1 = val___1 - hba->prev_stats.tx_stat.fcoe_tx_byte_cnt;
  } else {
#line 658
    val___1 = (val___1 - hba->prev_stats.tx_stat.fcoe_tx_byte_cnt) + 268435455U;
  }
#line 658
  hba->bfw_stats.fcoe_tx_byte_cnt = hba->bfw_stats.fcoe_tx_byte_cnt + (u64 )val___1;
#line 659
  bnx2fc_stats->tx_words = bnx2fc_stats->tx_words + hba->bfw_stats.fcoe_tx_byte_cnt / 4ULL;
#line 660
  val___2 = fw_stats->rx_stat0.fcoe_rx_pkt_cnt;
#line 660
  if (hba->prev_stats.rx_stat0.fcoe_rx_pkt_cnt <= val___2) {
#line 660
    val___2 = val___2 - hba->prev_stats.rx_stat0.fcoe_rx_pkt_cnt;
  } else {
#line 660
    val___2 = (val___2 - hba->prev_stats.rx_stat0.fcoe_rx_pkt_cnt) + 268435455U;
  }
#line 660
  hba->bfw_stats.fcoe_rx_pkt_cnt = hba->bfw_stats.fcoe_rx_pkt_cnt + (u64 )val___2;
#line 661
  bnx2fc_stats->rx_frames = bnx2fc_stats->rx_frames + hba->bfw_stats.fcoe_rx_pkt_cnt;
#line 662
  val___3 = fw_stats->rx_stat0.fcoe_rx_byte_cnt;
#line 662
  if (hba->prev_stats.rx_stat0.fcoe_rx_byte_cnt <= val___3) {
#line 662
    val___3 = val___3 - hba->prev_stats.rx_stat0.fcoe_rx_byte_cnt;
  } else {
#line 662
    val___3 = (val___3 - hba->prev_stats.rx_stat0.fcoe_rx_byte_cnt) + 268435455U;
  }
#line 662
  hba->bfw_stats.fcoe_rx_byte_cnt = hba->bfw_stats.fcoe_rx_byte_cnt + (u64 )val___3;
#line 663
  bnx2fc_stats->rx_words = bnx2fc_stats->rx_words + hba->bfw_stats.fcoe_rx_byte_cnt / 4ULL;
#line 665
  bnx2fc_stats->dumped_frames = 0ULL;
#line 666
  bnx2fc_stats->lip_count = 0ULL;
#line 667
  bnx2fc_stats->nos_count = 0ULL;
#line 668
  bnx2fc_stats->loss_of_sync_count = 0ULL;
#line 669
  bnx2fc_stats->loss_of_signal_count = 0ULL;
#line 670
  bnx2fc_stats->prim_seq_protocol_err_count = 0ULL;
#line 672
  memcpy((void *)(& hba->prev_stats), (void const   *)hba->stats_buffer, 64UL);
#line 674
  return (bnx2fc_stats);
}
}
#line 677 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_shost_config(struct fc_lport *lport , struct device *dev ) 
{ 
  struct fcoe_port *port ;
  void *tmp ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_hba *hba ;
  struct Scsi_Host *shost ;
  int rc ;

  {
#line 679
  tmp = lport_priv((struct fc_lport  const  *)lport);
#line 679
  port = (struct fcoe_port *)tmp;
#line 680
  interface = (struct bnx2fc_interface *)port->priv;
#line 681
  hba = interface->hba;
#line 682
  shost = lport->host;
#line 683
  rc = 0;
#line 685
  shost->max_cmd_len = 16U;
#line 686
  shost->max_lun = 65535ULL;
#line 687
  shost->max_id = 256U;
#line 688
  shost->max_channel = 0U;
#line 689
  if ((unsigned long )lport->vport != (unsigned long )((struct fc_vport *)0)) {
#line 690
    shost->transportt = bnx2fc_vport_xport_template;
  } else {
#line 692
    shost->transportt = bnx2fc_transport_template;
  }
#line 695
  rc = scsi_add_host(lport->host, dev);
#line 696
  if (rc != 0) {
#line 697
    printk("\vbnx2fc: Error on scsi_add_host\n");
#line 698
    return (rc);
  } else {

  }
#line 700
  if ((unsigned long )lport->vport == (unsigned long )((struct fc_vport *)0)) {
#line 701
    ((struct fc_host_attrs *)(lport->host)->shost_data)->max_npiv_vports = 65535U;
  } else {

  }
#line 702
  snprintf((char *)(& ((struct fc_host_attrs *)(lport->host)->shost_data)->symbolic_name),
           256UL, "%s (QLogic %s) v%s over %s", (char *)"bnx2fc", (char *)(& hba->chip_num),
           (char *)"2.4.2", (char *)(& (interface->netdev)->name));
#line 707
  return (0);
}
}
#line 710 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_link_ok(struct fc_lport *lport ) 
{ 
  struct fcoe_port *port ;
  void *tmp ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_hba *hba ;
  struct net_device *dev ;
  int rc ;
  bool tmp___0 ;

  {
#line 712
  tmp = lport_priv((struct fc_lport  const  *)lport);
#line 712
  port = (struct fcoe_port *)tmp;
#line 713
  interface = (struct bnx2fc_interface *)port->priv;
#line 714
  hba = interface->hba;
#line 715
  dev = hba->phys_dev;
#line 716
  rc = 0;
#line 718
  if ((int )dev->flags & 1) {
#line 718
    tmp___0 = netif_carrier_ok((struct net_device  const  *)dev);
#line 718
    if ((int )tmp___0) {
#line 719
      clear_bit(2L, (unsigned long volatile   *)(& hba->adapter_state));
    } else {
#line 721
      set_bit(2L, (unsigned long volatile   *)(& hba->adapter_state));
#line 722
      rc = -1;
    }
  } else {
#line 721
    set_bit(2L, (unsigned long volatile   *)(& hba->adapter_state));
#line 722
    rc = -1;
  }
#line 724
  return (rc);
}
}
#line 734 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
void bnx2fc_get_link_state(struct bnx2fc_hba *hba ) 
{ 
  int tmp ;

  {
#line 736
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& (hba->phys_dev)->state));
#line 736
  if (tmp != 0) {
#line 737
    set_bit(2L, (unsigned long volatile   *)(& hba->adapter_state));
  } else {
#line 739
    clear_bit(2L, (unsigned long volatile   *)(& hba->adapter_state));
  }
#line 740
  return;
}
}
#line 742 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_net_config(struct fc_lport *lport , struct net_device *netdev ) 
{ 
  struct bnx2fc_hba *hba ;
  struct bnx2fc_interface *interface ;
  struct fcoe_ctlr *ctlr ;
  struct fcoe_port *port ;
  u64 wwnn ;
  u64 wwpn ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 750
  tmp = lport_priv((struct fc_lport  const  *)lport);
#line 750
  port = (struct fcoe_port *)tmp;
#line 751
  interface = (struct bnx2fc_interface *)port->priv;
#line 752
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 753
  hba = interface->hba;
#line 756
  if ((unsigned long )(hba->phys_dev)->ethtool_ops == (unsigned long )((struct ethtool_ops  const  *)0) || (unsigned long )((hba->phys_dev)->ethtool_ops)->get_pauseparam == (unsigned long )((void (*/* const  */)(struct net_device * ,
                                                                                                                                                                                                                    struct ethtool_pauseparam * ))0)) {
#line 758
    return (-95);
  } else {

  }
#line 760
  tmp___0 = fc_set_mfs(lport, 2072U);
#line 760
  if (tmp___0 != 0) {
#line 761
    return (-22);
  } else {

  }
#line 763
  skb_queue_head_init(& port->fcoe_pending_queue);
#line 764
  port->fcoe_pending_queue_active = 0U;
#line 765
  reg_timer_6(& port->timer, & fcoe_queue_timer, (unsigned long )lport);
#line 767
  fcoe_link_speed_update(lport);
#line 769
  if ((unsigned long )lport->vport == (unsigned long )((struct fc_vport *)0)) {
#line 770
    tmp___1 = fcoe_get_wwn(netdev, & wwnn, 0);
#line 770
    if (tmp___1 != 0) {
#line 771
      wwnn = fcoe_wwn_from_mac((unsigned char *)(& ctlr->ctl_src_addr), 1U, 0U);
    } else {

    }
#line 773
    BNX2FC_HBA_DBG((struct fc_lport  const  *)lport, "WWNN = 0x%llx\n", wwnn);
#line 774
    fc_set_wwnn(lport, wwnn);
#line 776
    tmp___2 = fcoe_get_wwn(netdev, & wwpn, 1);
#line 776
    if (tmp___2 != 0) {
#line 777
      wwpn = fcoe_wwn_from_mac((unsigned char *)(& ctlr->ctl_src_addr), 2U, 0U);
    } else {

    }
#line 780
    BNX2FC_HBA_DBG((struct fc_lport  const  *)lport, "WWPN = 0x%llx\n", wwpn);
#line 781
    fc_set_wwpn(lport, wwpn);
  } else {

  }
#line 784
  return (0);
}
}
#line 787 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_destroy_timer(unsigned long data ) 
{ 
  struct bnx2fc_hba *hba ;

  {
#line 789
  hba = (struct bnx2fc_hba *)data;
#line 791
  printk("\vbnx2fc: OLD_ERROR:bnx2fc_destroy_timer - Destroy compl not received!!\n");
#line 793
  set_bit(1L, (unsigned long volatile   *)(& hba->flags));
#line 794
  __wake_up(& hba->destroy_wait, 1U, 1, (void *)0);
#line 795
  return;
}
}
#line 807 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_indicate_netevent(void *context , unsigned long event , u16 vlan_id ) 
{ 
  struct bnx2fc_hba *hba ;
  struct fcoe_ctlr_device *cdev ;
  struct fc_lport *lport ;
  struct fc_lport *vport ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_interface *tmp ;
  struct fcoe_ctlr *ctlr ;
  int wait_for_upload ;
  u32 link_possible ;
  int tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  int pscr_ret__ ;
  void const   *__vpp_verify___0 ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___1 ;
  int tmp___2 ;
  struct list_head  const  *__mptr___5 ;
  struct lock_class_key __key ;
  long tmp___3 ;
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp___4 ;
  long tmp___5 ;
  struct task_struct *tmp___6 ;
  struct task_struct *tmp___7 ;
  int tmp___8 ;

  {
#line 810
  hba = (struct bnx2fc_hba *)context;
#line 816
  wait_for_upload = 0;
#line 817
  link_possible = 1U;
#line 819
  if ((unsigned int )vlan_id != 0U && event != 6UL) {
#line 820
    return;
  } else {

  }
#line 822
  switch (event) {
  case 1UL: 
#line 824
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile   *)(& hba->adapter_state));
#line 824
  if (tmp___0 == 0) {
#line 825
    printk("\vindicate_netevent: hba is not UP!!\n");
  } else {

  }
#line 827
  goto ldv_55051;
  case 2UL: 
#line 830
  clear_bit(1L, (unsigned long volatile   *)(& hba->adapter_state));
#line 831
  clear_bit(0L, (unsigned long volatile   *)(& hba->adapter_state));
#line 832
  link_possible = 0U;
#line 833
  goto ldv_55051;
  case 9UL: 
#line 836
  set_bit(1L, (unsigned long volatile   *)(& hba->adapter_state));
#line 837
  link_possible = 0U;
#line 838
  goto ldv_55051;
  case 4UL: ;
#line 841
  goto ldv_55051;
  case 6UL: ;
#line 844
  if ((unsigned int )vlan_id == 0U) {
#line 845
    return;
  } else {

  }
#line 846
  mutex_lock_nested(& bnx2fc_dev_lock, 0U);
#line 847
  __mptr = (struct list_head  const  *)if_list.next;
#line 847
  interface = (struct bnx2fc_interface *)__mptr;
#line 847
  __mptr___0 = (struct list_head  const  *)interface->list.next;
#line 847
  tmp = (struct bnx2fc_interface *)__mptr___0;
#line 847
  goto ldv_55063;
  ldv_55062: ;
#line 848
  if ((unsigned long )interface->hba == (unsigned long )hba && interface->vlan_id == ((int )vlan_id & 4095)) {
#line 850
    __bnx2fc_destroy(interface);
  } else {

  }
#line 847
  interface = tmp;
#line 847
  __mptr___1 = (struct list_head  const  *)tmp->list.next;
#line 847
  tmp = (struct bnx2fc_interface *)__mptr___1;
  ldv_55063: ;
#line 847
  if ((unsigned long )(& interface->list) != (unsigned long )(& if_list)) {
#line 849
    goto ldv_55062;
  } else {

  }
#line 852
  mutex_unlock(& bnx2fc_dev_lock);
#line 855
  ldv_flush_workqueue_32(bnx2fc_wq);
#line 856
  return;
  default: 
#line 859
  printk("\vbnx2fc: Unknown netevent %ld", event);
#line 860
  return;
  }
  ldv_55051: 
#line 863
  mutex_lock_nested(& bnx2fc_dev_lock, 0U);
#line 864
  __mptr___2 = (struct list_head  const  *)if_list.next;
#line 864
  interface = (struct bnx2fc_interface *)__mptr___2;
#line 864
  goto ldv_55133;
  ldv_55132: ;
#line 866
  if ((unsigned long )interface->hba != (unsigned long )hba) {
#line 867
    goto ldv_55070;
  } else {

  }
#line 869
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 870
  lport = ctlr->lp;
#line 871
  BNX2FC_HBA_DBG((struct fc_lport  const  *)lport, "netevent handler - event=%s %ld\n",
                 (char *)(& (interface->netdev)->name), event);
#line 874
  fcoe_link_speed_update(lport);
#line 876
  cdev = ctlr->cdev;
#line 878
  if (link_possible != 0U) {
#line 878
    tmp___2 = bnx2fc_link_ok(lport);
#line 878
    if (tmp___2 == 0) {
#line 879
      switch ((unsigned int )cdev->enabled) {
      case 1U: 
#line 881
      printk("\016bnx2fc: Link up while interface is disabled.\n");
#line 882
      goto ldv_55072;
      case 0U: ;
      case 2U: 
#line 886
      fc_set_mfs(lport, 2072U);
#line 892
      if ((int )interface->enabled) {
#line 893
        fcoe_ctlr_link_up(ctlr);
      } else {

      }
      }
      ldv_55072: ;
    } else {
#line 878
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 895
    tmp___1 = fcoe_ctlr_link_down(ctlr);
#line 895
    if (tmp___1 != 0) {
#line 896
      switch ((unsigned int )cdev->enabled) {
      case 1U: 
#line 898
      printk("\016bnx2fc: Link down while interface is disabled.\n");
#line 899
      goto ldv_55076;
      case 0U: ;
      case 2U: 
#line 902
      mutex_lock_nested(& lport->lp_mutex, 0U);
#line 903
      __mptr___3 = (struct list_head  const  *)lport->vports.next;
#line 903
      vport = (struct fc_lport *)__mptr___3 + 0xfffffffffffffab0UL;
#line 903
      goto ldv_55084;
      ldv_55083: 
#line 904
      ((struct fc_host_attrs *)(vport->host)->shost_data)->port_type = 0;
#line 903
      __mptr___4 = (struct list_head  const  *)vport->list.next;
#line 903
      vport = (struct fc_lport *)__mptr___4 + 0xfffffffffffffab0UL;
      ldv_55084: ;
#line 903
      if ((unsigned long )(& vport->list) != (unsigned long )(& lport->vports)) {
#line 905
        goto ldv_55083;
      } else {

      }
#line 906
      mutex_unlock(& lport->lp_mutex);
#line 907
      ((struct fc_host_attrs *)(lport->host)->shost_data)->port_type = 0;
#line 909
      __vpp_verify = (void const   *)0;
#line 909
      __asm__  ("": "=r" (__ptr): "0" (lport->stats));
#line 909
      __preempt_count_add(1);
#line 909
      __asm__  volatile   ("": : : "memory");
#line 909
      __vpp_verify___0 = (void const   *)0;
#line 909
      switch (4UL) {
      case 1UL: ;
#line 909
      switch (4UL) {
      case 1UL: 
#line 909
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 909
      goto ldv_55093;
      case 2UL: 
#line 909
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 909
      goto ldv_55093;
      case 4UL: 
#line 909
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 909
      goto ldv_55093;
      case 8UL: 
#line 909
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 909
      goto ldv_55093;
      default: 
#line 909
      __bad_percpu_size();
      }
      ldv_55093: 
#line 909
      pscr_ret__ = pfo_ret__;
#line 909
      goto ldv_55099;
      case 2UL: ;
#line 909
      switch (4UL) {
      case 1UL: 
#line 909
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 909
      goto ldv_55103;
      case 2UL: 
#line 909
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 909
      goto ldv_55103;
      case 4UL: 
#line 909
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 909
      goto ldv_55103;
      case 8UL: 
#line 909
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 909
      goto ldv_55103;
      default: 
#line 909
      __bad_percpu_size();
      }
      ldv_55103: 
#line 909
      pscr_ret__ = pfo_ret_____0;
#line 909
      goto ldv_55099;
      case 4UL: ;
#line 909
      switch (4UL) {
      case 1UL: 
#line 909
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 909
      goto ldv_55112;
      case 2UL: 
#line 909
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 909
      goto ldv_55112;
      case 4UL: 
#line 909
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 909
      goto ldv_55112;
      case 8UL: 
#line 909
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 909
      goto ldv_55112;
      default: 
#line 909
      __bad_percpu_size();
      }
      ldv_55112: 
#line 909
      pscr_ret__ = pfo_ret_____1;
#line 909
      goto ldv_55099;
      case 8UL: ;
#line 909
      switch (4UL) {
      case 1UL: 
#line 909
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 909
      goto ldv_55121;
      case 2UL: 
#line 909
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 909
      goto ldv_55121;
      case 4UL: 
#line 909
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 909
      goto ldv_55121;
      case 8UL: 
#line 909
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 909
      goto ldv_55121;
      default: 
#line 909
      __bad_percpu_size();
      }
      ldv_55121: 
#line 909
      pscr_ret__ = pfo_ret_____2;
#line 909
      goto ldv_55099;
      default: 
#line 909
      __bad_size_call_parameter();
#line 909
      goto ldv_55099;
      }
      ldv_55099: 
#line 909
      ((struct fc_stats *)(__per_cpu_offset[pscr_ret__] + __ptr))->LinkFailureCount = ((struct fc_stats *)(__per_cpu_offset[pscr_ret__] + __ptr))->LinkFailureCount + 1ULL;
#line 911
      __asm__  volatile   ("": : : "memory");
#line 911
      __preempt_count_sub(1);
#line 912
      fcoe_clean_pending_queue(lport);
#line 913
      wait_for_upload = 1;
      }
      ldv_55076: ;
    } else {

    }
  }
  ldv_55070: 
#line 864
  __mptr___5 = (struct list_head  const  *)interface->list.next;
#line 864
  interface = (struct bnx2fc_interface *)__mptr___5;
  ldv_55133: ;
#line 864
  if ((unsigned long )(& interface->list) != (unsigned long )(& if_list)) {
#line 866
    goto ldv_55132;
  } else {

  }
#line 917
  mutex_unlock(& bnx2fc_dev_lock);
#line 919
  if (wait_for_upload != 0) {
#line 920
    clear_bit(3L, (unsigned long volatile   *)(& hba->adapter_state));
#line 921
    __init_waitqueue_head(& hba->shutdown_wait, "&hba->shutdown_wait", & __key);
#line 922
    tmp___3 = ldv__builtin_expect((bnx2fc_debug_level & 16U) != 0U, 0L);
#line 922
    if (tmp___3 != 0L) {
#line 922
      printk("\016bnx2fc: indicate_netevent num_ofld_sess = %d\n", hba->num_ofld_sess);
    } else {

    }
#line 925
    hba->wait_for_link_down = 1;
#line 926
    __ret = 0;
#line 926
    __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c",
                  927, 0);
#line 926
    if (hba->num_ofld_sess != 0) {
#line 926
      __ret___0 = 0L;
#line 926
      INIT_LIST_HEAD(& __wait.task_list);
#line 926
      __wait.flags = 0U;
      ldv_55142: 
#line 926
      tmp___4 = prepare_to_wait_event(& hba->shutdown_wait, & __wait, 1);
#line 926
      __int = tmp___4;
#line 926
      if (hba->num_ofld_sess == 0) {
#line 926
        goto ldv_55141;
      } else {

      }
#line 926
      if (__int != 0L) {
#line 926
        __ret___0 = __int;
#line 926
        goto ldv_55141;
      } else {

      }
#line 926
      schedule();
#line 926
      goto ldv_55142;
      ldv_55141: 
#line 926
      finish_wait(& hba->shutdown_wait, & __wait);
#line 926
      __ret = (int )__ret___0;
    } else {

    }
#line 928
    tmp___5 = ldv__builtin_expect((bnx2fc_debug_level & 16U) != 0U, 0L);
#line 928
    if (tmp___5 != 0L) {
#line 928
      printk("\016bnx2fc: wakeup - num_ofld_sess = %d\n", hba->num_ofld_sess);
    } else {

    }
#line 930
    hba->wait_for_link_down = 0;
#line 932
    tmp___7 = get_current();
#line 932
    tmp___8 = signal_pending(tmp___7);
#line 932
    if (tmp___8 != 0) {
#line 933
      tmp___6 = get_current();
#line 933
      flush_signals(tmp___6);
    } else {

    }
  } else {

  }
#line 935
  return;
}
}
#line 937 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_libfc_config(struct fc_lport *lport ) 
{ 


  {
#line 941
  memcpy((void *)(& lport->tt), (void const   *)(& bnx2fc_libfc_fcn_templ), 272UL);
#line 943
  fc_elsct_init(lport);
#line 944
  fc_exch_init(lport);
#line 945
  fc_rport_init(lport);
#line 946
  fc_disc_init(lport);
#line 947
  fc_disc_config(lport, (void *)lport);
#line 948
  return (0);
}
}
#line 951 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_em_config(struct fc_lport *lport , struct bnx2fc_hba *hba ) 
{ 
  int fcoe_min_xid ;
  int fcoe_max_xid ;
  struct fc_exch_mgr *tmp ;

  {
#line 955
  fcoe_min_xid = (int )hba->max_xid + 1;
#line 956
  if (nr_cpu_ids <= 2) {
#line 957
    fcoe_max_xid = (int )hba->max_xid + (nr_cpu_ids * 512 + -1);
  } else {
#line 959
    fcoe_max_xid = (int )hba->max_xid + 8191;
  }
#line 960
  tmp = fc_exch_mgr_alloc(lport, 46, (int )((u16 )fcoe_min_xid), (int )((u16 )fcoe_max_xid),
                          (bool (*)(struct fc_frame * ))0);
#line 960
  if ((unsigned long )tmp == (unsigned long )((struct fc_exch_mgr *)0)) {
#line 962
    printk("\vbnx2fc: em_config:fc_exch_mgr_alloc failed\n");
#line 963
    return (-12);
  } else {

  }
#line 966
  return (0);
}
}
#line 969 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_lport_config(struct fc_lport *lport ) 
{ 
  int tmp ;

  {
#line 971
  lport->link_up = 0U;
#line 972
  lport->qfull = 0U;
#line 973
  lport->max_retry_count = 3U;
#line 974
  lport->max_rport_retry_count = 255U;
#line 975
  lport->e_d_tov = 2000U;
#line 976
  lport->r_a_tov = 10000U;
#line 978
  lport->service_params = 418U;
#line 980
  lport->does_npiv = 1U;
#line 982
  memset((void *)(& lport->rnid_gen), 0, 52UL);
#line 983
  lport->rnid_gen.rnid_atype = 7U;
#line 986
  tmp = fc_lport_init_stats(lport);
#line 986
  if (tmp != 0) {
#line 987
    return (-12);
  } else {

  }
#line 990
  fc_lport_config(lport);
#line 992
  return (0);
}
}
#line 1005 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_fip_recv(struct sk_buff *skb , struct net_device *dev , struct packet_type *ptype ,
                           struct net_device *orig_dev ) 
{ 
  struct bnx2fc_interface *interface ;
  struct fcoe_ctlr *ctlr ;
  struct packet_type  const  *__mptr ;

  {
#line 1011
  __mptr = (struct packet_type  const  *)ptype;
#line 1011
  interface = (struct bnx2fc_interface *)__mptr + 0xffffffffffffffa0UL;
#line 1013
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 1014
  fcoe_ctlr_recv(ctlr, skb);
#line 1015
  return (0);
}
}
#line 1028 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_update_src_mac(struct fc_lport *lport , u8 *addr ) 
{ 
  struct fcoe_port *port ;
  void *tmp ;

  {
#line 1030
  tmp = lport_priv((struct fc_lport  const  *)lport);
#line 1030
  port = (struct fcoe_port *)tmp;
#line 1032
  memcpy((void *)(& port->data_src_addr), (void const   *)addr, 6UL);
#line 1033
  return;
}
}
#line 1040 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static u8 *bnx2fc_get_src_mac(struct fc_lport *lport ) 
{ 
  struct fcoe_port *port ;
  void *tmp ;

  {
#line 1044
  tmp = lport_priv((struct fc_lport  const  *)lport);
#line 1044
  port = (struct fcoe_port *)tmp;
#line 1045
  return ((u8 *)(& port->data_src_addr));
}
}
#line 1054 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_fip_send(struct fcoe_ctlr *fip , struct sk_buff *skb ) 
{ 


  {
#line 1056
  skb->dev = ((struct bnx2fc_interface *)fip + 1U)->netdev;
#line 1057
  dev_queue_xmit(skb);
#line 1058
  return;
}
}
#line 1060 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_vport_create(struct fc_vport *vport , bool disabled ) 
{ 
  struct Scsi_Host *shost ;
  struct fc_lport *n_port ;
  void *tmp ;
  struct fcoe_port *port ;
  void *tmp___0 ;
  struct bnx2fc_interface *interface ;
  struct net_device *netdev ;
  struct fc_lport *vn_port ;
  int rc ;
  char buf[32U] ;
  int tmp___1 ;

  {
#line 1062
  shost = vport->shost;
#line 1063
  tmp = shost_priv(shost);
#line 1063
  n_port = (struct fc_lport *)tmp;
#line 1064
  tmp___0 = lport_priv((struct fc_lport  const  *)n_port);
#line 1064
  port = (struct fcoe_port *)tmp___0;
#line 1065
  interface = (struct bnx2fc_interface *)port->priv;
#line 1066
  netdev = interface->netdev;
#line 1071
  rc = fcoe_validate_vport_create(vport);
#line 1072
  if (rc != 0) {
#line 1073
    fcoe_wwn_to_str(vport->port_name, (char *)(& buf), 32);
#line 1074
    printk("\vbnx2fc: Failed to create vport, WWPN (0x%s) already exists\n", (char *)(& buf));
#line 1077
    return (rc);
  } else {

  }
#line 1080
  tmp___1 = constant_test_bit(0L, (unsigned long const volatile   *)(& (interface->hba)->flags));
#line 1080
  if (tmp___1 == 0) {
#line 1081
    printk("\vbnx2fc: vn ports cannot be created onthis interface\n");
#line 1083
    return (-5);
  } else {

  }
#line 1085
  rtnl_lock();
#line 1086
  mutex_lock_nested(& bnx2fc_dev_lock, 0U);
#line 1087
  vn_port = bnx2fc_if_create(interface, & vport->dev, 1);
#line 1088
  mutex_unlock(& bnx2fc_dev_lock);
#line 1089
  rtnl_unlock();
#line 1091
  if ((unsigned long )vn_port == (unsigned long )((struct fc_lport *)0)) {
#line 1092
    printk("\vbnx2fc: bnx2fc_vport_create (%s) failed\n", (char *)(& netdev->name));
#line 1094
    return (-5);
  } else {

  }
#line 1097
  if ((int )disabled) {
#line 1098
    fc_vport_set_state(vport, 2);
  } else {
#line 1100
    vn_port->boot_time = jiffies;
#line 1101
    fc_lport_init(vn_port);
#line 1102
    fc_fabric_login(vn_port);
#line 1103
    fc_vport_setlink(vn_port);
  }
#line 1105
  return (0);
}
}
#line 1108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_free_vport(struct bnx2fc_hba *hba , struct fc_lport *lport ) 
{ 
  struct bnx2fc_lport *blport ;
  struct bnx2fc_lport *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 1112
  spin_lock_bh(& hba->hba_lock);
#line 1113
  __mptr = (struct list_head  const  *)hba->vports.next;
#line 1113
  blport = (struct bnx2fc_lport *)__mptr;
#line 1113
  __mptr___0 = (struct list_head  const  *)blport->list.next;
#line 1113
  tmp = (struct bnx2fc_lport *)__mptr___0;
#line 1113
  goto ldv_55205;
  ldv_55204: ;
#line 1114
  if ((unsigned long )blport->lport == (unsigned long )lport) {
#line 1115
    list_del(& blport->list);
#line 1116
    kfree((void const   *)blport);
  } else {

  }
#line 1113
  blport = tmp;
#line 1113
  __mptr___1 = (struct list_head  const  *)tmp->list.next;
#line 1113
  tmp = (struct bnx2fc_lport *)__mptr___1;
  ldv_55205: ;
#line 1113
  if ((unsigned long )(& blport->list) != (unsigned long )(& hba->vports)) {
#line 1115
    goto ldv_55204;
  } else {

  }
#line 1119
  spin_unlock_bh(& hba->hba_lock);
#line 1120
  return;
}
}
#line 1122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_vport_destroy(struct fc_vport *vport ) 
{ 
  struct Scsi_Host *shost ;
  struct fc_lport *n_port ;
  void *tmp ;
  struct fc_lport *vn_port ;
  struct fcoe_port *port ;
  void *tmp___0 ;
  struct bnx2fc_interface *interface ;
  struct fc_lport *v_port ;
  bool found ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1124
  shost = vport->shost;
#line 1125
  tmp = shost_priv(shost);
#line 1125
  n_port = (struct fc_lport *)tmp;
#line 1126
  vn_port = (struct fc_lport *)vport->dd_data;
#line 1127
  tmp___0 = lport_priv((struct fc_lport  const  *)vn_port);
#line 1127
  port = (struct fcoe_port *)tmp___0;
#line 1128
  interface = (struct bnx2fc_interface *)port->priv;
#line 1130
  found = 0;
#line 1132
  mutex_lock_nested(& n_port->lp_mutex, 0U);
#line 1133
  __mptr = (struct list_head  const  *)n_port->vports.next;
#line 1133
  v_port = (struct fc_lport *)__mptr + 0xfffffffffffffab0UL;
#line 1133
  goto ldv_55223;
  ldv_55222: ;
#line 1134
  if ((unsigned long )v_port->vport == (unsigned long )vport) {
#line 1135
    found = 1;
#line 1136
    goto ldv_55221;
  } else {

  }
#line 1133
  __mptr___0 = (struct list_head  const  *)v_port->list.next;
#line 1133
  v_port = (struct fc_lport *)__mptr___0 + 0xfffffffffffffab0UL;
  ldv_55223: ;
#line 1133
  if ((unsigned long )(& v_port->list) != (unsigned long )(& n_port->vports)) {
#line 1135
    goto ldv_55222;
  } else {

  }
  ldv_55221: ;
#line 1139
  if (! found) {
#line 1140
    mutex_unlock(& n_port->lp_mutex);
#line 1141
    return (-2);
  } else {

  }
#line 1143
  list_del(& vn_port->list);
#line 1144
  mutex_unlock(& n_port->lp_mutex);
#line 1145
  bnx2fc_free_vport(interface->hba, port->lport);
#line 1146
  bnx2fc_port_shutdown(port->lport);
#line 1147
  bnx2fc_interface_put(interface);
#line 1148
  queue_work(bnx2fc_wq, & port->destroy_work);
#line 1149
  return (0);
}
}
#line 1152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_vport_disable(struct fc_vport *vport , bool disable ) 
{ 
  struct fc_lport *lport ;

  {
#line 1154
  lport = (struct fc_lport *)vport->dd_data;
#line 1156
  if ((int )disable) {
#line 1157
    fc_vport_set_state(vport, 2);
#line 1158
    fc_fabric_logoff(lport);
  } else {
#line 1160
    lport->boot_time = jiffies;
#line 1161
    fc_fabric_login(lport);
#line 1162
    fc_vport_setlink(lport);
  }
#line 1164
  return (0);
}
}
#line 1168 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_interface_setup(struct bnx2fc_interface *interface ) 
{ 
  struct net_device *netdev ;
  struct net_device *physdev ;
  struct fcoe_ctlr *ctlr ;
  struct netdev_hw_addr *ha ;
  int sel_san_mac ;
  struct list_head *__ptr ;
  struct list_head  const  *__mptr ;
  struct list_head *________p1 ;
  struct list_head *_________p1 ;
  union __anonunion___u_361 __u ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  struct list_head *__ptr___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head *________p1___0 ;
  struct list_head *_________p1___0 ;
  union __anonunion___u_363 __u___0 ;
  int tmp___3 ;

  {
#line 1170
  netdev = interface->netdev;
#line 1171
  physdev = (interface->hba)->phys_dev;
#line 1172
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 1174
  sel_san_mac = 0;
#line 1177
  rcu_read_lock();
#line 1178
  __ptr = physdev->dev_addrs.list.next;
#line 1178
  __read_once_size((void const volatile   *)(& __ptr), (void *)(& __u.__c), 8);
#line 1178
  _________p1 = __u.__val;
#line 1178
  ________p1 = _________p1;
#line 1178
  tmp = debug_lockdep_rcu_enabled();
#line 1178
  __mptr = (struct list_head  const  *)________p1;
#line 1178
  ha = (struct netdev_hw_addr *)__mptr;
#line 1178
  goto ldv_55266;
  ldv_55265: 
#line 1179
  tmp___0 = ldv__builtin_expect((bnx2fc_debug_level & 16U) != 0U, 0L);
#line 1179
  if (tmp___0 != 0L) {
#line 1179
    printk("\016bnx2fc: net_config: ha->type = %d, fip_mac = ", (int )ha->type);
  } else {

  }
#line 1181
  printk("\016%2x:%2x:%2x:%2x:%2x:%2x\n", (int )ha->addr[0], (int )ha->addr[1], (int )ha->addr[2],
         (int )ha->addr[3], (int )ha->addr[4], (int )ha->addr[5]);
#line 1185
  if ((unsigned int )ha->type == 2U) {
#line 1185
    tmp___2 = is_valid_ether_addr((u8 const   *)(& ha->addr));
#line 1185
    if ((int )tmp___2) {
#line 1187
      memcpy((void *)(& ctlr->ctl_src_addr), (void const   *)(& ha->addr), 6UL);
#line 1189
      sel_san_mac = 1;
#line 1190
      tmp___1 = ldv__builtin_expect((bnx2fc_debug_level & 16U) != 0U, 0L);
#line 1190
      if (tmp___1 != 0L) {
#line 1190
        printk("\016bnx2fc: Found SAN MAC\n");
      } else {

      }
    } else {

    }
  } else {

  }
#line 1178
  __ptr___0 = ha->list.next;
#line 1178
  __read_once_size((void const volatile   *)(& __ptr___0), (void *)(& __u___0.__c),
                   8);
#line 1178
  _________p1___0 = __u___0.__val;
#line 1178
  ________p1___0 = _________p1___0;
#line 1178
  tmp___3 = debug_lockdep_rcu_enabled();
#line 1178
  __mptr___0 = (struct list_head  const  *)________p1___0;
#line 1178
  ha = (struct netdev_hw_addr *)__mptr___0;
  ldv_55266: ;
#line 1178
  if ((unsigned long )(& ha->list) != (unsigned long )(& physdev->dev_addrs.list)) {
#line 1180
    goto ldv_55265;
  } else {

  }
#line 1193
  rcu_read_unlock();
#line 1195
  if (sel_san_mac == 0) {
#line 1196
    return (-19);
  } else {

  }
#line 1198
  interface->fip_packet_type.func = & bnx2fc_fip_recv;
#line 1199
  interface->fip_packet_type.type = 5257U;
#line 1200
  interface->fip_packet_type.dev = netdev;
#line 1201
  dev_add_pack(& interface->fip_packet_type);
#line 1203
  interface->fcoe_packet_type.func = & bnx2fc_rcv;
#line 1204
  interface->fcoe_packet_type.type = 1673U;
#line 1205
  interface->fcoe_packet_type.dev = netdev;
#line 1206
  dev_add_pack(& interface->fcoe_packet_type);
#line 1208
  return (0);
}
}
#line 1211 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_attach_transport(void) 
{ 


  {
#line 1213
  bnx2fc_transport_template = fc_attach_transport(& bnx2fc_transport_function);
#line 1216
  if ((unsigned long )bnx2fc_transport_template == (unsigned long )((struct scsi_transport_template *)0)) {
#line 1217
    printk("\vbnx2fc: Failed to attach FC transport\n");
#line 1218
    return (-19);
  } else {

  }
#line 1221
  bnx2fc_vport_xport_template = fc_attach_transport(& bnx2fc_vport_xport_function);
#line 1223
  if ((unsigned long )bnx2fc_vport_xport_template == (unsigned long )((struct scsi_transport_template *)0)) {
#line 1224
    printk("\vbnx2fc: Failed to attach FC transport for vport\n");
#line 1226
    fc_release_transport(bnx2fc_transport_template);
#line 1227
    bnx2fc_transport_template = (struct scsi_transport_template *)0;
#line 1228
    return (-19);
  } else {

  }
#line 1230
  return (0);
}
}
#line 1232 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_release_transport(void) 
{ 


  {
#line 1234
  fc_release_transport(bnx2fc_transport_template);
#line 1235
  fc_release_transport(bnx2fc_vport_xport_template);
#line 1236
  bnx2fc_transport_template = (struct scsi_transport_template *)0;
#line 1237
  bnx2fc_vport_xport_template = (struct scsi_transport_template *)0;
#line 1238
  return;
}
}
#line 1240 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_interface_release(struct kref *kref ) 
{ 
  struct fcoe_ctlr_device *ctlr_dev ;
  struct bnx2fc_interface *interface ;
  struct fcoe_ctlr *ctlr ;
  struct net_device *netdev ;
  struct kref  const  *__mptr ;
  long tmp ;
  int tmp___0 ;

  {
#line 1247
  __mptr = (struct kref  const  *)kref;
#line 1247
  interface = (struct bnx2fc_interface *)__mptr + 0xffffffffffffff60UL;
#line 1248
  tmp = ldv__builtin_expect((bnx2fc_debug_level & 16U) != 0U, 0L);
#line 1248
  if (tmp != 0L) {
#line 1248
    printk("\016bnx2fc: Interface is being released\n");
  } else {

  }
#line 1250
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 1251
  ctlr_dev = ctlr->cdev;
#line 1252
  netdev = interface->netdev;
#line 1255
  tmp___0 = test_and_clear_bit(0L, (unsigned long volatile   *)(& interface->if_flags));
#line 1255
  if (tmp___0 != 0) {
#line 1256
    fcoe_ctlr_destroy(ctlr);
  } else {

  }
#line 1258
  fcoe_ctlr_device_delete(ctlr_dev);
#line 1260
  dev_put(netdev);
#line 1261
  ldv_module_put_33(& __this_module);
#line 1262
  return;
}
}
#line 1264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
__inline static void bnx2fc_interface_get(struct bnx2fc_interface *interface ) 
{ 


  {
#line 1266
  kref_get___0(& interface->kref);
#line 1267
  return;
}
}
#line 1269 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
__inline static void bnx2fc_interface_put(struct bnx2fc_interface *interface ) 
{ 


  {
#line 1271
  kref_put___0(& interface->kref, & bnx2fc_interface_release);
#line 1272
  return;
}
}
#line 1273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_hba_destroy(struct bnx2fc_hba *hba ) 
{ 


  {
#line 1276
  if ((unsigned long )hba->cmd_mgr != (unsigned long )((struct bnx2fc_cmd_mgr *)0)) {
#line 1277
    bnx2fc_cmd_mgr_free(hba->cmd_mgr);
#line 1278
    hba->cmd_mgr = (struct bnx2fc_cmd_mgr *)0;
  } else {

  }
#line 1280
  kfree((void const   *)hba->tgt_ofld_list);
#line 1281
  bnx2fc_unbind_pcidev(hba);
#line 1282
  kfree((void const   *)hba);
#line 1283
  return;
}
}
#line 1293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct bnx2fc_hba *bnx2fc_hba_create(struct cnic_dev *cnic ) 
{ 
  struct bnx2fc_hba *hba ;
  struct fcoe_capabilities *fcoe_cap ;
  int rc ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  void *tmp___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;

  {
#line 1299
  tmp = kzalloc(1024UL, 208U);
#line 1299
  hba = (struct bnx2fc_hba *)tmp;
#line 1300
  if ((unsigned long )hba == (unsigned long )((struct bnx2fc_hba *)0)) {
#line 1301
    printk("\vbnx2fc: Unable to allocate hba structure\n");
#line 1302
    return ((struct bnx2fc_hba *)0);
  } else {

  }
#line 1304
  spinlock_check(& hba->hba_lock);
#line 1304
  __raw_spin_lock_init(& hba->hba_lock.__annonCompField18.rlock, "&(&hba->hba_lock)->rlock",
                       & __key);
#line 1305
  __mutex_init(& hba->hba_mutex, "&hba->hba_mutex", & __key___0);
#line 1307
  hba->cnic = cnic;
#line 1309
  hba->max_tasks = (u32 )cnic->max_fcoe_exchanges;
#line 1310
  hba->elstm_xids = hba->max_tasks / 2U;
#line 1311
  hba->max_outstanding_cmds = hba->elstm_xids;
#line 1312
  hba->max_xid = (unsigned int )((u16 )hba->max_tasks) - 1U;
#line 1314
  rc = bnx2fc_bind_pcidev(hba);
#line 1315
  if (rc != 0) {
#line 1316
    printk("\vbnx2fc: create_adapter:  bind error\n");
#line 1317
    goto bind_err;
  } else {

  }
#line 1319
  hba->phys_dev = cnic->netdev;
#line 1320
  hba->next_conn_id = 0U;
#line 1322
  tmp___0 = kzalloc(8192UL, 208U);
#line 1322
  hba->tgt_ofld_list = (struct bnx2fc_rport **)tmp___0;
#line 1325
  if ((unsigned long )hba->tgt_ofld_list == (unsigned long )((struct bnx2fc_rport **)0)) {
#line 1326
    printk("\vbnx2fc: Unable to allocate tgt offload list\n");
#line 1327
    goto tgtofld_err;
  } else {

  }
#line 1330
  hba->num_ofld_sess = 0;
#line 1332
  hba->cmd_mgr = bnx2fc_cmd_mgr_alloc(hba);
#line 1333
  if ((unsigned long )hba->cmd_mgr == (unsigned long )((struct bnx2fc_cmd_mgr *)0)) {
#line 1334
    printk("\vbnx2fc: em_config:bnx2fc_cmd_mgr_alloc failed\n");
#line 1335
    goto cmgr_err;
  } else {

  }
#line 1337
  fcoe_cap = & hba->fcoe_cap;
#line 1339
  fcoe_cap->capability1 = 128U;
#line 1341
  fcoe_cap->capability1 = fcoe_cap->capability1 | 67108864U;
#line 1343
  fcoe_cap->capability2 = hba->max_outstanding_cmds;
#line 1345
  fcoe_cap->capability2 = fcoe_cap->capability2 | 16777216U;
#line 1347
  fcoe_cap->capability3 = 1024U;
#line 1349
  fcoe_cap->capability3 = fcoe_cap->capability3 | (hba->max_outstanding_cmds << 16);
#line 1351
  fcoe_cap->capability4 = 1U;
#line 1353
  __init_waitqueue_head(& hba->shutdown_wait, "&hba->shutdown_wait", & __key___1);
#line 1354
  __init_waitqueue_head(& hba->destroy_wait, "&hba->destroy_wait", & __key___2);
#line 1355
  INIT_LIST_HEAD(& hba->vports);
#line 1357
  return (hba);
  cmgr_err: 
#line 1360
  kfree((void const   *)hba->tgt_ofld_list);
  tgtofld_err: 
#line 1362
  bnx2fc_unbind_pcidev(hba);
  bind_err: 
#line 1364
  kfree((void const   *)hba);
#line 1365
  return ((struct bnx2fc_hba *)0);
}
}
#line 1368 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
struct bnx2fc_interface *bnx2fc_interface_create(struct bnx2fc_hba *hba , struct net_device *netdev ,
                                                 enum fip_state fip_mode ) 
{ 
  struct fcoe_ctlr_device *ctlr_dev ;
  struct bnx2fc_interface *interface ;
  struct fcoe_ctlr *ctlr ;
  int size ;
  int rc ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1376
  rc = 0;
#line 1378
  size = 960;
#line 1379
  ctlr_dev = fcoe_ctlr_device_add(& netdev->dev, & bnx2fc_fcoe_sysfs_templ, size);
#line 1381
  if ((unsigned long )ctlr_dev == (unsigned long )((struct fcoe_ctlr_device *)0)) {
#line 1382
    printk("\vbnx2fc: Unable to allocate interface structure\n");
#line 1383
    return ((struct bnx2fc_interface *)0);
  } else {

  }
#line 1385
  tmp = fcoe_ctlr_device_priv((struct fcoe_ctlr_device  const  *)ctlr_dev);
#line 1385
  ctlr = (struct fcoe_ctlr *)tmp;
#line 1386
  ctlr->cdev = ctlr_dev;
#line 1387
  tmp___0 = fcoe_ctlr_priv((struct fcoe_ctlr  const  *)ctlr);
#line 1387
  interface = (struct bnx2fc_interface *)tmp___0;
#line 1388
  dev_hold(netdev);
#line 1389
  kref_init(& interface->kref);
#line 1390
  interface->hba = hba;
#line 1391
  interface->netdev = netdev;
#line 1394
  fcoe_ctlr_init(ctlr, fip_mode);
#line 1395
  ctlr->send = & bnx2fc_fip_send;
#line 1396
  ctlr->update_mac = & bnx2fc_update_src_mac;
#line 1397
  ctlr->get_src_addr = & bnx2fc_get_src_mac;
#line 1398
  set_bit(0L, (unsigned long volatile   *)(& interface->if_flags));
#line 1400
  rc = bnx2fc_interface_setup(interface);
#line 1401
  if (rc == 0) {
#line 1402
    return (interface);
  } else {

  }
#line 1404
  fcoe_ctlr_destroy(ctlr);
#line 1405
  dev_put(netdev);
#line 1406
  fcoe_ctlr_device_delete(ctlr_dev);
#line 1407
  return ((struct bnx2fc_interface *)0);
}
}
#line 1421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct fc_lport *bnx2fc_if_create(struct bnx2fc_interface *interface , struct device *parent ,
                                         int npiv ) 
{ 
  struct fcoe_ctlr *ctlr ;
  struct fc_lport *lport ;
  struct fc_lport *n_port ;
  struct fcoe_port *port ;
  struct Scsi_Host *shost ;
  struct fc_vport *vport ;
  struct device  const  *__mptr ;
  struct bnx2fc_lport *blport ;
  struct bnx2fc_hba *hba ;
  int rc ;
  void *tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  void *tmp___1 ;

  {
#line 1424
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 1428
  __mptr = (struct device  const  *)parent;
#line 1428
  vport = (struct fc_vport *)__mptr + 0xffffffffffffff68UL;
#line 1430
  hba = interface->hba;
#line 1431
  rc = 0;
#line 1433
  tmp = kzalloc(24UL, 208U);
#line 1433
  blport = (struct bnx2fc_lport *)tmp;
#line 1434
  if ((unsigned long )blport == (unsigned long )((struct bnx2fc_lport *)0)) {
#line 1435
    BNX2FC_HBA_DBG((struct fc_lport  const  *)ctlr->lp, "Unable to alloc blport\n");
#line 1436
    return ((struct fc_lport *)0);
  } else {

  }
#line 1440
  bnx2fc_shost_template.can_queue = (int )hba->max_outstanding_cmds;
#line 1441
  if (npiv == 0) {
#line 1442
    lport = libfc_host_alloc(& bnx2fc_shost_template, 352);
  } else {
#line 1444
    lport = libfc_vport_create(vport, 352);
  }
#line 1446
  if ((unsigned long )lport == (unsigned long )((struct fc_lport *)0)) {
#line 1447
    printk("\vbnx2fc: could not allocate scsi host structure\n");
#line 1448
    goto free_blport;
  } else {

  }
#line 1450
  shost = lport->host;
#line 1451
  tmp___0 = lport_priv((struct fc_lport  const  *)lport);
#line 1451
  port = (struct fcoe_port *)tmp___0;
#line 1452
  port->lport = lport;
#line 1453
  port->priv = (void *)interface;
#line 1454
  port->get_netdev = & bnx2fc_netdev;
#line 1455
  __init_work(& port->destroy_work, 0);
#line 1455
  __constr_expr_0.counter = 137438953408L;
#line 1455
  port->destroy_work.data = __constr_expr_0;
#line 1455
  lockdep_init_map(& port->destroy_work.lockdep_map, "(&port->destroy_work)", & __key,
                   0);
#line 1455
  INIT_LIST_HEAD(& port->destroy_work.entry);
#line 1455
  port->destroy_work.func = & bnx2fc_destroy_work;
#line 1458
  rc = bnx2fc_lport_config(lport);
#line 1459
  if (rc != 0) {
#line 1460
    goto lp_config_err;
  } else {

  }
#line 1462
  if (npiv != 0) {
#line 1463
    printk("\vbnx2fc: Setting vport names, 0x%llX 0x%llX\n", vport->node_name, vport->port_name);
#line 1465
    fc_set_wwnn(lport, vport->node_name);
#line 1466
    fc_set_wwpn(lport, vport->port_name);
  } else {

  }
#line 1469
  rc = bnx2fc_net_config(lport, interface->netdev);
#line 1470
  if (rc != 0) {
#line 1471
    printk("\vbnx2fc: Error on bnx2fc_net_config\n");
#line 1472
    goto lp_config_err;
  } else {

  }
#line 1475
  rc = bnx2fc_shost_config(lport, parent);
#line 1476
  if (rc != 0) {
#line 1477
    printk("\vbnx2fc: Couldnt configure shost for %s\n", (char *)(& (interface->netdev)->name));
#line 1479
    goto lp_config_err;
  } else {

  }
#line 1483
  rc = bnx2fc_libfc_config(lport);
#line 1484
  if (rc != 0) {
#line 1485
    printk("\vbnx2fc: Couldnt configure libfc\n");
#line 1486
    goto shost_err;
  } else {

  }
#line 1488
  ((struct fc_host_attrs *)(lport->host)->shost_data)->port_type = 0;
#line 1491
  if (npiv == 0) {
#line 1492
    rc = bnx2fc_em_config(lport, hba);
  } else {
#line 1494
    shost = vport->shost;
#line 1495
    tmp___1 = shost_priv(shost);
#line 1495
    n_port = (struct fc_lport *)tmp___1;
#line 1496
    rc = fc_exch_mgr_list_clone(n_port, lport);
  }
#line 1499
  if (rc != 0) {
#line 1500
    printk("\vbnx2fc: Error on bnx2fc_em_config\n");
#line 1501
    goto shost_err;
  } else {

  }
#line 1504
  bnx2fc_interface_get(interface);
#line 1506
  spin_lock_bh(& hba->hba_lock);
#line 1507
  blport->lport = lport;
#line 1508
  list_add_tail(& blport->list, & hba->vports);
#line 1509
  spin_unlock_bh(& hba->hba_lock);
#line 1511
  return (lport);
  shost_err: 
#line 1514
  ldv_scsi_remove_host_34(shost);
  lp_config_err: 
#line 1516
  scsi_host_put(lport->host);
  free_blport: 
#line 1518
  kfree((void const   *)blport);
#line 1519
  return ((struct fc_lport *)0);
}
}
#line 1522 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_net_cleanup(struct bnx2fc_interface *interface ) 
{ 


  {
#line 1525
  __dev_remove_pack(& interface->fcoe_packet_type);
#line 1526
  __dev_remove_pack(& interface->fip_packet_type);
#line 1527
  synchronize_net();
#line 1528
  return;
}
}
#line 1530 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_interface_cleanup(struct bnx2fc_interface *interface ) 
{ 
  struct fcoe_ctlr *ctlr ;
  struct fc_lport *lport ;
  struct fcoe_port *port ;
  void *tmp ;
  struct bnx2fc_hba *hba ;

  {
#line 1532
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 1533
  lport = ctlr->lp;
#line 1534
  tmp = lport_priv((struct fc_lport  const  *)lport);
#line 1534
  port = (struct fcoe_port *)tmp;
#line 1535
  hba = interface->hba;
#line 1538
  ldv_del_timer_sync_35(& port->timer);
#line 1541
  fcoe_clean_pending_queue(lport);
#line 1543
  bnx2fc_net_cleanup(interface);
#line 1545
  bnx2fc_free_vport(hba, lport);
#line 1546
  return;
}
}
#line 1548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_if_destroy(struct fc_lport *lport ) 
{ 


  {
#line 1552
  bnx2fc_clean_rx_queue(lport);
#line 1555
  fc_remove_host(lport->host);
#line 1556
  ldv_scsi_remove_host_36(lport->host);
#line 1562
  fc_exch_mgr_free(lport);
#line 1565
  fc_lport_free_stats(lport);
#line 1568
  scsi_host_put(lport->host);
#line 1569
  return;
}
}
#line 1571 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void __bnx2fc_destroy(struct bnx2fc_interface *interface ) 
{ 
  struct fcoe_ctlr *ctlr ;
  struct fc_lport *lport ;
  struct fcoe_port *port ;
  void *tmp ;

  {
#line 1573
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 1574
  lport = ctlr->lp;
#line 1575
  tmp = lport_priv((struct fc_lport  const  *)lport);
#line 1575
  port = (struct fcoe_port *)tmp;
#line 1577
  bnx2fc_interface_cleanup(interface);
#line 1578
  bnx2fc_stop(interface);
#line 1579
  list_del(& interface->list);
#line 1580
  bnx2fc_interface_put(interface);
#line 1581
  queue_work(bnx2fc_wq, & port->destroy_work);
#line 1582
  return;
}
}
#line 1594 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_destroy(struct net_device *netdev ) 
{ 
  struct bnx2fc_interface *interface ;
  struct workqueue_struct *timer_work_queue ;
  struct fcoe_ctlr *ctlr ;
  int rc ;

  {
#line 1596
  interface = (struct bnx2fc_interface *)0;
#line 1599
  rc = 0;
#line 1601
  rtnl_lock();
#line 1602
  mutex_lock_nested(& bnx2fc_dev_lock, 0U);
#line 1604
  interface = bnx2fc_interface_lookup(netdev);
#line 1605
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 1606
  if ((unsigned long )interface == (unsigned long )((struct bnx2fc_interface *)0) || (unsigned long )ctlr->lp == (unsigned long )((struct fc_lport *)0)) {
#line 1607
    rc = -19;
#line 1608
    printk("\vbnx2fc: bnx2fc_destroy: interface or lport not found\n");
#line 1609
    goto netdev_err;
  } else {

  }
#line 1612
  timer_work_queue = interface->timer_work_queue;
#line 1613
  __bnx2fc_destroy(interface);
#line 1614
  ldv_destroy_workqueue_37(timer_work_queue);
  netdev_err: 
#line 1617
  mutex_unlock(& bnx2fc_dev_lock);
#line 1618
  rtnl_unlock();
#line 1619
  return (rc);
}
}
#line 1622 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_destroy_work(struct work_struct *work ) 
{ 
  struct fcoe_port *port ;
  struct fc_lport *lport ;
  struct work_struct  const  *__mptr ;

  {
#line 1627
  __mptr = (struct work_struct  const  *)work;
#line 1627
  port = (struct fcoe_port *)__mptr + 0xffffffffffffff00UL;
#line 1628
  lport = port->lport;
#line 1630
  BNX2FC_HBA_DBG((struct fc_lport  const  *)lport, "Entered bnx2fc_destroy_work\n");
#line 1632
  bnx2fc_if_destroy(lport);
#line 1633
  return;
}
}
#line 1635 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_unbind_adapter_devices(struct bnx2fc_hba *hba ) 
{ 


  {
#line 1637
  bnx2fc_free_fw_resc(hba);
#line 1638
  bnx2fc_free_task_ctx(hba);
#line 1639
  return;
}
}
#line 1647 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_bind_adapter_devices(struct bnx2fc_hba *hba ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1649
  tmp = bnx2fc_setup_task_ctx(hba);
#line 1649
  if (tmp != 0) {
#line 1650
    goto mem_err;
  } else {

  }
#line 1652
  tmp___0 = bnx2fc_setup_fw_resc(hba);
#line 1652
  if (tmp___0 != 0) {
#line 1653
    goto mem_err;
  } else {

  }
#line 1655
  return (0);
  mem_err: 
#line 1657
  bnx2fc_unbind_adapter_devices(hba);
#line 1658
  return (-12);
}
}
#line 1661 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_bind_pcidev(struct bnx2fc_hba *hba ) 
{ 
  struct cnic_dev *cnic ;
  struct pci_dev *pdev ;
  struct pci_dev *tmp ;

  {
#line 1666
  if ((unsigned long )hba->cnic == (unsigned long )((struct cnic_dev *)0)) {
#line 1667
    printk("\vbnx2fc: cnic is NULL\n");
#line 1668
    return (-19);
  } else {

  }
#line 1670
  cnic = hba->cnic;
#line 1671
  tmp = cnic->pcidev;
#line 1671
  hba->pcidev = tmp;
#line 1671
  pdev = tmp;
#line 1672
  if ((unsigned long )hba->pcidev == (unsigned long )((struct pci_dev *)0)) {
#line 1673
    return (-19);
  } else {

  }
#line 1675
  switch ((int )pdev->device) {
  case 5710: 
#line 1677
  strncpy((char *)(& hba->chip_num), "BCM57710", 16UL);
#line 1678
  goto ldv_55383;
  case 5711: 
#line 1680
  strncpy((char *)(& hba->chip_num), "BCM57711", 16UL);
#line 1681
  goto ldv_55383;
  case 5730: ;
  case 5731: ;
  case 5743: 
#line 1685
  strncpy((char *)(& hba->chip_num), "BCM57712", 16UL);
#line 1686
  goto ldv_55383;
  case 5770: ;
  case 5797: ;
  case 5801: 
#line 1690
  strncpy((char *)(& hba->chip_num), "BCM57800", 16UL);
#line 1691
  goto ldv_55383;
  case 5774: ;
  case 5806: ;
  case 5807: 
#line 1695
  strncpy((char *)(& hba->chip_num), "BCM57810", 16UL);
#line 1696
  goto ldv_55383;
  case 5773: ;
  case 5796: ;
  case 5805: ;
  case 5794: ;
  case 5793: 
#line 1702
  strncpy((char *)(& hba->chip_num), "BCM57840", 16UL);
#line 1703
  goto ldv_55383;
  default: 
#line 1705
  printk("\vbnx2fc: bnx2fc: Unknown device id 0x%x\n", (int )pdev->device);
#line 1706
  goto ldv_55383;
  }
  ldv_55383: 
#line 1708
  pci_dev_get(hba->pcidev);
#line 1709
  return (0);
}
}
#line 1712 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_unbind_pcidev(struct bnx2fc_hba *hba ) 
{ 


  {
#line 1714
  if ((unsigned long )hba->pcidev != (unsigned long )((struct pci_dev *)0)) {
#line 1715
    hba->chip_num[0] = 0;
#line 1716
    pci_dev_put(hba->pcidev);
  } else {

  }
#line 1718
  hba->pcidev = (struct pci_dev *)0;
#line 1719
  return;
}
}
#line 1726 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_ulp_get_stats(void *handle ) 
{ 
  struct bnx2fc_hba *hba ;
  struct cnic_dev *cnic ;
  struct fcoe_stats_info *stats_addr ;

  {
#line 1728
  hba = (struct bnx2fc_hba *)handle;
#line 1732
  if ((unsigned long )hba == (unsigned long )((struct bnx2fc_hba *)0)) {
#line 1733
    return (-22);
  } else {

  }
#line 1735
  cnic = hba->cnic;
#line 1736
  stats_addr = & (cnic->stats_addr)->fcoe_stat;
#line 1737
  if ((unsigned long )stats_addr == (unsigned long )((struct fcoe_stats_info *)0)) {
#line 1738
    return (-22);
  } else {

  }
#line 1740
  strncpy((char *)(& stats_addr->version), "2.4.2", 12UL);
#line 1742
  stats_addr->txq_size = 256U;
#line 1743
  stats_addr->rxq_size = 272U;
#line 1745
  return (0);
}
}
#line 1762 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_ulp_start(void *handle ) 
{ 
  struct bnx2fc_hba *hba ;
  struct bnx2fc_interface *interface ;
  struct fcoe_ctlr *ctlr ;
  struct fc_lport *lport ;
  int tmp ;
  long tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1764
  hba = (struct bnx2fc_hba *)handle;
#line 1769
  mutex_lock_nested(& bnx2fc_dev_lock, 0U);
#line 1771
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& hba->flags));
#line 1771
  if (tmp == 0) {
#line 1772
    bnx2fc_fw_init(hba);
  } else {

  }
#line 1774
  tmp___0 = ldv__builtin_expect((bnx2fc_debug_level & 16U) != 0U, 0L);
#line 1774
  if (tmp___0 != 0L) {
#line 1774
    printk("\016bnx2fc: bnx2fc started.\n");
  } else {

  }
#line 1776
  __mptr = (struct list_head  const  *)if_list.next;
#line 1776
  interface = (struct bnx2fc_interface *)__mptr;
#line 1776
  goto ldv_55421;
  ldv_55420: ;
#line 1777
  if ((unsigned long )interface->hba == (unsigned long )hba) {
#line 1778
    ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 1779
    lport = ctlr->lp;
#line 1781
    printk("\vbnx2fc: ulp_init: start discovery\n");
#line 1782
    lport->tt.frame_send = & bnx2fc_xmit;
#line 1783
    bnx2fc_start_disc(interface);
  } else {

  }
#line 1776
  __mptr___0 = (struct list_head  const  *)interface->list.next;
#line 1776
  interface = (struct bnx2fc_interface *)__mptr___0;
  ldv_55421: ;
#line 1776
  if ((unsigned long )(& interface->list) != (unsigned long )(& if_list)) {
#line 1778
    goto ldv_55420;
  } else {

  }
#line 1787
  mutex_unlock(& bnx2fc_dev_lock);
#line 1788
  return;
}
}
#line 1790 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_port_shutdown(struct fc_lport *lport ) 
{ 
  long tmp ;

  {
#line 1792
  tmp = ldv__builtin_expect((bnx2fc_debug_level & 16U) != 0U, 0L);
#line 1792
  if (tmp != 0L) {
#line 1792
    printk("\016bnx2fc: Entered %s\n", "bnx2fc_port_shutdown");
  } else {

  }
#line 1793
  fc_fabric_logoff(lport);
#line 1794
  fc_lport_destroy(lport);
#line 1795
  return;
}
}
#line 1797 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_stop(struct bnx2fc_interface *interface ) 
{ 
  struct fcoe_ctlr *ctlr ;
  struct fc_lport *lport ;
  struct fc_lport *vport ;
  int tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1799
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 1803
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& (interface->hba)->flags));
#line 1803
  if (tmp == 0) {
#line 1804
    return;
  } else {

  }
#line 1806
  lport = ctlr->lp;
#line 1807
  bnx2fc_port_shutdown(lport);
#line 1809
  mutex_lock_nested(& lport->lp_mutex, 0U);
#line 1810
  __mptr = (struct list_head  const  *)lport->vports.next;
#line 1810
  vport = (struct fc_lport *)__mptr + 0xfffffffffffffab0UL;
#line 1810
  goto ldv_55438;
  ldv_55437: 
#line 1811
  ((struct fc_host_attrs *)(vport->host)->shost_data)->port_type = 0;
#line 1810
  __mptr___0 = (struct list_head  const  *)vport->list.next;
#line 1810
  vport = (struct fc_lport *)__mptr___0 + 0xfffffffffffffab0UL;
  ldv_55438: ;
#line 1810
  if ((unsigned long )(& vport->list) != (unsigned long )(& lport->vports)) {
#line 1812
    goto ldv_55437;
  } else {

  }
#line 1813
  mutex_unlock(& lport->lp_mutex);
#line 1814
  ((struct fc_host_attrs *)(lport->host)->shost_data)->port_type = 0;
#line 1815
  fcoe_ctlr_link_down(ctlr);
#line 1816
  fcoe_clean_pending_queue(lport);
#line 1817
  return;
}
}
#line 1819 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_fw_init(struct bnx2fc_hba *hba ) 
{ 
  int rc ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1822
  rc = -1;
#line 1823
  i = 250;
#line 1825
  rc = bnx2fc_bind_adapter_devices(hba);
#line 1826
  if (rc != 0) {
#line 1827
    printk("\tbnx2fc: bnx2fc_bind_adapter_devices failed - rc = %d\n", rc);
#line 1829
    goto err_out;
  } else {

  }
#line 1832
  rc = bnx2fc_send_fw_fcoe_init_msg(hba);
#line 1833
  if (rc != 0) {
#line 1834
    printk("\tbnx2fc: bnx2fc_send_fw_fcoe_init_msg failed - rc = %d\n", rc);
#line 1836
    goto err_unbind;
  } else {

  }
#line 1843
  goto ldv_55448;
  ldv_55447: 
#line 1844
  msleep(4U);
  ldv_55448: 
#line 1843
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& hba->adapter_state));
#line 1843
  if (tmp == 0) {
#line 1843
    tmp___0 = i;
#line 1843
    i = i - 1;
#line 1843
    if (tmp___0 != 0) {
#line 1845
      goto ldv_55447;
    } else {
#line 1848
      goto ldv_55449;
    }
  } else {

  }
  ldv_55449: 
#line 1846
  tmp___1 = constant_test_bit(0L, (unsigned long const volatile   *)(& hba->adapter_state));
#line 1846
  if (tmp___1 == 0) {
#line 1847
    printk("\vbnx2fc: bnx2fc_start: %s failed to initialize.  Ignoring...\n", (char *)(& ((hba->cnic)->netdev)->name));
#line 1850
    rc = -1;
#line 1851
    goto err_unbind;
  } else {

  }
#line 1855
  set_bit(0L, (unsigned long volatile   *)(& hba->flags));
#line 1856
  return (0);
  err_unbind: 
#line 1859
  bnx2fc_unbind_adapter_devices(hba);
  err_out: ;
#line 1861
  return (rc);
}
}
#line 1864 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_fw_destroy(struct bnx2fc_hba *hba ) 
{ 
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1866
  tmp___6 = test_and_clear_bit(0L, (unsigned long volatile   *)(& hba->flags));
#line 1866
  if (tmp___6 != 0) {
#line 1867
    tmp___5 = bnx2fc_send_fw_fcoe_destroy_msg(hba);
#line 1867
    if (tmp___5 == 0) {
#line 1868
      reg_timer_7(& hba->destroy_timer);
#line 1869
      hba->destroy_timer.expires = (unsigned long )jiffies + 750UL;
#line 1871
      hba->destroy_timer.function = & bnx2fc_destroy_timer;
#line 1872
      hba->destroy_timer.data = (unsigned long )hba;
#line 1873
      add_timer(& hba->destroy_timer);
#line 1874
      __ret = 0;
#line 1874
      __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c",
                    1876, 0);
#line 1874
      tmp___1 = constant_test_bit(1L, (unsigned long const volatile   *)(& hba->flags));
#line 1874
      if (tmp___1 == 0) {
#line 1874
        __ret___0 = 0L;
#line 1874
        INIT_LIST_HEAD(& __wait.task_list);
#line 1874
        __wait.flags = 0U;
        ldv_55459: 
#line 1874
        tmp = prepare_to_wait_event(& hba->destroy_wait, & __wait, 1);
#line 1874
        __int = tmp;
#line 1874
        tmp___0 = constant_test_bit(1L, (unsigned long const volatile   *)(& hba->flags));
#line 1874
        if (tmp___0 != 0) {
#line 1874
          goto ldv_55458;
        } else {

        }
#line 1874
        if (__int != 0L) {
#line 1874
          __ret___0 = __int;
#line 1874
          goto ldv_55458;
        } else {

        }
#line 1874
        schedule();
#line 1874
        goto ldv_55459;
        ldv_55458: 
#line 1874
        finish_wait(& hba->destroy_wait, & __wait);
#line 1874
        __ret = (int )__ret___0;
      } else {

      }
#line 1877
      clear_bit(1L, (unsigned long volatile   *)(& hba->flags));
#line 1879
      tmp___3 = get_current();
#line 1879
      tmp___4 = signal_pending(tmp___3);
#line 1879
      if (tmp___4 != 0) {
#line 1880
        tmp___2 = get_current();
#line 1880
        flush_signals(tmp___2);
      } else {

      }
#line 1882
      ldv_del_timer_sync_38(& hba->destroy_timer);
    } else {

    }
#line 1884
    bnx2fc_unbind_adapter_devices(hba);
  } else {

  }
#line 1886
  return;
}
}
#line 1896 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_ulp_stop(void *handle ) 
{ 
  struct bnx2fc_hba *hba ;
  struct bnx2fc_interface *interface ;
  int tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  long tmp___0 ;

  {
#line 1898
  hba = (struct bnx2fc_hba *)handle;
#line 1901
  printk("\vULP_STOP\n");
#line 1903
  mutex_lock_nested(& bnx2fc_dev_lock, 0U);
#line 1904
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& hba->flags));
#line 1904
  if (tmp == 0) {
#line 1905
    goto exit;
  } else {

  }
#line 1906
  __mptr = (struct list_head  const  *)if_list.next;
#line 1906
  interface = (struct bnx2fc_interface *)__mptr;
#line 1906
  goto ldv_55473;
  ldv_55472: ;
#line 1907
  if ((unsigned long )interface->hba == (unsigned long )hba) {
#line 1908
    bnx2fc_stop(interface);
  } else {

  }
#line 1906
  __mptr___0 = (struct list_head  const  *)interface->list.next;
#line 1906
  interface = (struct bnx2fc_interface *)__mptr___0;
  ldv_55473: ;
#line 1906
  if ((unsigned long )(& interface->list) != (unsigned long )(& if_list)) {
#line 1908
    goto ldv_55472;
  } else {

  }
#line 1910
  tmp___0 = ldv__builtin_expect(hba->num_ofld_sess != 0, 0L);
#line 1910
  if (tmp___0 != 0L) {
#line 1910
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"),
                         "i" (1910), "i" (12UL));
    ldv_55475: ;
#line 1910
    goto ldv_55475;
  } else {

  }
#line 1912
  mutex_lock_nested(& hba->hba_mutex, 0U);
#line 1913
  clear_bit(0L, (unsigned long volatile   *)(& hba->adapter_state));
#line 1914
  clear_bit(1L, (unsigned long volatile   *)(& hba->adapter_state));
#line 1917
  clear_bit(3L, (unsigned long volatile   *)(& hba->adapter_state));
#line 1918
  mutex_unlock(& hba->hba_mutex);
#line 1920
  bnx2fc_fw_destroy(hba);
  exit: 
#line 1922
  mutex_unlock(& bnx2fc_dev_lock);
#line 1923
  return;
}
}
#line 1925 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_start_disc(struct bnx2fc_interface *interface ) 
{ 
  struct fcoe_ctlr *ctlr ;
  struct fc_lport *lport ;
  int wait_cnt ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1927
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 1929
  wait_cnt = 0;
#line 1931
  tmp = ldv__builtin_expect((bnx2fc_debug_level & 16U) != 0U, 0L);
#line 1931
  if (tmp != 0L) {
#line 1931
    printk("\016bnx2fc: Entered %s\n", "bnx2fc_start_disc");
  } else {

  }
#line 1933
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile   *)(& (interface->hba)->flags));
#line 1933
  if (tmp___0 == 0) {
#line 1934
    printk("\vbnx2fc: Init not done yet\n");
#line 1935
    return;
  } else {

  }
#line 1938
  lport = ctlr->lp;
#line 1939
  BNX2FC_HBA_DBG((struct fc_lport  const  *)lport, "calling fc_fabric_login\n");
#line 1941
  tmp___1 = bnx2fc_link_ok(lport);
#line 1941
  if (tmp___1 == 0 && (int )interface->enabled) {
#line 1942
    BNX2FC_HBA_DBG((struct fc_lport  const  *)lport, "ctlr_link_up\n");
#line 1943
    fcoe_ctlr_link_up(ctlr);
#line 1944
    ((struct fc_host_attrs *)(lport->host)->shost_data)->port_type = 3;
#line 1945
    set_bit(3L, (unsigned long volatile   *)(& (interface->hba)->adapter_state));
  } else {

  }
#line 1949
  goto ldv_55485;
  ldv_55484: 
#line 1950
  msleep(250U);
#line 1952
  wait_cnt = wait_cnt + 1;
#line 1952
  if (wait_cnt > 12) {
#line 1953
    goto ldv_55483;
  } else {

  }
  ldv_55485: ;
#line 1949
  if ((unsigned long )ctlr->sel_fcf == (unsigned long )((struct fcoe_fcf *)0)) {
#line 1951
    goto ldv_55484;
  } else {

  }
  ldv_55483: 
#line 1957
  tmp___2 = fc_set_mfs(lport, 2072U);
#line 1957
  if (tmp___2 != 0) {
#line 1958
    return;
  } else {

  }
#line 1960
  fc_lport_init(lport);
#line 1961
  fc_fabric_login(lport);
#line 1962
  return;
}
}
#line 1973 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_ulp_init(struct cnic_dev *dev ) 
{ 
  struct bnx2fc_hba *hba ;
  int rc ;
  long tmp ;
  int tmp___0 ;

  {
#line 1976
  rc = 0;
#line 1978
  tmp = ldv__builtin_expect((bnx2fc_debug_level & 16U) != 0U, 0L);
#line 1978
  if (tmp != 0L) {
#line 1978
    printk("\016bnx2fc: Entered %s\n", "bnx2fc_ulp_init");
  } else {

  }
#line 1980
  tmp___0 = constant_test_bit(4L, (unsigned long const volatile   *)(& dev->flags));
#line 1980
  if (tmp___0 == 0 || dev->max_fcoe_conn == 0) {
#line 1982
    printk("\vbnx2fc: bnx2fc FCoE not supported on %s, flags: %lx fcoe_conn: %d\n",
           (char *)(& (dev->netdev)->name), dev->flags, dev->max_fcoe_conn);
#line 1985
    return;
  } else {

  }
#line 1988
  hba = bnx2fc_hba_create(dev);
#line 1989
  if ((unsigned long )hba == (unsigned long )((struct bnx2fc_hba *)0)) {
#line 1990
    printk("\vbnx2fc: hba initialization failed\n");
#line 1991
    return;
  } else {

  }
#line 1995
  mutex_lock_nested(& bnx2fc_dev_lock, 0U);
#line 1996
  list_add_tail(& hba->list, & adapter_list);
#line 1997
  adapter_count = adapter_count + 1U;
#line 1998
  mutex_unlock(& bnx2fc_dev_lock);
#line 2000
  dev->fcoe_cap = & hba->fcoe_cap;
#line 2001
  clear_bit(1L, (unsigned long volatile   *)(& hba->reg_with_cnic));
#line 2002
  rc = (*(dev->register_device))(dev, 2, (void *)hba);
#line 2004
  if (rc != 0) {
#line 2005
    printk("\vbnx2fc: register_device failed, rc = %d\n", rc);
  } else {
#line 2007
    set_bit(1L, (unsigned long volatile   *)(& hba->reg_with_cnic));
  }
#line 2008
  return;
}
}
#line 2011 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int __bnx2fc_disable(struct fcoe_ctlr *ctlr ) 
{ 
  struct bnx2fc_interface *interface ;
  void *tmp ;

  {
#line 2013
  tmp = fcoe_ctlr_priv((struct fcoe_ctlr  const  *)ctlr);
#line 2013
  interface = (struct bnx2fc_interface *)tmp;
#line 2015
  if ((int )interface->enabled) {
#line 2016
    if ((unsigned long )ctlr->lp == (unsigned long )((struct fc_lport *)0)) {
#line 2017
      printk("\vbnx2fc: bnx2fc: __bnx2fc_disable: lport not found\n");
#line 2018
      return (-19);
    } else {
#line 2020
      interface->enabled = 0;
#line 2021
      fcoe_ctlr_link_down(ctlr);
#line 2022
      fcoe_clean_pending_queue(ctlr->lp);
    }
  } else {

  }
#line 2025
  return (0);
}
}
#line 2031 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_disable(struct net_device *netdev ) 
{ 
  struct bnx2fc_interface *interface ;
  struct fcoe_ctlr *ctlr ;
  int rc ;

  {
#line 2035
  rc = 0;
#line 2037
  rtnl_lock();
#line 2038
  mutex_lock_nested(& bnx2fc_dev_lock, 0U);
#line 2040
  interface = bnx2fc_interface_lookup(netdev);
#line 2041
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 2043
  if ((unsigned long )interface == (unsigned long )((struct bnx2fc_interface *)0)) {
#line 2044
    rc = -19;
#line 2045
    printk("\vbnx2fc: bnx2fc: bnx2fc_disable: interface not found\n");
  } else {
#line 2047
    rc = __bnx2fc_disable(ctlr);
  }
#line 2049
  mutex_unlock(& bnx2fc_dev_lock);
#line 2050
  rtnl_unlock();
#line 2051
  return (rc);
}
}
#line 2054 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int __bnx2fc_enable(struct fcoe_ctlr *ctlr ) 
{ 
  struct bnx2fc_interface *interface ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2056
  tmp = fcoe_ctlr_priv((struct fcoe_ctlr  const  *)ctlr);
#line 2056
  interface = (struct bnx2fc_interface *)tmp;
#line 2058
  if (! interface->enabled) {
#line 2059
    if ((unsigned long )ctlr->lp == (unsigned long )((struct fc_lport *)0)) {
#line 2060
      printk("\vbnx2fc: bnx2fc: __bnx2fc_enable: lport not found\n");
#line 2061
      return (-19);
    } else {
#line 2062
      tmp___0 = bnx2fc_link_ok(ctlr->lp);
#line 2062
      if (tmp___0 == 0) {
#line 2063
        fcoe_ctlr_link_up(ctlr);
#line 2064
        interface->enabled = 1;
      } else {

      }
    }
  } else {

  }
#line 2067
  return (0);
}
}
#line 2073 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_enable(struct net_device *netdev ) 
{ 
  struct bnx2fc_interface *interface ;
  struct fcoe_ctlr *ctlr ;
  int rc ;

  {
#line 2077
  rc = 0;
#line 2079
  rtnl_lock();
#line 2080
  mutex_lock_nested(& bnx2fc_dev_lock, 0U);
#line 2082
  interface = bnx2fc_interface_lookup(netdev);
#line 2083
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 2084
  if ((unsigned long )interface == (unsigned long )((struct bnx2fc_interface *)0)) {
#line 2085
    rc = -19;
#line 2086
    printk("\vbnx2fc: bnx2fc: bnx2fc_enable: interface not found\n");
  } else {
#line 2088
    rc = __bnx2fc_enable(ctlr);
  }
#line 2091
  mutex_unlock(& bnx2fc_dev_lock);
#line 2092
  rtnl_unlock();
#line 2093
  return (rc);
}
}
#line 2106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_ctlr_enabled(struct fcoe_ctlr_device *cdev ) 
{ 
  struct fcoe_ctlr *ctlr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2108
  tmp = fcoe_ctlr_device_priv((struct fcoe_ctlr_device  const  *)cdev);
#line 2108
  ctlr = (struct fcoe_ctlr *)tmp;
#line 2110
  switch ((unsigned int )cdev->enabled) {
  case 0U: 
#line 2112
  tmp___0 = __bnx2fc_enable(ctlr);
#line 2112
  return (tmp___0);
  case 1U: 
#line 2114
  tmp___1 = __bnx2fc_disable(ctlr);
#line 2114
  return (tmp___1);
  case 2U: ;
  default: ;
#line 2117
  return (-524);
  }
}
}
#line 2141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int _bnx2fc_create(struct net_device *netdev , enum fip_state fip_mode , enum bnx2fc_create_link_state link_state ) 
{ 
  struct fcoe_ctlr_device *cdev ;
  struct fcoe_ctlr *ctlr ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_hba *hba ;
  struct net_device *phys_dev ;
  struct fc_lport *lport ;
  struct ethtool_drvinfo drvinfo ;
  int rc ;
  int vlan_id ;
  long tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  struct bnx2fc_interface *tmp___4 ;
  u16 tmp___5 ;
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp___6 ;
  int tmp___7 ;

  {
#line 2149
  phys_dev = netdev;
#line 2152
  rc = 0;
#line 2153
  vlan_id = 0;
#line 2155
  tmp = ldv__builtin_expect((bnx2fc_debug_level & 16U) != 0U, 0L);
#line 2155
  if (tmp != 0L) {
#line 2155
    printk("\016bnx2fc: Entered bnx2fc_create\n");
  } else {

  }
#line 2156
  if ((unsigned int )fip_mode != 4U) {
#line 2157
    printk("\vfip mode not FABRIC\n");
#line 2158
    return (-5);
  } else {

  }
#line 2161
  rtnl_lock();
#line 2163
  mutex_lock_nested(& bnx2fc_dev_lock, 0U);
#line 2165
  tmp___0 = ldv_try_module_get_39(& __this_module);
#line 2165
  if (tmp___0) {
#line 2165
    tmp___1 = 0;
  } else {
#line 2165
    tmp___1 = 1;
  }
#line 2165
  if (tmp___1) {
#line 2166
    rc = -22;
#line 2167
    goto mod_err;
  } else {

  }
#line 2171
  if ((int )netdev->priv_flags & 1) {
#line 2172
    phys_dev = vlan_dev_real_dev((struct net_device  const  *)netdev);
  } else {

  }
#line 2175
  if ((unsigned long )phys_dev->ethtool_ops != (unsigned long )((struct ethtool_ops  const  *)0) && (unsigned long )(phys_dev->ethtool_ops)->get_drvinfo != (unsigned long )((void (*/* const  */)(struct net_device * ,
                                                                                                                                                                                                   struct ethtool_drvinfo * ))0)) {
#line 2176
    memset((void *)(& drvinfo), 0, 196UL);
#line 2177
    (*((phys_dev->ethtool_ops)->get_drvinfo))(phys_dev, & drvinfo);
#line 2178
    tmp___2 = strlen("bnx2x");
#line 2178
    tmp___3 = strncmp((char const   *)(& drvinfo.driver), "bnx2x", tmp___2);
#line 2178
    if (tmp___3 != 0) {
#line 2179
      printk("\vbnx2fc: Not a netxtreme2 device\n");
#line 2180
      rc = -22;
#line 2181
      goto netdev_err;
    } else {

    }
  } else {
#line 2184
    printk("\vbnx2fc: unable to obtain drv_info\n");
#line 2185
    rc = -22;
#line 2186
    goto netdev_err;
  }
#line 2190
  hba = bnx2fc_hba_lookup(phys_dev);
#line 2191
  if ((unsigned long )hba == (unsigned long )((struct bnx2fc_hba *)0)) {
#line 2192
    rc = -19;
#line 2193
    printk("\vbnx2fc: bnx2fc_create: hba not found\n");
#line 2194
    goto netdev_err;
  } else {

  }
#line 2197
  tmp___4 = bnx2fc_interface_lookup(netdev);
#line 2197
  if ((unsigned long )tmp___4 != (unsigned long )((struct bnx2fc_interface *)0)) {
#line 2198
    rc = -17;
#line 2199
    goto netdev_err;
  } else {

  }
#line 2202
  interface = bnx2fc_interface_create(hba, netdev, fip_mode);
#line 2203
  if ((unsigned long )interface == (unsigned long )((struct bnx2fc_interface *)0)) {
#line 2204
    printk("\vbnx2fc: bnx2fc_interface_create failed\n");
#line 2205
    rc = -12;
#line 2206
    goto ifput_err;
  } else {

  }
#line 2209
  if ((int )netdev->priv_flags & 1) {
#line 2210
    tmp___5 = vlan_dev_vlan_id((struct net_device  const  *)netdev);
#line 2210
    vlan_id = (int )tmp___5;
#line 2211
    interface->vlan_enabled = 1U;
  } else {

  }
#line 2214
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 2215
  cdev = ctlr->cdev;
#line 2216
  interface->vlan_id = vlan_id;
#line 2219
  __lock_name = "\"%s\"\"bnx2fc_timer_wq\"";
#line 2219
  tmp___6 = __alloc_workqueue_key("%s", 131082U, 1, & __key, __lock_name, (char *)"bnx2fc_timer_wq");
#line 2219
  interface->timer_work_queue = tmp___6;
#line 2220
  if ((unsigned long )interface->timer_work_queue == (unsigned long )((struct workqueue_struct *)0)) {
#line 2221
    printk("\vbnx2fc: ulp_init could not create timer_wq\n");
#line 2222
    rc = -22;
#line 2223
    goto ifput_err;
  } else {

  }
#line 2226
  lport = bnx2fc_if_create(interface, & cdev->dev, 0);
#line 2227
  if ((unsigned long )lport == (unsigned long )((struct fc_lport *)0)) {
#line 2228
    printk("\vbnx2fc: Failed to create interface (%s)\n", (char *)(& netdev->name));
#line 2230
    rc = -22;
#line 2231
    goto if_create_err;
  } else {

  }
#line 2235
  list_add_tail(& interface->list, & if_list);
#line 2237
  lport->boot_time = jiffies;
#line 2240
  ctlr->lp = lport;
#line 2242
  if ((unsigned int )link_state == 1U) {
#line 2243
    cdev->enabled = 0;
  } else {
#line 2245
    cdev->enabled = 1;
  }
#line 2247
  if ((unsigned int )link_state == 1U) {
#line 2247
    tmp___7 = bnx2fc_link_ok(lport);
#line 2247
    if (tmp___7 == 0) {
#line 2249
      fcoe_ctlr_link_up(ctlr);
#line 2250
      ((struct fc_host_attrs *)(lport->host)->shost_data)->port_type = 3;
#line 2251
      set_bit(3L, (unsigned long volatile   *)(& (interface->hba)->adapter_state));
    } else {

    }
  } else {

  }
#line 2254
  BNX2FC_HBA_DBG((struct fc_lport  const  *)lport, "create: START DISC\n");
#line 2255
  bnx2fc_start_disc(interface);
#line 2257
  if ((unsigned int )link_state == 1U) {
#line 2258
    interface->enabled = 1;
  } else {

  }
#line 2264
  bnx2fc_interface_put(interface);
#line 2266
  mutex_unlock(& bnx2fc_dev_lock);
#line 2267
  rtnl_unlock();
#line 2268
  return (0);
  if_create_err: 
#line 2271
  ldv_destroy_workqueue_40(interface->timer_work_queue);
  ifput_err: 
#line 2273
  bnx2fc_net_cleanup(interface);
#line 2274
  bnx2fc_interface_put(interface);
#line 2275
  goto mod_err;
  netdev_err: 
#line 2277
  ldv_module_put_41(& __this_module);
  mod_err: 
#line 2279
  mutex_unlock(& bnx2fc_dev_lock);
#line 2280
  rtnl_unlock();
#line 2281
  return (rc);
}
}
#line 2293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_create(struct net_device *netdev , enum fip_state fip_mode ) 
{ 
  int tmp ;

  {
#line 2295
  tmp = _bnx2fc_create(netdev, fip_mode, 1);
#line 2295
  return (tmp);
}
}
#line 2309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_ctlr_alloc(struct net_device *netdev ) 
{ 
  int tmp ;

  {
#line 2311
  tmp = _bnx2fc_create(netdev, 4, 0);
#line 2311
  return (tmp);
}
}
#line 2321 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct bnx2fc_hba *bnx2fc_find_hba_for_cnic(struct cnic_dev *cnic ) 
{ 
  struct bnx2fc_hba *hba ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 2326
  __mptr = (struct list_head  const  *)adapter_list.next;
#line 2326
  hba = (struct bnx2fc_hba *)__mptr;
#line 2326
  goto ldv_55560;
  ldv_55559: ;
#line 2327
  if ((unsigned long )hba->cnic == (unsigned long )cnic) {
#line 2328
    return (hba);
  } else {

  }
#line 2326
  __mptr___0 = (struct list_head  const  *)hba->list.next;
#line 2326
  hba = (struct bnx2fc_hba *)__mptr___0;
  ldv_55560: ;
#line 2326
  if ((unsigned long )(& hba->list) != (unsigned long )(& adapter_list)) {
#line 2328
    goto ldv_55559;
  } else {

  }

#line 2330
  return ((struct bnx2fc_hba *)0);
}
}
#line 2333 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct bnx2fc_interface *bnx2fc_interface_lookup(struct net_device *netdev ) 
{ 
  struct bnx2fc_interface *interface ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 2339
  __mptr = (struct list_head  const  *)if_list.next;
#line 2339
  interface = (struct bnx2fc_interface *)__mptr;
#line 2339
  goto ldv_55571;
  ldv_55570: ;
#line 2340
  if ((unsigned long )interface->netdev == (unsigned long )netdev) {
#line 2341
    return (interface);
  } else {

  }
#line 2339
  __mptr___0 = (struct list_head  const  *)interface->list.next;
#line 2339
  interface = (struct bnx2fc_interface *)__mptr___0;
  ldv_55571: ;
#line 2339
  if ((unsigned long )(& interface->list) != (unsigned long )(& if_list)) {
#line 2341
    goto ldv_55570;
  } else {

  }

#line 2343
  return ((struct bnx2fc_interface *)0);
}
}
#line 2346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct bnx2fc_hba *bnx2fc_hba_lookup(struct net_device *phys_dev ) 
{ 
  struct bnx2fc_hba *hba ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 2352
  __mptr = (struct list_head  const  *)adapter_list.next;
#line 2352
  hba = (struct bnx2fc_hba *)__mptr;
#line 2352
  goto ldv_55582;
  ldv_55581: ;
#line 2353
  if ((unsigned long )hba->phys_dev == (unsigned long )phys_dev) {
#line 2354
    return (hba);
  } else {

  }
#line 2352
  __mptr___0 = (struct list_head  const  *)hba->list.next;
#line 2352
  hba = (struct bnx2fc_hba *)__mptr___0;
  ldv_55582: ;
#line 2352
  if ((unsigned long )(& hba->list) != (unsigned long )(& adapter_list)) {
#line 2354
    goto ldv_55581;
  } else {

  }
#line 2356
  printk("\vbnx2fc: adapter_lookup: hba NULL\n");
#line 2357
  return ((struct bnx2fc_hba *)0);
}
}
#line 2365 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_ulp_exit(struct cnic_dev *dev ) 
{ 
  struct bnx2fc_hba *hba ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_interface *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int tmp___2 ;

  {
#line 2370
  tmp___0 = ldv__builtin_expect((bnx2fc_debug_level & 16U) != 0U, 0L);
#line 2370
  if (tmp___0 != 0L) {
#line 2370
    printk("\016bnx2fc: Entered bnx2fc_ulp_exit\n");
  } else {

  }
#line 2372
  tmp___1 = constant_test_bit(4L, (unsigned long const volatile   *)(& dev->flags));
#line 2372
  if (tmp___1 == 0) {
#line 2373
    printk("\vbnx2fc: bnx2fc port check: %s, flags: %lx\n", (char *)(& (dev->netdev)->name),
           dev->flags);
#line 2375
    return;
  } else {

  }
#line 2378
  mutex_lock_nested(& bnx2fc_dev_lock, 0U);
#line 2379
  hba = bnx2fc_find_hba_for_cnic(dev);
#line 2380
  if ((unsigned long )hba == (unsigned long )((struct bnx2fc_hba *)0)) {
#line 2381
    printk("\vbnx2fc: bnx2fc_ulp_exit: hba not found, dev 0%p\n", dev);
#line 2383
    mutex_unlock(& bnx2fc_dev_lock);
#line 2384
    return;
  } else {

  }
#line 2387
  list_del_init(& hba->list);
#line 2388
  adapter_count = adapter_count - 1U;
#line 2390
  __mptr = (struct list_head  const  *)if_list.next;
#line 2390
  interface = (struct bnx2fc_interface *)__mptr;
#line 2390
  __mptr___0 = (struct list_head  const  *)interface->list.next;
#line 2390
  tmp = (struct bnx2fc_interface *)__mptr___0;
#line 2390
  goto ldv_55597;
  ldv_55596: ;
#line 2392
  if ((unsigned long )interface->hba == (unsigned long )hba) {
#line 2393
    __bnx2fc_destroy(interface);
  } else {

  }
#line 2390
  interface = tmp;
#line 2390
  __mptr___1 = (struct list_head  const  *)tmp->list.next;
#line 2390
  tmp = (struct bnx2fc_interface *)__mptr___1;
  ldv_55597: ;
#line 2390
  if ((unsigned long )(& interface->list) != (unsigned long )(& if_list)) {
#line 2392
    goto ldv_55596;
  } else {

  }
#line 2394
  mutex_unlock(& bnx2fc_dev_lock);
#line 2397
  ldv_flush_workqueue_42(bnx2fc_wq);
#line 2399
  bnx2fc_ulp_stop((void *)hba);
#line 2401
  tmp___2 = test_and_clear_bit(1L, (unsigned long volatile   *)(& hba->reg_with_cnic));
#line 2401
  if (tmp___2 != 0) {
#line 2402
    (*((hba->cnic)->unregister_device))(hba->cnic, 2);
  } else {

  }
#line 2403
  bnx2fc_hba_destroy(hba);
#line 2404
  return;
}
}
#line 2413 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_fcoe_reset(struct Scsi_Host *shost ) 
{ 
  struct fc_lport *lport ;
  void *tmp ;

  {
#line 2415
  tmp = shost_priv(shost);
#line 2415
  lport = (struct fc_lport *)tmp;
#line 2416
  fc_lport_reset(lport);
#line 2417
  return (0);
}
}
#line 2421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static bool bnx2fc_match(struct net_device *netdev ) 
{ 
  struct net_device *phys_dev ;
  struct bnx2fc_hba *tmp ;

  {
#line 2423
  phys_dev = netdev;
#line 2425
  mutex_lock_nested(& bnx2fc_dev_lock, 0U);
#line 2426
  if ((int )netdev->priv_flags & 1) {
#line 2427
    phys_dev = vlan_dev_real_dev((struct net_device  const  *)netdev);
  } else {

  }
#line 2429
  tmp = bnx2fc_hba_lookup(phys_dev);
#line 2429
  if ((unsigned long )tmp != (unsigned long )((struct bnx2fc_hba *)0)) {
#line 2430
    mutex_unlock(& bnx2fc_dev_lock);
#line 2431
    return (1);
  } else {

  }
#line 2434
  mutex_unlock(& bnx2fc_dev_lock);
#line 2435
  return (0);
}
}
#line 2439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct fcoe_transport bnx2fc_transport  = 
#line 2439
     {{'b', 'n', 'x', '2', 'f', 'c', '\000'}, 0, {& bnx2fc_transport.list, & bnx2fc_transport.list},
    & bnx2fc_match, & bnx2fc_ctlr_alloc, & bnx2fc_create, & bnx2fc_destroy, & bnx2fc_enable,
    & bnx2fc_disable};
#line 2457 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_percpu_thread_create(unsigned int cpu ) 
{ 
  struct bnx2fc_percpu_s *p ;
  struct task_struct *thread ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 2462
  __vpp_verify = (void const   *)0;
#line 2462
  __asm__  ("": "=r" (__ptr): "0" (& bnx2fc_percpu));
#line 2462
  p = (struct bnx2fc_percpu_s *)(__per_cpu_offset[cpu] + __ptr);
#line 2464
  tmp = __cpu_to_node((int )cpu);
#line 2464
  thread = kthread_create_on_node(& bnx2fc_percpu_io_thread, (void *)p, tmp, "bnx2fc_thread/%d",
                                  cpu);
#line 2468
  tmp___0 = IS_ERR((void const   *)thread);
#line 2468
  if (tmp___0) {
#line 2468
    tmp___1 = 0;
  } else {
#line 2468
    tmp___1 = 1;
  }
#line 2468
  tmp___2 = ldv__builtin_expect((long )tmp___1, 1L);
#line 2468
  if (tmp___2 != 0L) {
#line 2469
    kthread_bind(thread, cpu);
#line 2470
    p->iothread = thread;
#line 2471
    wake_up_process(thread);
  } else {

  }
#line 2473
  return;
}
}
#line 2475 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_percpu_thread_destroy(unsigned int cpu ) 
{ 
  struct bnx2fc_percpu_s *p ;
  struct task_struct *thread ;
  struct bnx2fc_work *work ;
  struct bnx2fc_work *tmp ;
  long tmp___0 ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 2481
  tmp___0 = ldv__builtin_expect((bnx2fc_debug_level & 16U) != 0U, 0L);
#line 2481
  if (tmp___0 != 0L) {
#line 2481
    printk("\016bnx2fc: destroying io thread for CPU %d\n", cpu);
  } else {

  }
#line 2484
  __vpp_verify = (void const   *)0;
#line 2484
  __asm__  ("": "=r" (__ptr): "0" (& bnx2fc_percpu));
#line 2484
  p = (struct bnx2fc_percpu_s *)(__per_cpu_offset[cpu] + __ptr);
#line 2485
  spin_lock_bh(& p->fp_work_lock);
#line 2486
  thread = p->iothread;
#line 2487
  p->iothread = (struct task_struct *)0;
#line 2491
  __mptr = (struct list_head  const  *)p->work_list.next;
#line 2491
  work = (struct bnx2fc_work *)__mptr;
#line 2491
  __mptr___0 = (struct list_head  const  *)work->list.next;
#line 2491
  tmp = (struct bnx2fc_work *)__mptr___0;
#line 2491
  goto ldv_55635;
  ldv_55634: 
#line 2492
  list_del_init(& work->list);
#line 2493
  bnx2fc_process_cq_compl(work->tgt, (int )work->wqe);
#line 2494
  kfree((void const   *)work);
#line 2491
  work = tmp;
#line 2491
  __mptr___1 = (struct list_head  const  *)tmp->list.next;
#line 2491
  tmp = (struct bnx2fc_work *)__mptr___1;
  ldv_55635: ;
#line 2491
  if ((unsigned long )(& work->list) != (unsigned long )(& p->work_list)) {
#line 2493
    goto ldv_55634;
  } else {

  }
#line 2497
  spin_unlock_bh(& p->fp_work_lock);
#line 2499
  if ((unsigned long )thread != (unsigned long )((struct task_struct *)0)) {
#line 2500
    kthread_stop(thread);
  } else {

  }
#line 2501
  return;
}
}
#line 2514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_cpu_callback(struct notifier_block *nfb , unsigned long action ,
                               void *hcpu ) 
{ 
  unsigned int cpu ;

  {
#line 2517
  cpu = (unsigned int )((long )hcpu);
#line 2519
  switch (action) {
  case 2UL: ;
  case 18UL: 
#line 2522
  printk("bnx2fc: CPU %x online: Create Rx thread\n", cpu);
#line 2523
  bnx2fc_percpu_thread_create(cpu);
#line 2524
  goto ldv_55645;
  case 7UL: ;
  case 23UL: 
#line 2527
  printk("bnx2fc: CPU %x offline: Remove Rx thread\n", cpu);
#line 2528
  bnx2fc_percpu_thread_destroy(cpu);
#line 2529
  goto ldv_55645;
  default: ;
#line 2531
  goto ldv_55645;
  }
  ldv_55645: ;
#line 2533
  return (1);
}
}
#line 2542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static int bnx2fc_mod_init(void) 
{ 
  struct fcoe_percpu_s *bg ;
  struct task_struct *l2_thread ;
  int rc ;
  unsigned int cpu ;
  struct bnx2fc_percpu_s *p ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp ;
  long tmp___0 ;
  bool tmp___1 ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  struct lock_class_key __key___1 ;

  {
#line 2546
  rc = 0;
#line 2547
  cpu = 0U;
#line 2550
  printk("\016bnx2fc: %s", (char *)(& version));
#line 2553
  rc = fcoe_transport_attach(& bnx2fc_transport);
#line 2554
  if (rc != 0) {
#line 2555
    printk("\vfailed to register an fcoe transport, check if libfcoe is loaded\n");
#line 2557
    goto out;
  } else {

  }
#line 2560
  INIT_LIST_HEAD(& adapter_list);
#line 2561
  INIT_LIST_HEAD(& if_list);
#line 2562
  __mutex_init(& bnx2fc_dev_lock, "&bnx2fc_dev_lock", & __key);
#line 2563
  adapter_count = 0U;
#line 2566
  rc = bnx2fc_attach_transport();
#line 2567
  if (rc != 0) {
#line 2568
    goto detach_ft;
  } else {

  }
#line 2570
  __lock_name = "\"bnx2fc\"";
#line 2570
  tmp = __alloc_workqueue_key("bnx2fc", 0U, 0, & __key___0, __lock_name);
#line 2570
  bnx2fc_wq = tmp;
#line 2571
  if ((unsigned long )bnx2fc_wq == (unsigned long )((struct workqueue_struct *)0)) {
#line 2572
    rc = -12;
#line 2573
    goto release_bt;
  } else {

  }
#line 2576
  bg = & bnx2fc_global;
#line 2577
  skb_queue_head_init(& bg->fcoe_rx_list);
#line 2578
  l2_thread = kthread_create_on_node(& bnx2fc_l2_rcv_thread, (void *)bg, -1, "bnx2fc_l2_thread");
#line 2581
  tmp___1 = IS_ERR((void const   *)l2_thread);
#line 2581
  if ((int )tmp___1) {
#line 2582
    tmp___0 = PTR_ERR((void const   *)l2_thread);
#line 2582
    rc = (int )tmp___0;
#line 2583
    goto free_wq;
  } else {

  }
#line 2585
  wake_up_process(l2_thread);
#line 2586
  spin_lock_bh(& bg->fcoe_rx_list.lock);
#line 2587
  bg->thread = l2_thread;
#line 2588
  spin_unlock_bh(& bg->fcoe_rx_list.lock);
#line 2590
  cpu = 4294967295U;
#line 2590
  goto ldv_55671;
  ldv_55670: 
#line 2591
  __vpp_verify = (void const   *)0;
#line 2591
  __asm__  ("": "=r" (__ptr): "0" (& bnx2fc_percpu));
#line 2591
  p = (struct bnx2fc_percpu_s *)(__per_cpu_offset[cpu] + __ptr);
#line 2592
  INIT_LIST_HEAD(& p->work_list);
#line 2593
  spinlock_check(& p->fp_work_lock);
#line 2593
  __raw_spin_lock_init(& p->fp_work_lock.__annonCompField18.rlock, "&(&p->fp_work_lock)->rlock",
                       & __key___1);
  ldv_55671: 
#line 2590
  cpu = cpumask_next((int )cpu, cpu_possible_mask);
#line 2590
  if ((unsigned int )nr_cpu_ids > cpu) {
#line 2592
    goto ldv_55670;
  } else {

  }
#line 2596
  cpu_maps_update_begin();
#line 2598
  cpu = 4294967295U;
#line 2598
  goto ldv_55674;
  ldv_55673: 
#line 2599
  bnx2fc_percpu_thread_create(cpu);
  ldv_55674: 
#line 2598
  cpu = cpumask_next((int )cpu, cpu_online_mask);
#line 2598
  if ((unsigned int )nr_cpu_ids > cpu) {
#line 2600
    goto ldv_55673;
  } else {

  }
#line 2603
  __register_cpu_notifier(& bnx2fc_cpu_notifier);
#line 2605
  cpu_maps_update_done();
#line 2607
  cnic_register_driver(2, & bnx2fc_cnic_cb);
#line 2609
  return (0);
  free_wq: 
#line 2612
  ldv_destroy_workqueue_43(bnx2fc_wq);
  release_bt: 
#line 2614
  bnx2fc_release_transport();
  detach_ft: 
#line 2616
  fcoe_transport_detach(& bnx2fc_transport);
  out: ;
#line 2618
  return (rc);
}
}
#line 2621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static void bnx2fc_mod_exit(void) 
{ 
  struct list_head to_be_deleted ;
  struct bnx2fc_hba *hba ;
  struct bnx2fc_hba *next ;
  struct fcoe_percpu_s *bg ;
  struct task_struct *l2_thread ;
  struct sk_buff *skb ;
  unsigned int cpu ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp ;
  struct list_head  const  *__mptr___1 ;

  {
#line 2623
  to_be_deleted.next = & to_be_deleted;
#line 2623
  to_be_deleted.prev = & to_be_deleted;
#line 2628
  cpu = 0U;
#line 2636
  mutex_lock_nested(& bnx2fc_dev_lock, 0U);
#line 2637
  list_splice((struct list_head  const  *)(& adapter_list), & to_be_deleted);
#line 2638
  INIT_LIST_HEAD(& adapter_list);
#line 2639
  adapter_count = 0U;
#line 2640
  mutex_unlock(& bnx2fc_dev_lock);
#line 2643
  __mptr = (struct list_head  const  *)to_be_deleted.next;
#line 2643
  hba = (struct bnx2fc_hba *)__mptr;
#line 2643
  __mptr___0 = (struct list_head  const  *)hba->list.next;
#line 2643
  next = (struct bnx2fc_hba *)__mptr___0;
#line 2643
  goto ldv_55693;
  ldv_55692: 
#line 2644
  list_del_init(& hba->list);
#line 2645
  printk("\vbnx2fc: MOD_EXIT:destroy hba = 0x%p\n", hba);
#line 2647
  bnx2fc_ulp_stop((void *)hba);
#line 2649
  tmp = test_and_clear_bit(1L, (unsigned long volatile   *)(& hba->reg_with_cnic));
#line 2649
  if (tmp != 0) {
#line 2651
    (*((hba->cnic)->unregister_device))(hba->cnic, 2);
  } else {

  }
#line 2653
  bnx2fc_hba_destroy(hba);
#line 2643
  hba = next;
#line 2643
  __mptr___1 = (struct list_head  const  *)next->list.next;
#line 2643
  next = (struct bnx2fc_hba *)__mptr___1;
  ldv_55693: ;
#line 2643
  if ((unsigned long )(& hba->list) != (unsigned long )(& to_be_deleted)) {
#line 2645
    goto ldv_55692;
  } else {

  }
#line 2655
  cnic_unregister_driver(2);
#line 2658
  bg = & bnx2fc_global;
#line 2659
  spin_lock_bh(& bg->fcoe_rx_list.lock);
#line 2660
  l2_thread = bg->thread;
#line 2661
  bg->thread = (struct task_struct *)0;
#line 2662
  goto ldv_55696;
  ldv_55695: 
#line 2663
  kfree_skb(skb);
  ldv_55696: 
#line 2662
  skb = __skb_dequeue(& bg->fcoe_rx_list);
#line 2662
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 2664
    goto ldv_55695;
  } else {

  }
#line 2665
  spin_unlock_bh(& bg->fcoe_rx_list.lock);
#line 2667
  if ((unsigned long )l2_thread != (unsigned long )((struct task_struct *)0)) {
#line 2668
    kthread_stop(l2_thread);
  } else {

  }
#line 2670
  cpu_maps_update_begin();
#line 2673
  cpu = 4294967295U;
#line 2673
  goto ldv_55699;
  ldv_55698: 
#line 2674
  bnx2fc_percpu_thread_destroy(cpu);
  ldv_55699: 
#line 2673
  cpu = cpumask_next((int )cpu, cpu_online_mask);
#line 2673
  if ((unsigned int )nr_cpu_ids > cpu) {
#line 2675
    goto ldv_55698;
  } else {

  }
#line 2677
  __unregister_cpu_notifier(& bnx2fc_cpu_notifier);
#line 2679
  cpu_maps_update_done();
#line 2681
  ldv_destroy_workqueue_44(bnx2fc_wq);
#line 2686
  bnx2fc_release_transport();
#line 2689
  fcoe_transport_detach(& bnx2fc_transport);
#line 2690
  return;
}
}
#line 2695 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct fcoe_sysfs_function_template bnx2fc_fcoe_sysfs_templ  = 
#line 2695
     {& fcoe_ctlr_get_lesb, & fcoe_ctlr_get_lesb, & fcoe_ctlr_get_lesb, & fcoe_ctlr_get_lesb,
    & fcoe_ctlr_get_lesb, & fcoe_ctlr_get_lesb, 0, & bnx2fc_ctlr_enabled, & fcoe_fcf_get_selected,
    & bnx2fc_fcf_get_vlan_id};
#line 2708 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct fc_function_template bnx2fc_transport_function  = 
#line 2708
     {0, & fc_set_rport_loss_tmo, 0, 0, 0, 0, 0, & fc_get_host_port_state, 0, & fc_get_host_speed,
    0, 0, 0, & bnx2fc_get_host_stats, 0, & bnx2fc_fcoe_reset, 0, & fc_rport_terminate_io,
    0, & bnx2fc_vport_create, & bnx2fc_vport_disable, & bnx2fc_vport_destroy, 0, 0,
    & fc_lport_bsg_request, 0, 3160U, 0U, 0U, 1U, 1U, 1U, 1U, 1U, 1U, 1U, 1U, (unsigned char)0,
    1U, 1U, 1U, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U, 1U,
    1U, 1U, 1U, 1U, 1U, (unsigned char)0, (unsigned char)0};
#line 2748 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct fc_function_template bnx2fc_vport_xport_function  = 
#line 2748
     {0, & fc_set_rport_loss_tmo, 0, 0, 0, 0, 0, & fc_get_host_port_state, 0, & fc_get_host_speed,
    0, 0, 0, & fc_get_host_stats, 0, & bnx2fc_fcoe_reset, 0, & fc_rport_terminate_io,
    0, 0, 0, 0, 0, 0, & fc_lport_bsg_request, 0, 3160U, 0U, 0U, 1U, 1U, 1U, 1U, 1U,
    1U, 1U, 1U, (unsigned char)0, 1U, 1U, 1U, 1U, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, 1U, 1U, 1U, 1U, 1U, 1U, 1U, (unsigned char)0, (unsigned char)0};
#line 2785 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct scsi_host_template bnx2fc_shost_template  = 
#line 2785
     {& __this_module, "QLogic Offload FCoE Initiator", 0, 0, 0, 0, 0, & bnx2fc_queuecommand,
    & bnx2fc_eh_abort, & bnx2fc_eh_device_reset, & bnx2fc_eh_target_reset, 0, & fc_eh_host_reset,
    & fc_slave_alloc, 0, 0, 0, 0, 0, 0, & scsi_change_queue_depth, 0, 0, 0, 0, 0,
    0, 0, 0, 0, -1, 256U, (unsigned short)0, 1024U, 0UL, 3, (unsigned char)0, 0, 1U,
    1U, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, 0U, 0, 0, {0, 0}, 0ULL, 0U, 0, (_Bool)0};
#line 2804 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct libfc_function_template bnx2fc_libfc_fcn_templ  = 
#line 2804
     {& bnx2fc_xmit, & bnx2fc_elsct_send, 0, 0, 0, 0, & fcoe_get_lesb, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & bnx2fc_rport_event_handler, 0, & bnx2fc_cleanup,
    & bnx2fc_abort_io, 0, 0, 0, 0};
#line 2817 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c"
static struct cnic_ulp_ops bnx2fc_cnic_cb  = 
#line 2817
     {& bnx2fc_ulp_init, & bnx2fc_ulp_exit, & bnx2fc_ulp_start, & bnx2fc_ulp_stop, & bnx2fc_indicate_kcqe,
    & bnx2fc_indicate_netevent, 0, 0, 0, 0, 0, 0, & bnx2fc_ulp_get_stats, & __this_module,
    {0}};
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_retval_0  ;
#line 155
extern void ldv_initialize(void) ;
#line 156
void ldv_check_final_state(void) ;
#line 159 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void call_and_disable_work_1(struct work_struct *work ) 
{ 


  {
#line 162
  if ((ldv_work_1_0 == 2 || ldv_work_1_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_0) {
#line 164
    bnx2fc_destroy_work(work);
#line 165
    ldv_work_1_0 = 1;
#line 166
    return;
  } else {

  }
#line 168
  if ((ldv_work_1_1 == 2 || ldv_work_1_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_1) {
#line 170
    bnx2fc_destroy_work(work);
#line 171
    ldv_work_1_1 = 1;
#line 172
    return;
  } else {

  }
#line 174
  if ((ldv_work_1_2 == 2 || ldv_work_1_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_2) {
#line 176
    bnx2fc_destroy_work(work);
#line 177
    ldv_work_1_2 = 1;
#line 178
    return;
  } else {

  }
#line 180
  if ((ldv_work_1_3 == 2 || ldv_work_1_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_3) {
#line 182
    bnx2fc_destroy_work(work);
#line 183
    ldv_work_1_3 = 1;
#line 184
    return;
  } else {

  }
#line 186
  return;
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int reg_timer_7(struct timer_list *timer ) 
{ 


  {
#line 190
  ldv_timer_list_7 = timer;
#line 191
  ldv_timer_state_7 = 1;
#line 192
  return (0);
}
}
#line 195 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_initialize_fc_function_template_11(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 196
  tmp = ldv_init_zalloc(3816UL);
#line 196
  bnx2fc_vport_xport_function_group0 = (struct Scsi_Host *)tmp;
#line 197
  tmp___0 = ldv_init_zalloc(2208UL);
#line 197
  bnx2fc_vport_xport_function_group1 = (struct fc_rport *)tmp___0;
#line 198
  return;
}
}
#line 200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 201
  if ((unsigned long )ldv_timer_list_4_0 == (unsigned long )timer) {
#line 202
    if (ldv_timer_4_0 == 2 || pending_flag != 0) {
#line 203
      ldv_timer_list_4_0 = timer;
#line 204
      ldv_timer_list_4_0->data = data;
#line 205
      ldv_timer_4_0 = 1;
    } else {

    }
#line 207
    return;
  } else {

  }
#line 210
  if ((unsigned long )ldv_timer_list_4_1 == (unsigned long )timer) {
#line 211
    if (ldv_timer_4_1 == 2 || pending_flag != 0) {
#line 212
      ldv_timer_list_4_1 = timer;
#line 213
      ldv_timer_list_4_1->data = data;
#line 214
      ldv_timer_4_1 = 1;
    } else {

    }
#line 216
    return;
  } else {

  }
#line 219
  if ((unsigned long )ldv_timer_list_4_2 == (unsigned long )timer) {
#line 220
    if (ldv_timer_4_2 == 2 || pending_flag != 0) {
#line 221
      ldv_timer_list_4_2 = timer;
#line 222
      ldv_timer_list_4_2->data = data;
#line 223
      ldv_timer_4_2 = 1;
    } else {

    }
#line 225
    return;
  } else {

  }
#line 228
  if ((unsigned long )ldv_timer_list_4_3 == (unsigned long )timer) {
#line 229
    if (ldv_timer_4_3 == 2 || pending_flag != 0) {
#line 230
      ldv_timer_list_4_3 = timer;
#line 231
      ldv_timer_list_4_3->data = data;
#line 232
      ldv_timer_4_3 = 1;
    } else {

    }
#line 234
    return;
  } else {

  }
#line 236
  activate_suitable_timer_4(timer, data);
#line 237
  return;
}
}
#line 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void timer_init_4(void) 
{ 


  {
#line 241
  ldv_timer_4_0 = 0;
#line 242
  ldv_timer_4_1 = 0;
#line 243
  ldv_timer_4_2 = 0;
#line 244
  ldv_timer_4_3 = 0;
#line 245
  return;
}
}
#line 248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void activate_work_1(struct work_struct *work , int state ) 
{ 


  {
#line 249
  if (ldv_work_1_0 == 0) {
#line 250
    ldv_work_struct_1_0 = work;
#line 251
    ldv_work_1_0 = state;
#line 252
    return;
  } else {

  }
#line 255
  if (ldv_work_1_1 == 0) {
#line 256
    ldv_work_struct_1_1 = work;
#line 257
    ldv_work_1_1 = state;
#line 258
    return;
  } else {

  }
#line 261
  if (ldv_work_1_2 == 0) {
#line 262
    ldv_work_struct_1_2 = work;
#line 263
    ldv_work_1_2 = state;
#line 264
    return;
  } else {

  }
#line 267
  if (ldv_work_1_3 == 0) {
#line 268
    ldv_work_struct_1_3 = work;
#line 269
    ldv_work_1_3 = state;
#line 270
    return;
  } else {

  }
#line 272
  return;
}
}
#line 275 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void disable_work_1(struct work_struct *work ) 
{ 


  {
#line 277
  if ((ldv_work_1_0 == 3 || ldv_work_1_0 == 2) && (unsigned long )ldv_work_struct_1_0 == (unsigned long )work) {
#line 279
    ldv_work_1_0 = 1;
  } else {

  }
#line 281
  if ((ldv_work_1_1 == 3 || ldv_work_1_1 == 2) && (unsigned long )ldv_work_struct_1_1 == (unsigned long )work) {
#line 283
    ldv_work_1_1 = 1;
  } else {

  }
#line 285
  if ((ldv_work_1_2 == 3 || ldv_work_1_2 == 2) && (unsigned long )ldv_work_struct_1_2 == (unsigned long )work) {
#line 287
    ldv_work_1_2 = 1;
  } else {

  }
#line 289
  if ((ldv_work_1_3 == 3 || ldv_work_1_3 == 2) && (unsigned long )ldv_work_struct_1_3 == (unsigned long )work) {
#line 291
    ldv_work_1_3 = 1;
  } else {

  }
#line 292
  return;
}
}
#line 296 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void work_init_1(void) 
{ 


  {
#line 297
  ldv_work_1_0 = 0;
#line 298
  ldv_work_1_1 = 0;
#line 299
  ldv_work_1_2 = 0;
#line 300
  ldv_work_1_3 = 0;
#line 301
  return;
}
}
#line 304 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_initialize_fcoe_sysfs_function_template_13(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 305
  tmp = ldv_init_zalloc(1712UL);
#line 305
  bnx2fc_fcoe_sysfs_templ_group0 = (struct fcoe_ctlr_device *)tmp;
#line 306
  tmp___0 = ldv_init_zalloc(1808UL);
#line 306
  bnx2fc_fcoe_sysfs_templ_group1 = (struct fcoe_fcf_device *)tmp___0;
#line 307
  return;
}
}
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_initialize_cnic_ulp_ops_8(void) 
{ 
  void *tmp ;

  {
#line 310
  tmp = ldv_init_zalloc(192UL);
#line 310
  bnx2fc_cnic_cb_group0 = (struct cnic_dev *)tmp;
#line 311
  return;
}
}
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void activate_suitable_timer_4(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 314
  if (ldv_timer_4_0 == 0 || ldv_timer_4_0 == 2) {
#line 315
    ldv_timer_list_4_0 = timer;
#line 316
    ldv_timer_list_4_0->data = data;
#line 317
    ldv_timer_4_0 = 1;
#line 318
    return;
  } else {

  }
#line 320
  if (ldv_timer_4_1 == 0 || ldv_timer_4_1 == 2) {
#line 321
    ldv_timer_list_4_1 = timer;
#line 322
    ldv_timer_list_4_1->data = data;
#line 323
    ldv_timer_4_1 = 1;
#line 324
    return;
  } else {

  }
#line 326
  if (ldv_timer_4_2 == 0 || ldv_timer_4_2 == 2) {
#line 327
    ldv_timer_list_4_2 = timer;
#line 328
    ldv_timer_list_4_2->data = data;
#line 329
    ldv_timer_4_2 = 1;
#line 330
    return;
  } else {

  }
#line 332
  if (ldv_timer_4_3 == 0 || ldv_timer_4_3 == 2) {
#line 333
    ldv_timer_list_4_3 = timer;
#line 334
    ldv_timer_list_4_3->data = data;
#line 335
    ldv_timer_4_3 = 1;
#line 336
    return;
  } else {

  }
#line 338
  return;
}
}
#line 342 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void disable_suitable_timer_7(struct timer_list *timer ) 
{ 


  {
#line 343
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_7) {
#line 344
    ldv_timer_state_7 = 0;
#line 345
    return;
  } else {

  }
#line 347
  return;
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void call_and_disable_all_1(int state ) 
{ 


  {
#line 352
  if (ldv_work_1_0 == state) {
#line 353
    call_and_disable_work_1(ldv_work_struct_1_0);
  } else {

  }
#line 354
  if (ldv_work_1_1 == state) {
#line 355
    call_and_disable_work_1(ldv_work_struct_1_1);
  } else {

  }
#line 356
  if (ldv_work_1_2 == state) {
#line 357
    call_and_disable_work_1(ldv_work_struct_1_2);
  } else {

  }
#line 358
  if (ldv_work_1_3 == state) {
#line 359
    call_and_disable_work_1(ldv_work_struct_1_3);
  } else {

  }
#line 360
  return;
}
}
#line 363 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_initialize_scsi_host_template_10(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 364
  tmp = __VERIFIER_nondet_pointer();
#line 364
  bnx2fc_shost_template_group0 = (struct scsi_cmnd *)tmp;
#line 365
  tmp___0 = __VERIFIER_nondet_pointer();
#line 365
  bnx2fc_shost_template_group1 = (struct scsi_device *)tmp___0;
#line 366
  return;
}
}
#line 368 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_initialize_libfc_function_template_9(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 369
  tmp = ldv_init_zalloc(232UL);
#line 369
  bnx2fc_libfc_fcn_templ_group0 = (struct fc_frame *)tmp;
#line 370
  tmp___0 = ldv_init_zalloc(1688UL);
#line 370
  bnx2fc_libfc_fcn_templ_group1 = (struct fc_lport *)tmp___0;
#line 371
  return;
}
}
#line 373 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_initialize_fc_function_template_12(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 374
  tmp = ldv_init_zalloc(3816UL);
#line 374
  bnx2fc_transport_function_group0 = (struct Scsi_Host *)tmp;
#line 375
  tmp___0 = ldv_init_zalloc(1648UL);
#line 375
  bnx2fc_transport_function_group1 = (struct fc_vport *)tmp___0;
#line 376
  tmp___1 = ldv_init_zalloc(2208UL);
#line 376
  bnx2fc_transport_function_group2 = (struct fc_rport *)tmp___1;
#line 377
  return;
}
}
#line 379 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void choose_timer_4(void) 
{ 
  int tmp ;

  {
#line 380
  tmp = __VERIFIER_nondet_int();
#line 380
  switch (tmp) {
  case 0: ;
#line 382
  if (ldv_timer_4_0 == 1) {
#line 383
    ldv_timer_4_0 = 2;
#line 384
    ldv_timer_4(ldv_timer_4_0, ldv_timer_list_4_0);
  } else {

  }
#line 387
  goto ldv_55780;
  case 1: ;
#line 389
  if (ldv_timer_4_1 == 1) {
#line 390
    ldv_timer_4_1 = 2;
#line 391
    ldv_timer_4(ldv_timer_4_1, ldv_timer_list_4_1);
  } else {

  }
#line 394
  goto ldv_55780;
  case 2: ;
#line 396
  if (ldv_timer_4_2 == 1) {
#line 397
    ldv_timer_4_2 = 2;
#line 398
    ldv_timer_4(ldv_timer_4_2, ldv_timer_list_4_2);
  } else {

  }
#line 401
  goto ldv_55780;
  case 3: ;
#line 403
  if (ldv_timer_4_3 == 1) {
#line 404
    ldv_timer_4_3 = 2;
#line 405
    ldv_timer_4(ldv_timer_4_3, ldv_timer_list_4_3);
  } else {

  }
#line 408
  goto ldv_55780;
  default: 
#line 409
  ldv_stop();
  }
  ldv_55780: ;
#line 411
  return;
}
}
#line 415 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void disable_suitable_timer_4(struct timer_list *timer ) 
{ 


  {
#line 416
  if (ldv_timer_4_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_0) {
#line 417
    ldv_timer_4_0 = 0;
#line 418
    return;
  } else {

  }
#line 420
  if (ldv_timer_4_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_1) {
#line 421
    ldv_timer_4_1 = 0;
#line 422
    return;
  } else {

  }
#line 424
  if (ldv_timer_4_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_2) {
#line 425
    ldv_timer_4_2 = 0;
#line 426
    return;
  } else {

  }
#line 428
  if (ldv_timer_4_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_3) {
#line 429
    ldv_timer_4_3 = 0;
#line 430
    return;
  } else {

  }
#line 432
  return;
}
}
#line 436 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int reg_timer_4(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 437
  if ((unsigned long )function == (unsigned long )(& fcoe_queue_timer)) {
#line 438
    activate_suitable_timer_4(timer, data);
  } else {

  }
#line 439
  return (0);
}
}
#line 443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void invoke_work_1(void) 
{ 
  int tmp ;

  {
#line 445
  tmp = __VERIFIER_nondet_int();
#line 445
  switch (tmp) {
  case 0: ;
#line 447
  if (ldv_work_1_0 == 2 || ldv_work_1_0 == 3) {
#line 448
    ldv_work_1_0 = 4;
#line 449
    bnx2fc_destroy_work(ldv_work_struct_1_0);
#line 450
    ldv_work_1_0 = 1;
  } else {

  }
#line 453
  goto ldv_55800;
  case 1: ;
#line 455
  if (ldv_work_1_1 == 2 || ldv_work_1_1 == 3) {
#line 456
    ldv_work_1_1 = 4;
#line 457
    bnx2fc_destroy_work(ldv_work_struct_1_0);
#line 458
    ldv_work_1_1 = 1;
  } else {

  }
#line 461
  goto ldv_55800;
  case 2: ;
#line 463
  if (ldv_work_1_2 == 2 || ldv_work_1_2 == 3) {
#line 464
    ldv_work_1_2 = 4;
#line 465
    bnx2fc_destroy_work(ldv_work_struct_1_0);
#line 466
    ldv_work_1_2 = 1;
  } else {

  }
#line 469
  goto ldv_55800;
  case 3: ;
#line 471
  if (ldv_work_1_3 == 2 || ldv_work_1_3 == 3) {
#line 472
    ldv_work_1_3 = 4;
#line 473
    bnx2fc_destroy_work(ldv_work_struct_1_0);
#line 474
    ldv_work_1_3 = 1;
  } else {

  }
#line 477
  goto ldv_55800;
  default: 
#line 478
  ldv_stop();
  }
  ldv_55800: ;
#line 480
  return;
}
}
#line 485 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void choose_timer_7(struct timer_list *timer ) 
{ 


  {
#line 486
  LDV_IN_INTERRUPT = 2;
#line 487
  (*(timer->function))(timer->data);
#line 488
  LDV_IN_INTERRUPT = 1;
#line 489
  ldv_timer_state_7 = 2;
#line 490
  return;
}
}
#line 493 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_initialize_fcoe_transport_14(void) 
{ 
  void *tmp ;

  {
#line 494
  tmp = ldv_init_zalloc(3008UL);
#line 494
  bnx2fc_transport_group0 = (struct net_device *)tmp;
#line 495
  return;
}
}
#line 497 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_timer_4(int state , struct timer_list *timer ) 
{ 


  {
#line 498
  LDV_IN_INTERRUPT = 2;
#line 499
  fcoe_queue_timer(timer->data);
#line 500
  LDV_IN_INTERRUPT = 1;
#line 501
  return;
}
}
#line 504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void activate_pending_timer_7(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 504
  if ((unsigned long )ldv_timer_list_7 == (unsigned long )timer) {
#line 505
    if (ldv_timer_state_7 == 2 || pending_flag != 0) {
#line 506
      ldv_timer_list_7 = timer;
#line 507
      ldv_timer_list_7->data = data;
#line 508
      ldv_timer_state_7 = 1;
    } else {

    }
#line 510
    return;
  } else {

  }
#line 512
  reg_timer_7(timer);
#line 513
  ldv_timer_list_7->data = data;
#line 514
  return;
}
}
#line 530 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int main(void) 
{ 
  u32 ldvarg1 ;
  struct fc_bsg_job *ldvarg0 ;
  void *tmp ;
  u32 ldvarg7 ;
  struct fc_rport_priv *ldvarg3 ;
  void *tmp___0 ;
  void *ldvarg5 ;
  void *tmp___1 ;
  unsigned int ldvarg6 ;
  u32 ldvarg8 ;
  struct fc_els_lesb *ldvarg4 ;
  void *tmp___2 ;
  void (*ldvarg9)(struct fc_seq * , struct fc_frame * , void * ) ;
  enum fc_rport_event ldvarg2 ;
  bool ldvarg11 ;
  u32 ldvarg13 ;
  bool ldvarg10 ;
  struct fc_bsg_job *ldvarg12 ;
  void *tmp___3 ;
  enum fip_state ldvarg14 ;
  unsigned long ldvarg17 ;
  void *ldvarg16 ;
  void *tmp___4 ;
  struct notifier_block *ldvarg15 ;
  void *tmp___5 ;
  struct kcqe **ldvarg24 ;
  void *tmp___6 ;
  void *ldvarg18 ;
  void *tmp___7 ;
  void *ldvarg26 ;
  void *tmp___8 ;
  u16 ldvarg20 ;
  u32 ldvarg23 ;
  unsigned long ldvarg21 ;
  void *ldvarg25 ;
  void *tmp___9 ;
  void *ldvarg22 ;
  void *tmp___10 ;
  void *ldvarg19 ;
  void *tmp___11 ;
  struct Scsi_Host *ldvarg27 ;
  void *tmp___12 ;
  int ldvarg28 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 534
  tmp = ldv_init_zalloc(184UL);
#line 534
  ldvarg0 = (struct fc_bsg_job *)tmp;
#line 536
  tmp___0 = ldv_init_zalloc(608UL);
#line 536
  ldvarg3 = (struct fc_rport_priv *)tmp___0;
#line 537
  tmp___1 = ldv_init_zalloc(1UL);
#line 537
  ldvarg5 = tmp___1;
#line 540
  tmp___2 = ldv_init_zalloc(24UL);
#line 540
  ldvarg4 = (struct fc_els_lesb *)tmp___2;
#line 546
  tmp___3 = ldv_init_zalloc(184UL);
#line 546
  ldvarg12 = (struct fc_bsg_job *)tmp___3;
#line 549
  tmp___4 = ldv_init_zalloc(1UL);
#line 549
  ldvarg16 = tmp___4;
#line 550
  tmp___5 = ldv_init_zalloc(24UL);
#line 550
  ldvarg15 = (struct notifier_block *)tmp___5;
#line 551
  tmp___6 = ldv_init_zalloc(8UL);
#line 551
  ldvarg24 = (struct kcqe **)tmp___6;
#line 552
  tmp___7 = ldv_init_zalloc(1UL);
#line 552
  ldvarg18 = tmp___7;
#line 553
  tmp___8 = ldv_init_zalloc(1UL);
#line 553
  ldvarg26 = tmp___8;
#line 557
  tmp___9 = ldv_init_zalloc(1UL);
#line 557
  ldvarg25 = tmp___9;
#line 558
  tmp___10 = ldv_init_zalloc(1UL);
#line 558
  ldvarg22 = tmp___10;
#line 559
  tmp___11 = ldv_init_zalloc(1UL);
#line 559
  ldvarg19 = tmp___11;
#line 560
  tmp___12 = ldv_init_zalloc(3816UL);
#line 560
  ldvarg27 = (struct Scsi_Host *)tmp___12;
#line 531
  ldv_initialize();
#line 533
  ldv_memset((void *)(& ldvarg1), 0, 4UL);
#line 535
  ldv_memset((void *)(& ldvarg7), 0, 4UL);
#line 538
  ldv_memset((void *)(& ldvarg6), 0, 4UL);
#line 539
  ldv_memset((void *)(& ldvarg8), 0, 4UL);
#line 541
  ldv_memset((void *)(& ldvarg9), 0, 8UL);
#line 542
  ldv_memset((void *)(& ldvarg2), 0, 4UL);
#line 543
  ldv_memset((void *)(& ldvarg11), 0, 1UL);
#line 544
  ldv_memset((void *)(& ldvarg13), 0, 4UL);
#line 545
  ldv_memset((void *)(& ldvarg10), 0, 1UL);
#line 547
  ldv_memset((void *)(& ldvarg14), 0, 4UL);
#line 548
  ldv_memset((void *)(& ldvarg17), 0, 8UL);
#line 554
  ldv_memset((void *)(& ldvarg20), 0, 2UL);
#line 555
  ldv_memset((void *)(& ldvarg23), 0, 4UL);
#line 556
  ldv_memset((void *)(& ldvarg21), 0, 8UL);
#line 561
  ldv_memset((void *)(& ldvarg28), 0, 4UL);
#line 563
  ldv_state_variable_11 = 0;
#line 565
  ldv_state_variable_7 = 1;
#line 567
  work_init_2();
#line 569
  ldv_state_variable_2 = 1;
#line 571
  work_init_1();
#line 573
  ldv_state_variable_1 = 1;
#line 574
  ref_cnt = 0;
#line 575
  ldv_state_variable_0 = 1;
#line 576
  ldv_state_variable_13 = 0;
#line 578
  timer_init_6();
#line 580
  ldv_state_variable_6 = 1;
#line 582
  work_init_3();
#line 584
  ldv_state_variable_3 = 1;
#line 585
  ldv_state_variable_9 = 0;
#line 586
  ldv_state_variable_12 = 0;
#line 587
  ldv_state_variable_14 = 0;
#line 588
  ldv_state_variable_15 = 0;
#line 589
  ldv_state_variable_8 = 0;
#line 591
  timer_init_4();
#line 593
  ldv_state_variable_4 = 1;
#line 594
  ldv_state_variable_10 = 0;
#line 596
  timer_init_5();
#line 598
  ldv_state_variable_5 = 1;
  ldv_55970: 
#line 600
  tmp___13 = __VERIFIER_nondet_int();
#line 600
  switch (tmp___13) {
  case 0: ;
#line 604
  if (ldv_state_variable_11 != 0) {
#line 605
    tmp___14 = __VERIFIER_nondet_int();
#line 605
    switch (tmp___14) {
    case 0: ;
#line 608
    if (ldv_state_variable_11 == 1) {
#line 610
      fc_get_host_speed(bnx2fc_vport_xport_function_group0);
#line 612
      ldv_state_variable_11 = 1;
    } else {

    }
#line 615
    goto ldv_55880;
    case 1: ;
#line 618
    if (ldv_state_variable_11 == 1) {
#line 620
      bnx2fc_fcoe_reset(bnx2fc_vport_xport_function_group0);
#line 622
      ldv_state_variable_11 = 1;
    } else {

    }
#line 625
    goto ldv_55880;
    case 2: ;
#line 628
    if (ldv_state_variable_11 == 1) {
#line 630
      fc_set_rport_loss_tmo(bnx2fc_vport_xport_function_group1, ldvarg1);
#line 632
      ldv_state_variable_11 = 1;
    } else {

    }
#line 635
    goto ldv_55880;
    case 3: ;
#line 638
    if (ldv_state_variable_11 == 1) {
#line 640
      fc_lport_bsg_request(ldvarg0);
#line 642
      ldv_state_variable_11 = 1;
    } else {

    }
#line 645
    goto ldv_55880;
    case 4: ;
#line 648
    if (ldv_state_variable_11 == 1) {
#line 650
      fc_get_host_stats(bnx2fc_vport_xport_function_group0);
#line 652
      ldv_state_variable_11 = 1;
    } else {

    }
#line 655
    goto ldv_55880;
    case 5: ;
#line 658
    if (ldv_state_variable_11 == 1) {
#line 660
      fc_rport_terminate_io(bnx2fc_vport_xport_function_group1);
#line 662
      ldv_state_variable_11 = 1;
    } else {

    }
#line 665
    goto ldv_55880;
    case 6: ;
#line 668
    if (ldv_state_variable_11 == 1) {
#line 670
      fc_get_host_port_state(bnx2fc_vport_xport_function_group0);
#line 672
      ldv_state_variable_11 = 1;
    } else {

    }
#line 675
    goto ldv_55880;
    default: 
#line 676
    ldv_stop();
    }
    ldv_55880: ;
  } else {

  }
#line 680
  goto ldv_55888;
  case 1: ;
#line 684
  if (ldv_state_variable_7 != 0) {
#line 685
    choose_timer_7(ldv_timer_list_7);
  } else {

  }
#line 688
  goto ldv_55888;
  case 2: ;
#line 695
  goto ldv_55888;
  case 3: ;
#line 699
  if (ldv_state_variable_1 != 0) {
#line 700
    invoke_work_1();
  } else {

  }
#line 703
  goto ldv_55888;
  case 4: ;
#line 707
  if (ldv_state_variable_0 != 0) {
#line 708
    tmp___15 = __VERIFIER_nondet_int();
#line 708
    switch (tmp___15) {
    case 0: ;
#line 711
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 713
      bnx2fc_mod_exit();
#line 714
      ldv_state_variable_0 = 2;
#line 715
      goto ldv_final;
    } else {

    }
#line 718
    goto ldv_55895;
    case 1: ;
#line 721
    if (ldv_state_variable_0 == 1) {
#line 723
      ldv_retval_0 = bnx2fc_mod_init();
#line 725
      if (ldv_retval_0 == 0) {
#line 726
        ldv_state_variable_0 = 3;
#line 727
        ldv_state_variable_14 = 1;
#line 728
        ldv_initialize_fcoe_transport_14();
#line 729
        ldv_state_variable_15 = 1;
#line 730
        ldv_state_variable_12 = 1;
#line 731
        ldv_initialize_fc_function_template_12();
#line 732
        ldv_state_variable_9 = 1;
#line 733
        ldv_initialize_libfc_function_template_9();
#line 734
        ldv_state_variable_13 = 1;
#line 735
        ldv_initialize_fcoe_sysfs_function_template_13();
#line 736
        ldv_state_variable_11 = 1;
#line 737
        ldv_initialize_fc_function_template_11();
#line 738
        ldv_state_variable_8 = 1;
#line 739
        ldv_initialize_cnic_ulp_ops_8();
      } else {

      }
#line 741
      if (ldv_retval_0 != 0) {
#line 742
        ldv_state_variable_0 = 2;
#line 743
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 747
    goto ldv_55895;
    default: 
#line 748
    ldv_stop();
    }
    ldv_55895: ;
  } else {

  }
#line 752
  goto ldv_55888;
  case 5: ;
#line 756
  if (ldv_state_variable_13 != 0) {
#line 757
    tmp___16 = __VERIFIER_nondet_int();
#line 757
    switch (tmp___16) {
    case 0: ;
#line 760
    if (ldv_state_variable_13 == 1) {
#line 762
      fcoe_ctlr_get_lesb(bnx2fc_fcoe_sysfs_templ_group0);
#line 764
      ldv_state_variable_13 = 1;
    } else {

    }
#line 767
    goto ldv_55900;
    case 1: ;
#line 770
    if (ldv_state_variable_13 == 1) {
#line 772
      fcoe_ctlr_get_lesb(bnx2fc_fcoe_sysfs_templ_group0);
#line 774
      ldv_state_variable_13 = 1;
    } else {

    }
#line 777
    goto ldv_55900;
    case 2: ;
#line 780
    if (ldv_state_variable_13 == 1) {
#line 782
      bnx2fc_ctlr_enabled(bnx2fc_fcoe_sysfs_templ_group0);
#line 784
      ldv_state_variable_13 = 1;
    } else {

    }
#line 787
    goto ldv_55900;
    case 3: ;
#line 790
    if (ldv_state_variable_13 == 1) {
#line 792
      fcoe_ctlr_get_lesb(bnx2fc_fcoe_sysfs_templ_group0);
#line 794
      ldv_state_variable_13 = 1;
    } else {

    }
#line 797
    goto ldv_55900;
    case 4: ;
#line 800
    if (ldv_state_variable_13 == 1) {
#line 802
      fcoe_ctlr_get_lesb(bnx2fc_fcoe_sysfs_templ_group0);
#line 804
      ldv_state_variable_13 = 1;
    } else {

    }
#line 807
    goto ldv_55900;
    case 5: ;
#line 810
    if (ldv_state_variable_13 == 1) {
#line 812
      fcoe_fcf_get_selected(bnx2fc_fcoe_sysfs_templ_group1);
#line 814
      ldv_state_variable_13 = 1;
    } else {

    }
#line 817
    goto ldv_55900;
    case 6: ;
#line 820
    if (ldv_state_variable_13 == 1) {
#line 822
      fcoe_ctlr_get_lesb(bnx2fc_fcoe_sysfs_templ_group0);
#line 824
      ldv_state_variable_13 = 1;
    } else {

    }
#line 827
    goto ldv_55900;
    case 7: ;
#line 830
    if (ldv_state_variable_13 == 1) {
#line 832
      bnx2fc_fcf_get_vlan_id(bnx2fc_fcoe_sysfs_templ_group1);
#line 834
      ldv_state_variable_13 = 1;
    } else {

    }
#line 837
    goto ldv_55900;
    case 8: ;
#line 840
    if (ldv_state_variable_13 == 1) {
#line 842
      fcoe_ctlr_get_lesb(bnx2fc_fcoe_sysfs_templ_group0);
#line 844
      ldv_state_variable_13 = 1;
    } else {

    }
#line 847
    goto ldv_55900;
    default: 
#line 848
    ldv_stop();
    }
    ldv_55900: ;
  } else {

  }
#line 852
  goto ldv_55888;
  case 6: ;
#line 859
  goto ldv_55888;
  case 7: ;
#line 866
  goto ldv_55888;
  case 8: ;
#line 870
  if (ldv_state_variable_9 != 0) {
#line 871
    tmp___17 = __VERIFIER_nondet_int();
#line 871
    switch (tmp___17) {
    case 0: ;
#line 874
    if (ldv_state_variable_9 == 1) {
#line 876
      bnx2fc_elsct_send(bnx2fc_libfc_fcn_templ_group1, ldvarg8, bnx2fc_libfc_fcn_templ_group0,
                        ldvarg6, ldvarg9, ldvarg5, ldvarg7);
#line 878
      ldv_state_variable_9 = 1;
    } else {

    }
#line 881
    goto ldv_55914;
    case 1: ;
#line 884
    if (ldv_state_variable_9 == 1) {
#line 886
      bnx2fc_abort_io(bnx2fc_libfc_fcn_templ_group1);
#line 888
      ldv_state_variable_9 = 1;
    } else {

    }
#line 891
    goto ldv_55914;
    case 2: ;
#line 894
    if (ldv_state_variable_9 == 1) {
#line 896
      fcoe_get_lesb(bnx2fc_libfc_fcn_templ_group1, ldvarg4);
#line 898
      ldv_state_variable_9 = 1;
    } else {

    }
#line 901
    goto ldv_55914;
    case 3: ;
#line 904
    if (ldv_state_variable_9 == 1) {
#line 906
      bnx2fc_rport_event_handler(bnx2fc_libfc_fcn_templ_group1, ldvarg3, ldvarg2);
#line 908
      ldv_state_variable_9 = 1;
    } else {

    }
#line 911
    goto ldv_55914;
    case 4: ;
#line 914
    if (ldv_state_variable_9 == 1) {
#line 916
      bnx2fc_xmit(bnx2fc_libfc_fcn_templ_group1, bnx2fc_libfc_fcn_templ_group0);
#line 918
      ldv_state_variable_9 = 1;
    } else {

    }
#line 921
    goto ldv_55914;
    case 5: ;
#line 924
    if (ldv_state_variable_9 == 1) {
#line 926
      bnx2fc_cleanup(bnx2fc_libfc_fcn_templ_group1);
#line 928
      ldv_state_variable_9 = 1;
    } else {

    }
#line 931
    goto ldv_55914;
    default: 
#line 932
    ldv_stop();
    }
    ldv_55914: ;
  } else {

  }
#line 936
  goto ldv_55888;
  case 9: ;
#line 940
  if (ldv_state_variable_12 != 0) {
#line 941
    tmp___18 = __VERIFIER_nondet_int();
#line 941
    switch (tmp___18) {
    case 0: ;
#line 944
    if (ldv_state_variable_12 == 1) {
#line 946
      fc_get_host_speed(bnx2fc_transport_function_group0);
#line 948
      ldv_state_variable_12 = 1;
    } else {

    }
#line 951
    goto ldv_55923;
    case 1: ;
#line 954
    if (ldv_state_variable_12 == 1) {
#line 956
      bnx2fc_fcoe_reset(bnx2fc_transport_function_group0);
#line 958
      ldv_state_variable_12 = 1;
    } else {

    }
#line 961
    goto ldv_55923;
    case 2: ;
#line 964
    if (ldv_state_variable_12 == 1) {
#line 966
      fc_set_rport_loss_tmo(bnx2fc_transport_function_group2, ldvarg13);
#line 968
      ldv_state_variable_12 = 1;
    } else {

    }
#line 971
    goto ldv_55923;
    case 3: ;
#line 974
    if (ldv_state_variable_12 == 1) {
#line 976
      bnx2fc_vport_destroy(bnx2fc_transport_function_group1);
#line 978
      ldv_state_variable_12 = 1;
    } else {

    }
#line 981
    goto ldv_55923;
    case 4: ;
#line 984
    if (ldv_state_variable_12 == 1) {
#line 986
      fc_lport_bsg_request(ldvarg12);
#line 988
      ldv_state_variable_12 = 1;
    } else {

    }
#line 991
    goto ldv_55923;
    case 5: ;
#line 994
    if (ldv_state_variable_12 == 1) {
#line 996
      bnx2fc_vport_create(bnx2fc_transport_function_group1, (int )ldvarg11);
#line 998
      ldv_state_variable_12 = 1;
    } else {

    }
#line 1001
    goto ldv_55923;
    case 6: ;
#line 1004
    if (ldv_state_variable_12 == 1) {
#line 1006
      bnx2fc_get_host_stats(bnx2fc_transport_function_group0);
#line 1008
      ldv_state_variable_12 = 1;
    } else {

    }
#line 1011
    goto ldv_55923;
    case 7: ;
#line 1014
    if (ldv_state_variable_12 == 1) {
#line 1016
      bnx2fc_vport_disable(bnx2fc_transport_function_group1, (int )ldvarg10);
#line 1018
      ldv_state_variable_12 = 1;
    } else {

    }
#line 1021
    goto ldv_55923;
    case 8: ;
#line 1024
    if (ldv_state_variable_12 == 1) {
#line 1026
      fc_rport_terminate_io(bnx2fc_transport_function_group2);
#line 1028
      ldv_state_variable_12 = 1;
    } else {

    }
#line 1031
    goto ldv_55923;
    case 9: ;
#line 1034
    if (ldv_state_variable_12 == 1) {
#line 1036
      fc_get_host_port_state(bnx2fc_transport_function_group0);
#line 1038
      ldv_state_variable_12 = 1;
    } else {

    }
#line 1041
    goto ldv_55923;
    default: 
#line 1042
    ldv_stop();
    }
    ldv_55923: ;
  } else {

  }
#line 1046
  goto ldv_55888;
  case 10: ;
#line 1050
  if (ldv_state_variable_14 != 0) {
#line 1051
    tmp___19 = __VERIFIER_nondet_int();
#line 1051
    switch (tmp___19) {
    case 0: ;
#line 1054
    if (ldv_state_variable_14 == 1) {
#line 1056
      bnx2fc_disable(bnx2fc_transport_group0);
#line 1058
      ldv_state_variable_14 = 1;
    } else {

    }
#line 1061
    goto ldv_55936;
    case 1: ;
#line 1064
    if (ldv_state_variable_14 == 1) {
#line 1066
      bnx2fc_destroy(bnx2fc_transport_group0);
#line 1068
      ldv_state_variable_14 = 1;
    } else {

    }
#line 1071
    goto ldv_55936;
    case 2: ;
#line 1074
    if (ldv_state_variable_14 == 1) {
#line 1076
      bnx2fc_match(bnx2fc_transport_group0);
#line 1078
      ldv_state_variable_14 = 1;
    } else {

    }
#line 1081
    goto ldv_55936;
    case 3: ;
#line 1084
    if (ldv_state_variable_14 == 1) {
#line 1086
      bnx2fc_ctlr_alloc(bnx2fc_transport_group0);
#line 1088
      ldv_state_variable_14 = 1;
    } else {

    }
#line 1091
    goto ldv_55936;
    case 4: ;
#line 1094
    if (ldv_state_variable_14 == 1) {
#line 1096
      bnx2fc_enable(bnx2fc_transport_group0);
#line 1098
      ldv_state_variable_14 = 1;
    } else {

    }
#line 1101
    goto ldv_55936;
    case 5: ;
#line 1104
    if (ldv_state_variable_14 == 1) {
#line 1106
      bnx2fc_create(bnx2fc_transport_group0, ldvarg14);
#line 1108
      ldv_state_variable_14 = 1;
    } else {

    }
#line 1111
    goto ldv_55936;
    default: 
#line 1112
    ldv_stop();
    }
    ldv_55936: ;
  } else {

  }
#line 1116
  goto ldv_55888;
  case 11: ;
#line 1120
  if (ldv_state_variable_15 != 0) {
#line 1121
    tmp___20 = __VERIFIER_nondet_int();
#line 1121
    switch (tmp___20) {
    case 0: ;
#line 1124
    if (ldv_state_variable_15 == 1) {
#line 1126
      bnx2fc_cpu_callback(ldvarg15, ldvarg17, ldvarg16);
#line 1128
      ldv_state_variable_15 = 1;
    } else {

    }
#line 1131
    goto ldv_55945;
    default: 
#line 1132
    ldv_stop();
    }
    ldv_55945: ;
  } else {

  }
#line 1136
  goto ldv_55888;
  case 12: ;
#line 1140
  if (ldv_state_variable_8 != 0) {
#line 1141
    tmp___21 = __VERIFIER_nondet_int();
#line 1141
    switch (tmp___21) {
    case 0: ;
#line 1144
    if (ldv_state_variable_8 == 1) {
#line 1146
      bnx2fc_ulp_get_stats(ldvarg26);
#line 1148
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1151
    goto ldv_55949;
    case 1: ;
#line 1154
    if (ldv_state_variable_8 == 1) {
#line 1156
      bnx2fc_ulp_exit(bnx2fc_cnic_cb_group0);
#line 1158
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1161
    goto ldv_55949;
    case 2: ;
#line 1164
    if (ldv_state_variable_8 == 1) {
#line 1166
      bnx2fc_ulp_start(ldvarg25);
#line 1168
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1171
    goto ldv_55949;
    case 3: ;
#line 1174
    if (ldv_state_variable_8 == 1) {
#line 1176
      bnx2fc_indicate_kcqe(ldvarg22, ldvarg24, ldvarg23);
#line 1178
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1181
    goto ldv_55949;
    case 4: ;
#line 1184
    if (ldv_state_variable_8 == 1) {
#line 1186
      bnx2fc_ulp_init(bnx2fc_cnic_cb_group0);
#line 1188
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1191
    goto ldv_55949;
    case 5: ;
#line 1194
    if (ldv_state_variable_8 == 1) {
#line 1196
      bnx2fc_indicate_netevent(ldvarg19, ldvarg21, (int )ldvarg20);
#line 1198
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1201
    goto ldv_55949;
    case 6: ;
#line 1204
    if (ldv_state_variable_8 == 1) {
#line 1206
      bnx2fc_ulp_stop(ldvarg18);
#line 1208
      ldv_state_variable_8 = 1;
    } else {

    }
#line 1211
    goto ldv_55949;
    default: 
#line 1212
    ldv_stop();
    }
    ldv_55949: ;
  } else {

  }
#line 1216
  goto ldv_55888;
  case 13: ;
#line 1220
  if (ldv_state_variable_4 != 0) {
#line 1221
    choose_timer_4();
  } else {

  }
#line 1224
  goto ldv_55888;
  case 14: ;
#line 1228
  if (ldv_state_variable_10 != 0) {
#line 1229
    tmp___22 = __VERIFIER_nondet_int();
#line 1229
    switch (tmp___22) {
    case 0: ;
#line 1232
    if (ldv_state_variable_10 == 1) {
#line 1234
      scsi_change_queue_depth(bnx2fc_shost_template_group1, ldvarg28);
#line 1236
      ldv_state_variable_10 = 1;
    } else {

    }
#line 1239
    goto ldv_55960;
    case 1: ;
#line 1242
    if (ldv_state_variable_10 == 1) {
#line 1244
      bnx2fc_queuecommand(ldvarg27, bnx2fc_shost_template_group0);
#line 1246
      ldv_state_variable_10 = 1;
    } else {

    }
#line 1249
    goto ldv_55960;
    case 2: ;
#line 1252
    if (ldv_state_variable_10 == 1) {
#line 1254
      bnx2fc_eh_target_reset(bnx2fc_shost_template_group0);
#line 1256
      ldv_state_variable_10 = 1;
    } else {

    }
#line 1259
    goto ldv_55960;
    case 3: ;
#line 1262
    if (ldv_state_variable_10 == 1) {
#line 1264
      bnx2fc_eh_device_reset(bnx2fc_shost_template_group0);
#line 1266
      ldv_state_variable_10 = 1;
    } else {

    }
#line 1269
    goto ldv_55960;
    case 4: ;
#line 1272
    if (ldv_state_variable_10 == 1) {
#line 1274
      bnx2fc_eh_abort(bnx2fc_shost_template_group0);
#line 1276
      ldv_state_variable_10 = 1;
    } else {

    }
#line 1279
    goto ldv_55960;
    case 5: ;
#line 1282
    if (ldv_state_variable_10 == 1) {
#line 1284
      fc_slave_alloc(bnx2fc_shost_template_group1);
#line 1286
      ldv_state_variable_10 = 1;
    } else {

    }
#line 1289
    goto ldv_55960;
    case 6: ;
#line 1292
    if (ldv_state_variable_10 == 1) {
#line 1294
      fc_eh_host_reset(bnx2fc_shost_template_group0);
#line 1296
      ldv_state_variable_10 = 1;
    } else {

    }
#line 1299
    goto ldv_55960;
    default: 
#line 1300
    ldv_stop();
    }
    ldv_55960: ;
  } else {

  }
#line 1304
  goto ldv_55888;
  case 15: ;
#line 1311
  goto ldv_55888;
  default: 
#line 1312
  ldv_stop();
  }
  ldv_55888: ;
#line 1314
  goto ldv_55970;
  ldv_final: 
#line 1316
  ldv_check_final_state();
#line 1317
  return 0;
}
}
#line 1326 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 1329
  tmp = ldv_ptr_err(ptr);
#line 1329
  return (tmp);
}
}
#line 1344 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
bool ldv_queue_work_on_25(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 1348
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1348
  ldv_func_res = tmp;
#line 1350
  activate_work_2(ldv_func_arg3, 2);
#line 1352
  return (ldv_func_res);
}
}
#line 1355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
bool ldv_queue_delayed_work_on_26(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 1359
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1359
  ldv_func_res = tmp;
#line 1361
  activate_work_2(& ldv_func_arg3->work, 2);
#line 1363
  return (ldv_func_res);
}
}
#line 1366 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
bool ldv_queue_work_on_27(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 1370
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1370
  ldv_func_res = tmp;
#line 1372
  activate_work_2(ldv_func_arg3, 2);
#line 1374
  return (ldv_func_res);
}
}
#line 1377 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_flush_workqueue_28(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1380
  flush_workqueue(ldv_func_arg1);
#line 1382
  call_and_disable_all_2(2);
#line 1383
  return;
}
}
#line 1385 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
bool ldv_queue_delayed_work_on_29(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1389
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1389
  ldv_func_res = tmp;
#line 1391
  activate_work_2(& ldv_func_arg3->work, 2);
#line 1393
  return (ldv_func_res);
}
}
#line 1396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_scsi_add_host_with_dma_30(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 1400
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 1400
  ldv_func_res = tmp;
#line 1402
  if (ldv_func_res == 0) {
#line 1403
    ldv_state_variable_10 = 1;
#line 1403
    ldv_initialize_scsi_host_template_10();
  } else {

  }
#line 1407
  return (ldv_func_res);
}
}
#line 1410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
struct Scsi_Host *ldv_scsi_host_alloc_31(struct scsi_host_template *sht , int privsize ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  struct Scsi_Host *tmp ;

  {
#line 1414
  tmp = scsi_host_alloc(sht, privsize);
#line 1414
  ldv_func_res = tmp;
#line 1416
  if ((unsigned long )ldv_func_res != (unsigned long )((ldv_func_ret_type___4 )0)) {
#line 1417
    ldv_state_variable_10 = 1;
#line 1417
    ldv_initialize_scsi_host_template_10();
  } else {

  }
#line 1421
  return (ldv_func_res);
}
}
#line 1424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_flush_workqueue_32(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1427
  flush_workqueue(ldv_func_arg1);
#line 1429
  call_and_disable_all_2(2);
#line 1430
  return;
}
}
#line 1432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_module_put_33(struct module *ldv_func_arg1 ) 
{ 


  {
#line 1435
  ldv_module_put(ldv_func_arg1);
#line 1436
  return;
}
}
#line 1438 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_scsi_remove_host_34(struct Scsi_Host *shost ) 
{ 


  {
#line 1441
  scsi_remove_host(shost);
#line 1443
  ldv_state_variable_10 = 0;
#line 1444
  return;
}
}
#line 1446 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_del_timer_sync_35(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 1450
  tmp = del_timer_sync(ldv_func_arg1);
#line 1450
  ldv_func_res = tmp;
#line 1452
  disable_suitable_timer_6(ldv_func_arg1);
#line 1454
  return (ldv_func_res);
}
}
#line 1457 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_scsi_remove_host_36(struct Scsi_Host *shost ) 
{ 


  {
#line 1460
  scsi_remove_host(shost);
#line 1462
  ldv_state_variable_10 = 0;
#line 1463
  return;
}
}
#line 1465 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_destroy_workqueue_37(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1468
  destroy_workqueue(ldv_func_arg1);
#line 1470
  call_and_disable_all_2(2);
#line 1471
  return;
}
}
#line 1473 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
int ldv_del_timer_sync_38(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 1477
  tmp = del_timer_sync(ldv_func_arg1);
#line 1477
  ldv_func_res = tmp;
#line 1479
  disable_suitable_timer_6(ldv_func_arg1);
#line 1481
  return (ldv_func_res);
}
}
#line 1484 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
bool ldv_try_module_get_39(struct module *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
#line 1487
  tmp = ldv_try_module_get(ldv_func_arg1);
#line 1487
  return (tmp != 0);
}
}
#line 1490 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_destroy_workqueue_40(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1493
  destroy_workqueue(ldv_func_arg1);
#line 1495
  call_and_disable_all_2(2);
#line 1496
  return;
}
}
#line 1498 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_module_put_41(struct module *ldv_func_arg1 ) 
{ 


  {
#line 1501
  ldv_module_put(ldv_func_arg1);
#line 1502
  return;
}
}
#line 1504 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_flush_workqueue_42(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1507
  flush_workqueue(ldv_func_arg1);
#line 1509
  call_and_disable_all_2(2);
#line 1510
  return;
}
}
#line 1512 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_destroy_workqueue_43(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1515
  destroy_workqueue(ldv_func_arg1);
#line 1517
  call_and_disable_all_2(2);
#line 1518
  return;
}
}
#line 1520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_fcoe.o.c.prepared"
void ldv_destroy_workqueue_44(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1523
  destroy_workqueue(ldv_func_arg1);
#line 1525
  call_and_disable_all_2(2);
#line 1526
  return;
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 112 "include/linux/bitmap.h"
extern int __bitmap_weight(unsigned long const   * , unsigned int  ) ;
#line 298 "include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const   *src , unsigned int nbits ) 
{ 
  int tmp___0 ;

  {
#line 302
  tmp___0 = __bitmap_weight(src, nbits);
#line 302
  return (tmp___0);
}
}
#line 474 "include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp ) 
{ 
  int tmp ;

  {
#line 476
  tmp = bitmap_weight((unsigned long const   *)(& srcp->bits), (unsigned int )nr_cpu_ids);
#line 476
  return ((unsigned int )tmp);
}
}
#line 49 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_add(int i , atomic_t *v ) 
{ 


  {
#line 51
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; addl %1,%0": "+m" (v->counter): "ir" (i));
#line 53
  return;
}
}
#line 106 "include/linux/completion.h"
extern void complete(struct completion * ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_66(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_68(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_67(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_70(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_69(struct workqueue_struct *ldv_func_arg1 ) ;
#line 470
bool ldv_cancel_delayed_work_73(struct delayed_work *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work___0(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_66(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 66 "./arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 66
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
#line 67
  return;
}
}
#line 181
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
#line 68 "include/linux/kref.h"
__inline static int kref_sub___1(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
#line 71
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
#line 71
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 71
  if (tmp != 0L) {
#line 71
    warn_slowpath_null("include/linux/kref.h", 71);
  } else {

  }
#line 71
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 73
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
#line 73
  if (tmp___0 != 0) {
#line 74
    (*release)(kref);
#line 75
    return (1);
  } else {

  }
#line 77
  return (0);
}
}
#line 97 "include/linux/kref.h"
__inline static int kref_put___1(struct kref *kref , void (*release)(struct kref * ) ) 
{ 
  int tmp ;

  {
#line 99
  tmp = kref_sub___1(kref, 1U, release);
#line 99
  return (tmp);
}
}
#line 125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.o.c.prepared"
void invoke_work_2(void) ;
#line 151
void call_and_disable_work_2(struct work_struct *work ) ;
#line 131 "./arch/x86/include/asm/dma-mapping.h"
extern void *dma_alloc_attrs(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
#line 136
extern void dma_free_attrs(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
#line 792 "include/scsi/scsi_host.h"
struct Scsi_Host *ldv_scsi_host_alloc_72(struct scsi_host_template *sht , int privsize ) ;
#line 799
int ldv_scsi_add_host_with_dma_71(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 496 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/scsi/bnx2fc/bnx2fc.h"
int bnx2fc_send_session_ofld_req(struct fcoe_port *port , struct bnx2fc_rport *tgt ) ;
#line 498
int bnx2fc_send_session_enable_req(struct fcoe_port *port , struct bnx2fc_rport *tgt ) ;
#line 500
int bnx2fc_send_session_disable_req(struct fcoe_port *port , struct bnx2fc_rport *tgt ) ;
#line 502
int bnx2fc_send_session_destroy_req(struct bnx2fc_hba *hba , struct bnx2fc_rport *tgt ) ;
#line 504
int bnx2fc_map_doorbell(struct bnx2fc_rport *tgt ) ;
#line 514
char *bnx2fc_get_next_rqe(struct bnx2fc_rport *tgt , u8 num_items ) ;
#line 515
void bnx2fc_return_rqe(struct bnx2fc_rport *tgt , u8 num_items ) ;
#line 526
void bnx2fc_init_cleanup_task(struct bnx2fc_cmd *io_req , struct fcoe_task_ctx_entry *task ,
                              u16 orig_xid ) ;
#line 529
void bnx2fc_init_seq_cleanup_task(struct bnx2fc_cmd *seq_clnp_req , struct fcoe_task_ctx_entry *task ,
                                  struct bnx2fc_cmd *orig_io_req , u32 offset ) ;
#line 535
void bnx2fc_init_task(struct bnx2fc_cmd *io_req , struct fcoe_task_ctx_entry *task ) ;
#line 546
void bnx2fc_process_scsi_cmd_compl(struct bnx2fc_cmd *io_req , struct fcoe_task_ctx_entry *task ,
                                   u8 num_rq ) ;
#line 549
void bnx2fc_process_cleanup_compl(struct bnx2fc_cmd *io_req , struct fcoe_task_ctx_entry *task ,
                                  u8 num_rq ) ;
#line 552
void bnx2fc_process_abts_compl(struct bnx2fc_cmd *io_req , struct fcoe_task_ctx_entry *task ,
                               u8 num_rq ) ;
#line 555
void bnx2fc_process_tm_compl(struct bnx2fc_cmd *io_req , struct fcoe_task_ctx_entry *task ,
                             u8 num_rq ) ;
#line 561
void bnx2fc_build_fcp_cmnd(struct bnx2fc_cmd *io_req , struct fcp_cmnd *fcp_cmnd ) ;
#line 573
void bnx2fc_arm_cq(struct bnx2fc_rport *tgt ) ;
#line 574
int bnx2fc_process_new_cqes(struct bnx2fc_rport *tgt ) ;
#line 585
void bnx2fc_process_seq_cleanup_compl(struct bnx2fc_cmd *seq_clnp_req , struct fcoe_task_ctx_entry *task ,
                                      u8 rx_state ) ;
#line 19 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
static void bnx2fc_fastpath_notification(struct bnx2fc_hba *hba , struct fcoe_kcqe *new_cqe_kcqe ) ;
#line 21
static void bnx2fc_process_ofld_cmpl(struct bnx2fc_hba *hba , struct fcoe_kcqe *ofld_kcqe ) ;
#line 23
static void bnx2fc_process_enable_conn_cmpl(struct bnx2fc_hba *hba , struct fcoe_kcqe *ofld_kcqe ) ;
#line 25
static void bnx2fc_init_failure(struct bnx2fc_hba *hba , u32 err_code ) ;
#line 26
static void bnx2fc_process_conn_destroy_cmpl(struct bnx2fc_hba *hba , struct fcoe_kcqe *destroy_kcqe ) ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
int bnx2fc_send_stat_req(struct bnx2fc_hba *hba ) 
{ 
  struct fcoe_kwqe_stat stat_req ;
  struct kwqe *kwqe_arr[2U] ;
  int num_kwqes ;
  int rc ;

  {
#line 33
  num_kwqes = 1;
#line 34
  rc = 0;
#line 36
  memset((void *)(& stat_req), 0, 32UL);
#line 37
  stat_req.hdr.op_code = 11U;
#line 38
  stat_req.hdr.flags = 112U;
#line 41
  stat_req.stat_params_addr_lo = (unsigned int )hba->stats_buf_dma;
#line 42
  stat_req.stat_params_addr_hi = (unsigned int )(hba->stats_buf_dma >> 32);
#line 44
  kwqe_arr[0] = (struct kwqe *)(& stat_req);
#line 46
  if ((unsigned long )hba->cnic != (unsigned long )((struct cnic_dev *)0) && (unsigned long )(hba->cnic)->submit_kwqes != (unsigned long )((int (*)(struct cnic_dev * ,
                                                                                                                                                    struct kwqe ** ,
                                                                                                                                                    u32  ))0)) {
#line 47
    rc = (*((hba->cnic)->submit_kwqes))(hba->cnic, (struct kwqe **)(& kwqe_arr), (u32 )num_kwqes);
  } else {

  }
#line 49
  return (rc);
}
}
#line 61 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
int bnx2fc_send_fw_fcoe_init_msg(struct bnx2fc_hba *hba ) 
{ 
  struct fcoe_kwqe_init1 fcoe_init1 ;
  struct fcoe_kwqe_init2 fcoe_init2 ;
  struct fcoe_kwqe_init3 fcoe_init3 ;
  struct kwqe *kwqe_arr[3U] ;
  int num_kwqes ;
  int rc ;

  {
#line 67
  num_kwqes = 3;
#line 68
  rc = 0;
#line 70
  if ((unsigned long )hba->cnic == (unsigned long )((struct cnic_dev *)0)) {
#line 71
    printk("\vbnx2fc: hba->cnic NULL during fcoe fw init\n");
#line 72
    return (-19);
  } else {

  }
#line 76
  memset((void *)(& fcoe_init1), 0, 32UL);
#line 77
  fcoe_init1.hdr.op_code = 0U;
#line 78
  fcoe_init1.hdr.flags = 112U;
#line 81
  fcoe_init1.num_tasks = (__le16 )hba->max_tasks;
#line 82
  fcoe_init1.sq_num_wqes = 256U;
#line 83
  fcoe_init1.rq_num_wqes = 16U;
#line 84
  fcoe_init1.rq_buffer_log_size = 8U;
#line 85
  fcoe_init1.cq_num_wqes = 272U;
#line 86
  fcoe_init1.dummy_buffer_addr_lo = (unsigned int )hba->dummy_buf_dma;
#line 87
  fcoe_init1.dummy_buffer_addr_hi = (unsigned int )(hba->dummy_buf_dma >> 32);
#line 88
  fcoe_init1.task_list_pbl_addr_lo = (unsigned int )hba->task_ctx_bd_dma;
#line 89
  fcoe_init1.task_list_pbl_addr_hi = (unsigned int )(hba->task_ctx_bd_dma >> 32);
#line 91
  fcoe_init1.mtu = 2500U;
#line 93
  fcoe_init1.flags = 12U;
#line 96
  fcoe_init1.num_sessions_log = 10U;
#line 99
  memset((void *)(& fcoe_init2), 0, 32UL);
#line 100
  fcoe_init2.hdr.op_code = 1U;
#line 101
  fcoe_init2.hdr.flags = 112U;
#line 104
  fcoe_init2.hsi_major_version = 2U;
#line 105
  fcoe_init2.hsi_minor_version = 1U;
#line 108
  fcoe_init2.hash_tbl_pbl_addr_lo = (unsigned int )hba->hash_tbl_pbl_dma;
#line 109
  fcoe_init2.hash_tbl_pbl_addr_hi = (unsigned int )(hba->hash_tbl_pbl_dma >> 32);
#line 112
  fcoe_init2.t2_hash_tbl_addr_lo = (unsigned int )hba->t2_hash_tbl_dma;
#line 113
  fcoe_init2.t2_hash_tbl_addr_hi = (unsigned int )(hba->t2_hash_tbl_dma >> 32);
#line 116
  fcoe_init2.t2_ptr_hash_tbl_addr_lo = (unsigned int )hba->t2_hash_tbl_ptr_dma;
#line 117
  fcoe_init2.t2_ptr_hash_tbl_addr_hi = (unsigned int )(hba->t2_hash_tbl_ptr_dma >> 32);
#line 120
  fcoe_init2.free_list_count = 1024U;
#line 123
  memset((void *)(& fcoe_init3), 0, 32UL);
#line 124
  fcoe_init3.hdr.op_code = 2U;
#line 125
  fcoe_init3.hdr.flags = 112U;
#line 127
  fcoe_init3.error_bit_map_lo = 4294967295U;
#line 128
  fcoe_init3.error_bit_map_hi = 4294967295U;
#line 134
  fcoe_init3.perf_config = 3U;
#line 136
  kwqe_arr[0] = (struct kwqe *)(& fcoe_init1);
#line 137
  kwqe_arr[1] = (struct kwqe *)(& fcoe_init2);
#line 138
  kwqe_arr[2] = (struct kwqe *)(& fcoe_init3);
#line 140
  if ((unsigned long )hba->cnic != (unsigned long )((struct cnic_dev *)0) && (unsigned long )(hba->cnic)->submit_kwqes != (unsigned long )((int (*)(struct cnic_dev * ,
                                                                                                                                                    struct kwqe ** ,
                                                                                                                                                    u32  ))0)) {
#line 141
    rc = (*((hba->cnic)->submit_kwqes))(hba->cnic, (struct kwqe **)(& kwqe_arr), (u32 )num_kwqes);
  } else {

  }
#line 143
  return (rc);
}
}
#line 145 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
int bnx2fc_send_fw_fcoe_destroy_msg(struct bnx2fc_hba *hba ) 
{ 
  struct fcoe_kwqe_destroy fcoe_destroy ;
  struct kwqe *kwqe_arr[2U] ;
  int num_kwqes ;
  int rc ;

  {
#line 149
  num_kwqes = 1;
#line 150
  rc = -1;
#line 153
  memset((void *)(& fcoe_destroy), 0, 32UL);
#line 154
  fcoe_destroy.hdr.op_code = 10U;
#line 155
  fcoe_destroy.hdr.flags = 112U;
#line 157
  kwqe_arr[0] = (struct kwqe *)(& fcoe_destroy);
#line 159
  if ((unsigned long )hba->cnic != (unsigned long )((struct cnic_dev *)0) && (unsigned long )(hba->cnic)->submit_kwqes != (unsigned long )((int (*)(struct cnic_dev * ,
                                                                                                                                                    struct kwqe ** ,
                                                                                                                                                    u32  ))0)) {
#line 160
    rc = (*((hba->cnic)->submit_kwqes))(hba->cnic, (struct kwqe **)(& kwqe_arr), (u32 )num_kwqes);
  } else {

  }
#line 161
  return (rc);
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
int bnx2fc_send_session_ofld_req(struct fcoe_port *port , struct bnx2fc_rport *tgt ) 
{ 
  struct fc_lport *lport ;
  struct bnx2fc_interface *interface ;
  struct fcoe_ctlr *ctlr ;
  struct bnx2fc_hba *hba ;
  struct kwqe *kwqe_arr[4U] ;
  struct fcoe_kwqe_conn_offload1 ofld_req1 ;
  struct fcoe_kwqe_conn_offload2 ofld_req2 ;
  struct fcoe_kwqe_conn_offload3 ofld_req3 ;
  struct fcoe_kwqe_conn_offload4 ofld_req4 ;
  struct fc_rport_priv *rdata ;
  struct fc_rport *rport ;
  int num_kwqes ;
  u32 port_id ;
  int rc ;
  u16 conn_id ;

  {
#line 173
  lport = port->lport;
#line 174
  interface = (struct bnx2fc_interface *)port->priv;
#line 175
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 176
  hba = interface->hba;
#line 182
  rdata = tgt->rdata;
#line 183
  rport = tgt->rport;
#line 184
  num_kwqes = 4;
#line 186
  rc = 0;
#line 190
  memset((void *)(& ofld_req1), 0, 32UL);
#line 192
  ofld_req1.hdr.op_code = 3U;
#line 193
  ofld_req1.hdr.flags = 112U;
#line 197
  conn_id = (unsigned short )tgt->fcoe_conn_id;
#line 198
  ofld_req1.fcoe_conn_id = conn_id;
#line 201
  ofld_req1.sq_addr_lo = (unsigned int )tgt->sq_dma;
#line 202
  ofld_req1.sq_addr_hi = (unsigned int )(tgt->sq_dma >> 32);
#line 204
  ofld_req1.rq_pbl_addr_lo = (unsigned int )tgt->rq_pbl_dma;
#line 205
  ofld_req1.rq_pbl_addr_hi = (unsigned int )(tgt->rq_pbl_dma >> 32);
#line 207
  ofld_req1.rq_first_pbe_addr_lo = (unsigned int )tgt->rq_dma;
#line 208
  ofld_req1.rq_first_pbe_addr_hi = (unsigned int )(tgt->rq_dma >> 32);
#line 211
  ofld_req1.rq_prod = 32768U;
#line 214
  memset((void *)(& ofld_req2), 0, 32UL);
#line 216
  ofld_req2.hdr.op_code = 4U;
#line 217
  ofld_req2.hdr.flags = 112U;
#line 220
  ofld_req2.tx_max_fc_pay_len = rdata->maxframe_size;
#line 222
  ofld_req2.cq_addr_lo = (unsigned int )tgt->cq_dma;
#line 223
  ofld_req2.cq_addr_hi = (unsigned int )(tgt->cq_dma >> 32);
#line 225
  ofld_req2.xferq_addr_lo = (unsigned int )tgt->xferq_dma;
#line 226
  ofld_req2.xferq_addr_hi = (unsigned int )(tgt->xferq_dma >> 32);
#line 228
  ofld_req2.conn_db_addr_lo = (unsigned int )tgt->conn_db_dma;
#line 229
  ofld_req2.conn_db_addr_hi = (unsigned int )(tgt->conn_db_dma >> 32);
#line 232
  memset((void *)(& ofld_req3), 0, 32UL);
#line 234
  ofld_req3.hdr.op_code = 5U;
#line 235
  ofld_req3.hdr.flags = 112U;
#line 238
  ofld_req3.vlan_tag = (__le16 )interface->vlan_id;
#line 240
  ofld_req3.vlan_tag = (__le16 )((unsigned int )ofld_req3.vlan_tag | 24576U);
#line 242
  port_id = ((struct fc_host_attrs *)(lport->host)->shost_data)->port_id;
#line 243
  if (port_id == 0U) {
#line 244
    BNX2FC_HBA_DBG((struct fc_lport  const  *)lport, "ofld_req: port_id = 0, link down?\n");
#line 245
    return (-22);
  } else {

  }
#line 253
  tgt->sid = port_id;
#line 254
  ofld_req3.s_id[0] = (u8 )port_id;
#line 255
  ofld_req3.s_id[1] = (u8 )((port_id & 65280U) >> 8);
#line 256
  ofld_req3.s_id[2] = (u8 )((port_id & 16711680U) >> 16);
#line 258
  port_id = rport->port_id;
#line 259
  ofld_req3.d_id[0] = (u8 )port_id;
#line 260
  ofld_req3.d_id[1] = (u8 )((port_id & 65280U) >> 8);
#line 261
  ofld_req3.d_id[2] = (u8 )((port_id & 16711680U) >> 16);
#line 263
  ofld_req3.tx_total_conc_seqs = rdata->max_seq;
#line 265
  ofld_req3.tx_max_conc_seqs_c3 = (u8 )rdata->max_seq;
#line 266
  ofld_req3.rx_max_fc_pay_len = (__le16 )lport->mfs;
#line 268
  ofld_req3.rx_total_conc_seqs = 255U;
#line 269
  ofld_req3.rx_max_conc_seqs_c3 = 255U;
#line 270
  ofld_req3.rx_open_seqs_exch_c3 = 1U;
#line 272
  ofld_req3.confq_first_pbe_addr_lo = (__le32 )tgt->confq_dma;
#line 273
  ofld_req3.confq_first_pbe_addr_hi = (unsigned int )(tgt->confq_dma >> 32);
#line 276
  ofld_req3.flags = 0U;
#line 282
  ofld_req3.flags = (u8 )((int )((signed char )ofld_req3.flags) | (((int )rdata->sp_features & 1024) != 0 ? 2 : 0));
#line 285
  ofld_req3.flags = (u8 )((int )((signed char )ofld_req3.flags) | (((int )rdata->sp_features & 2) != 0 ? 4 : 0));
#line 292
  if (tgt->dev_type == 1) {
#line 293
    ofld_req3.flags = (u8 )((unsigned int )ofld_req3.flags | 8U);
#line 295
    ofld_req3.flags = (u8 )((int )((signed char )ofld_req3.flags) | (int )((signed char )(((int )rdata->flags & 1) << 4)));
  } else {

  }
#line 301
  ofld_req3.flags = (u8 )((int )((signed char )ofld_req3.flags) | (int )((signed char )((int )interface->vlan_enabled << 7)));
#line 308
  memset((void *)(& ofld_req4), 0, 32UL);
#line 309
  ofld_req4.hdr.op_code = 6U;
#line 310
  ofld_req4.hdr.flags = 112U;
#line 313
  ofld_req4.e_d_tov_timer_val = (u8 )(lport->e_d_tov / 20U);
#line 316
  ofld_req4.src_mac_addr_lo[0] = port->data_src_addr[5];
#line 318
  ofld_req4.src_mac_addr_lo[1] = port->data_src_addr[4];
#line 319
  ofld_req4.src_mac_addr_mid[0] = port->data_src_addr[3];
#line 320
  ofld_req4.src_mac_addr_mid[1] = port->data_src_addr[2];
#line 321
  ofld_req4.src_mac_addr_hi[0] = port->data_src_addr[1];
#line 322
  ofld_req4.src_mac_addr_hi[1] = port->data_src_addr[0];
#line 323
  ofld_req4.dst_mac_addr_lo[0] = ctlr->dest_addr[5];
#line 325
  ofld_req4.dst_mac_addr_lo[1] = ctlr->dest_addr[4];
#line 326
  ofld_req4.dst_mac_addr_mid[0] = ctlr->dest_addr[3];
#line 327
  ofld_req4.dst_mac_addr_mid[1] = ctlr->dest_addr[2];
#line 328
  ofld_req4.dst_mac_addr_hi[0] = ctlr->dest_addr[1];
#line 329
  ofld_req4.dst_mac_addr_hi[1] = ctlr->dest_addr[0];
#line 331
  ofld_req4.lcq_addr_lo = (unsigned int )tgt->lcq_dma;
#line 332
  ofld_req4.lcq_addr_hi = (unsigned int )(tgt->lcq_dma >> 32);
#line 334
  ofld_req4.confq_pbl_base_addr_lo = (unsigned int )tgt->confq_pbl_dma;
#line 335
  ofld_req4.confq_pbl_base_addr_hi = (unsigned int )(tgt->confq_pbl_dma >> 32);
#line 338
  kwqe_arr[0] = (struct kwqe *)(& ofld_req1);
#line 339
  kwqe_arr[1] = (struct kwqe *)(& ofld_req2);
#line 340
  kwqe_arr[2] = (struct kwqe *)(& ofld_req3);
#line 341
  kwqe_arr[3] = (struct kwqe *)(& ofld_req4);
#line 343
  if ((unsigned long )hba->cnic != (unsigned long )((struct cnic_dev *)0) && (unsigned long )(hba->cnic)->submit_kwqes != (unsigned long )((int (*)(struct cnic_dev * ,
                                                                                                                                                    struct kwqe ** ,
                                                                                                                                                    u32  ))0)) {
#line 344
    rc = (*((hba->cnic)->submit_kwqes))(hba->cnic, (struct kwqe **)(& kwqe_arr), (u32 )num_kwqes);
  } else {

  }
#line 346
  return (rc);
}
}
#line 355 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
int bnx2fc_send_session_enable_req(struct fcoe_port *port , struct bnx2fc_rport *tgt ) 
{ 
  struct kwqe *kwqe_arr[2U] ;
  struct bnx2fc_interface *interface ;
  struct fcoe_ctlr *ctlr ;
  struct bnx2fc_hba *hba ;
  struct fcoe_kwqe_conn_enable_disable enbl_req ;
  struct fc_lport *lport ;
  struct fc_rport *rport ;
  int num_kwqes ;
  int rc ;
  u32 port_id ;

  {
#line 359
  interface = (struct bnx2fc_interface *)port->priv;
#line 360
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 361
  hba = interface->hba;
#line 363
  lport = port->lport;
#line 364
  rport = tgt->rport;
#line 365
  num_kwqes = 1;
#line 366
  rc = 0;
#line 369
  memset((void *)(& enbl_req), 0, 40UL);
#line 371
  enbl_req.hdr.op_code = 7U;
#line 372
  enbl_req.hdr.flags = 112U;
#line 375
  enbl_req.src_mac_addr_lo[0] = port->data_src_addr[5];
#line 377
  enbl_req.src_mac_addr_lo[1] = port->data_src_addr[4];
#line 378
  enbl_req.src_mac_addr_mid[0] = port->data_src_addr[3];
#line 379
  enbl_req.src_mac_addr_mid[1] = port->data_src_addr[2];
#line 380
  enbl_req.src_mac_addr_hi[0] = port->data_src_addr[1];
#line 381
  enbl_req.src_mac_addr_hi[1] = port->data_src_addr[0];
#line 382
  memcpy((void *)(& tgt->src_addr), (void const   *)(& port->data_src_addr), 6UL);
#line 384
  enbl_req.dst_mac_addr_lo[0] = ctlr->dest_addr[5];
#line 385
  enbl_req.dst_mac_addr_lo[1] = ctlr->dest_addr[4];
#line 386
  enbl_req.dst_mac_addr_mid[0] = ctlr->dest_addr[3];
#line 387
  enbl_req.dst_mac_addr_mid[1] = ctlr->dest_addr[2];
#line 388
  enbl_req.dst_mac_addr_hi[0] = ctlr->dest_addr[1];
#line 389
  enbl_req.dst_mac_addr_hi[1] = ctlr->dest_addr[0];
#line 391
  port_id = ((struct fc_host_attrs *)(lport->host)->shost_data)->port_id;
#line 392
  if (tgt->sid != port_id) {
#line 393
    printk("\vbnx2fc: WARN: enable_req port_id = 0x%x,sid = 0x%x\n", port_id, tgt->sid);
#line 395
    port_id = tgt->sid;
  } else {

  }
#line 397
  enbl_req.s_id[0] = (u8 )port_id;
#line 398
  enbl_req.s_id[1] = (u8 )((port_id & 65280U) >> 8);
#line 399
  enbl_req.s_id[2] = (u8 )((port_id & 16711680U) >> 16);
#line 401
  port_id = rport->port_id;
#line 402
  enbl_req.d_id[0] = (u8 )port_id;
#line 403
  enbl_req.d_id[1] = (u8 )((port_id & 65280U) >> 8);
#line 404
  enbl_req.d_id[2] = (u8 )((port_id & 16711680U) >> 16);
#line 405
  enbl_req.vlan_tag = (u16 )interface->vlan_id;
#line 407
  enbl_req.vlan_tag = (u16 )((unsigned int )enbl_req.vlan_tag | 24576U);
#line 408
  enbl_req.vlan_flag = interface->vlan_enabled;
#line 409
  enbl_req.context_id = tgt->context_id;
#line 410
  enbl_req.conn_id = tgt->fcoe_conn_id;
#line 412
  kwqe_arr[0] = (struct kwqe *)(& enbl_req);
#line 414
  if ((unsigned long )hba->cnic != (unsigned long )((struct cnic_dev *)0) && (unsigned long )(hba->cnic)->submit_kwqes != (unsigned long )((int (*)(struct cnic_dev * ,
                                                                                                                                                    struct kwqe ** ,
                                                                                                                                                    u32  ))0)) {
#line 415
    rc = (*((hba->cnic)->submit_kwqes))(hba->cnic, (struct kwqe **)(& kwqe_arr), (u32 )num_kwqes);
  } else {

  }
#line 416
  return (rc);
}
}
#line 425 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
int bnx2fc_send_session_disable_req(struct fcoe_port *port , struct bnx2fc_rport *tgt ) 
{ 
  struct bnx2fc_interface *interface ;
  struct fcoe_ctlr *ctlr ;
  struct bnx2fc_hba *hba ;
  struct fcoe_kwqe_conn_enable_disable disable_req ;
  struct kwqe *kwqe_arr[2U] ;
  struct fc_rport *rport ;
  int num_kwqes ;
  int rc ;
  u32 port_id ;

  {
#line 428
  interface = (struct bnx2fc_interface *)port->priv;
#line 429
  ctlr = (struct fcoe_ctlr *)interface + 0xffffffffffffffffUL;
#line 430
  hba = interface->hba;
#line 433
  rport = tgt->rport;
#line 434
  num_kwqes = 1;
#line 435
  rc = 0;
#line 438
  memset((void *)(& disable_req), 0, 40UL);
#line 440
  disable_req.hdr.op_code = 8U;
#line 441
  disable_req.hdr.flags = 112U;
#line 444
  disable_req.src_mac_addr_lo[0] = tgt->src_addr[5];
#line 445
  disable_req.src_mac_addr_lo[1] = tgt->src_addr[4];
#line 446
  disable_req.src_mac_addr_mid[0] = tgt->src_addr[3];
#line 447
  disable_req.src_mac_addr_mid[1] = tgt->src_addr[2];
#line 448
  disable_req.src_mac_addr_hi[0] = tgt->src_addr[1];
#line 449
  disable_req.src_mac_addr_hi[1] = tgt->src_addr[0];
#line 451
  disable_req.dst_mac_addr_lo[0] = ctlr->dest_addr[5];
#line 452
  disable_req.dst_mac_addr_lo[1] = ctlr->dest_addr[4];
#line 453
  disable_req.dst_mac_addr_mid[0] = ctlr->dest_addr[3];
#line 454
  disable_req.dst_mac_addr_mid[1] = ctlr->dest_addr[2];
#line 455
  disable_req.dst_mac_addr_hi[0] = ctlr->dest_addr[1];
#line 456
  disable_req.dst_mac_addr_hi[1] = ctlr->dest_addr[0];
#line 458
  port_id = tgt->sid;
#line 459
  disable_req.s_id[0] = (u8 )port_id;
#line 460
  disable_req.s_id[1] = (u8 )((port_id & 65280U) >> 8);
#line 461
  disable_req.s_id[2] = (u8 )((port_id & 16711680U) >> 16);
#line 464
  port_id = rport->port_id;
#line 465
  disable_req.d_id[0] = (u8 )port_id;
#line 466
  disable_req.d_id[1] = (u8 )((port_id & 65280U) >> 8);
#line 467
  disable_req.d_id[2] = (u8 )((port_id & 16711680U) >> 16);
#line 468
  disable_req.context_id = tgt->context_id;
#line 469
  disable_req.conn_id = tgt->fcoe_conn_id;
#line 470
  disable_req.vlan_tag = (u16 )interface->vlan_id;
#line 472
  disable_req.vlan_tag = (u16 )((unsigned int )disable_req.vlan_tag | 24576U);
#line 474
  disable_req.vlan_flag = interface->vlan_enabled;
#line 476
  kwqe_arr[0] = (struct kwqe *)(& disable_req);
#line 478
  if ((unsigned long )hba->cnic != (unsigned long )((struct cnic_dev *)0) && (unsigned long )(hba->cnic)->submit_kwqes != (unsigned long )((int (*)(struct cnic_dev * ,
                                                                                                                                                    struct kwqe ** ,
                                                                                                                                                    u32  ))0)) {
#line 479
    rc = (*((hba->cnic)->submit_kwqes))(hba->cnic, (struct kwqe **)(& kwqe_arr), (u32 )num_kwqes);
  } else {

  }
#line 481
  return (rc);
}
}
#line 490 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
int bnx2fc_send_session_destroy_req(struct bnx2fc_hba *hba , struct bnx2fc_rport *tgt ) 
{ 
  struct fcoe_kwqe_conn_destroy destroy_req ;
  struct kwqe *kwqe_arr[2U] ;
  int num_kwqes ;
  int rc ;

  {
#line 495
  num_kwqes = 1;
#line 496
  rc = 0;
#line 498
  memset((void *)(& destroy_req), 0, 32UL);
#line 499
  destroy_req.hdr.op_code = 9U;
#line 500
  destroy_req.hdr.flags = 112U;
#line 503
  destroy_req.context_id = tgt->context_id;
#line 504
  destroy_req.conn_id = tgt->fcoe_conn_id;
#line 506
  kwqe_arr[0] = (struct kwqe *)(& destroy_req);
#line 508
  if ((unsigned long )hba->cnic != (unsigned long )((struct cnic_dev *)0) && (unsigned long )(hba->cnic)->submit_kwqes != (unsigned long )((int (*)(struct cnic_dev * ,
                                                                                                                                                    struct kwqe ** ,
                                                                                                                                                    u32  ))0)) {
#line 509
    rc = (*((hba->cnic)->submit_kwqes))(hba->cnic, (struct kwqe **)(& kwqe_arr), (u32 )num_kwqes);
  } else {

  }
#line 511
  return (rc);
}
}
#line 514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
static bool is_valid_lport(struct bnx2fc_hba *hba , struct fc_lport *lport ) 
{ 
  struct bnx2fc_lport *blport ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 518
  spin_lock_bh(& hba->hba_lock);
#line 519
  __mptr = (struct list_head  const  *)hba->vports.next;
#line 519
  blport = (struct bnx2fc_lport *)__mptr;
#line 519
  goto ldv_54676;
  ldv_54675: ;
#line 520
  if ((unsigned long )blport->lport == (unsigned long )lport) {
#line 521
    spin_unlock_bh(& hba->hba_lock);
#line 522
    return (1);
  } else {

  }
#line 519
  __mptr___0 = (struct list_head  const  *)blport->list.next;
#line 519
  blport = (struct bnx2fc_lport *)__mptr___0;
  ldv_54676: ;
#line 519
  if ((unsigned long )(& blport->list) != (unsigned long )(& hba->vports)) {
#line 521
    goto ldv_54675;
  } else {

  }
#line 525
  spin_unlock_bh(& hba->hba_lock);
#line 526
  return (0);
}
}
#line 531 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
static void bnx2fc_unsol_els_work(struct work_struct *work ) 
{ 
  struct bnx2fc_unsol_els *unsol_els ;
  struct fc_lport *lport ;
  struct bnx2fc_hba *hba ;
  struct fc_frame *fp ;
  struct work_struct  const  *__mptr ;
  bool tmp ;

  {
#line 538
  __mptr = (struct work_struct  const  *)work;
#line 538
  unsol_els = (struct bnx2fc_unsol_els *)__mptr + 0xffffffffffffffe8UL;
#line 539
  lport = unsol_els->lport;
#line 540
  fp = unsol_els->fp;
#line 541
  hba = unsol_els->hba;
#line 542
  tmp = is_valid_lport(hba, lport);
#line 542
  if ((int )tmp) {
#line 543
    fc_exch_recv(lport, fp);
  } else {

  }
#line 544
  kfree((void const   *)unsol_els);
#line 545
  return;
}
}
#line 547 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
void bnx2fc_process_l2_frame_compl(struct bnx2fc_rport *tgt , unsigned char *buf ,
                                   u32 frame_len , u16 l2_oxid ) 
{ 
  struct fcoe_port *port ;
  struct fc_lport *lport ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_unsol_els *unsol_els ;
  struct fc_frame_header *fh ;
  struct fc_frame *fp ;
  struct sk_buff *skb ;
  u32 payload_len ;
  u32 crc ;
  u8 op ;
  void *tmp ;
  __u16 tmp___0 ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
#line 551
  port = tgt->port;
#line 552
  lport = port->lport;
#line 553
  interface = (struct bnx2fc_interface *)port->priv;
#line 563
  tmp = kzalloc(104UL, 32U);
#line 563
  unsol_els = (struct bnx2fc_unsol_els *)tmp;
#line 564
  if ((unsigned long )unsol_els == (unsigned long )((struct bnx2fc_unsol_els *)0)) {
#line 565
    BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "Unable to allocate unsol_work\n");
#line 566
    return;
  } else {

  }
#line 569
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "l2_frame_compl l2_oxid = 0x%x, frame_len = %d\n",
                 (int )l2_oxid, frame_len);
#line 572
  payload_len = frame_len - 24U;
#line 574
  fp = fc_frame_alloc(lport, (size_t )payload_len);
#line 575
  if ((unsigned long )fp == (unsigned long )((struct fc_frame *)0)) {
#line 576
    printk("\vbnx2fc: fc_frame_alloc failure\n");
#line 577
    kfree((void const   *)unsol_els);
#line 578
    return;
  } else {

  }
#line 581
  fh = fc_frame_header_get((struct fc_frame  const  *)fp);
#line 583
  memcpy((void *)fh, (void const   *)buf, (size_t )frame_len);
#line 585
  if ((unsigned int )l2_oxid != 65535U) {
#line 586
    tmp___0 = __fswab16((int )l2_oxid);
#line 586
    fh->fh_ox_id = tmp___0;
  } else {

  }
#line 588
  skb = & fp->skb;
#line 590
  if ((unsigned int )fh->fh_r_ctl == 34U || (unsigned int )fh->fh_r_ctl == 35U) {
#line 593
    if ((unsigned int )fh->fh_type == 1U) {
#line 594
      op = fc_frame_payload_op((struct fc_frame  const  *)fp);
#line 595
      if ((((unsigned int )op == 17U || (unsigned int )op == 12U) || (unsigned int )op == 96U) || (unsigned int )op == 105U) {
#line 601
        printk("\vbnx2fc: dropping ELS 0x%x\n", (int )op);
#line 602
        kfree_skb(skb);
#line 603
        kfree((void const   *)unsol_els);
#line 604
        return;
      } else {

      }
    } else {

    }
#line 607
    crc = fcoe_fc_crc(fp);
#line 608
    fc_frame_init(fp);
#line 609
    ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_dev = lport;
#line 610
    ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_sof = 46U;
#line 611
    ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_eof = 66U;
#line 612
    ((struct fcoe_rcv_info *)(& fp->skb.cb))->fr_crc = ~ crc;
#line 613
    unsol_els->lport = lport;
#line 614
    unsol_els->hba = interface->hba;
#line 615
    unsol_els->fp = fp;
#line 616
    __init_work(& unsol_els->unsol_els_work, 0);
#line 616
    __constr_expr_0.counter = 137438953408L;
#line 616
    unsol_els->unsol_els_work.data = __constr_expr_0;
#line 616
    lockdep_init_map(& unsol_els->unsol_els_work.lockdep_map, "(&unsol_els->unsol_els_work)",
                     & __key, 0);
#line 616
    INIT_LIST_HEAD(& unsol_els->unsol_els_work.entry);
#line 616
    unsol_els->unsol_els_work.func = & bnx2fc_unsol_els_work;
#line 617
    queue_work___0(bnx2fc_wq, & unsol_els->unsol_els_work);
  } else {
#line 619
    BNX2FC_HBA_DBG((struct fc_lport  const  *)lport, "fh_r_ctl = 0x%x\n", (int )fh->fh_r_ctl);
#line 620
    kfree_skb(skb);
#line 621
    kfree((void const   *)unsol_els);
  }
#line 623
  return;
}
}
#line 625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
static void bnx2fc_process_unsol_compl(struct bnx2fc_rport *tgt , u16 wqe ) 
{ 
  u8 num_rq ;
  struct fcoe_err_report_entry *err_entry ;
  unsigned char *rq_data ;
  unsigned char *buf ;
  unsigned char *buf1 ;
  int i ;
  u16 xid ;
  u32 frame_len ;
  u32 len ;
  struct bnx2fc_cmd *io_req ;
  struct fcoe_task_ctx_entry *task ;
  struct fcoe_task_ctx_entry *task_page ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_hba *hba ;
  int task_idx ;
  int index ;
  int rc ;
  u64 err_warn_bit_map ;
  u8 err_warn ;
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  char *tmp___7 ;
  __u16 tmp___8 ;
  long tmp___9 ;

  {
#line 630
  buf = (unsigned char *)0U;
#line 634
  io_req = (struct bnx2fc_cmd *)0;
#line 636
  interface = (struct bnx2fc_interface *)(tgt->port)->priv;
#line 637
  hba = interface->hba;
#line 639
  rc = 0;
#line 641
  err_warn = 255U;
#line 644
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "Entered UNSOL COMPLETION wqe = 0x%x\n",
                 (int )wqe);
#line 645
  switch ((int )wqe & 3) {
  case 0: 
#line 647
  frame_len = (u32 )(((int )wqe & 16380) >> 2);
#line 650
  num_rq = (u8 )((frame_len + 255U) / 256U);
#line 652
  spin_lock_bh(& tgt->tgt_lock);
#line 653
  tmp = bnx2fc_get_next_rqe(tgt, (int )num_rq);
#line 653
  rq_data = (unsigned char *)tmp;
#line 654
  spin_unlock_bh(& tgt->tgt_lock);
#line 656
  if ((unsigned long )rq_data != (unsigned long )((unsigned char *)0U)) {
#line 657
    buf = rq_data;
  } else {
#line 659
    tmp___0 = kmalloc((size_t )((int )num_rq * 256), 32U);
#line 659
    buf = (unsigned char *)tmp___0;
#line 659
    buf1 = buf;
#line 662
    if ((unsigned long )buf1 == (unsigned long )((unsigned char *)0U)) {
#line 663
      BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "Memory alloc failure\n");
#line 664
      goto ldv_54729;
    } else {

    }
#line 667
    i = 0;
#line 667
    goto ldv_54731;
    ldv_54730: 
#line 668
    spin_lock_bh(& tgt->tgt_lock);
#line 669
    tmp___1 = bnx2fc_get_next_rqe(tgt, 1);
#line 669
    rq_data = (unsigned char *)tmp___1;
#line 671
    spin_unlock_bh(& tgt->tgt_lock);
#line 672
    len = 256U;
#line 673
    memcpy((void *)buf1, (void const   *)rq_data, (size_t )len);
#line 674
    buf1 = buf1 + (unsigned long )len;
#line 667
    i = i + 1;
    ldv_54731: ;
#line 667
    if ((int )num_rq > i) {
#line 669
      goto ldv_54730;
    } else {

    }

  }
#line 677
  bnx2fc_process_l2_frame_compl(tgt, buf, frame_len, 65535);
#line 680
  if ((unsigned long )buf != (unsigned long )rq_data) {
#line 681
    kfree((void const   *)buf);
  } else {

  }
#line 682
  spin_lock_bh(& tgt->tgt_lock);
#line 683
  bnx2fc_return_rqe(tgt, (int )num_rq);
#line 684
  spin_unlock_bh(& tgt->tgt_lock);
#line 685
  goto ldv_54729;
  case 1: 
#line 692
  spin_lock_bh(& tgt->tgt_lock);
#line 693
  num_rq = 1U;
#line 694
  tmp___2 = bnx2fc_get_next_rqe(tgt, 1);
#line 694
  err_entry = (struct fcoe_err_report_entry *)tmp___2;
#line 696
  xid = err_entry->fc_hdr.ox_id;
#line 697
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "Unsol Error Frame OX_ID = 0x%x\n",
                 (int )xid);
#line 698
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "err_warn_bitmap = %08x:%08x\n",
                 err_entry->data.err_warn_bitmap_hi, err_entry->data.err_warn_bitmap_lo);
#line 701
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "buf_offsets - tx = 0x%x, rx = 0x%x\n",
                 err_entry->data.tx_buf_off, err_entry->data.rx_buf_off);
#line 705
  if ((int )hba->max_xid < (int )xid) {
#line 706
    BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "xid(0x%x) out of FW range\n",
                   (int )xid);
#line 708
    goto ret_err_rqe;
  } else {

  }
#line 711
  task_idx = (int )((unsigned int )xid / 32U);
#line 712
  index = (int )xid & 31;
#line 713
  task_page = *(hba->task_ctx + (unsigned long )task_idx);
#line 715
  task = task_page + (unsigned long )index;
#line 717
  io_req = *((hba->cmd_mgr)->cmds + (unsigned long )xid);
#line 718
  if ((unsigned long )io_req == (unsigned long )((struct bnx2fc_cmd *)0)) {
#line 719
    goto ret_err_rqe;
  } else {

  }
#line 721
  if ((unsigned int )io_req->cmd_type != 1U) {
#line 722
    printk("\vbnx2fc: err_warn: Not a SCSI cmd\n");
#line 723
    goto ret_err_rqe;
  } else {

  }
#line 726
  tmp___3 = test_and_clear_bit(6L, (unsigned long volatile   *)(& io_req->req_flags));
#line 726
  if (tmp___3 != 0) {
#line 728
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "unsol_err: cleanup in progress.. ignore unsol err\n");
#line 730
    goto ret_err_rqe;
  } else {

  }
#line 733
  err_warn_bit_map = ((unsigned long long )err_entry->data.err_warn_bitmap_hi << 32) | (unsigned long long )err_entry->data.err_warn_bitmap_lo;
#line 736
  i = 0;
#line 736
  goto ldv_54737;
  ldv_54736: ;
#line 737
  if ((int )(err_warn_bit_map >> i) & 1) {
#line 738
    err_warn = (u8 )i;
#line 739
    goto ldv_54735;
  } else {

  }
#line 736
  i = i + 1;
  ldv_54737: ;
#line 736
  if (i <= 62) {
#line 738
    goto ldv_54736;
  } else {

  }
  ldv_54735: 
#line 750
  tmp___4 = constant_test_bit(2L, (unsigned long const volatile   *)(& io_req->req_flags));
#line 750
  if (tmp___4 != 0) {
#line 751
    printk("\vbnx2fc: err_warn: io_req (0x%x) already in ABTS processing\n", (int )xid);
#line 753
    goto ret_err_rqe;
  } else {

  }
#line 755
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "err = 0x%x\n", (int )err_warn);
#line 756
  if (tgt->dev_type != 1) {
#line 757
    goto skip_rec;
  } else {

  }
#line 758
  switch ((int )err_warn) {
  case 61: ;
  case 20: ;
  case 45: ;
  case 23: ;
  case 16: ;
  case 24: 
#line 765
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "REC TOV popped for xid - 0x%x\n",
                 (int )xid);
#line 767
  memcpy((void *)(& io_req->err_entry), (void const   *)err_entry, 40UL);
#line 769
  tmp___5 = constant_test_bit(13L, (unsigned long const volatile   *)(& io_req->req_flags));
#line 769
  if (tmp___5 == 0) {
#line 771
    spin_unlock_bh(& tgt->tgt_lock);
#line 772
    rc = bnx2fc_send_rec(io_req);
#line 773
    spin_lock_bh(& tgt->tgt_lock);
#line 775
    if (rc != 0) {
#line 776
      goto skip_rec;
    } else {

    }
  } else {
#line 778
    printk("\vbnx2fc: SRR in progress\n");
  }
#line 779
  goto ret_err_rqe;
  default: ;
#line 782
  goto ldv_54746;
  }
  ldv_54746: ;
  skip_rec: 
#line 786
  set_bit(2L, (unsigned long volatile   *)(& io_req->req_flags));
#line 791
  tmp___6 = ldv_cancel_delayed_work_73(& io_req->timeout_work);
#line 791
  if ((int )tmp___6) {
#line 792
    kref_put___1(& io_req->refcount, & bnx2fc_cmd_release);
  } else {

  }
#line 794
  rc = bnx2fc_initiate_abts(io_req);
#line 795
  if (rc != 8194) {
#line 796
    printk("\vbnx2fc: err_warn: initiate_abts failed xid = 0x%x. issue cleanup\n",
           (int )io_req->xid);
#line 799
    bnx2fc_initiate_cleanup(io_req);
  } else {

  }
  ret_err_rqe: 
#line 802
  bnx2fc_return_rqe(tgt, 1);
#line 803
  spin_unlock_bh(& tgt->tgt_lock);
#line 804
  goto ldv_54729;
  case 2: 
#line 811
  spin_lock_bh(& tgt->tgt_lock);
#line 812
  num_rq = 1U;
#line 813
  tmp___7 = bnx2fc_get_next_rqe(tgt, 1);
#line 813
  err_entry = (struct fcoe_err_report_entry *)tmp___7;
#line 815
  tmp___8 = __fswab16((int )err_entry->fc_hdr.ox_id);
#line 815
  xid = tmp___8;
#line 816
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "Unsol Warning Frame OX_ID = 0x%x\n",
                 (int )xid);
#line 817
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "err_warn_bitmap = %08x:%08x",
                 err_entry->data.err_warn_bitmap_hi, err_entry->data.err_warn_bitmap_lo);
#line 820
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "buf_offsets - tx = 0x%x, rx = 0x%x",
                 err_entry->data.tx_buf_off, err_entry->data.rx_buf_off);
#line 823
  if ((int )hba->max_xid < (int )xid) {
#line 824
    BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "xid(0x%x) out of FW range\n",
                   (int )xid);
#line 825
    goto ret_warn_rqe;
  } else {

  }
#line 828
  err_warn_bit_map = ((unsigned long long )err_entry->data.err_warn_bitmap_hi << 32) | (unsigned long long )err_entry->data.err_warn_bitmap_lo;
#line 831
  i = 0;
#line 831
  goto ldv_54751;
  ldv_54750: ;
#line 832
  if (((unsigned long long )(1 << i) & err_warn_bit_map) != 0ULL) {
#line 833
    err_warn = (u8 )i;
#line 834
    goto ldv_54749;
  } else {

  }
#line 831
  i = i + 1;
  ldv_54751: ;
#line 831
  if (i <= 62) {
#line 833
    goto ldv_54750;
  } else {

  }
  ldv_54749: 
#line 837
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "warn = 0x%x\n", (int )err_warn);
#line 839
  task_idx = (int )((unsigned int )xid / 32U);
#line 840
  index = (int )xid & 31;
#line 841
  task_page = *((interface->hba)->task_ctx + (unsigned long )task_idx);
#line 843
  task = task_page + (unsigned long )index;
#line 844
  io_req = *((hba->cmd_mgr)->cmds + (unsigned long )xid);
#line 845
  if ((unsigned long )io_req == (unsigned long )((struct bnx2fc_cmd *)0)) {
#line 846
    goto ret_warn_rqe;
  } else {

  }
#line 848
  if ((unsigned int )io_req->cmd_type != 1U) {
#line 849
    printk("\vbnx2fc: err_warn: Not a SCSI cmd\n");
#line 850
    goto ret_warn_rqe;
  } else {

  }
#line 853
  memcpy((void *)(& io_req->err_entry), (void const   *)err_entry, 40UL);
#line 856
  if ((unsigned int )err_warn == 61U) {
#line 858
    tmp___9 = ldv__builtin_expect(1L, 0L);
#line 858
    if (tmp___9 != 0L) {
#line 858
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"),
                           "i" (858), "i" (12UL));
      ldv_54752: ;
#line 858
      goto ldv_54752;
    } else {

    }
  } else {
#line 860
    BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "Unsolicited warning\n");
  }
  ret_warn_rqe: 
#line 862
  bnx2fc_return_rqe(tgt, 1);
#line 863
  spin_unlock_bh(& tgt->tgt_lock);
#line 864
  goto ldv_54729;
  default: 
#line 867
  printk("\vbnx2fc: Unsol Compl: Invalid CQE Subtype\n");
#line 868
  goto ldv_54729;
  }
  ldv_54729: ;
#line 871
  return;
}
}
#line 872 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
void bnx2fc_process_cq_compl(struct bnx2fc_rport *tgt , u16 wqe ) 
{ 
  struct fcoe_task_ctx_entry *task ;
  struct fcoe_task_ctx_entry *task_page ;
  struct fcoe_port *port ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_hba *hba ;
  struct bnx2fc_cmd *io_req ;
  int task_idx ;
  int index ;
  u16 xid ;
  u8 cmd_type ;
  u8 rx_state ;
  u8 num_rq ;

  {
#line 876
  port = tgt->port;
#line 877
  interface = (struct bnx2fc_interface *)port->priv;
#line 878
  hba = interface->hba;
#line 883
  rx_state = 0U;
#line 886
  spin_lock_bh(& tgt->tgt_lock);
#line 887
  xid = (unsigned int )wqe & 16383U;
#line 888
  if ((u32 )xid >= hba->max_tasks) {
#line 889
    printk("\vbnx2fc: OLD_ERROR:xid out of range\n");
#line 890
    spin_unlock_bh(& tgt->tgt_lock);
#line 891
    return;
  } else {

  }
#line 893
  task_idx = (int )((unsigned int )xid / 32U);
#line 894
  index = (int )xid & 31;
#line 895
  task_page = *(hba->task_ctx + (unsigned long )task_idx);
#line 896
  task = task_page + (unsigned long )index;
#line 898
  num_rq = (u8 )(((int )task->rxwr_txrd.var_ctx.rx_flags & 112) >> 4);
#line 902
  io_req = *((hba->cmd_mgr)->cmds + (unsigned long )xid);
#line 904
  if ((unsigned long )io_req == (unsigned long )((struct bnx2fc_cmd *)0)) {
#line 905
    printk("\vbnx2fc: OLD_ERROR? cq_compl - io_req is NULL\n");
#line 906
    spin_unlock_bh(& tgt->tgt_lock);
#line 907
    return;
  } else {

  }
#line 911
  cmd_type = io_req->cmd_type;
#line 913
  rx_state = (u8 )(((int )task->rxwr_txrd.var_ctx.rx_flags & 3840) >> 8);
#line 918
  switch ((int )cmd_type) {
  case 1: ;
#line 920
  if ((unsigned int )rx_state == 1U) {
#line 921
    bnx2fc_process_scsi_cmd_compl(io_req, task, (int )num_rq);
#line 922
    spin_unlock_bh(& tgt->tgt_lock);
#line 923
    return;
  } else {

  }
#line 926
  if ((unsigned int )rx_state == 7U) {
#line 927
    bnx2fc_process_abts_compl(io_req, task, (int )num_rq);
  } else
#line 928
  if ((unsigned int )rx_state == 9U) {
#line 930
    bnx2fc_process_cleanup_compl(io_req, task, (int )num_rq);
  } else {
#line 932
    printk("\vbnx2fc: Invalid rx state - %d\n", (int )rx_state);
  }
#line 934
  goto ldv_54771;
  case 2: 
#line 937
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "Processing TM complete\n");
#line 938
  bnx2fc_process_tm_compl(io_req, task, (int )num_rq);
#line 939
  goto ldv_54771;
  case 3: 
#line 947
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "cq_compl- ABTS sent out by fw\n");
#line 948
  kref_put___1(& io_req->refcount, & bnx2fc_cmd_release);
#line 949
  goto ldv_54771;
  case 4: ;
#line 952
  if ((unsigned int )rx_state == 1U) {
#line 953
    bnx2fc_process_els_compl(io_req, task, (int )num_rq);
  } else
#line 954
  if ((unsigned int )rx_state == 7U) {
#line 955
    bnx2fc_process_abts_compl(io_req, task, (int )num_rq);
  } else
#line 956
  if ((unsigned int )rx_state == 9U) {
#line 958
    bnx2fc_process_cleanup_compl(io_req, task, (int )num_rq);
  } else {
#line 960
    printk("\vbnx2fc: Invalid rx state =  %d\n", (int )rx_state);
  }
#line 962
  goto ldv_54771;
  case 5: 
#line 965
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "cq_compl- cleanup resp rcvd\n");
#line 966
  kref_put___1(& io_req->refcount, & bnx2fc_cmd_release);
#line 967
  goto ldv_54771;
  case 6: 
#line 970
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "cq_compl(0x%x) - seq cleanup resp\n",
                (int )io_req->xid);
#line 972
  bnx2fc_process_seq_cleanup_compl(io_req, task, (int )rx_state);
#line 973
  kref_put___1(& io_req->refcount, & bnx2fc_cmd_release);
#line 974
  goto ldv_54771;
  default: 
#line 977
  printk("\vbnx2fc: Invalid cmd_type %d\n", (int )cmd_type);
#line 978
  goto ldv_54771;
  }
  ldv_54771: 
#line 980
  spin_unlock_bh(& tgt->tgt_lock);
#line 981
  return;
}
}
#line 983 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
void bnx2fc_arm_cq(struct bnx2fc_rport *tgt ) 
{ 
  struct b577xx_fcoe_rx_doorbell *rx_db ;
  u32 msg ;

  {
#line 985
  rx_db = & tgt->rx_db;
#line 988
  __asm__  volatile   ("sfence": : : "memory");
#line 989
  rx_db->doorbell_cq_cons = (__le16 )((int )((short )tgt->cq_cons_idx) | (int )((short )((int )tgt->cq_curr_toggle_bit << 15)));
#line 991
  msg = *((u32 *)rx_db);
#line 992
  writel(msg, (void volatile   *)tgt->ctx_base);
#line 993
  __asm__  volatile   ("": : : "memory");
#line 994
  return;
}
}
#line 997 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
struct bnx2fc_work *bnx2fc_alloc_work(struct bnx2fc_rport *tgt , u16 wqe ) 
{ 
  struct bnx2fc_work *work ;
  void *tmp ;

  {
#line 1000
  tmp = kzalloc(32UL, 32U);
#line 1000
  work = (struct bnx2fc_work *)tmp;
#line 1001
  if ((unsigned long )work == (unsigned long )((struct bnx2fc_work *)0)) {
#line 1002
    return ((struct bnx2fc_work *)0);
  } else {

  }
#line 1004
  INIT_LIST_HEAD(& work->list);
#line 1005
  work->tgt = tgt;
#line 1006
  work->wqe = wqe;
#line 1007
  return (work);
}
}
#line 1010 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
int bnx2fc_process_new_cqes(struct bnx2fc_rport *tgt ) 
{ 
  struct fcoe_cqe *cq ;
  u32 cq_cons ;
  struct fcoe_cqe *cqe ;
  u32 num_free_sqes ;
  u32 num_cqes ;
  u16 wqe ;
  struct bnx2fc_work *work ;
  struct bnx2fc_percpu_s *fps ;
  unsigned int cpu ;
  unsigned int tmp ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  long tmp___0 ;

  {
#line 1015
  num_free_sqes = 0U;
#line 1016
  num_cqes = 0U;
#line 1024
  spin_lock_bh(& tgt->cq_lock);
#line 1026
  if ((unsigned long )tgt->cq == (unsigned long )((struct fcoe_cqe *)0)) {
#line 1027
    printk("\vbnx2fc: process_new_cqes: cq is NULL\n");
#line 1028
    spin_unlock_bh(& tgt->cq_lock);
#line 1029
    return (0);
  } else {

  }
#line 1031
  cq = tgt->cq;
#line 1032
  cq_cons = (u32 )tgt->cq_cons_idx;
#line 1033
  cqe = cq + (unsigned long )cq_cons;
#line 1035
  goto ldv_54806;
  ldv_54805: ;
#line 1040
  if (((int )wqe & 16384) != 0) {
#line 1042
    bnx2fc_process_unsol_compl(tgt, (int )wqe);
  } else {
#line 1045
    work = (struct bnx2fc_work *)0;
#line 1046
    fps = (struct bnx2fc_percpu_s *)0;
#line 1047
    tmp = cpumask_weight(cpu_possible_mask);
#line 1047
    cpu = (unsigned int )wqe % tmp;
#line 1049
    __vpp_verify = (void const   *)0;
#line 1049
    __asm__  ("": "=r" (__ptr): "0" (& bnx2fc_percpu));
#line 1049
    fps = (struct bnx2fc_percpu_s *)(__per_cpu_offset[cpu] + __ptr);
#line 1050
    spin_lock_bh(& fps->fp_work_lock);
#line 1051
    tmp___0 = ldv__builtin_expect((unsigned long )fps->iothread == (unsigned long )((struct task_struct *)0),
                               0L);
#line 1051
    if (tmp___0 != 0L) {
#line 1052
      goto unlock;
    } else {

    }
#line 1054
    work = bnx2fc_alloc_work(tgt, (int )wqe);
#line 1055
    if ((unsigned long )work != (unsigned long )((struct bnx2fc_work *)0)) {
#line 1056
      list_add_tail(& work->list, & fps->work_list);
    } else {

    }
    unlock: 
#line 1059
    spin_unlock_bh(& fps->fp_work_lock);
#line 1062
    if ((unsigned long )fps->iothread != (unsigned long )((struct task_struct *)0) && (unsigned long )work != (unsigned long )((struct bnx2fc_work *)0)) {
#line 1063
      wake_up_process(fps->iothread);
    } else {
#line 1065
      bnx2fc_process_cq_compl(tgt, (int )wqe);
    }
#line 1066
    num_free_sqes = num_free_sqes + 1U;
  }
#line 1068
  cqe = cqe + 1;
#line 1069
  tgt->cq_cons_idx = (u16 )((int )tgt->cq_cons_idx + 1);
#line 1070
  num_cqes = num_cqes + 1U;
#line 1072
  if ((unsigned int )tgt->cq_cons_idx == 272U) {
#line 1073
    tgt->cq_cons_idx = 0U;
#line 1074
    cqe = cq;
#line 1075
    tgt->cq_curr_toggle_bit = 1U - (unsigned int )tgt->cq_curr_toggle_bit;
  } else {

  }
  ldv_54806: 
#line 1035
  wqe = cqe->wqe;
#line 1035
  if (((int )wqe & 32768) == (int )tgt->cq_curr_toggle_bit << 15) {
#line 1038
    goto ldv_54805;
  } else {

  }

#line 1079
  if (num_cqes != 0U) {
#line 1081
    if ((unsigned long )tgt->ctx_base != (unsigned long )((void *)0)) {
#line 1082
      bnx2fc_arm_cq(tgt);
    } else {

    }
#line 1083
    atomic_add((int )num_free_sqes, & tgt->free_sqes);
  } else {

  }
#line 1085
  spin_unlock_bh(& tgt->cq_lock);
#line 1086
  return (0);
}
}
#line 1097 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
static void bnx2fc_fastpath_notification(struct bnx2fc_hba *hba , struct fcoe_kcqe *new_cqe_kcqe ) 
{ 
  u32 conn_id ;
  struct bnx2fc_rport *tgt ;

  {
#line 1100
  conn_id = new_cqe_kcqe->fcoe_conn_id;
#line 1101
  tgt = *(hba->tgt_ofld_list + (unsigned long )conn_id);
#line 1103
  if ((unsigned long )tgt == (unsigned long )((struct bnx2fc_rport *)0)) {
#line 1104
    printk("\vbnx2fc: conn_id 0x%x not valid\n", conn_id);
#line 1105
    return;
  } else {

  }
#line 1108
  bnx2fc_process_new_cqes(tgt);
#line 1109
  return;
}
}
#line 1120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
static void bnx2fc_process_ofld_cmpl(struct bnx2fc_hba *hba , struct fcoe_kcqe *ofld_kcqe ) 
{ 
  struct bnx2fc_rport *tgt ;
  struct fcoe_port *port ;
  struct bnx2fc_interface *interface ;
  u32 conn_id ;
  u32 context_id ;

  {
#line 1129
  conn_id = ofld_kcqe->fcoe_conn_id;
#line 1130
  context_id = ofld_kcqe->fcoe_conn_context_id;
#line 1131
  tgt = *(hba->tgt_ofld_list + (unsigned long )conn_id);
#line 1132
  if ((unsigned long )tgt == (unsigned long )((struct bnx2fc_rport *)0)) {
#line 1133
    printk("\tbnx2fc: OLD_ERROR:ofld_cmpl: No pending ofld req\n");
#line 1134
    return;
  } else {

  }
#line 1136
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "Entered ofld compl - context_id = 0x%x\n",
                 ofld_kcqe->fcoe_conn_context_id);
#line 1138
  port = tgt->port;
#line 1139
  interface = (struct bnx2fc_interface *)(tgt->port)->priv;
#line 1140
  if ((unsigned long )interface->hba != (unsigned long )hba) {
#line 1141
    printk("\vbnx2fc: OLD_ERROR:ofld_cmpl: HBA mis-match\n");
#line 1142
    goto ofld_cmpl_err;
  } else {

  }
#line 1148
  tgt->context_id = context_id;
#line 1149
  if (ofld_kcqe->completion_status != 0U) {
#line 1150
    if (ofld_kcqe->completion_status == 3U) {
#line 1152
      printk("\vbnx2fc: unable to allocate FCoE context resources\n");
#line 1154
      set_bit(6L, (unsigned long volatile   *)(& tgt->flags));
    } else {

    }
  } else {
#line 1158
    set_bit(2L, (unsigned long volatile   *)(& tgt->flags));
  }
  ofld_cmpl_err: 
#line 1161
  set_bit(5L, (unsigned long volatile   *)(& tgt->flags));
#line 1162
  __wake_up(& tgt->ofld_wait, 1U, 1, (void *)0);
#line 1163
  return;
}
}
#line 1174 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
static void bnx2fc_process_enable_conn_cmpl(struct bnx2fc_hba *hba , struct fcoe_kcqe *ofld_kcqe ) 
{ 
  struct bnx2fc_rport *tgt ;
  struct bnx2fc_interface *interface ;
  u32 conn_id ;
  u32 context_id ;

  {
#line 1182
  context_id = ofld_kcqe->fcoe_conn_context_id;
#line 1183
  conn_id = ofld_kcqe->fcoe_conn_id;
#line 1184
  tgt = *(hba->tgt_ofld_list + (unsigned long )conn_id);
#line 1185
  if ((unsigned long )tgt == (unsigned long )((struct bnx2fc_rport *)0)) {
#line 1186
    printk("\vbnx2fc: OLD_ERROR:enbl_cmpl: No pending ofld req\n");
#line 1187
    return;
  } else {

  }
#line 1190
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "Enable compl - context_id = 0x%x\n",
                 ofld_kcqe->fcoe_conn_context_id);
#line 1197
  if (tgt->context_id != context_id) {
#line 1198
    printk("\vbnx2fc: context id mis-match\n");
#line 1199
    return;
  } else {

  }
#line 1201
  interface = (struct bnx2fc_interface *)(tgt->port)->priv;
#line 1202
  if ((unsigned long )interface->hba != (unsigned long )hba) {
#line 1203
    printk("\vbnx2fc: bnx2fc-enbl_cmpl: HBA mis-match\n");
#line 1204
    goto enbl_cmpl_err;
  } else {

  }
#line 1206
  if (ofld_kcqe->completion_status == 0U) {
#line 1208
    set_bit(10L, (unsigned long volatile   *)(& tgt->flags));
  } else {

  }
  enbl_cmpl_err: 
#line 1211
  set_bit(5L, (unsigned long volatile   *)(& tgt->flags));
#line 1212
  __wake_up(& tgt->ofld_wait, 1U, 1, (void *)0);
#line 1213
  return;
}
}
#line 1215 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
static void bnx2fc_process_conn_disable_cmpl(struct bnx2fc_hba *hba , struct fcoe_kcqe *disable_kcqe ) 
{ 
  struct bnx2fc_rport *tgt ;
  u32 conn_id ;

  {
#line 1222
  conn_id = disable_kcqe->fcoe_conn_id;
#line 1223
  tgt = *(hba->tgt_ofld_list + (unsigned long )conn_id);
#line 1224
  if ((unsigned long )tgt == (unsigned long )((struct bnx2fc_rport *)0)) {
#line 1225
    printk("\vbnx2fc: OLD_ERROR: disable_cmpl: No disable req\n");
#line 1226
    return;
  } else {

  }
#line 1229
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "bnx2fc: disable_cmpl: conn_id %d\n",
                 conn_id);
#line 1231
  if (disable_kcqe->completion_status != 0U) {
#line 1232
    printk("\vbnx2fc: Disable failed with cmpl status %d\n", disable_kcqe->completion_status);
#line 1234
    set_bit(9L, (unsigned long volatile   *)(& tgt->flags));
#line 1235
    set_bit(7L, (unsigned long volatile   *)(& tgt->flags));
#line 1236
    __wake_up(& tgt->upld_wait, 1U, 1, (void *)0);
  } else {
#line 1239
    BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "disable successful\n");
#line 1240
    clear_bit(2L, (unsigned long volatile   *)(& tgt->flags));
#line 1241
    clear_bit(10L, (unsigned long volatile   *)(& tgt->flags));
#line 1242
    set_bit(3L, (unsigned long volatile   *)(& tgt->flags));
#line 1243
    set_bit(7L, (unsigned long volatile   *)(& tgt->flags));
#line 1244
    __wake_up(& tgt->upld_wait, 1U, 1, (void *)0);
  }
#line 1246
  return;
}
}
#line 1248 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
static void bnx2fc_process_conn_destroy_cmpl(struct bnx2fc_hba *hba , struct fcoe_kcqe *destroy_kcqe ) 
{ 
  struct bnx2fc_rport *tgt ;
  u32 conn_id ;

  {
#line 1254
  conn_id = destroy_kcqe->fcoe_conn_id;
#line 1255
  tgt = *(hba->tgt_ofld_list + (unsigned long )conn_id);
#line 1256
  if ((unsigned long )tgt == (unsigned long )((struct bnx2fc_rport *)0)) {
#line 1257
    printk("\vbnx2fc: destroy_cmpl: No destroy req\n");
#line 1258
    return;
  } else {

  }
#line 1261
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "destroy_cmpl: conn_id %d\n",
                 conn_id);
#line 1263
  if (destroy_kcqe->completion_status != 0U) {
#line 1264
    printk("\vbnx2fc: Destroy conn failed, cmpl status %d\n", destroy_kcqe->completion_status);
#line 1266
    return;
  } else {
#line 1269
    BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "upload successful\n");
#line 1270
    clear_bit(3L, (unsigned long volatile   *)(& tgt->flags));
#line 1271
    set_bit(4L, (unsigned long volatile   *)(& tgt->flags));
#line 1272
    set_bit(7L, (unsigned long volatile   *)(& tgt->flags));
#line 1273
    __wake_up(& tgt->upld_wait, 1U, 1, (void *)0);
  }
#line 1275
  return;
}
}
#line 1277 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
static void bnx2fc_init_failure(struct bnx2fc_hba *hba , u32 err_code ) 
{ 


  {
#line 1279
  switch (err_code) {
  case 2U: 
#line 1281
  printk("\vbnx2fc: init_failure due to invalid opcode\n");
#line 1282
  goto ldv_54850;
  case 3U: 
#line 1285
  printk("\vbnx2fc: init failed due to ctx alloc failure\n");
#line 1286
  goto ldv_54850;
  case 5U: 
#line 1289
  printk("\vbnx2fc: init_failure due to NIC error\n");
#line 1290
  goto ldv_54850;
  case 1U: 
#line 1292
  printk("\vbnx2fc: init failure due to compl status err\n");
#line 1293
  goto ldv_54850;
  case 6U: 
#line 1295
  printk("\vbnx2fc: init failure due to HSI mismatch\n");
#line 1296
  goto ldv_54850;
  default: 
#line 1298
  printk("\vbnx2fc: Unknown Error code %d\n", err_code);
  }
  ldv_54850: ;
#line 1301
  return;
}
}
#line 1311 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
void bnx2fc_indicate_kcqe(void *context , struct kcqe **kcq , u32 num_cqe ) 
{ 
  struct bnx2fc_hba *hba ;
  int i ;
  struct fcoe_kcqe *kcqe ;
  int tmp ;

  {
#line 1314
  hba = (struct bnx2fc_hba *)context;
#line 1315
  i = 0;
#line 1316
  kcqe = (struct fcoe_kcqe *)0;
#line 1318
  goto ldv_54876;
  ldv_54875: 
#line 1319
  tmp = i;
#line 1319
  i = i + 1;
#line 1319
  kcqe = (struct fcoe_kcqe *)*(kcq + (unsigned long )tmp);
#line 1321
  switch ((int )kcqe->op_code) {
  case 32: 
#line 1323
  bnx2fc_fastpath_notification(hba, kcqe);
#line 1324
  goto ldv_54865;
  case 21: 
#line 1327
  bnx2fc_process_ofld_cmpl(hba, kcqe);
#line 1328
  goto ldv_54865;
  case 22: 
#line 1331
  bnx2fc_process_enable_conn_cmpl(hba, kcqe);
#line 1332
  goto ldv_54865;
  case 16: ;
#line 1335
  if (kcqe->completion_status != 0U) {
#line 1337
    bnx2fc_init_failure(hba, kcqe->completion_status);
  } else {
#line 1340
    set_bit(0L, (unsigned long volatile   *)(& hba->adapter_state));
#line 1341
    bnx2fc_get_link_state(hba);
#line 1342
    printk("\016bnx2fc: [%.2x]: FCOE_INIT passed\n", (int )((hba->pcidev)->bus)->number);
  }
#line 1345
  goto ldv_54865;
  case 17: ;
#line 1348
  if (kcqe->completion_status != 0U) {
#line 1351
    printk("\vbnx2fc: DESTROY failed\n");
  } else {
#line 1353
    printk("\vbnx2fc: DESTROY success\n");
  }
#line 1355
  set_bit(1L, (unsigned long volatile   *)(& hba->flags));
#line 1356
  __wake_up(& hba->destroy_wait, 1U, 1, (void *)0);
#line 1357
  goto ldv_54865;
  case 23: 
#line 1360
  bnx2fc_process_conn_disable_cmpl(hba, kcqe);
#line 1361
  goto ldv_54865;
  case 24: 
#line 1364
  bnx2fc_process_conn_destroy_cmpl(hba, kcqe);
#line 1365
  goto ldv_54865;
  case 18: ;
#line 1368
  if (kcqe->completion_status != 0U) {
#line 1370
    printk("\vbnx2fc: STAT failed\n");
  } else {

  }
#line 1371
  complete(& hba->stat_req_done);
#line 1372
  goto ldv_54865;
  case 33: ;
  default: 
#line 1377
  printk("\vbnx2fc: unknown opcode 0x%x\n", (int )kcqe->op_code);
  }
  ldv_54865: ;
  ldv_54876: ;
#line 1318
  if ((u32 )i < num_cqe) {
#line 1320
    goto ldv_54875;
  } else {

  }

#line 1325
  return;
}
}
#line 1383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
void bnx2fc_add_2_sq(struct bnx2fc_rport *tgt , u16 xid ) 
{ 
  struct fcoe_sqe *sqe ;

  {
#line 1387
  sqe = tgt->sq + (unsigned long )tgt->sq_prod_idx;
#line 1390
  sqe->wqe = xid;
#line 1391
  sqe->wqe = (__le16 )((int )((short )sqe->wqe) | (int )((short )((int )tgt->sq_curr_toggle_bit << 15)));
#line 1394
  tgt->sq_prod_idx = (u16 )((int )tgt->sq_prod_idx + 1);
#line 1394
  if ((unsigned int )tgt->sq_prod_idx == 256U) {
#line 1395
    tgt->sq_prod_idx = 0U;
#line 1396
    tgt->sq_curr_toggle_bit = 1U - (unsigned int )tgt->sq_curr_toggle_bit;
  } else {

  }
#line 1398
  return;
}
}
#line 1400 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
void bnx2fc_ring_doorbell(struct bnx2fc_rport *tgt ) 
{ 
  struct b577xx_doorbell_set_prod *sq_db ;
  u32 msg ;

  {
#line 1402
  sq_db = & tgt->sq_db;
#line 1405
  __asm__  volatile   ("sfence": : : "memory");
#line 1406
  sq_db->prod = (u16 )((int )((short )tgt->sq_prod_idx) | (int )((short )((int )tgt->sq_curr_toggle_bit << 15)));
#line 1408
  msg = *((u32 *)sq_db);
#line 1409
  writel(msg, (void volatile   *)tgt->ctx_base);
#line 1410
  __asm__  volatile   ("": : : "memory");
#line 1411
  return;
}
}
#line 1414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
int bnx2fc_map_doorbell(struct bnx2fc_rport *tgt ) 
{ 
  u32 context_id ;
  struct fcoe_port *port ;
  u32 reg_off ;
  resource_size_t reg_base ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_hba *hba ;

  {
#line 1416
  context_id = tgt->context_id;
#line 1417
  port = tgt->port;
#line 1420
  interface = (struct bnx2fc_interface *)port->priv;
#line 1421
  hba = interface->hba;
#line 1423
  reg_base = (hba->pcidev)->resource[2].start;
#line 1425
  reg_off = (context_id & 131071U) * 8U;
#line 1426
  tgt->ctx_base = ioremap_nocache((resource_size_t )reg_off + reg_base, 4UL);
#line 1427
  if ((unsigned long )tgt->ctx_base == (unsigned long )((void *)0)) {
#line 1428
    return (-12);
  } else {

  }
#line 1429
  return (0);
}
}
#line 1432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
char *bnx2fc_get_next_rqe(struct bnx2fc_rport *tgt , u8 num_items ) 
{ 
  char *buf ;

  {
#line 1434
  buf = (char *)tgt->rq + (unsigned long )(tgt->rq_cons_idx * 256U);
#line 1436
  if (tgt->rq_cons_idx + (u32 )num_items > 16U) {
#line 1437
    return ((char *)0);
  } else {

  }
#line 1439
  tgt->rq_cons_idx = tgt->rq_cons_idx + (u32 )num_items;
#line 1441
  if (tgt->rq_cons_idx > 15U) {
#line 1442
    tgt->rq_cons_idx = tgt->rq_cons_idx - 16U;
  } else {

  }
#line 1444
  return (buf);
}
}
#line 1447 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
void bnx2fc_return_rqe(struct bnx2fc_rport *tgt , u8 num_items ) 
{ 
  u32 next_prod_idx ;

  {
#line 1450
  next_prod_idx = tgt->rq_prod_idx + (u32 )num_items;
#line 1451
  if ((next_prod_idx & 32767U) == 16U) {
#line 1453
    next_prod_idx = next_prod_idx + 32752U;
  } else {

  }
#line 1455
  tgt->rq_prod_idx = next_prod_idx;
#line 1456
  (tgt->conn_db)->rq_prod = (u16 )tgt->rq_prod_idx;
#line 1457
  return;
}
}
#line 1459 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
void bnx2fc_init_seq_cleanup_task(struct bnx2fc_cmd *seq_clnp_req , struct fcoe_task_ctx_entry *task ,
                                  struct bnx2fc_cmd *orig_io_req , u32 offset ) 
{ 
  struct scsi_cmnd *sc_cmd ;
  struct bnx2fc_rport *tgt ;
  struct bnx2fc_interface *interface ;
  struct fcoe_bd_ctx *bd ;
  struct fcoe_task_ctx_entry *orig_task ;
  struct fcoe_task_ctx_entry *task_page ;
  struct fcoe_ext_mul_sges_ctx *sgl ;
  u8 task_type ;
  u8 orig_task_type ;
  u16 orig_xid ;
  u32 context_id ;
  u64 phys_addr ;
  u32 orig_offset ;
  int bd_count ;
  int orig_task_idx ;
  int index ;
  int i ;

  {
#line 1464
  sc_cmd = orig_io_req->sc_cmd;
#line 1465
  tgt = seq_clnp_req->tgt;
#line 1466
  interface = (struct bnx2fc_interface *)(tgt->port)->priv;
#line 1467
  bd = (orig_io_req->bd_tbl)->bd_tbl;
#line 1471
  task_type = 6U;
#line 1473
  orig_xid = orig_io_req->xid;
#line 1474
  context_id = tgt->context_id;
#line 1475
  phys_addr = (orig_io_req->bd_tbl)->bd_tbl_dma;
#line 1476
  orig_offset = offset;
#line 1481
  memset((void *)task, 0, 128UL);
#line 1483
  if ((unsigned int )sc_cmd->sc_data_direction == 1U) {
#line 1484
    orig_task_type = 0U;
  } else {
#line 1486
    orig_task_type = 1U;
  }
#line 1489
  task->txwr_rxrd.const_ctx.tx_flags = 14U;
#line 1493
  task->txwr_rxrd.const_ctx.init_flags = task_type;
#line 1495
  task->txwr_rxrd.const_ctx.init_flags = task->txwr_rxrd.const_ctx.init_flags;
#line 1497
  task->rxwr_txrd.const_ctx.init_flags = context_id;
#line 1499
  task->rxwr_txrd.const_ctx.init_flags = context_id;
#line 1502
  task->txwr_rxrd.union_ctx.cleanup.ctx.cleaned_task_id = orig_xid;
#line 1504
  task->txwr_rxrd.union_ctx.cleanup.ctx.rolled_tx_seq_cnt = 0U;
#line 1505
  task->txwr_rxrd.union_ctx.cleanup.ctx.rolled_tx_data_offset = offset;
#line 1507
  bd_count = (int )(orig_io_req->bd_tbl)->bd_valid;
#line 1510
  i = 0;
#line 1510
  goto ldv_54932;
  ldv_54931: ;
#line 1511
  if ((u32 )(bd + (unsigned long )i)->buf_len > offset) {
#line 1512
    goto ldv_54930;
  } else {

  }
#line 1513
  offset = offset - (u32 )(bd + (unsigned long )i)->buf_len;
#line 1510
  i = i + 1;
  ldv_54932: ;
#line 1510
  if (i < bd_count) {
#line 1512
    goto ldv_54931;
  } else {

  }
  ldv_54930: 
#line 1515
  phys_addr = (unsigned long long )((unsigned long )i * 16UL) + phys_addr;
#line 1517
  if ((unsigned int )orig_task_type == 0U) {
#line 1518
    task->txwr_only.sgl_ctx.sgl.mul_sgl.cur_sge_addr.lo = (unsigned int )phys_addr;
#line 1520
    task->txwr_only.sgl_ctx.sgl.mul_sgl.cur_sge_addr.hi = (unsigned int )(phys_addr >> 32);
#line 1522
    task->txwr_only.sgl_ctx.sgl.mul_sgl.sgl_size = (u8 )bd_count;
#line 1524
    task->txwr_only.sgl_ctx.sgl.mul_sgl.cur_sge_off = (__le16 )offset;
#line 1526
    task->txwr_only.sgl_ctx.sgl.mul_sgl.cur_sge_idx = (u8 )i;
  } else {
#line 1528
    orig_task_idx = (int )((unsigned int )orig_xid / 32U);
#line 1529
    index = (int )orig_xid & 31;
#line 1531
    task_page = *((interface->hba)->task_ctx + (unsigned long )orig_task_idx);
#line 1533
    orig_task = task_page + (unsigned long )index;
#line 1536
    sgl = & task->rxwr_only.union_ctx.read_info.sgl_ctx.sgl;
#line 1537
    sgl->mul_sgl.cur_sge_addr.lo = (unsigned int )phys_addr;
#line 1538
    sgl->mul_sgl.cur_sge_addr.hi = (unsigned int )(phys_addr >> 32);
#line 1539
    sgl->mul_sgl.sgl_size = (u8 )bd_count;
#line 1540
    sgl->mul_sgl.cur_sge_off = (__le16 )offset;
#line 1541
    sgl->mul_sgl.cur_sge_idx = (u8 )i;
#line 1543
    memset((void *)(& task->rxwr_only.rx_seq_ctx), 0, 12UL);
#line 1545
    task->rxwr_only.rx_seq_ctx.low_exp_ro = orig_offset;
#line 1546
    task->rxwr_only.rx_seq_ctx.high_exp_ro = orig_offset;
  }
#line 1548
  return;
}
}
#line 1549 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
void bnx2fc_init_cleanup_task(struct bnx2fc_cmd *io_req , struct fcoe_task_ctx_entry *task ,
                              u16 orig_xid ) 
{ 
  u8 task_type ;
  struct bnx2fc_rport *tgt ;
  u32 context_id ;

  {
#line 1553
  task_type = 5U;
#line 1554
  tgt = io_req->tgt;
#line 1555
  context_id = tgt->context_id;
#line 1557
  memset((void *)task, 0, 128UL);
#line 1561
  task->txwr_rxrd.const_ctx.init_flags = task_type;
#line 1563
  task->txwr_rxrd.const_ctx.init_flags = task->txwr_rxrd.const_ctx.init_flags;
#line 1565
  if (tgt->dev_type == 1) {
#line 1566
    task->txwr_rxrd.const_ctx.init_flags = (u8 )((unsigned int )task->txwr_rxrd.const_ctx.init_flags | 8U);
  } else {
#line 1570
    task->txwr_rxrd.const_ctx.init_flags = task->txwr_rxrd.const_ctx.init_flags;
  }
#line 1573
  task->txwr_rxrd.union_ctx.cleanup.ctx.cleaned_task_id = orig_xid;
#line 1576
  task->txwr_rxrd.const_ctx.tx_flags = 12U;
#line 1581
  task->rxwr_txrd.const_ctx.init_flags = context_id;
#line 1583
  task->rxwr_txrd.var_ctx.rx_flags = (__le16 )((unsigned int )task->rxwr_txrd.var_ctx.rx_flags | 4096U);
#line 1584
  return;
}
}
#line 1587 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
void bnx2fc_init_mp_task(struct bnx2fc_cmd *io_req , struct fcoe_task_ctx_entry *task ) 
{ 
  struct bnx2fc_mp_req *mp_req ;
  struct bnx2fc_rport *tgt ;
  struct fc_frame_header *fc_hdr ;
  struct fcoe_ext_mul_sges_ctx *sgl ;
  u8 task_type ;
  u64 *hdr ;
  u64 temp_hdr[3U] ;
  u32 context_id ;
  __u16 tmp ;
  __u16 tmp___0 ;
  __u64 tmp___1 ;
  __u64 tmp___2 ;
  __u64 tmp___3 ;

  {
#line 1590
  mp_req = & io_req->mp_req;
#line 1591
  tgt = io_req->tgt;
#line 1594
  task_type = 0U;
#line 1601
  if ((unsigned int )io_req->cmd_type == 2U || (unsigned int )io_req->cmd_type == 4U) {
#line 1603
    task_type = 2U;
  } else
#line 1604
  if ((unsigned int )io_req->cmd_type == 3U) {
#line 1605
    task_type = 4U;
  } else {

  }
#line 1608
  memset((void *)task, 0, 128UL);
#line 1611
  io_req->task = task;
#line 1613
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "Init MP task for cmd_type = %d task_type = %d\n",
                (int )io_req->cmd_type, (int )task_type);
#line 1617
  if ((unsigned int )task_type == 2U || (unsigned int )task_type == 3U) {
#line 1619
    task->txwr_only.sgl_ctx.sgl.mul_sgl.cur_sge_addr.lo = (unsigned int )mp_req->mp_req_bd_dma;
#line 1621
    task->txwr_only.sgl_ctx.sgl.mul_sgl.cur_sge_addr.hi = (unsigned int )(mp_req->mp_req_bd_dma >> 32);
#line 1623
    task->txwr_only.sgl_ctx.sgl.mul_sgl.sgl_size = 1U;
  } else {

  }
#line 1628
  task->txwr_rxrd.const_ctx.init_flags = task_type;
#line 1630
  if (tgt->dev_type == 1) {
#line 1631
    task->txwr_rxrd.const_ctx.init_flags = (u8 )((unsigned int )task->txwr_rxrd.const_ctx.init_flags | 8U);
  } else {
#line 1635
    task->txwr_rxrd.const_ctx.init_flags = task->txwr_rxrd.const_ctx.init_flags;
  }
#line 1638
  task->txwr_rxrd.const_ctx.init_flags = task->txwr_rxrd.const_ctx.init_flags;
#line 1642
  task->txwr_rxrd.const_ctx.tx_flags = 0U;
#line 1646
  task->rxwr_txrd.const_ctx.data_2_trns = (__le32 )io_req->data_xfer_len;
#line 1649
  task->rxwr_txrd.var_ctx.rx_flags = (__le16 )((unsigned int )task->rxwr_txrd.var_ctx.rx_flags | 4096U);
#line 1652
  context_id = tgt->context_id;
#line 1653
  task->rxwr_txrd.const_ctx.init_flags = context_id;
#line 1656
  fc_hdr = & mp_req->req_fc_hdr;
#line 1657
  if ((unsigned int )task_type == 2U) {
#line 1658
    tmp = __fswab16((int )io_req->xid);
#line 1658
    fc_hdr->fh_ox_id = tmp;
#line 1659
    fc_hdr->fh_rx_id = 65535U;
#line 1660
    task->rxwr_txrd.var_ctx.rx_id = 65535U;
  } else
#line 1661
  if ((unsigned int )task_type == 3U) {
#line 1662
    tmp___0 = __fswab16((int )io_req->xid);
#line 1662
    fc_hdr->fh_rx_id = tmp___0;
  } else {

  }
#line 1666
  hdr = (u64 *)(& task->txwr_rxrd.union_ctx.tx_frame.fc_hdr);
#line 1667
  memcpy((void *)(& temp_hdr), (void const   *)fc_hdr, 24UL);
#line 1668
  tmp___1 = __fswab64(temp_hdr[0]);
#line 1668
  *hdr = tmp___1;
#line 1669
  tmp___2 = __fswab64(temp_hdr[1]);
#line 1669
  *(hdr + 1UL) = tmp___2;
#line 1670
  tmp___3 = __fswab64(temp_hdr[2]);
#line 1670
  *(hdr + 2UL) = tmp___3;
#line 1673
  if ((unsigned int )task_type == 2U) {
#line 1674
    sgl = & task->rxwr_only.union_ctx.read_info.sgl_ctx.sgl;
#line 1676
    sgl->mul_sgl.cur_sge_addr.lo = (unsigned int )mp_req->mp_resp_bd_dma;
#line 1677
    sgl->mul_sgl.cur_sge_addr.hi = (unsigned int )(mp_req->mp_resp_bd_dma >> 32);
#line 1679
    sgl->mul_sgl.sgl_size = 1U;
  } else {

  }
#line 1681
  return;
}
}
#line 1683 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
void bnx2fc_init_task(struct bnx2fc_cmd *io_req , struct fcoe_task_ctx_entry *task ) 
{ 
  u8 task_type ;
  struct scsi_cmnd *sc_cmd ;
  struct io_bdt *bd_tbl ;
  struct bnx2fc_rport *tgt ;
  struct fcoe_cached_sge_ctx *cached_sge ;
  struct fcoe_ext_mul_sges_ctx *sgl ;
  int dev_type ;
  u64 *fcp_cmnd ;
  u64 tmp_fcp_cmnd[4U] ;
  u32 context_id ;
  int cnt ;
  int i ;
  int bd_count ;
  struct fcoe_bd_ctx *fcoe_bd_tbl ;
  __le32 tmp ;
  __le32 tmp___0 ;
  __le16 tmp___1 ;
  __u64 tmp___2 ;
  struct fcoe_bd_ctx *fcoe_bd_tbl___0 ;
  struct fcoe_bd_ctx *fcoe_bd_tbl___1 ;

  {
#line 1687
  sc_cmd = io_req->sc_cmd;
#line 1688
  bd_tbl = io_req->bd_tbl;
#line 1689
  tgt = io_req->tgt;
#line 1692
  dev_type = tgt->dev_type;
#line 1699
  memset((void *)task, 0, 128UL);
#line 1702
  io_req->task = task;
#line 1704
  if ((unsigned int )sc_cmd->sc_data_direction == 1U) {
#line 1705
    task_type = 0U;
  } else {
#line 1707
    task_type = 1U;
  }
#line 1710
  bd_count = (int )bd_tbl->bd_valid;
#line 1711
  cached_sge = & task->rxwr_only.union_ctx.read_info.sgl_ctx.cached_sge;
#line 1712
  if ((unsigned int )task_type == 0U) {
#line 1713
    if (dev_type == 0 && bd_count == 1) {
#line 1714
      fcoe_bd_tbl = bd_tbl->bd_tbl;
#line 1716
      tmp = fcoe_bd_tbl->buf_addr_lo;
#line 1716
      cached_sge->cur_buf_addr.lo = tmp;
#line 1716
      task->txwr_only.sgl_ctx.cached_sge.cur_buf_addr.lo = tmp;
#line 1719
      tmp___0 = fcoe_bd_tbl->buf_addr_hi;
#line 1719
      cached_sge->cur_buf_addr.hi = tmp___0;
#line 1719
      task->txwr_only.sgl_ctx.cached_sge.cur_buf_addr.hi = tmp___0;
#line 1722
      tmp___1 = fcoe_bd_tbl->buf_len;
#line 1722
      cached_sge->cur_buf_rem = tmp___1;
#line 1722
      task->txwr_only.sgl_ctx.cached_sge.cur_buf_rem = tmp___1;
#line 1726
      task->txwr_rxrd.const_ctx.init_flags = (u8 )((unsigned int )task->txwr_rxrd.const_ctx.init_flags | 32U);
    } else {
#line 1729
      task->txwr_only.sgl_ctx.sgl.mul_sgl.cur_sge_addr.lo = (unsigned int )bd_tbl->bd_tbl_dma;
#line 1731
      task->txwr_only.sgl_ctx.sgl.mul_sgl.cur_sge_addr.hi = (unsigned int )(bd_tbl->bd_tbl_dma >> 32);
#line 1733
      task->txwr_only.sgl_ctx.sgl.mul_sgl.sgl_size = (u8 )bd_tbl->bd_valid;
    }
  } else {

  }
#line 1740
  task->txwr_rxrd.const_ctx.init_flags = (int )task->txwr_rxrd.const_ctx.init_flags | (int )task_type;
#line 1742
  if (dev_type == 1) {
#line 1743
    task->txwr_rxrd.const_ctx.init_flags = (u8 )((unsigned int )task->txwr_rxrd.const_ctx.init_flags | 8U);
#line 1746
    io_req->rec_retry = 0U;
#line 1747
    io_req->rec_retry = 0U;
  } else {
#line 1749
    task->txwr_rxrd.const_ctx.init_flags = task->txwr_rxrd.const_ctx.init_flags;
  }
#line 1752
  task->txwr_rxrd.const_ctx.init_flags = task->txwr_rxrd.const_ctx.init_flags;
#line 1755
  task->txwr_rxrd.const_ctx.tx_flags = 2U;
#line 1759
  task->txwr_rxrd.union_ctx.tx_seq.ctx.seq_cnt = 1U;
#line 1762
  fcp_cmnd = (u64 *)(& task->txwr_rxrd.union_ctx.fcp_cmd.opaque);
#line 1764
  bnx2fc_build_fcp_cmnd(io_req, (struct fcp_cmnd *)(& tmp_fcp_cmnd));
#line 1767
  cnt = 4;
#line 1769
  i = 0;
#line 1769
  goto ldv_54972;
  ldv_54971: 
#line 1770
  tmp___2 = __fswab64(tmp_fcp_cmnd[i]);
#line 1770
  *fcp_cmnd = tmp___2;
#line 1771
  fcp_cmnd = fcp_cmnd + 1;
#line 1769
  i = i + 1;
  ldv_54972: ;
#line 1769
  if (i < cnt) {
#line 1771
    goto ldv_54971;
  } else {

  }
#line 1775
  task->rxwr_txrd.const_ctx.data_2_trns = (__le32 )io_req->data_xfer_len;
#line 1777
  context_id = tgt->context_id;
#line 1778
  task->rxwr_txrd.const_ctx.init_flags = context_id;
#line 1783
  task->rxwr_txrd.var_ctx.rx_flags = (__le16 )((unsigned int )task->rxwr_txrd.var_ctx.rx_flags | 4096U);
#line 1786
  task->rxwr_txrd.var_ctx.rx_id = 65535U;
#line 1789
  if ((unsigned int )task_type != 1U) {
#line 1790
    return;
  } else {

  }
#line 1792
  sgl = & task->rxwr_only.union_ctx.read_info.sgl_ctx.sgl;
#line 1793
  bd_count = (int )bd_tbl->bd_valid;
#line 1795
  if (dev_type == 0) {
#line 1796
    if (bd_count == 1) {
#line 1798
      fcoe_bd_tbl___0 = bd_tbl->bd_tbl;
#line 1800
      cached_sge->cur_buf_addr.lo = fcoe_bd_tbl___0->buf_addr_lo;
#line 1801
      cached_sge->cur_buf_addr.hi = fcoe_bd_tbl___0->buf_addr_hi;
#line 1802
      cached_sge->cur_buf_rem = fcoe_bd_tbl___0->buf_len;
#line 1803
      task->txwr_rxrd.const_ctx.init_flags = (u8 )((unsigned int )task->txwr_rxrd.const_ctx.init_flags | 32U);
    } else
#line 1805
    if (bd_count == 2) {
#line 1806
      fcoe_bd_tbl___1 = bd_tbl->bd_tbl;
#line 1808
      cached_sge->cur_buf_addr.lo = fcoe_bd_tbl___1->buf_addr_lo;
#line 1809
      cached_sge->cur_buf_addr.hi = fcoe_bd_tbl___1->buf_addr_hi;
#line 1810
      cached_sge->cur_buf_rem = fcoe_bd_tbl___1->buf_len;
#line 1812
      fcoe_bd_tbl___1 = fcoe_bd_tbl___1 + 1;
#line 1813
      cached_sge->second_buf_addr.lo = fcoe_bd_tbl___1->buf_addr_lo;
#line 1815
      cached_sge->second_buf_addr.hi = fcoe_bd_tbl___1->buf_addr_hi;
#line 1817
      cached_sge->second_buf_rem = fcoe_bd_tbl___1->buf_len;
#line 1818
      task->txwr_rxrd.const_ctx.init_flags = (u8 )((unsigned int )task->txwr_rxrd.const_ctx.init_flags | 32U);
    } else {
#line 1822
      sgl->mul_sgl.cur_sge_addr.lo = (unsigned int )bd_tbl->bd_tbl_dma;
#line 1823
      sgl->mul_sgl.cur_sge_addr.hi = (unsigned int )(bd_tbl->bd_tbl_dma >> 32);
#line 1825
      sgl->mul_sgl.sgl_size = (u8 )bd_count;
    }
  } else {
#line 1828
    sgl->mul_sgl.cur_sge_addr.lo = (unsigned int )bd_tbl->bd_tbl_dma;
#line 1829
    sgl->mul_sgl.cur_sge_addr.hi = (unsigned int )(bd_tbl->bd_tbl_dma >> 32);
#line 1831
    sgl->mul_sgl.sgl_size = (u8 )bd_count;
  }
#line 1833
  return;
}
}
#line 1844 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
int bnx2fc_setup_task_ctx(struct bnx2fc_hba *hba ) 
{ 
  int rc ;
  struct regpair *task_ctx_bdt ;
  dma_addr_t addr ;
  int task_ctx_arr_sz ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 1846
  rc = 0;
#line 1858
  tmp = dma_alloc_attrs(& (hba->pcidev)->dev, 4096UL, & hba->task_ctx_bd_dma, 208U,
                        (struct dma_attrs *)0);
#line 1858
  hba->task_ctx_bd_tbl = (struct regpair *)tmp;
#line 1862
  if ((unsigned long )hba->task_ctx_bd_tbl == (unsigned long )((struct regpair *)0)) {
#line 1863
    printk("\vbnx2fc: unable to allocate task context BDT\n");
#line 1864
    rc = -1;
#line 1865
    goto out;
  } else {

  }
#line 1867
  memset((void *)hba->task_ctx_bd_tbl, 0, 4096UL);
#line 1873
  task_ctx_arr_sz = (int )(hba->max_tasks / 32U);
#line 1874
  tmp___0 = kzalloc((unsigned long )task_ctx_arr_sz * 8UL, 208U);
#line 1874
  hba->task_ctx = (struct fcoe_task_ctx_entry **)tmp___0;
#line 1876
  if ((unsigned long )hba->task_ctx == (unsigned long )((struct fcoe_task_ctx_entry **)0)) {
#line 1877
    printk("\vbnx2fc: unable to allocate task context array\n");
#line 1878
    rc = -1;
#line 1879
    goto out1;
  } else {

  }
#line 1885
  tmp___1 = kmalloc((unsigned long )task_ctx_arr_sz * 8UL, 208U);
#line 1885
  hba->task_ctx_dma = (dma_addr_t *)tmp___1;
#line 1887
  if ((unsigned long )hba->task_ctx_dma == (unsigned long )((dma_addr_t *)0ULL)) {
#line 1888
    printk("\vbnx2fc: unable to alloc context mapping array\n");
#line 1889
    rc = -1;
#line 1890
    goto out2;
  } else {

  }
#line 1893
  task_ctx_bdt = hba->task_ctx_bd_tbl;
#line 1894
  i = 0;
#line 1894
  goto ldv_54989;
  ldv_54988: 
#line 1896
  tmp___2 = dma_alloc_attrs(& (hba->pcidev)->dev, 4096UL, hba->task_ctx_dma + (unsigned long )i,
                            208U, (struct dma_attrs *)0);
#line 1896
  *(hba->task_ctx + (unsigned long )i) = (struct fcoe_task_ctx_entry *)tmp___2;
#line 1900
  if ((unsigned long )*(hba->task_ctx + (unsigned long )i) == (unsigned long )((struct fcoe_task_ctx_entry *)0)) {
#line 1901
    printk("\vbnx2fc: unable to alloc task context\n");
#line 1902
    rc = -1;
#line 1903
    goto out3;
  } else {

  }
#line 1905
  memset((void *)*(hba->task_ctx + (unsigned long )i), 0, 4096UL);
#line 1906
  addr = *(hba->task_ctx_dma + (unsigned long )i);
#line 1907
  task_ctx_bdt->hi = (unsigned int )(addr >> 32);
#line 1908
  task_ctx_bdt->lo = (unsigned int )addr;
#line 1909
  task_ctx_bdt = task_ctx_bdt + 1;
#line 1894
  i = i + 1;
  ldv_54989: ;
#line 1894
  if (i < task_ctx_arr_sz) {
#line 1896
    goto ldv_54988;
  } else {

  }

#line 1911
  return (0);
  out3: 
#line 1914
  i = 0;
#line 1914
  goto ldv_54992;
  ldv_54991: ;
#line 1915
  if ((unsigned long )*(hba->task_ctx + (unsigned long )i) != (unsigned long )((struct fcoe_task_ctx_entry *)0)) {
#line 1917
    dma_free_attrs(& (hba->pcidev)->dev, 4096UL, (void *)*(hba->task_ctx + (unsigned long )i),
                   *(hba->task_ctx_dma + (unsigned long )i), (struct dma_attrs *)0);
#line 1919
    *(hba->task_ctx + (unsigned long )i) = (struct fcoe_task_ctx_entry *)0;
  } else {

  }
#line 1914
  i = i + 1;
  ldv_54992: ;
#line 1914
  if (i < task_ctx_arr_sz) {
#line 1916
    goto ldv_54991;
  } else {

  }
#line 1923
  kfree((void const   *)hba->task_ctx_dma);
#line 1924
  hba->task_ctx_dma = (dma_addr_t *)0ULL;
  out2: 
#line 1926
  kfree((void const   *)hba->task_ctx);
#line 1927
  hba->task_ctx = (struct fcoe_task_ctx_entry **)0;
  out1: 
#line 1929
  dma_free_attrs(& (hba->pcidev)->dev, 4096UL, (void *)hba->task_ctx_bd_tbl, hba->task_ctx_bd_dma,
                 (struct dma_attrs *)0);
#line 1931
  hba->task_ctx_bd_tbl = (struct regpair *)0;
  out: ;
#line 1933
  return (rc);
}
}
#line 1936 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
void bnx2fc_free_task_ctx(struct bnx2fc_hba *hba ) 
{ 
  int task_ctx_arr_sz ;
  int i ;

  {
#line 1941
  if ((unsigned long )hba->task_ctx_bd_tbl != (unsigned long )((struct regpair *)0)) {
#line 1942
    dma_free_attrs(& (hba->pcidev)->dev, 4096UL, (void *)hba->task_ctx_bd_tbl, hba->task_ctx_bd_dma,
                   (struct dma_attrs *)0);
#line 1945
    hba->task_ctx_bd_tbl = (struct regpair *)0;
  } else {

  }
#line 1948
  task_ctx_arr_sz = (int )(hba->max_tasks / 32U);
#line 1949
  if ((unsigned long )hba->task_ctx != (unsigned long )((struct fcoe_task_ctx_entry **)0)) {
#line 1950
    i = 0;
#line 1950
    goto ldv_55000;
    ldv_54999: ;
#line 1951
    if ((unsigned long )*(hba->task_ctx + (unsigned long )i) != (unsigned long )((struct fcoe_task_ctx_entry *)0)) {
#line 1952
      dma_free_attrs(& (hba->pcidev)->dev, 4096UL, (void *)*(hba->task_ctx + (unsigned long )i),
                     *(hba->task_ctx_dma + (unsigned long )i), (struct dma_attrs *)0);
#line 1955
      *(hba->task_ctx + (unsigned long )i) = (struct fcoe_task_ctx_entry *)0;
    } else {

    }
#line 1950
    i = i + 1;
    ldv_55000: ;
#line 1950
    if (i < task_ctx_arr_sz) {
#line 1952
      goto ldv_54999;
    } else {

    }
#line 1958
    kfree((void const   *)hba->task_ctx);
#line 1959
    hba->task_ctx = (struct fcoe_task_ctx_entry **)0;
  } else {

  }
#line 1962
  kfree((void const   *)hba->task_ctx_dma);
#line 1963
  hba->task_ctx_dma = (dma_addr_t *)0ULL;
#line 1964
  return;
}
}
#line 1966 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
static void bnx2fc_free_hash_table(struct bnx2fc_hba *hba ) 
{ 
  int i ;
  int segment_count ;
  u32 *pbl ;
  dma_addr_t dma_address ;

  {
#line 1972
  if ((unsigned long )hba->hash_tbl_segments != (unsigned long )((void **)0)) {
#line 1974
    pbl = (u32 *)hba->hash_tbl_pbl;
#line 1975
    if ((unsigned long )pbl != (unsigned long )((u32 *)0U)) {
#line 1976
      segment_count = hba->hash_tbl_segment_count;
#line 1977
      i = 0;
#line 1977
      goto ldv_55010;
      ldv_55009: 
#line 1980
      dma_address = (dma_addr_t )*pbl;
#line 1981
      pbl = pbl + 1;
#line 1982
      dma_address = ((unsigned long long )*pbl << 32) + dma_address;
#line 1983
      pbl = pbl + 1;
#line 1984
      dma_free_attrs(& (hba->pcidev)->dev, 16384UL, *(hba->hash_tbl_segments + (unsigned long )i),
                     dma_address, (struct dma_attrs *)0);
#line 1977
      i = i + 1;
      ldv_55010: ;
#line 1977
      if (i < segment_count) {
#line 1979
        goto ldv_55009;
      } else {

      }

    } else {

    }
#line 1991
    kfree((void const   *)hba->hash_tbl_segments);
#line 1992
    hba->hash_tbl_segments = (void **)0;
  } else {

  }
#line 1995
  if ((unsigned long )hba->hash_tbl_pbl != (unsigned long )((void *)0)) {
#line 1996
    dma_free_attrs(& (hba->pcidev)->dev, 4096UL, hba->hash_tbl_pbl, hba->hash_tbl_pbl_dma,
                   (struct dma_attrs *)0);
#line 1999
    hba->hash_tbl_pbl = (void *)0;
  } else {

  }
#line 2001
  return;
}
}
#line 2003 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
static int bnx2fc_allocate_hash_table(struct bnx2fc_hba *hba ) 
{ 
  int i ;
  int hash_table_size ;
  int segment_count ;
  int segment_array_size ;
  int dma_segment_array_size ;
  dma_addr_t *dma_segment_array ;
  u32 *pbl ;
  void *tmp ;
  void *tmp___0 ;
  u64 paddr ;
  u32 lo ;
  u32 hi ;

  {
#line 2013
  hash_table_size = 262144;
#line 2016
  segment_count = hash_table_size + 16383;
#line 2017
  segment_count = segment_count / 16384;
#line 2018
  hba->hash_tbl_segment_count = segment_count;
#line 2020
  segment_array_size = (int )((unsigned int )segment_count * 8U);
#line 2021
  tmp = kzalloc((size_t )segment_array_size, 208U);
#line 2021
  hba->hash_tbl_segments = (void **)tmp;
#line 2022
  if ((unsigned long )hba->hash_tbl_segments == (unsigned long )((void **)0)) {
#line 2023
    printk("\vbnx2fc: hash table pointers alloc failed\n");
#line 2024
    return (-12);
  } else {

  }
#line 2026
  dma_segment_array_size = (int )((unsigned int )segment_count * 8U);
#line 2027
  tmp___0 = kzalloc((size_t )dma_segment_array_size, 208U);
#line 2027
  dma_segment_array = (dma_addr_t *)tmp___0;
#line 2028
  if ((unsigned long )dma_segment_array == (unsigned long )((dma_addr_t *)0ULL)) {
#line 2029
    printk("\vbnx2fc: hash table pointers (dma) alloc failed\n");
#line 2030
    goto cleanup_ht;
  } else {

  }
#line 2033
  i = 0;
#line 2033
  goto ldv_55025;
  ldv_55024: 
#line 2034
  *(hba->hash_tbl_segments + (unsigned long )i) = dma_alloc_attrs(& (hba->pcidev)->dev,
                                                                  16384UL, dma_segment_array + (unsigned long )i,
                                                                  208U, (struct dma_attrs *)0);
#line 2039
  if ((unsigned long )*(hba->hash_tbl_segments + (unsigned long )i) == (unsigned long )((void *)0)) {
#line 2040
    printk("\vbnx2fc: hash segment alloc failed\n");
#line 2041
    goto cleanup_dma;
  } else {

  }
#line 2043
  memset(*(hba->hash_tbl_segments + (unsigned long )i), 0, 16384UL);
#line 2033
  i = i + 1;
  ldv_55025: ;
#line 2033
  if (i < segment_count) {
#line 2035
    goto ldv_55024;
  } else {

  }
#line 2047
  hba->hash_tbl_pbl = dma_alloc_attrs(& (hba->pcidev)->dev, 4096UL, & hba->hash_tbl_pbl_dma,
                                      208U, (struct dma_attrs *)0);
#line 2051
  if ((unsigned long )hba->hash_tbl_pbl == (unsigned long )((void *)0)) {
#line 2052
    printk("\vbnx2fc: hash table pbl alloc failed\n");
#line 2053
    goto cleanup_dma;
  } else {

  }
#line 2055
  memset(hba->hash_tbl_pbl, 0, 4096UL);
#line 2057
  pbl = (u32 *)hba->hash_tbl_pbl;
#line 2058
  i = 0;
#line 2058
  goto ldv_55029;
  ldv_55028: 
#line 2059
  paddr = *(dma_segment_array + (unsigned long )i);
#line 2060
  *pbl = (unsigned int )paddr;
#line 2061
  pbl = pbl + 1;
#line 2062
  *pbl = (unsigned int )(paddr >> 32);
#line 2063
  pbl = pbl + 1;
#line 2058
  i = i + 1;
  ldv_55029: ;
#line 2058
  if (i < segment_count) {
#line 2060
    goto ldv_55028;
  } else {

  }
#line 2065
  pbl = (u32 *)hba->hash_tbl_pbl;
#line 2066
  i = 0;
#line 2067
  goto ldv_55034;
  ldv_55033: 
#line 2070
  lo = *pbl;
#line 2071
  pbl = pbl + 1;
#line 2072
  hi = *pbl;
#line 2073
  pbl = pbl + 1;
#line 2074
  i = i + 1;
  ldv_55034: ;
#line 2067
  if (*pbl != 0U && *(pbl + 1UL) != 0U) {
#line 2069
    goto ldv_55033;
  } else {

  }
#line 2076
  kfree((void const   *)dma_segment_array);
#line 2077
  return (0);
  cleanup_dma: 
#line 2080
  i = 0;
#line 2080
  goto ldv_55037;
  ldv_55036: ;
#line 2081
  if ((unsigned long )*(hba->hash_tbl_segments + (unsigned long )i) != (unsigned long )((void *)0)) {
#line 2082
    dma_free_attrs(& (hba->pcidev)->dev, 16384UL, *(hba->hash_tbl_segments + (unsigned long )i),
                   *(dma_segment_array + (unsigned long )i), (struct dma_attrs *)0);
  } else {

  }
#line 2080
  i = i + 1;
  ldv_55037: ;
#line 2080
  if (i < segment_count) {
#line 2082
    goto ldv_55036;
  } else {

  }
#line 2088
  kfree((void const   *)dma_segment_array);
  cleanup_ht: 
#line 2091
  kfree((void const   *)hba->hash_tbl_segments);
#line 2092
  hba->hash_tbl_segments = (void **)0;
#line 2093
  return (-12);
}
}
#line 2102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
int bnx2fc_setup_fw_resc(struct bnx2fc_hba *hba ) 
{ 
  u64 addr ;
  u32 mem_size ;
  int i ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 2108
  tmp = bnx2fc_allocate_hash_table(hba);
#line 2108
  if (tmp != 0) {
#line 2109
    return (-12);
  } else {

  }
#line 2111
  mem_size = 8192U;
#line 2112
  tmp___0 = dma_alloc_attrs(& (hba->pcidev)->dev, (size_t )mem_size, & hba->t2_hash_tbl_ptr_dma,
                            208U, (struct dma_attrs *)0);
#line 2112
  hba->t2_hash_tbl_ptr = (char *)tmp___0;
#line 2115
  if ((unsigned long )hba->t2_hash_tbl_ptr == (unsigned long )((char *)0)) {
#line 2116
    printk("\vbnx2fc: unable to allocate t2 hash table ptr\n");
#line 2117
    bnx2fc_free_fw_resc(hba);
#line 2118
    return (-12);
  } else {

  }
#line 2120
  memset((void *)hba->t2_hash_tbl_ptr, 0, (size_t )mem_size);
#line 2122
  mem_size = 65536U;
#line 2124
  tmp___1 = dma_alloc_attrs(& (hba->pcidev)->dev, (size_t )mem_size, & hba->t2_hash_tbl_dma,
                            208U, (struct dma_attrs *)0);
#line 2124
  hba->t2_hash_tbl = (struct fcoe_t2_hash_table_entry *)tmp___1;
#line 2127
  if ((unsigned long )hba->t2_hash_tbl == (unsigned long )((struct fcoe_t2_hash_table_entry *)0)) {
#line 2128
    printk("\vbnx2fc: unable to allocate t2 hash table\n");
#line 2129
    bnx2fc_free_fw_resc(hba);
#line 2130
    return (-12);
  } else {

  }
#line 2132
  memset((void *)hba->t2_hash_tbl, 0, (size_t )mem_size);
#line 2133
  i = 0;
#line 2133
  goto ldv_55046;
  ldv_55045: 
#line 2134
  addr = (u64 )((unsigned long )hba->t2_hash_tbl_dma + (unsigned long )(i + 1) * 64UL);
#line 2136
  (hba->t2_hash_tbl + (unsigned long )i)->next.lo = (__le32 )addr;
#line 2137
  (hba->t2_hash_tbl + (unsigned long )i)->next.hi = (__le32 )(addr >> 32);
#line 2133
  i = i + 1;
  ldv_55046: ;
#line 2133
  if (i <= 1023) {
#line 2135
    goto ldv_55045;
  } else {

  }
#line 2140
  tmp___2 = dma_alloc_attrs(& (hba->pcidev)->dev, 4096UL, & hba->dummy_buf_dma, 208U,
                            (struct dma_attrs *)0);
#line 2140
  hba->dummy_buffer = (char *)tmp___2;
#line 2143
  if ((unsigned long )hba->dummy_buffer == (unsigned long )((char *)0)) {
#line 2144
    printk("\vbnx2fc: unable to alloc MP Dummy Buffer\n");
#line 2145
    bnx2fc_free_fw_resc(hba);
#line 2146
    return (-12);
  } else {

  }
#line 2149
  tmp___3 = dma_alloc_attrs(& (hba->pcidev)->dev, 4096UL, & hba->stats_buf_dma, 208U,
                            (struct dma_attrs *)0);
#line 2149
  hba->stats_buffer = (struct fcoe_statistics_params *)tmp___3;
#line 2153
  if ((unsigned long )hba->stats_buffer == (unsigned long )((struct fcoe_statistics_params *)0)) {
#line 2154
    printk("\vbnx2fc: unable to alloc Stats Buffer\n");
#line 2155
    bnx2fc_free_fw_resc(hba);
#line 2156
    return (-12);
  } else {

  }
#line 2158
  memset((void *)hba->stats_buffer, 0, 4096UL);
#line 2160
  return (0);
}
}
#line 2163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.c"
void bnx2fc_free_fw_resc(struct bnx2fc_hba *hba ) 
{ 
  u32 mem_size ;

  {
#line 2167
  if ((unsigned long )hba->stats_buffer != (unsigned long )((struct fcoe_statistics_params *)0)) {
#line 2168
    dma_free_attrs(& (hba->pcidev)->dev, 4096UL, (void *)hba->stats_buffer, hba->stats_buf_dma,
                   (struct dma_attrs *)0);
#line 2170
    hba->stats_buffer = (struct fcoe_statistics_params *)0;
  } else {

  }
#line 2173
  if ((unsigned long )hba->dummy_buffer != (unsigned long )((char *)0)) {
#line 2174
    dma_free_attrs(& (hba->pcidev)->dev, 4096UL, (void *)hba->dummy_buffer, hba->dummy_buf_dma,
                   (struct dma_attrs *)0);
#line 2176
    hba->dummy_buffer = (char *)0;
  } else {

  }
#line 2179
  if ((unsigned long )hba->t2_hash_tbl_ptr != (unsigned long )((char *)0)) {
#line 2180
    mem_size = 8192U;
#line 2181
    dma_free_attrs(& (hba->pcidev)->dev, (size_t )mem_size, (void *)hba->t2_hash_tbl_ptr,
                   hba->t2_hash_tbl_ptr_dma, (struct dma_attrs *)0);
#line 2184
    hba->t2_hash_tbl_ptr = (char *)0;
  } else {

  }
#line 2187
  if ((unsigned long )hba->t2_hash_tbl != (unsigned long )((struct fcoe_t2_hash_table_entry *)0)) {
#line 2188
    mem_size = 65536U;
#line 2190
    dma_free_attrs(& (hba->pcidev)->dev, (size_t )mem_size, (void *)hba->t2_hash_tbl,
                   hba->t2_hash_tbl_dma, (struct dma_attrs *)0);
#line 2192
    hba->t2_hash_tbl = (struct fcoe_t2_hash_table_entry *)0;
  } else {

  }
#line 2194
  bnx2fc_free_hash_table(hba);
#line 2195
  return;
}
}
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.o.c.prepared"
void call_and_disable_all_2(int state ) 
{ 


  {
#line 156
  if (ldv_work_2_0 == state) {
#line 157
    call_and_disable_work_2(ldv_work_struct_2_0);
  } else {

  }
#line 158
  if (ldv_work_2_1 == state) {
#line 159
    call_and_disable_work_2(ldv_work_struct_2_1);
  } else {

  }
#line 160
  if (ldv_work_2_2 == state) {
#line 161
    call_and_disable_work_2(ldv_work_struct_2_2);
  } else {

  }
#line 162
  if (ldv_work_2_3 == state) {
#line 163
    call_and_disable_work_2(ldv_work_struct_2_3);
  } else {

  }
#line 164
  return;
}
}
#line 167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.o.c.prepared"
void invoke_work_2(void) 
{ 
  int tmp ;

  {
#line 169
  tmp = __VERIFIER_nondet_int();
#line 169
  switch (tmp) {
  case 0: ;
#line 171
  if (ldv_work_2_0 == 2 || ldv_work_2_0 == 3) {
#line 172
    ldv_work_2_0 = 4;
#line 173
    bnx2fc_unsol_els_work(ldv_work_struct_2_0);
#line 174
    ldv_work_2_0 = 1;
  } else {

  }
#line 177
  goto ldv_55061;
  case 1: ;
#line 179
  if (ldv_work_2_1 == 2 || ldv_work_2_1 == 3) {
#line 180
    ldv_work_2_1 = 4;
#line 181
    bnx2fc_unsol_els_work(ldv_work_struct_2_0);
#line 182
    ldv_work_2_1 = 1;
  } else {

  }
#line 185
  goto ldv_55061;
  case 2: ;
#line 187
  if (ldv_work_2_2 == 2 || ldv_work_2_2 == 3) {
#line 188
    ldv_work_2_2 = 4;
#line 189
    bnx2fc_unsol_els_work(ldv_work_struct_2_0);
#line 190
    ldv_work_2_2 = 1;
  } else {

  }
#line 193
  goto ldv_55061;
  case 3: ;
#line 195
  if (ldv_work_2_3 == 2 || ldv_work_2_3 == 3) {
#line 196
    ldv_work_2_3 = 4;
#line 197
    bnx2fc_unsol_els_work(ldv_work_struct_2_0);
#line 198
    ldv_work_2_3 = 1;
  } else {

  }
#line 201
  goto ldv_55061;
  default: 
#line 202
  ldv_stop();
  }
  ldv_55061: ;
#line 204
  return;
}
}
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.o.c.prepared"
void work_init_2(void) 
{ 


  {
#line 209
  ldv_work_2_0 = 0;
#line 210
  ldv_work_2_1 = 0;
#line 211
  ldv_work_2_2 = 0;
#line 212
  ldv_work_2_3 = 0;
#line 213
  return;
}
}
#line 216 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.o.c.prepared"
void activate_work_2(struct work_struct *work , int state ) 
{ 


  {
#line 217
  if (ldv_work_2_0 == 0) {
#line 218
    ldv_work_struct_2_0 = work;
#line 219
    ldv_work_2_0 = state;
#line 220
    return;
  } else {

  }
#line 223
  if (ldv_work_2_1 == 0) {
#line 224
    ldv_work_struct_2_1 = work;
#line 225
    ldv_work_2_1 = state;
#line 226
    return;
  } else {

  }
#line 229
  if (ldv_work_2_2 == 0) {
#line 230
    ldv_work_struct_2_2 = work;
#line 231
    ldv_work_2_2 = state;
#line 232
    return;
  } else {

  }
#line 235
  if (ldv_work_2_3 == 0) {
#line 236
    ldv_work_struct_2_3 = work;
#line 237
    ldv_work_2_3 = state;
#line 238
    return;
  } else {

  }
#line 240
  return;
}
}
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.o.c.prepared"
void disable_work_2(struct work_struct *work ) 
{ 


  {
#line 245
  if ((ldv_work_2_0 == 3 || ldv_work_2_0 == 2) && (unsigned long )ldv_work_struct_2_0 == (unsigned long )work) {
#line 247
    ldv_work_2_0 = 1;
  } else {

  }
#line 249
  if ((ldv_work_2_1 == 3 || ldv_work_2_1 == 2) && (unsigned long )ldv_work_struct_2_1 == (unsigned long )work) {
#line 251
    ldv_work_2_1 = 1;
  } else {

  }
#line 253
  if ((ldv_work_2_2 == 3 || ldv_work_2_2 == 2) && (unsigned long )ldv_work_struct_2_2 == (unsigned long )work) {
#line 255
    ldv_work_2_2 = 1;
  } else {

  }
#line 257
  if ((ldv_work_2_3 == 3 || ldv_work_2_3 == 2) && (unsigned long )ldv_work_struct_2_3 == (unsigned long )work) {
#line 259
    ldv_work_2_3 = 1;
  } else {

  }
#line 260
  return;
}
}
#line 264 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.o.c.prepared"
void call_and_disable_work_2(struct work_struct *work ) 
{ 


  {
#line 267
  if ((ldv_work_2_0 == 2 || ldv_work_2_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_0) {
#line 269
    bnx2fc_unsol_els_work(work);
#line 270
    ldv_work_2_0 = 1;
#line 271
    return;
  } else {

  }
#line 273
  if ((ldv_work_2_1 == 2 || ldv_work_2_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_1) {
#line 275
    bnx2fc_unsol_els_work(work);
#line 276
    ldv_work_2_1 = 1;
#line 277
    return;
  } else {

  }
#line 279
  if ((ldv_work_2_2 == 2 || ldv_work_2_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_2) {
#line 281
    bnx2fc_unsol_els_work(work);
#line 282
    ldv_work_2_2 = 1;
#line 283
    return;
  } else {

  }
#line 285
  if ((ldv_work_2_3 == 2 || ldv_work_2_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_3) {
#line 287
    bnx2fc_unsol_els_work(work);
#line 288
    ldv_work_2_3 = 1;
#line 289
    return;
  } else {

  }
#line 291
  return;
}
}
#line 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.o.c.prepared"
bool ldv_queue_work_on_66(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 321
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 321
  ldv_func_res = tmp;
#line 323
  activate_work_2(ldv_func_arg3, 2);
#line 325
  return (ldv_func_res);
}
}
#line 328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.o.c.prepared"
bool ldv_queue_delayed_work_on_67(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 332
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 332
  ldv_func_res = tmp;
#line 334
  activate_work_2(& ldv_func_arg3->work, 2);
#line 336
  return (ldv_func_res);
}
}
#line 339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.o.c.prepared"
bool ldv_queue_work_on_68(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 343
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 343
  ldv_func_res = tmp;
#line 345
  activate_work_2(ldv_func_arg3, 2);
#line 347
  return (ldv_func_res);
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.o.c.prepared"
void ldv_flush_workqueue_69(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 353
  flush_workqueue(ldv_func_arg1);
#line 355
  call_and_disable_all_2(2);
#line 356
  return;
}
}
#line 358 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.o.c.prepared"
bool ldv_queue_delayed_work_on_70(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 362
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 362
  ldv_func_res = tmp;
#line 364
  activate_work_2(& ldv_func_arg3->work, 2);
#line 366
  return (ldv_func_res);
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.o.c.prepared"
int ldv_scsi_add_host_with_dma_71(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 373
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 373
  ldv_func_res = tmp;
#line 375
  if (ldv_func_res == 0) {
#line 376
    ldv_state_variable_10 = 1;
#line 376
    ldv_initialize_scsi_host_template_10();
  } else {

  }
#line 380
  return (ldv_func_res);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.o.c.prepared"
struct Scsi_Host *ldv_scsi_host_alloc_72(struct scsi_host_template *sht , int privsize ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  struct Scsi_Host *tmp ;

  {
#line 387
  tmp = scsi_host_alloc(sht, privsize);
#line 387
  ldv_func_res = tmp;
#line 389
  if ((unsigned long )ldv_func_res != (unsigned long )((ldv_func_ret_type___4 )0)) {
#line 390
    ldv_state_variable_10 = 1;
#line 390
    ldv_initialize_scsi_host_template_10();
  } else {

  }
#line 394
  return (ldv_func_res);
}
}
#line 397 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_hwi.o.c.prepared"
bool ldv_cancel_delayed_work_73(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 401
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 401
  ldv_func_res = tmp;
#line 403
  disable_work_2(& ldv_func_arg1->work);
#line 405
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 61 "include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 63
  __list_add(new, head, head->next);
#line 64
  return;
}
}
#line 90 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 92
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 94
  return;
}
}
#line 102 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
#line 104
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0": "+m" (v->counter));
#line 106
  return;
}
}
#line 91 "include/linux/completion.h"
extern void wait_for_completion(struct completion * ) ;
#line 292 "include/linux/jiffies.h"
extern unsigned long __msecs_to_jiffies(unsigned int const    ) ;
#line 354 "include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const   m ) 
{ 
  unsigned long tmp___0 ;

  {
#line 361
  tmp___0 = __msecs_to_jiffies(m);
#line 361
  return (tmp___0);
}
}
#line 88 "include/linux/timer.h"
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
#line 20 "include/linux/workqueue.h"
extern void delayed_work_timer_fn(unsigned long  ) ;
#line 433
bool ldv_queue_work_on_86(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_88(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_87(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_90(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_89(struct workqueue_struct *ldv_func_arg1 ) ;
#line 470
bool ldv_cancel_delayed_work_93(struct delayed_work *ldv_func_arg1 ) ;
#line 474
bool ldv_cancel_delayed_work_94(struct delayed_work *ldv_func_arg1 ) ;
#line 478
bool ldv_cancel_delayed_work_95(struct delayed_work *ldv_func_arg1 ) ;
#line 482
bool ldv_cancel_delayed_work_96(struct delayed_work *ldv_func_arg1 ) ;
#line 486
bool ldv_cancel_delayed_work_97(struct delayed_work *ldv_func_arg1 ) ;
#line 490
bool ldv_cancel_delayed_work_98(struct delayed_work *ldv_func_arg1 ) ;
#line 483 "include/linux/workqueue.h"
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay ) 
{ 
  bool tmp ;

  {
#line 487
  tmp = ldv_queue_delayed_work_on_87(8192, wq, dwork, delay);
#line 487
  return (tmp);
}
}
#line 41 "include/linux/kref.h"
__inline static void kref_get___1(struct kref *kref ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 47
  tmp = atomic_add_return(1, & kref->refcount);
#line 47
  __ret_warn_once = tmp <= 1;
#line 47
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 47
  if (tmp___2 != 0L) {
#line 47
    __ret_warn_on = ! __warned;
#line 47
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___0 != 0L) {
#line 47
      warn_slowpath_null("include/linux/kref.h", 47);
    } else {

    }
#line 47
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___1 != 0L) {
#line 47
      __warned = 1;
    } else {

    }
  } else {

  }
#line 47
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 49
  return;
}
}
#line 68 "include/linux/kref.h"
__inline static int kref_sub___2(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
#line 71
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
#line 71
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 71
  if (tmp != 0L) {
#line 71
    warn_slowpath_null("include/linux/kref.h", 71);
  } else {

  }
#line 71
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 73
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
#line 73
  if (tmp___0 != 0) {
#line 74
    (*release)(kref);
#line 75
    return (1);
  } else {

  }
#line 77
  return (0);
}
}
#line 97 "include/linux/kref.h"
__inline static int kref_put___2(struct kref *kref , void (*release)(struct kref * ) ) 
{ 
  int tmp ;

  {
#line 99
  tmp = kref_sub___2(kref, 1U, release);
#line 99
  return (tmp);
}
}
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
void activate_work_3(struct work_struct *work , int state ) ;
#line 113
void call_and_disable_work_3(struct work_struct *work ) ;
#line 115
void disable_work_3(struct work_struct *work ) ;
#line 140
void invoke_work_3(void) ;
#line 145
void call_and_disable_all_3(int state ) ;
#line 131 "include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 120 "include/linux/scatterlist.h"
__inline static struct page *sg_page(struct scatterlist *sg ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 123
  tmp = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
#line 123
  if (tmp != 0L) {
#line 123
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (123), "i" (12UL));
    ldv_25442: ;
#line 123
    goto ldv_25442;
  } else {

  }
#line 124
  tmp___0 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
#line 124
  if (tmp___0 != 0L) {
#line 124
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (124), "i" (12UL));
    ldv_25443: ;
#line 124
    goto ldv_25443;
  } else {

  }
#line 126
  return ((struct page *)(sg->page_link & 0xfffffffffffffffcUL));
}
}
#line 243 "include/linux/scatterlist.h"
__inline static void *sg_virt(struct scatterlist *sg ) 
{ 
  struct page *tmp ;
  void *tmp___0 ;

  {
#line 245
  tmp = sg_page(sg);
#line 245
  tmp___0 = lowmem_page_address((struct page  const  *)tmp);
#line 245
  return (tmp___0 + (unsigned long )sg->offset);
}
}
#line 250
extern struct scatterlist *sg_next(struct scatterlist * ) ;
#line 73 "include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 75
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
#line 47 "include/linux/dma-debug.h"
extern void debug_dma_map_sg(struct device * , struct scatterlist * , int  , int  ,
                             int  ) ;
#line 50
extern void debug_dma_unmap_sg(struct device * , struct scatterlist * , int  , int  ) ;
#line 30 "./arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops ;
#line 32 "./arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
#line 37
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 46 "include/asm-generic/dma-mapping-common.h"
__inline static int dma_map_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                     int nents , enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int i ;
  int ents ;
  struct scatterlist *s ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 50
  tmp = get_dma_ops(dev);
#line 50
  ops = tmp;
#line 54
  i = 0;
#line 54
  s = sg;
#line 54
  goto ldv_25961;
  ldv_25960: 
#line 55
  tmp___0 = sg_virt(s);
#line 55
  kmemcheck_mark_initialized(tmp___0, s->length);
#line 54
  i = i + 1;
#line 54
  s = sg_next(s);
  ldv_25961: ;
#line 54
  if (i < nents) {
#line 56
    goto ldv_25960;
  } else {

  }
#line 56
  tmp___1 = valid_dma_direction((int )dir);
#line 56
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
#line 56
  if (tmp___2 != 0L) {
#line 56
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (56), "i" (12UL));
    ldv_25963: ;
#line 56
    goto ldv_25963;
  } else {

  }
#line 57
  ents = (*(ops->map_sg))(dev, sg, nents, dir, attrs);
#line 58
  tmp___3 = ldv__builtin_expect(ents < 0, 0L);
#line 58
  if (tmp___3 != 0L) {
#line 58
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (58), "i" (12UL));
    ldv_25964: ;
#line 58
    goto ldv_25964;
  } else {

  }
#line 59
  debug_dma_map_sg(dev, sg, nents, ents, (int )dir);
#line 61
  return (ents);
}
}
#line 64 "include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                        int nents , enum dma_data_direction dir ,
                                        struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 68
  tmp = get_dma_ops(dev);
#line 68
  ops = tmp;
#line 70
  tmp___0 = valid_dma_direction((int )dir);
#line 70
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
#line 70
  if (tmp___1 != 0L) {
#line 70
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (70), "i" (12UL));
    ldv_25973: ;
#line 70
    goto ldv_25973;
  } else {

  }
#line 71
  debug_dma_unmap_sg(dev, sg, nents, (int )dir);
#line 72
  if ((unsigned long )ops->unmap_sg != (unsigned long )((void (*)(struct device * ,
                                                                  struct scatterlist * ,
                                                                  int  , enum dma_data_direction  ,
                                                                  struct dma_attrs * ))0)) {
#line 73
    (*(ops->unmap_sg))(dev, sg, nents, dir, attrs);
  } else {

  }
#line 74
  return;
}
}
#line 30 "include/scsi/scsi_common.h"
extern void int_to_scsilun(u64  , struct scsi_lun * ) ;
#line 792 "include/scsi/scsi_host.h"
struct Scsi_Host *ldv_scsi_host_alloc_92(struct scsi_host_template *sht , int privsize ) ;
#line 799
int ldv_scsi_add_host_with_dma_91(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
#line 310 "include/scsi/scsi_device.h"
__inline static struct scsi_target *scsi_target(struct scsi_device *sdev ) 
{ 
  struct device  const  *__mptr ;

  {
#line 312
  __mptr = (struct device  const  *)sdev->sdev_gendev.parent;
#line 312
  return ((struct scsi_target *)__mptr + 0xffffffffffffffd8UL);
}
}
#line 171 "include/scsi/scsi_cmnd.h"
__inline static unsigned int scsi_sg_count(struct scsi_cmnd *cmd ) 
{ 


  {
#line 173
  return (cmd->sdb.table.nents);
}
}
#line 176 "include/scsi/scsi_cmnd.h"
__inline static struct scatterlist *scsi_sglist(struct scsi_cmnd *cmd ) 
{ 


  {
#line 178
  return (cmd->sdb.table.sgl);
}
}
#line 181 "include/scsi/scsi_cmnd.h"
__inline static unsigned int scsi_bufflen(struct scsi_cmnd *cmd ) 
{ 


  {
#line 183
  return (cmd->sdb.length);
}
}
#line 186 "include/scsi/scsi_cmnd.h"
__inline static void scsi_set_resid(struct scsi_cmnd *cmd , int resid ) 
{ 


  {
#line 188
  cmd->sdb.resid = resid;
#line 189
  return;
}
}
#line 772 "include/scsi/scsi_transport_fc.h"
__inline static int fc_remote_port_chkready___0(struct fc_rport *rport ) 
{ 
  int result ;

  {
#line 776
  switch ((unsigned int )rport->port_state) {
  case 2U: ;
#line 778
  if ((int )rport->roles & 1) {
#line 779
    result = 0;
  } else
#line 780
  if ((int )rport->flags & 1) {
#line 781
    result = 786432;
  } else {
#line 783
    result = 65536;
  }
#line 784
  goto ldv_51227;
  case 4U: ;
#line 786
  if (((int )rport->flags & 4) != 0) {
#line 787
    result = 983040;
  } else {
#line 789
    result = 786432;
  }
#line 790
  goto ldv_51227;
  default: 
#line 792
  result = 65536;
#line 793
  goto ldv_51227;
  }
  ldv_51227: ;
#line 795
  return (result);
}
}
#line 846
extern int scsi_is_fc_rport(struct device  const  * ) ;
#line 859
extern int fc_block_scsi_eh(struct scsi_cmnd * ) ;
#line 18 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
static int bnx2fc_split_bd(struct bnx2fc_cmd *io_req , u64 addr , int sg_len , int bd_index ) ;
#line 20
static int bnx2fc_map_sg(struct bnx2fc_cmd *io_req ) ;
#line 21
static int bnx2fc_build_bd_list_from_sg(struct bnx2fc_cmd *io_req ) ;
#line 22
static void bnx2fc_unmap_sg_list(struct bnx2fc_cmd *io_req ) ;
#line 23
static void bnx2fc_free_mp_resc(struct bnx2fc_cmd *io_req ) ;
#line 24
static void bnx2fc_parse_fcp_rsp(struct bnx2fc_cmd *io_req , struct fcoe_fcp_rsp_payload *fcp_rsp ,
                                 u8 num_rq ) ;
#line 28 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
void bnx2fc_cmd_timer_set(struct bnx2fc_cmd *io_req , unsigned int timer_msec ) 
{ 
  struct bnx2fc_interface *interface ;
  unsigned long tmp ;
  bool tmp___0 ;

  {
#line 31
  interface = (struct bnx2fc_interface *)(io_req->port)->priv;
#line 33
  tmp = msecs_to_jiffies(timer_msec);
#line 33
  tmp___0 = queue_delayed_work(interface->timer_work_queue, & io_req->timeout_work,
                               tmp);
#line 33
  if ((int )tmp___0) {
#line 36
    kref_get___1(& io_req->refcount);
  } else {

  }
#line 37
  return;
}
}
#line 39 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
static void bnx2fc_cmd_timeout(struct work_struct *work ) 
{ 
  struct bnx2fc_cmd *io_req ;
  struct work_struct  const  *__mptr ;
  struct fc_lport *lport ;
  struct fc_rport_priv *rdata ;
  u8 cmd_type ;
  struct bnx2fc_rport *tgt ;
  int logo_issued ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 41
  __mptr = (struct work_struct  const  *)work;
#line 41
  io_req = (struct bnx2fc_cmd *)__mptr + 0xffffffffffffff38UL;
#line 45
  cmd_type = io_req->cmd_type;
#line 46
  tgt = io_req->tgt;
#line 50
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "cmd_timeout, cmd_type = %d,req_flags = %lx\n",
                (int )cmd_type, io_req->req_flags);
#line 53
  spin_lock_bh(& tgt->tgt_lock);
#line 54
  tmp = test_and_clear_bit(1L, (unsigned long volatile   *)(& io_req->req_flags));
#line 54
  if (tmp != 0) {
#line 55
    clear_bit(7L, (unsigned long volatile   *)(& io_req->req_flags));
#line 60
    spin_unlock_bh(& tgt->tgt_lock);
#line 61
    bnx2fc_send_rrq(io_req);
#line 62
    return;
  } else {

  }
#line 64
  tmp___0 = test_and_clear_bit(7L, (unsigned long volatile   *)(& io_req->req_flags));
#line 64
  if (tmp___0 != 0) {
#line 65
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "IO ready for reuse now\n");
#line 66
    goto done;
  } else {

  }
#line 69
  switch ((int )cmd_type) {
  case 1: 
#line 71
  tmp___5 = test_and_clear_bit(8L, (unsigned long volatile   *)(& io_req->req_flags));
#line 71
  if (tmp___5 != 0) {
#line 74
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "eh_abort timed out\n");
#line 75
    complete(& io_req->tm_done);
  } else {
#line 76
    tmp___4 = constant_test_bit(2L, (unsigned long const volatile   *)(& io_req->req_flags));
#line 76
    if (tmp___4 != 0) {
#line 79
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "ABTS timed out refcnt = %d\n",
                    io_req->refcount.refcount.counter);
#line 81
      tmp___1 = test_and_set_bit(3L, (unsigned long volatile   *)(& io_req->req_flags));
#line 81
      if (tmp___1 == 0) {
#line 84
        lport = (io_req->port)->lport;
#line 85
        rdata = (io_req->tgt)->rdata;
#line 86
        logo_issued = test_and_set_bit(8L, (unsigned long volatile   *)(& tgt->flags));
#line 89
        kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
#line 90
        spin_unlock_bh(& tgt->tgt_lock);
#line 93
        if (logo_issued == 0) {
#line 94
          BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "Explicit logo - tgt flags = 0x%lx\n",
                        tgt->flags);
#line 98
          mutex_lock_nested(& lport->disc.disc_mutex, 0U);
#line 99
          (*(lport->tt.rport_logoff))(rdata);
#line 100
          mutex_unlock(& lport->disc.disc_mutex);
        } else {

        }
#line 102
        return;
      } else {

      }
    } else {
#line 106
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "IO timed out. issue ABTS\n");
#line 107
      tmp___2 = test_and_set_bit(9L, (unsigned long volatile   *)(& io_req->req_flags));
#line 107
      if (tmp___2 != 0) {
#line 109
        BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "IO completed before  timer expiry\n");
#line 111
        goto done;
      } else {

      }
#line 114
      tmp___3 = test_and_set_bit(2L, (unsigned long volatile   *)(& io_req->req_flags));
#line 114
      if (tmp___3 == 0) {
#line 116
        rc = bnx2fc_initiate_abts(io_req);
#line 117
        if (rc == 8194) {
#line 118
          goto done;
        } else {

        }
#line 123
        lport = (io_req->port)->lport;
#line 124
        rdata = (io_req->tgt)->rdata;
#line 125
        logo_issued = test_and_set_bit(8L, (unsigned long volatile   *)(& tgt->flags));
#line 128
        kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
#line 129
        spin_unlock_bh(& tgt->tgt_lock);
#line 131
        if (logo_issued == 0) {
#line 132
          BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "Explicit logo - tgt flags = 0x%lx\n",
                        tgt->flags);
#line 137
          mutex_lock_nested(& lport->disc.disc_mutex, 0U);
#line 138
          (*(lport->tt.rport_logoff))(rdata);
#line 139
          mutex_unlock(& lport->disc.disc_mutex);
        } else {

        }
#line 141
        return;
      } else {
#line 143
        BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "IO already in ABTS processing\n");
      }
    }
  }
#line 147
  goto ldv_54628;
  case 4: 
#line 150
  tmp___8 = constant_test_bit(2L, (unsigned long const volatile   *)(& io_req->req_flags));
#line 150
  if (tmp___8 != 0) {
#line 151
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "ABTS for ELS timed out\n");
#line 153
    tmp___6 = test_and_set_bit(3L, (unsigned long volatile   *)(& io_req->req_flags));
#line 153
    if (tmp___6 == 0) {
#line 155
      lport = (io_req->port)->lport;
#line 156
      rdata = (io_req->tgt)->rdata;
#line 157
      logo_issued = test_and_set_bit(8L, (unsigned long volatile   *)(& tgt->flags));
#line 160
      kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
#line 161
      spin_unlock_bh(& tgt->tgt_lock);
#line 164
      if (logo_issued == 0) {
#line 165
        BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "Explicitly logo(els)\n");
#line 167
        mutex_lock_nested(& lport->disc.disc_mutex, 0U);
#line 168
        (*(lport->tt.rport_logoff))(rdata);
#line 169
        mutex_unlock(& lport->disc.disc_mutex);
      } else {

      }
#line 171
      return;
    } else {

    }
  } else {
#line 180
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "ELS timed out\n");
#line 181
    tmp___7 = test_and_set_bit(10L, (unsigned long volatile   *)(& io_req->req_flags));
#line 181
    if (tmp___7 != 0) {
#line 183
      goto done;
    } else {

    }
#line 186
    set_bit(11L, (unsigned long volatile   *)(& io_req->req_flags));
#line 188
    if ((unsigned long )io_req->cb_func != (unsigned long )((void (*)(struct bnx2fc_els_cb_arg * ))0) && (unsigned long )io_req->cb_arg != (unsigned long )((struct bnx2fc_els_cb_arg *)0)) {
#line 189
      (*(io_req->cb_func))(io_req->cb_arg);
#line 190
      io_req->cb_arg = (struct bnx2fc_els_cb_arg *)0;
    } else {

    }
  }
#line 193
  goto ldv_54628;
  default: 
#line 195
  printk("\vbnx2fc: cmd_timeout: invalid cmd_type %d\n", (int )cmd_type);
#line 197
  goto ldv_54628;
  }
  ldv_54628: ;
  done: 
#line 202
  kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
#line 203
  spin_unlock_bh(& tgt->tgt_lock);
#line 204
  return;
}
}
#line 206 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
static void bnx2fc_scsi_done(struct bnx2fc_cmd *io_req , int err_code ) 
{ 
  struct scsi_cmnd *sc_cmd ;
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 209
  sc_cmd = io_req->sc_cmd;
#line 216
  if ((unsigned int )io_req->cmd_type != 1U) {
#line 217
    return;
  } else {

  }
#line 219
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "scsi_done. err_code = 0x%x\n",
                err_code);
#line 220
  tmp = constant_test_bit(12L, (unsigned long const volatile   *)(& io_req->req_flags));
#line 220
  if (tmp != 0) {
#line 222
    return;
  } else {

  }
#line 225
  bnx2fc_unmap_sg_list(io_req);
#line 226
  io_req->sc_cmd = (struct scsi_cmnd *)0;
#line 227
  if ((unsigned long )sc_cmd == (unsigned long )((struct scsi_cmnd *)0)) {
#line 228
    printk("\vbnx2fc: scsi_done - sc_cmd NULL. IO(0x%x) already cleaned up\n", (int )io_req->xid);
#line 231
    return;
  } else {

  }
#line 233
  sc_cmd->result = err_code << 16;
#line 235
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "sc=%p, result=0x%x, retries=%d, allowed=%d\n",
                sc_cmd, (sc_cmd->result >> 16) & 255, sc_cmd->retries, sc_cmd->allowed);
#line 238
  tmp___0 = scsi_bufflen(sc_cmd);
#line 238
  scsi_set_resid(sc_cmd, (int )tmp___0);
#line 239
  sc_cmd->SCp.ptr = (char *)0;
#line 240
  (*(sc_cmd->scsi_done))(sc_cmd);
#line 241
  return;
}
}
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
struct bnx2fc_cmd_mgr *bnx2fc_cmd_mgr_alloc(struct bnx2fc_hba *hba ) 
{ 
  struct bnx2fc_cmd_mgr *cmgr ;
  struct io_bdt *bdt_info ;
  struct bnx2fc_cmd *io_req ;
  size_t len ;
  u32 mem_size ;
  u16 xid ;
  int i ;
  int num_ios ;
  int num_pri_ios ;
  size_t bd_tbl_sz ;
  int arr_sz ;
  unsigned int tmp ;
  u16 min_xid ;
  u16 max_xid ;
  long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  struct lock_class_key __key ;
  void *tmp___4 ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___1 ;
  u16 tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;

  {
#line 254
  tmp = cpumask_weight(cpu_possible_mask);
#line 254
  arr_sz = (int )(tmp + 1U);
#line 255
  min_xid = 0U;
#line 256
  max_xid = hba->max_xid;
#line 258
  if ((int )max_xid <= (int )min_xid || (unsigned int )max_xid == 65535U) {
#line 259
    printk("\vbnx2fc: cmd_mgr_alloc: Invalid min_xid 0x%x \t\t\t\t\tand max_xid 0x%x\n",
           (int )min_xid, (int )max_xid);
#line 261
    return ((struct bnx2fc_cmd_mgr *)0);
  } else {

  }
#line 263
  tmp___0 = ldv__builtin_expect((bnx2fc_debug_level & 16U) != 0U, 0L);
#line 263
  if (tmp___0 != 0L) {
#line 263
    printk("\016bnx2fc: min xid 0x%x, max xid 0x%x\n", (int )min_xid, (int )max_xid);
  } else {

  }
#line 265
  num_ios = ((int )max_xid - (int )min_xid) + 1;
#line 266
  len = (unsigned long )num_ios * 8UL;
#line 267
  len = len + 48UL;
#line 269
  tmp___1 = kzalloc(len, 208U);
#line 269
  cmgr = (struct bnx2fc_cmd_mgr *)tmp___1;
#line 270
  if ((unsigned long )cmgr == (unsigned long )((struct bnx2fc_cmd_mgr *)0)) {
#line 271
    printk("\vbnx2fc: failed to alloc cmgr\n");
#line 272
    return ((struct bnx2fc_cmd_mgr *)0);
  } else {

  }
#line 275
  tmp___2 = kzalloc((unsigned long )arr_sz * 16UL, 208U);
#line 275
  cmgr->free_list = (struct list_head *)tmp___2;
#line 277
  if ((unsigned long )cmgr->free_list == (unsigned long )((struct list_head *)0)) {
#line 278
    printk("\vbnx2fc: failed to alloc free_list\n");
#line 279
    goto mem_err;
  } else {

  }
#line 282
  tmp___3 = kzalloc((unsigned long )arr_sz * 72UL, 208U);
#line 282
  cmgr->free_list_lock = (spinlock_t *)tmp___3;
#line 284
  if ((unsigned long )cmgr->free_list_lock == (unsigned long )((spinlock_t *)0)) {
#line 285
    printk("\vbnx2fc: failed to alloc free_list_lock\n");
#line 286
    kfree((void const   *)cmgr->free_list);
#line 287
    cmgr->free_list = (struct list_head *)0;
#line 288
    goto mem_err;
  } else {

  }
#line 291
  cmgr->hba = hba;
#line 292
  cmgr->cmds = (struct bnx2fc_cmd **)cmgr + 1U;
#line 294
  i = 0;
#line 294
  goto ldv_54655;
  ldv_54654: 
#line 295
  INIT_LIST_HEAD(cmgr->free_list + (unsigned long )i);
#line 296
  spinlock_check(cmgr->free_list_lock + (unsigned long )i);
#line 296
  __raw_spin_lock_init(& (cmgr->free_list_lock + (unsigned long )i)->__annonCompField18.rlock,
                       "&(&cmgr->free_list_lock[i])->rlock", & __key);
#line 294
  i = i + 1;
  ldv_54655: ;
#line 294
  if (i < arr_sz) {
#line 296
    goto ldv_54654;
  } else {

  }
#line 304
  xid = 0U;
#line 305
  num_pri_ios = (int )((u32 )num_ios - hba->elstm_xids);
#line 306
  i = 0;
#line 306
  goto ldv_54661;
  ldv_54660: 
#line 307
  tmp___4 = kzalloc(640UL, 208U);
#line 307
  io_req = (struct bnx2fc_cmd *)tmp___4;
#line 309
  if ((unsigned long )io_req == (unsigned long )((struct bnx2fc_cmd *)0)) {
#line 310
    printk("\vbnx2fc: failed to alloc io_req\n");
#line 311
    goto mem_err;
  } else {

  }
#line 314
  INIT_LIST_HEAD(& io_req->link);
#line 315
  __init_work(& io_req->timeout_work.work, 0);
#line 315
  __constr_expr_0.counter = 137438953408L;
#line 315
  io_req->timeout_work.work.data = __constr_expr_0;
#line 315
  lockdep_init_map(& io_req->timeout_work.work.lockdep_map, "(&(&io_req->timeout_work)->work)",
                   & __key___0, 0);
#line 315
  INIT_LIST_HEAD(& io_req->timeout_work.work.entry);
#line 315
  io_req->timeout_work.work.func = & bnx2fc_cmd_timeout;
#line 315
  init_timer_key(& io_req->timeout_work.timer, 2097152U, "(&(&io_req->timeout_work)->timer)",
                 & __key___1);
#line 315
  io_req->timeout_work.timer.function = & delayed_work_timer_fn;
#line 315
  io_req->timeout_work.timer.data = (unsigned long )(& io_req->timeout_work);
#line 317
  tmp___5 = xid;
#line 317
  xid = (u16 )((int )xid + 1);
#line 317
  io_req->xid = tmp___5;
#line 318
  if (i < num_pri_ios) {
#line 319
    tmp___6 = cpumask_weight(cpu_possible_mask);
#line 319
    list_add_tail(& io_req->link, cmgr->free_list + (unsigned long )((unsigned int )io_req->xid % tmp___6));
  } else {
#line 323
    tmp___7 = cpumask_weight(cpu_possible_mask);
#line 323
    list_add_tail(& io_req->link, cmgr->free_list + (unsigned long )tmp___7);
  }
#line 325
  io_req = io_req + 1;
#line 306
  i = i + 1;
  ldv_54661: ;
#line 306
  if (i < num_ios) {
#line 308
    goto ldv_54660;
  } else {

  }
#line 329
  mem_size = (u32 )((unsigned long )num_ios) * 8U;
#line 330
  tmp___8 = kmalloc((size_t )mem_size, 208U);
#line 330
  cmgr->io_bdt_pool = (struct io_bdt **)tmp___8;
#line 331
  if ((unsigned long )cmgr->io_bdt_pool == (unsigned long )((struct io_bdt **)0)) {
#line 332
    printk("\vbnx2fc: failed to alloc io_bdt_pool\n");
#line 333
    goto mem_err;
  } else {

  }
#line 336
  mem_size = 32U;
#line 337
  i = 0;
#line 337
  goto ldv_54664;
  ldv_54663: 
#line 338
  tmp___9 = kmalloc((size_t )mem_size, 208U);
#line 338
  *(cmgr->io_bdt_pool + (unsigned long )i) = (struct io_bdt *)tmp___9;
#line 339
  if ((unsigned long )*(cmgr->io_bdt_pool + (unsigned long )i) == (unsigned long )((struct io_bdt *)0)) {
#line 340
    printk("\vbnx2fc: failed to alloc io_bdt_pool[%d]\n", i);
#line 342
    goto mem_err;
  } else {

  }
#line 337
  i = i + 1;
  ldv_54664: ;
#line 337
  if (i < num_ios) {
#line 339
    goto ldv_54663;
  } else {

  }
#line 347
  bd_tbl_sz = 4096UL;
#line 348
  i = 0;
#line 348
  goto ldv_54667;
  ldv_54666: 
#line 349
  bdt_info = *(cmgr->io_bdt_pool + (unsigned long )i);
#line 350
  tmp___10 = dma_alloc_attrs(& (hba->pcidev)->dev, bd_tbl_sz, & bdt_info->bd_tbl_dma,
                             208U, (struct dma_attrs *)0);
#line 350
  bdt_info->bd_tbl = (struct fcoe_bd_ctx *)tmp___10;
#line 354
  if ((unsigned long )bdt_info->bd_tbl == (unsigned long )((struct fcoe_bd_ctx *)0)) {
#line 355
    printk("\vbnx2fc: failed to alloc bdt_tbl[%d]\n", i);
#line 357
    goto mem_err;
  } else {

  }
#line 348
  i = i + 1;
  ldv_54667: ;
#line 348
  if (i < num_ios) {
#line 350
    goto ldv_54666;
  } else {

  }

#line 361
  return (cmgr);
  mem_err: 
#line 364
  bnx2fc_cmd_mgr_free(cmgr);
#line 365
  return ((struct bnx2fc_cmd_mgr *)0);
}
}
#line 368 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
void bnx2fc_cmd_mgr_free(struct bnx2fc_cmd_mgr *cmgr ) 
{ 
  struct io_bdt *bdt_info ;
  struct bnx2fc_hba *hba ;
  size_t bd_tbl_sz ;
  u16 min_xid ;
  u16 max_xid ;
  int num_ios ;
  int i ;
  struct bnx2fc_cmd *tmp ;
  struct bnx2fc_cmd *io_req ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  unsigned int tmp___0 ;

  {
#line 371
  hba = cmgr->hba;
#line 373
  min_xid = 0U;
#line 374
  max_xid = hba->max_xid;
#line 378
  num_ios = ((int )max_xid - (int )min_xid) + 1;
#line 381
  if ((unsigned long )cmgr->io_bdt_pool == (unsigned long )((struct io_bdt **)0)) {
#line 382
    goto free_cmd_pool;
  } else {

  }
#line 384
  bd_tbl_sz = 4096UL;
#line 385
  i = 0;
#line 385
  goto ldv_54681;
  ldv_54680: 
#line 386
  bdt_info = *(cmgr->io_bdt_pool + (unsigned long )i);
#line 387
  if ((unsigned long )bdt_info->bd_tbl != (unsigned long )((struct fcoe_bd_ctx *)0)) {
#line 388
    dma_free_attrs(& (hba->pcidev)->dev, bd_tbl_sz, (void *)bdt_info->bd_tbl, bdt_info->bd_tbl_dma,
                   (struct dma_attrs *)0);
#line 391
    bdt_info->bd_tbl = (struct fcoe_bd_ctx *)0;
  } else {

  }
#line 385
  i = i + 1;
  ldv_54681: ;
#line 385
  if (i < num_ios) {
#line 387
    goto ldv_54680;
  } else {

  }
#line 396
  i = 0;
#line 396
  goto ldv_54684;
  ldv_54683: 
#line 397
  kfree((void const   *)*(cmgr->io_bdt_pool + (unsigned long )i));
#line 398
  *(cmgr->io_bdt_pool + (unsigned long )i) = (struct io_bdt *)0;
#line 396
  i = i + 1;
  ldv_54684: ;
#line 396
  if (i < num_ios) {
#line 398
    goto ldv_54683;
  } else {

  }
#line 401
  kfree((void const   *)cmgr->io_bdt_pool);
#line 402
  cmgr->io_bdt_pool = (struct io_bdt **)0;
  free_cmd_pool: 
#line 405
  kfree((void const   *)cmgr->free_list_lock);
#line 408
  if ((unsigned long )cmgr->free_list == (unsigned long )((struct list_head *)0)) {
#line 409
    goto free_cmgr;
  } else {

  }
#line 411
  i = 0;
#line 411
  goto ldv_54699;
  ldv_54698: 
#line 414
  __mptr = (struct list_head  const  *)(cmgr->free_list + (unsigned long )i)->next;
#line 414
  io_req = (struct bnx2fc_cmd *)__mptr;
#line 414
  __mptr___0 = (struct list_head  const  *)io_req->link.next;
#line 414
  tmp = (struct bnx2fc_cmd *)__mptr___0;
#line 414
  goto ldv_54696;
  ldv_54695: 
#line 416
  list_del(& io_req->link);
#line 417
  kfree((void const   *)io_req);
#line 414
  io_req = tmp;
#line 414
  __mptr___1 = (struct list_head  const  *)tmp->link.next;
#line 414
  tmp = (struct bnx2fc_cmd *)__mptr___1;
  ldv_54696: ;
#line 414
  if ((unsigned long )(& io_req->link) != (unsigned long )(cmgr->free_list + (unsigned long )i)) {
#line 416
    goto ldv_54695;
  } else {

  }
#line 411
  i = i + 1;
  ldv_54699: 
#line 411
  tmp___0 = cpumask_weight(cpu_possible_mask);
#line 411
  if ((unsigned int )i < tmp___0 + 1U) {
#line 413
    goto ldv_54698;
  } else {

  }
#line 420
  kfree((void const   *)cmgr->free_list);
  free_cmgr: 
#line 423
  kfree((void const   *)cmgr);
#line 424
  return;
}
}
#line 426 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
struct bnx2fc_cmd *bnx2fc_elstm_alloc(struct bnx2fc_rport *tgt , int type ) 
{ 
  struct fcoe_port *port ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_cmd_mgr *cmd_mgr ;
  struct bnx2fc_cmd *io_req ;
  struct list_head *listp ;
  struct io_bdt *bd_tbl ;
  int index ;
  unsigned int tmp ;
  u32 free_sqes ;
  u32 max_sqes ;
  u16 xid ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct io_bdt *tmp___3 ;

  {
#line 428
  port = tgt->port;
#line 429
  interface = (struct bnx2fc_interface *)port->priv;
#line 430
  cmd_mgr = (interface->hba)->cmd_mgr;
#line 434
  tmp = cpumask_weight(cpu_possible_mask);
#line 434
  index = (int )tmp;
#line 439
  max_sqes = tgt->max_sqes;
#line 440
  switch (type) {
  case 2: 
#line 442
  max_sqes = 128U;
#line 443
  goto ldv_54716;
  case 4: 
#line 445
  max_sqes = 127U;
#line 446
  goto ldv_54716;
  default: ;
#line 448
  goto ldv_54716;
  }
  ldv_54716: 
#line 455
  spin_lock_bh(cmd_mgr->free_list_lock + (unsigned long )index);
#line 456
  tmp___0 = atomic_read((atomic_t const   *)(& tgt->free_sqes));
#line 456
  free_sqes = (u32 )tmp___0;
#line 457
  tmp___2 = list_empty((struct list_head  const  *)cmd_mgr->free_list + (unsigned long )index);
#line 457
  if ((tmp___2 != 0 || (u32 )tgt->num_active_ios.counter >= max_sqes) || free_sqes + max_sqes <= 256U) {
#line 460
    BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "No free els_tm cmds available ios(%d):sqes(%d)\n",
                   tgt->num_active_ios.counter, tgt->max_sqes);
#line 463
    tmp___1 = list_empty((struct list_head  const  *)cmd_mgr->free_list + (unsigned long )index);
#line 463
    if (tmp___1 != 0) {
#line 464
      printk("\vbnx2fc: elstm_alloc: list_empty\n");
    } else {

    }
#line 465
    spin_unlock_bh(cmd_mgr->free_list_lock + (unsigned long )index);
#line 466
    return ((struct bnx2fc_cmd *)0);
  } else {

  }
#line 469
  listp = (cmd_mgr->free_list + (unsigned long )index)->next;
#line 471
  list_del_init(listp);
#line 472
  io_req = (struct bnx2fc_cmd *)listp;
#line 473
  xid = io_req->xid;
#line 474
  *(cmd_mgr->cmds + (unsigned long )xid) = io_req;
#line 475
  atomic_inc(& tgt->num_active_ios);
#line 476
  atomic_dec(& tgt->free_sqes);
#line 477
  spin_unlock_bh(cmd_mgr->free_list_lock + (unsigned long )index);
#line 479
  INIT_LIST_HEAD(& io_req->link);
#line 481
  io_req->port = port;
#line 482
  io_req->cmd_mgr = cmd_mgr;
#line 483
  io_req->req_flags = 0UL;
#line 484
  io_req->cmd_type = (u8 )type;
#line 488
  tmp___3 = *(cmd_mgr->io_bdt_pool + (unsigned long )xid);
#line 488
  io_req->bd_tbl = tmp___3;
#line 488
  bd_tbl = tmp___3;
#line 489
  bd_tbl->io_req = io_req;
#line 492
  kref_init(& io_req->refcount);
#line 493
  return (io_req);
}
}
#line 496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
struct bnx2fc_cmd *bnx2fc_cmd_alloc(struct bnx2fc_rport *tgt ) 
{ 
  struct fcoe_port *port ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_cmd_mgr *cmd_mgr ;
  struct bnx2fc_cmd *io_req ;
  struct list_head *listp ;
  struct io_bdt *bd_tbl ;
  u32 free_sqes ;
  u32 max_sqes ;
  u16 xid ;
  int index ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp ;
  int tmp___0 ;
  struct io_bdt *tmp___1 ;

  {
#line 498
  port = tgt->port;
#line 499
  interface = (struct bnx2fc_interface *)port->priv;
#line 500
  cmd_mgr = (interface->hba)->cmd_mgr;
#line 507
  __preempt_count_add(1);
#line 507
  __asm__  volatile   ("": : : "memory");
#line 507
  __vpp_verify = (void const   *)0;
#line 507
  switch (4UL) {
  case 1UL: ;
#line 507
  switch (4UL) {
  case 1UL: 
#line 507
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 507
  goto ldv_54737;
  case 2UL: 
#line 507
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 507
  goto ldv_54737;
  case 4UL: 
#line 507
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 507
  goto ldv_54737;
  case 8UL: 
#line 507
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 507
  goto ldv_54737;
  default: 
#line 507
  __bad_percpu_size();
  }
  ldv_54737: 
#line 507
  pscr_ret__ = pfo_ret__;
#line 507
  goto ldv_54743;
  case 2UL: ;
#line 507
  switch (4UL) {
  case 1UL: 
#line 507
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 507
  goto ldv_54747;
  case 2UL: 
#line 507
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 507
  goto ldv_54747;
  case 4UL: 
#line 507
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 507
  goto ldv_54747;
  case 8UL: 
#line 507
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 507
  goto ldv_54747;
  default: 
#line 507
  __bad_percpu_size();
  }
  ldv_54747: 
#line 507
  pscr_ret__ = pfo_ret_____0;
#line 507
  goto ldv_54743;
  case 4UL: ;
#line 507
  switch (4UL) {
  case 1UL: 
#line 507
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 507
  goto ldv_54756;
  case 2UL: 
#line 507
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 507
  goto ldv_54756;
  case 4UL: 
#line 507
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 507
  goto ldv_54756;
  case 8UL: 
#line 507
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 507
  goto ldv_54756;
  default: 
#line 507
  __bad_percpu_size();
  }
  ldv_54756: 
#line 507
  pscr_ret__ = pfo_ret_____1;
#line 507
  goto ldv_54743;
  case 8UL: ;
#line 507
  switch (4UL) {
  case 1UL: 
#line 507
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 507
  goto ldv_54765;
  case 2UL: 
#line 507
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 507
  goto ldv_54765;
  case 4UL: 
#line 507
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 507
  goto ldv_54765;
  case 8UL: 
#line 507
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 507
  goto ldv_54765;
  default: 
#line 507
  __bad_percpu_size();
  }
  ldv_54765: 
#line 507
  pscr_ret__ = pfo_ret_____2;
#line 507
  goto ldv_54743;
  default: 
#line 507
  __bad_size_call_parameter();
#line 507
  goto ldv_54743;
  }
  ldv_54743: 
#line 507
  index = pscr_ret__;
#line 509
  max_sqes = 96U;
#line 514
  spin_lock_bh(cmd_mgr->free_list_lock + (unsigned long )index);
#line 515
  tmp = atomic_read((atomic_t const   *)(& tgt->free_sqes));
#line 515
  free_sqes = (u32 )tmp;
#line 516
  tmp___0 = list_empty((struct list_head  const  *)cmd_mgr->free_list + (unsigned long )index);
#line 516
  if ((tmp___0 != 0 || (u32 )tgt->num_active_ios.counter >= max_sqes) || free_sqes + max_sqes <= 256U) {
#line 519
    spin_unlock_bh(cmd_mgr->free_list_lock + (unsigned long )index);
#line 520
    __asm__  volatile   ("": : : "memory");
#line 520
    __preempt_count_sub(1);
#line 521
    return ((struct bnx2fc_cmd *)0);
  } else {

  }
#line 524
  listp = (cmd_mgr->free_list + (unsigned long )index)->next;
#line 526
  list_del_init(listp);
#line 527
  io_req = (struct bnx2fc_cmd *)listp;
#line 528
  xid = io_req->xid;
#line 529
  *(cmd_mgr->cmds + (unsigned long )xid) = io_req;
#line 530
  atomic_inc(& tgt->num_active_ios);
#line 531
  atomic_dec(& tgt->free_sqes);
#line 532
  spin_unlock_bh(cmd_mgr->free_list_lock + (unsigned long )index);
#line 533
  __asm__  volatile   ("": : : "memory");
#line 533
  __preempt_count_sub(1);
#line 535
  INIT_LIST_HEAD(& io_req->link);
#line 537
  io_req->port = port;
#line 538
  io_req->cmd_mgr = cmd_mgr;
#line 539
  io_req->req_flags = 0UL;
#line 543
  tmp___1 = *(cmd_mgr->io_bdt_pool + (unsigned long )xid);
#line 543
  io_req->bd_tbl = tmp___1;
#line 543
  bd_tbl = tmp___1;
#line 544
  bd_tbl->io_req = io_req;
#line 547
  kref_init(& io_req->refcount);
#line 548
  return (io_req);
}
}
#line 551 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
void bnx2fc_cmd_release(struct kref *ref ) 
{ 
  struct bnx2fc_cmd *io_req ;
  struct kref  const  *__mptr ;
  struct bnx2fc_cmd_mgr *cmd_mgr ;
  int index ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 553
  __mptr = (struct kref  const  *)ref;
#line 553
  io_req = (struct bnx2fc_cmd *)__mptr + 0xffffffffffffffecUL;
#line 555
  cmd_mgr = io_req->cmd_mgr;
#line 558
  if ((unsigned int )io_req->cmd_type == 1U) {
#line 559
    tmp = cpumask_weight(cpu_possible_mask);
#line 559
    index = (int )((unsigned int )io_req->xid % tmp);
  } else {
#line 561
    tmp___0 = cpumask_weight(cpu_possible_mask);
#line 561
    index = (int )tmp___0;
  }
#line 564
  spin_lock_bh(cmd_mgr->free_list_lock + (unsigned long )index);
#line 565
  if ((unsigned int )io_req->cmd_type != 1U) {
#line 566
    bnx2fc_free_mp_resc(io_req);
  } else {

  }
#line 567
  *(cmd_mgr->cmds + (unsigned long )io_req->xid) = (struct bnx2fc_cmd *)0;
#line 569
  list_del_init(& io_req->link);
#line 571
  list_add(& io_req->link, cmd_mgr->free_list + (unsigned long )index);
#line 573
  atomic_dec(& (io_req->tgt)->num_active_ios);
#line 574
  spin_unlock_bh(cmd_mgr->free_list_lock + (unsigned long )index);
#line 575
  return;
}
}
#line 578 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
static void bnx2fc_free_mp_resc(struct bnx2fc_cmd *io_req ) 
{ 
  struct bnx2fc_mp_req *mp_req ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_hba *hba ;
  size_t sz ;

  {
#line 580
  mp_req = & io_req->mp_req;
#line 581
  interface = (struct bnx2fc_interface *)(io_req->port)->priv;
#line 582
  hba = interface->hba;
#line 583
  sz = 16UL;
#line 586
  mp_req->tm_flags = 0U;
#line 587
  if ((unsigned long )mp_req->mp_req_bd != (unsigned long )((struct fcoe_bd_ctx *)0)) {
#line 588
    dma_free_attrs(& (hba->pcidev)->dev, sz, (void *)mp_req->mp_req_bd, mp_req->mp_req_bd_dma,
                   (struct dma_attrs *)0);
#line 591
    mp_req->mp_req_bd = (struct fcoe_bd_ctx *)0;
  } else {

  }
#line 593
  if ((unsigned long )mp_req->mp_resp_bd != (unsigned long )((struct fcoe_bd_ctx *)0)) {
#line 594
    dma_free_attrs(& (hba->pcidev)->dev, sz, (void *)mp_req->mp_resp_bd, mp_req->mp_resp_bd_dma,
                   (struct dma_attrs *)0);
#line 597
    mp_req->mp_resp_bd = (struct fcoe_bd_ctx *)0;
  } else {

  }
#line 599
  if ((unsigned long )mp_req->req_buf != (unsigned long )((void *)0)) {
#line 600
    dma_free_attrs(& (hba->pcidev)->dev, 4096UL, mp_req->req_buf, mp_req->req_buf_dma,
                   (struct dma_attrs *)0);
#line 603
    mp_req->req_buf = (void *)0;
  } else {

  }
#line 605
  if ((unsigned long )mp_req->resp_buf != (unsigned long )((void *)0)) {
#line 606
    dma_free_attrs(& (hba->pcidev)->dev, 4096UL, mp_req->resp_buf, mp_req->resp_buf_dma,
                   (struct dma_attrs *)0);
#line 609
    mp_req->resp_buf = (void *)0;
  } else {

  }
#line 611
  return;
}
}
#line 613 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
int bnx2fc_init_mp_req(struct bnx2fc_cmd *io_req ) 
{ 
  struct bnx2fc_mp_req *mp_req ;
  struct fcoe_bd_ctx *mp_req_bd ;
  struct fcoe_bd_ctx *mp_resp_bd ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_hba *hba ;
  dma_addr_t addr ;
  size_t sz ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 618
  interface = (struct bnx2fc_interface *)(io_req->port)->priv;
#line 619
  hba = interface->hba;
#line 623
  mp_req = & io_req->mp_req;
#line 624
  memset((void *)mp_req, 0, 128UL);
#line 626
  mp_req->req_len = 32U;
#line 627
  io_req->data_xfer_len = (size_t )mp_req->req_len;
#line 628
  mp_req->req_buf = dma_alloc_attrs(& (hba->pcidev)->dev, 4096UL, & mp_req->req_buf_dma,
                                    32U, (struct dma_attrs *)0);
#line 631
  if ((unsigned long )mp_req->req_buf == (unsigned long )((void *)0)) {
#line 632
    printk("\vbnx2fc: unable to alloc MP req buffer\n");
#line 633
    bnx2fc_free_mp_resc(io_req);
#line 634
    return (8195);
  } else {

  }
#line 637
  mp_req->resp_buf = dma_alloc_attrs(& (hba->pcidev)->dev, 4096UL, & mp_req->resp_buf_dma,
                                     32U, (struct dma_attrs *)0);
#line 640
  if ((unsigned long )mp_req->resp_buf == (unsigned long )((void *)0)) {
#line 641
    printk("\vbnx2fc: unable to alloc TM resp buffer\n");
#line 642
    bnx2fc_free_mp_resc(io_req);
#line 643
    return (8195);
  } else {

  }
#line 645
  memset(mp_req->req_buf, 0, 4096UL);
#line 646
  memset(mp_req->resp_buf, 0, 4096UL);
#line 649
  sz = 16UL;
#line 650
  tmp = dma_alloc_attrs(& (hba->pcidev)->dev, sz, & mp_req->mp_req_bd_dma, 32U, (struct dma_attrs *)0);
#line 650
  mp_req->mp_req_bd = (struct fcoe_bd_ctx *)tmp;
#line 653
  if ((unsigned long )mp_req->mp_req_bd == (unsigned long )((struct fcoe_bd_ctx *)0)) {
#line 654
    printk("\vbnx2fc: unable to alloc MP req bd\n");
#line 655
    bnx2fc_free_mp_resc(io_req);
#line 656
    return (8195);
  } else {

  }
#line 658
  tmp___0 = dma_alloc_attrs(& (hba->pcidev)->dev, sz, & mp_req->mp_resp_bd_dma, 32U,
                            (struct dma_attrs *)0);
#line 658
  mp_req->mp_resp_bd = (struct fcoe_bd_ctx *)tmp___0;
#line 661
  if ((unsigned long )mp_req->mp_resp_bd == (unsigned long )((struct fcoe_bd_ctx *)0)) {
#line 662
    printk("\vbnx2fc: unable to alloc MP resp bd\n");
#line 663
    bnx2fc_free_mp_resc(io_req);
#line 664
    return (8195);
  } else {

  }
#line 667
  addr = mp_req->req_buf_dma;
#line 668
  mp_req_bd = mp_req->mp_req_bd;
#line 669
  mp_req_bd->buf_addr_lo = (unsigned int )addr;
#line 670
  mp_req_bd->buf_addr_hi = (unsigned int )(addr >> 32);
#line 671
  mp_req_bd->buf_len = 4096U;
#line 672
  mp_req_bd->flags = 0U;
#line 679
  mp_resp_bd = mp_req->mp_resp_bd;
#line 680
  addr = mp_req->resp_buf_dma;
#line 681
  mp_resp_bd->buf_addr_lo = (unsigned int )addr;
#line 682
  mp_resp_bd->buf_addr_hi = (unsigned int )(addr >> 32);
#line 683
  mp_resp_bd->buf_len = 4096U;
#line 684
  mp_resp_bd->flags = 0U;
#line 686
  return (8194);
}
}
#line 689 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
static int bnx2fc_initiate_tmf(struct scsi_cmnd *sc_cmd , u8 tm_flags ) 
{ 
  struct fc_lport *lport ;
  struct fc_rport *rport ;
  struct fc_rport_libfc_priv *rp ;
  struct fcoe_port *port ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_rport *tgt ;
  struct bnx2fc_cmd *io_req ;
  struct bnx2fc_mp_req *tm_req ;
  struct fcoe_task_ctx_entry *task ;
  struct fcoe_task_ctx_entry *task_page ;
  struct Scsi_Host *host ;
  struct fc_frame_header *fc_hdr ;
  struct fcp_cmnd *fcp_cmnd ;
  int task_idx ;
  int index ;
  int rc ;
  u16 xid ;
  u32 sid ;
  u32 did ;
  unsigned long start ;
  void *tmp ;
  struct device  const  *__mptr ;
  struct scsi_target *tmp___2 ;
  struct scsi_target *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  int tmp___9 ;

  {
#line 701
  host = (sc_cmd->device)->host;
#line 705
  rc = 8194;
#line 708
  start = jiffies;
#line 710
  tmp = shost_priv(host);
#line 710
  lport = (struct fc_lport *)tmp;
#line 711
  tmp___3 = scsi_target(sc_cmd->device);
#line 711
  tmp___4 = scsi_is_fc_rport((struct device  const  *)tmp___3->dev.parent);
#line 711
  if (tmp___4 != 0) {
#line 711
    tmp___2 = scsi_target(sc_cmd->device);
#line 711
    __mptr = (struct device  const  *)tmp___2->dev.parent;
#line 711
    rport = (struct fc_rport *)__mptr + 0xffffffffffffffa0UL;
  } else {
#line 711
    rport = (struct fc_rport *)0;
  }
#line 712
  tmp___5 = lport_priv((struct fc_lport  const  *)lport);
#line 712
  port = (struct fcoe_port *)tmp___5;
#line 713
  interface = (struct bnx2fc_interface *)port->priv;
#line 715
  if ((unsigned long )rport == (unsigned long )((struct fc_rport *)0)) {
#line 716
    printk("\vbnx2fc: device_reset: rport is NULL\n");
#line 717
    rc = 8195;
#line 718
    goto tmf_err;
  } else {

  }
#line 720
  rp = (struct fc_rport_libfc_priv *)rport->dd_data;
#line 722
  rc = fc_block_scsi_eh(sc_cmd);
#line 723
  if (rc != 0) {
#line 724
    return (rc);
  } else {

  }
#line 726
  if ((unsigned int )lport->state != 14U || (unsigned int )lport->link_up == 0U) {
#line 727
    printk("\vbnx2fc: device_reset: link is not ready\n");
#line 728
    rc = 8195;
#line 729
    goto tmf_err;
  } else {

  }
#line 732
  tgt = (struct bnx2fc_rport *)rp + 1U;
#line 734
  tmp___6 = constant_test_bit(1L, (unsigned long const volatile   *)(& tgt->flags));
#line 734
  if (tmp___6 == 0) {
#line 735
    printk("\vbnx2fc: device_reset: tgt not offloaded\n");
#line 736
    rc = 8195;
#line 737
    goto tmf_err;
  } else {

  }
  retry_tmf: 
#line 740
  io_req = bnx2fc_elstm_alloc(tgt, 2);
#line 741
  if ((unsigned long )io_req == (unsigned long )((struct bnx2fc_cmd *)0)) {
#line 742
    if ((long )((start - (unsigned long )jiffies) + 250UL) < 0L) {
#line 743
      printk("\vbnx2fc: tmf: Failed TMF");
#line 744
      rc = 8195;
#line 745
      goto tmf_err;
    } else {

    }
#line 747
    msleep(20U);
#line 748
    goto retry_tmf;
  } else {

  }
#line 751
  io_req->sc_cmd = sc_cmd;
#line 752
  io_req->port = port;
#line 753
  io_req->tgt = tgt;
#line 755
  tm_req = & io_req->mp_req;
#line 757
  rc = bnx2fc_init_mp_req(io_req);
#line 758
  if (rc == 8195) {
#line 759
    printk("\vbnx2fc: Task mgmt MP request init failed\n");
#line 760
    spin_lock_bh(& tgt->tgt_lock);
#line 761
    kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
#line 762
    spin_unlock_bh(& tgt->tgt_lock);
#line 763
    goto tmf_err;
  } else {

  }
#line 767
  io_req->io_req_flags = 0U;
#line 768
  tm_req->tm_flags = tm_flags;
#line 771
  bnx2fc_build_fcp_cmnd(io_req, (struct fcp_cmnd *)tm_req->req_buf);
#line 772
  fcp_cmnd = (struct fcp_cmnd *)tm_req->req_buf;
#line 773
  memset((void *)(& fcp_cmnd->fc_cdb), 0, (size_t )sc_cmd->cmd_len);
#line 774
  fcp_cmnd->fc_dl = 0U;
#line 777
  fc_hdr = & tm_req->req_fc_hdr;
#line 778
  sid = tgt->sid;
#line 779
  did = rport->port_id;
#line 780
  __fc_fill_fc_hdr(fc_hdr, 6, did, sid, 8, 2686976U, 0U);
#line 784
  xid = io_req->xid;
#line 786
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "Initiate TMF - xid = 0x%x\n",
                 (int )xid);
#line 787
  task_idx = (int )((unsigned int )xid / 32U);
#line 788
  index = (int )xid & 31;
#line 791
  task_page = *((interface->hba)->task_ctx + (unsigned long )task_idx);
#line 793
  task = task_page + (unsigned long )index;
#line 794
  bnx2fc_init_mp_task(io_req, task);
#line 796
  sc_cmd->SCp.ptr = (char *)io_req;
#line 799
  spin_lock_bh(& tgt->tgt_lock);
#line 800
  bnx2fc_add_2_sq(tgt, (int )xid);
#line 803
  io_req->on_tmf_queue = 1U;
#line 804
  list_add_tail(& io_req->link, & tgt->active_tm_queue);
#line 806
  init_completion(& io_req->tm_done);
#line 807
  io_req->wait_for_comp = 1;
#line 810
  bnx2fc_ring_doorbell(tgt);
#line 811
  spin_unlock_bh(& tgt->tgt_lock);
#line 813
  tmp___7 = wait_for_completion_timeout(& io_req->tm_done, 15000UL);
#line 813
  rc = (int )tmp___7;
#line 815
  spin_lock_bh(& tgt->tgt_lock);
#line 817
  io_req->wait_for_comp = 0;
#line 818
  tmp___9 = constant_test_bit(4L, (unsigned long const volatile   *)(& io_req->req_flags));
#line 818
  if (tmp___9 == 0) {
#line 819
    set_bit(5L, (unsigned long volatile   *)(& io_req->req_flags));
#line 820
    if ((unsigned int )io_req->on_tmf_queue != 0U) {
#line 821
      list_del_init(& io_req->link);
#line 822
      io_req->on_tmf_queue = 0U;
    } else {

    }
#line 824
    io_req->wait_for_comp = 1;
#line 825
    bnx2fc_initiate_cleanup(io_req);
#line 826
    spin_unlock_bh(& tgt->tgt_lock);
#line 827
    tmp___8 = wait_for_completion_timeout(& io_req->tm_done, 750UL);
#line 827
    rc = (int )tmp___8;
#line 829
    spin_lock_bh(& tgt->tgt_lock);
#line 830
    io_req->wait_for_comp = 0;
#line 831
    if (rc == 0) {
#line 832
      kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
    } else {

    }
  } else {

  }
#line 835
  spin_unlock_bh(& tgt->tgt_lock);
#line 837
  if (rc == 0) {
#line 838
    BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "task mgmt command failed...\n");
#line 839
    rc = 8195;
  } else {
#line 841
    BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "task mgmt command success...\n");
#line 842
    rc = 8194;
  }
  tmf_err: ;
#line 845
  return (rc);
}
}
#line 848 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
int bnx2fc_initiate_abts(struct bnx2fc_cmd *io_req ) 
{ 
  struct fc_lport *lport ;
  struct bnx2fc_rport *tgt ;
  struct fc_rport *rport ;
  struct fc_rport_priv *rdata ;
  struct bnx2fc_interface *interface ;
  struct fcoe_port *port ;
  struct bnx2fc_cmd *abts_io_req ;
  struct fcoe_task_ctx_entry *task ;
  struct fcoe_task_ctx_entry *task_page ;
  struct fc_frame_header *fc_hdr ;
  struct bnx2fc_mp_req *abts_req ;
  int task_idx ;
  int index ;
  u32 sid ;
  u32 did ;
  u16 xid ;
  int rc ;
  u32 r_a_tov ;
  int tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;

  {
#line 851
  tgt = io_req->tgt;
#line 852
  rport = tgt->rport;
#line 853
  rdata = tgt->rdata;
#line 864
  rc = 8194;
#line 865
  r_a_tov = rdata->r_a_tov;
#line 868
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "Entered bnx2fc_initiate_abts\n");
#line 870
  port = io_req->port;
#line 871
  interface = (struct bnx2fc_interface *)port->priv;
#line 872
  lport = port->lport;
#line 874
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& tgt->flags));
#line 874
  if (tmp == 0) {
#line 875
    printk("\vbnx2fc: initiate_abts: tgt not offloaded\n");
#line 876
    rc = 8195;
#line 877
    goto abts_err;
  } else {

  }
#line 880
  if ((unsigned long )rport == (unsigned long )((struct fc_rport *)0)) {
#line 881
    printk("\vbnx2fc: initiate_abts: rport is NULL\n");
#line 882
    rc = 8195;
#line 883
    goto abts_err;
  } else {

  }
#line 886
  if ((unsigned int )lport->state != 14U || (unsigned int )lport->link_up == 0U) {
#line 887
    printk("\vbnx2fc: initiate_abts: link is not ready\n");
#line 888
    rc = 8195;
#line 889
    goto abts_err;
  } else {

  }
#line 892
  abts_io_req = bnx2fc_elstm_alloc(tgt, 3);
#line 893
  if ((unsigned long )abts_io_req == (unsigned long )((struct bnx2fc_cmd *)0)) {
#line 894
    printk("\vbnx2fc: abts: couldnt allocate cmd\n");
#line 895
    rc = 8195;
#line 896
    goto abts_err;
  } else {

  }
#line 900
  abts_io_req->sc_cmd = (struct scsi_cmnd *)0;
#line 901
  abts_io_req->port = port;
#line 902
  abts_io_req->tgt = tgt;
#line 903
  abts_io_req->data_xfer_len = 0UL;
#line 905
  abts_req = & abts_io_req->mp_req;
#line 906
  memset((void *)abts_req, 0, 128UL);
#line 909
  fc_hdr = & abts_req->req_fc_hdr;
#line 912
  tmp___0 = __fswab16((int )io_req->xid);
#line 912
  fc_hdr->fh_ox_id = tmp___0;
#line 913
  tmp___1 = __fswab16((int )(io_req->task)->rxwr_txrd.var_ctx.rx_id);
#line 913
  fc_hdr->fh_rx_id = tmp___1;
#line 915
  sid = tgt->sid;
#line 916
  did = rport->port_id;
#line 918
  __fc_fill_fc_hdr(fc_hdr, 129, did, sid, 0, 2686976U, 0U);
#line 922
  xid = abts_io_req->xid;
#line 923
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)abts_io_req, "ABTS io_req\n");
#line 924
  task_idx = (int )((unsigned int )xid / 32U);
#line 925
  index = (int )xid & 31;
#line 928
  task_page = *((interface->hba)->task_ctx + (unsigned long )task_idx);
#line 930
  task = task_page + (unsigned long )index;
#line 931
  bnx2fc_init_mp_task(abts_io_req, task);
#line 945
  bnx2fc_cmd_timer_set(io_req, r_a_tov * 2U);
#line 948
  bnx2fc_add_2_sq(tgt, (int )xid);
#line 951
  bnx2fc_ring_doorbell(tgt);
  abts_err: ;
#line 954
  return (rc);
}
}
#line 957 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
int bnx2fc_initiate_seq_cleanup(struct bnx2fc_cmd *orig_io_req , u32 offset , enum fc_rctl r_ctl ) 
{ 
  struct fc_lport *lport ;
  struct bnx2fc_rport *tgt ;
  struct bnx2fc_interface *interface ;
  struct fcoe_port *port ;
  struct bnx2fc_cmd *seq_clnp_req ;
  struct fcoe_task_ctx_entry *task ;
  struct fcoe_task_ctx_entry *task_page ;
  struct bnx2fc_els_cb_arg *cb_arg ;
  int task_idx ;
  int index ;
  u16 xid ;
  int rc ;
  void *tmp ;

  {
#line 961
  tgt = orig_io_req->tgt;
#line 967
  cb_arg = (struct bnx2fc_els_cb_arg *)0;
#line 970
  rc = 0;
#line 972
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)orig_io_req, "bnx2fc_initiate_seq_cleanup xid = 0x%x\n",
                (int )orig_io_req->xid);
#line 974
  kref_get___1(& orig_io_req->refcount);
#line 976
  port = orig_io_req->port;
#line 977
  interface = (struct bnx2fc_interface *)port->priv;
#line 978
  lport = port->lport;
#line 980
  tmp = kzalloc(32UL, 32U);
#line 980
  cb_arg = (struct bnx2fc_els_cb_arg *)tmp;
#line 981
  if ((unsigned long )cb_arg == (unsigned long )((struct bnx2fc_els_cb_arg *)0)) {
#line 982
    printk("\vbnx2fc: Unable to alloc cb_arg for seq clnup\n");
#line 983
    rc = -12;
#line 984
    goto cleanup_err;
  } else {

  }
#line 987
  seq_clnp_req = bnx2fc_elstm_alloc(tgt, 6);
#line 988
  if ((unsigned long )seq_clnp_req == (unsigned long )((struct bnx2fc_cmd *)0)) {
#line 989
    printk("\vbnx2fc: cleanup: couldnt allocate cmd\n");
#line 990
    rc = -12;
#line 991
    kfree((void const   *)cb_arg);
#line 992
    goto cleanup_err;
  } else {

  }
#line 995
  seq_clnp_req->sc_cmd = (struct scsi_cmnd *)0;
#line 996
  seq_clnp_req->port = port;
#line 997
  seq_clnp_req->tgt = tgt;
#line 998
  seq_clnp_req->data_xfer_len = 0UL;
#line 1000
  xid = seq_clnp_req->xid;
#line 1002
  task_idx = (int )((unsigned int )xid / 32U);
#line 1003
  index = (int )xid & 31;
#line 1006
  task_page = *((interface->hba)->task_ctx + (unsigned long )task_idx);
#line 1008
  task = task_page + (unsigned long )index;
#line 1009
  cb_arg->aborted_io_req = orig_io_req;
#line 1010
  cb_arg->io_req = seq_clnp_req;
#line 1011
  cb_arg->r_ctl = r_ctl;
#line 1012
  cb_arg->offset = offset;
#line 1013
  seq_clnp_req->cb_arg = cb_arg;
#line 1015
  printk("\vbnx2fc: call init_seq_cleanup_task\n");
#line 1016
  bnx2fc_init_seq_cleanup_task(seq_clnp_req, task, orig_io_req, offset);
#line 1019
  bnx2fc_add_2_sq(tgt, (int )xid);
#line 1022
  bnx2fc_ring_doorbell(tgt);
  cleanup_err: ;
#line 1024
  return (rc);
}
}
#line 1027 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
int bnx2fc_initiate_cleanup(struct bnx2fc_cmd *io_req ) 
{ 
  struct fc_lport *lport ;
  struct bnx2fc_rport *tgt ;
  struct bnx2fc_interface *interface ;
  struct fcoe_port *port ;
  struct bnx2fc_cmd *cleanup_io_req ;
  struct fcoe_task_ctx_entry *task ;
  struct fcoe_task_ctx_entry *task_page ;
  int task_idx ;
  int index ;
  u16 xid ;
  u16 orig_xid ;
  int rc ;

  {
#line 1030
  tgt = io_req->tgt;
#line 1038
  rc = 0;
#line 1041
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "Entered bnx2fc_initiate_cleanup\n");
#line 1043
  port = io_req->port;
#line 1044
  interface = (struct bnx2fc_interface *)port->priv;
#line 1045
  lport = port->lport;
#line 1047
  cleanup_io_req = bnx2fc_elstm_alloc(tgt, 5);
#line 1048
  if ((unsigned long )cleanup_io_req == (unsigned long )((struct bnx2fc_cmd *)0)) {
#line 1049
    printk("\vbnx2fc: cleanup: couldnt allocate cmd\n");
#line 1050
    rc = -1;
#line 1051
    goto cleanup_err;
  } else {

  }
#line 1055
  cleanup_io_req->sc_cmd = (struct scsi_cmnd *)0;
#line 1056
  cleanup_io_req->port = port;
#line 1057
  cleanup_io_req->tgt = tgt;
#line 1058
  cleanup_io_req->data_xfer_len = 0UL;
#line 1060
  xid = cleanup_io_req->xid;
#line 1062
  task_idx = (int )((unsigned int )xid / 32U);
#line 1063
  index = (int )xid & 31;
#line 1066
  task_page = *((interface->hba)->task_ctx + (unsigned long )task_idx);
#line 1068
  task = task_page + (unsigned long )index;
#line 1069
  orig_xid = io_req->xid;
#line 1071
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "CLEANUP io_req xid = 0x%x\n",
                (int )xid);
#line 1073
  bnx2fc_init_cleanup_task(cleanup_io_req, task, (int )orig_xid);
#line 1076
  bnx2fc_add_2_sq(tgt, (int )xid);
#line 1079
  bnx2fc_ring_doorbell(tgt);
  cleanup_err: ;
#line 1082
  return (rc);
}
}
#line 1093 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
int bnx2fc_eh_target_reset(struct scsi_cmnd *sc_cmd ) 
{ 
  int tmp ;

  {
#line 1095
  tmp = bnx2fc_initiate_tmf(sc_cmd, 32);
#line 1095
  return (tmp);
}
}
#line 1106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
int bnx2fc_eh_device_reset(struct scsi_cmnd *sc_cmd ) 
{ 
  int tmp ;

  {
#line 1108
  tmp = bnx2fc_initiate_tmf(sc_cmd, 16);
#line 1108
  return (tmp);
}
}
#line 1111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
int bnx2fc_expl_logo(struct fc_lport *lport , struct bnx2fc_cmd *io_req ) 
{ 
  struct bnx2fc_rport *tgt ;
  struct fc_rport_priv *rdata ;
  int logo_issued ;
  int rc ;
  int wait_cnt ;
  int tmp ;
  int tmp___0 ;

  {
#line 1113
  tgt = io_req->tgt;
#line 1114
  rdata = tgt->rdata;
#line 1116
  rc = 8194;
#line 1117
  wait_cnt = 0;
#line 1119
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "Expl logo - tgt flags = 0x%lx\n",
                tgt->flags);
#line 1121
  logo_issued = test_and_set_bit(8L, (unsigned long volatile   *)(& tgt->flags));
#line 1123
  io_req->wait_for_comp = 1;
#line 1124
  bnx2fc_initiate_cleanup(io_req);
#line 1126
  spin_unlock_bh(& tgt->tgt_lock);
#line 1128
  wait_for_completion(& io_req->tm_done);
#line 1130
  io_req->wait_for_comp = 0;
#line 1135
  kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
#line 1137
  if (logo_issued == 0) {
#line 1138
    clear_bit(1L, (unsigned long volatile   *)(& tgt->flags));
#line 1139
    mutex_lock_nested(& lport->disc.disc_mutex, 0U);
#line 1140
    (*(lport->tt.rport_logoff))(rdata);
#line 1141
    mutex_unlock(& lport->disc.disc_mutex);
    ldv_54905: 
#line 1143
    msleep(200U);
#line 1144
    tmp = wait_cnt;
#line 1144
    wait_cnt = wait_cnt + 1;
#line 1144
    if (tmp > 10) {
#line 1145
      rc = 8195;
#line 1146
      goto ldv_54904;
    } else {

    }
#line 1148
    tmp___0 = constant_test_bit(1L, (unsigned long const volatile   *)(& tgt->flags));
#line 1148
    if (tmp___0 == 0) {
#line 1150
      goto ldv_54905;
    } else {

    }
    ldv_54904: ;
  } else {

  }
#line 1150
  spin_lock_bh(& tgt->tgt_lock);
#line 1151
  return (rc);
}
}
#line 1161 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
int bnx2fc_eh_abort(struct scsi_cmnd *sc_cmd ) 
{ 
  struct fc_rport *rport ;
  struct device  const  *__mptr ;
  struct scsi_target *tmp___1 ;
  struct fc_rport *tmp___2 ;
  struct scsi_target *tmp___3 ;
  int tmp___4 ;
  struct fc_rport_libfc_priv *rp ;
  struct bnx2fc_cmd *io_req ;
  struct fc_lport *lport ;
  struct bnx2fc_rport *tgt ;
  int rc ;
  void *tmp___5 ;
  long tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 1163
  tmp___3 = scsi_target(sc_cmd->device);
#line 1163
  tmp___4 = scsi_is_fc_rport((struct device  const  *)tmp___3->dev.parent);
#line 1163
  if (tmp___4 != 0) {
#line 1163
    tmp___1 = scsi_target(sc_cmd->device);
#line 1163
    __mptr = (struct device  const  *)tmp___1->dev.parent;
#line 1163
    tmp___2 = (struct fc_rport *)__mptr + 0xffffffffffffffa0UL;
  } else {
#line 1163
    tmp___2 = (struct fc_rport *)0;
  }
#line 1163
  rport = tmp___2;
#line 1164
  rp = (struct fc_rport_libfc_priv *)rport->dd_data;
#line 1168
  rc = 8195;
#line 1171
  rc = fc_block_scsi_eh(sc_cmd);
#line 1172
  if (rc != 0) {
#line 1173
    return (rc);
  } else {

  }
#line 1175
  tmp___5 = shost_priv((sc_cmd->device)->host);
#line 1175
  lport = (struct fc_lport *)tmp___5;
#line 1176
  if ((unsigned int )lport->state != 14U || (unsigned int )lport->link_up == 0U) {
#line 1177
    printk("\vbnx2fc: eh_abort: link not ready\n");
#line 1178
    return (rc);
  } else {

  }
#line 1181
  tgt = (struct bnx2fc_rport *)rp + 1U;
#line 1183
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "Entered bnx2fc_eh_abort\n");
#line 1185
  spin_lock_bh(& tgt->tgt_lock);
#line 1186
  io_req = (struct bnx2fc_cmd *)sc_cmd->SCp.ptr;
#line 1187
  if ((unsigned long )io_req == (unsigned long )((struct bnx2fc_cmd *)0)) {
#line 1189
    printk("\vbnx2fc: eh_abort: io_req is NULL\n");
#line 1190
    spin_unlock_bh(& tgt->tgt_lock);
#line 1191
    return (8194);
  } else {

  }
#line 1193
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "eh_abort - refcnt = %d\n", io_req->refcount.refcount.counter);
#line 1197
  kref_get___1(& io_req->refcount);
#line 1199
  tmp___6 = ldv__builtin_expect((unsigned long )io_req->tgt != (unsigned long )tgt, 0L);
#line 1199
  if (tmp___6 != 0L) {
#line 1199
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"),
                         "i" (1199), "i" (12UL));
    ldv_54917: ;
#line 1199
    goto ldv_54917;
  } else {

  }
#line 1207
  if (tgt->flush_in_prog != 0U) {
#line 1208
    printk("\vbnx2fc: eh_abort: io_req (xid = 0x%x) flush in progress\n", (int )io_req->xid);
#line 1210
    kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
#line 1211
    spin_unlock_bh(& tgt->tgt_lock);
#line 1212
    return (8194);
  } else {

  }
#line 1215
  if ((unsigned int )io_req->on_active_queue == 0U) {
#line 1216
    printk("\vbnx2fc: eh_abort: io_req (xid = 0x%x) not on active_q\n", (int )io_req->xid);
#line 1224
    bnx2fc_scsi_done(io_req, 5);
#line 1226
    kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
#line 1227
    spin_unlock_bh(& tgt->tgt_lock);
#line 1228
    return (8194);
  } else {

  }
#line 1238
  list_del_init(& io_req->link);
#line 1239
  io_req->on_active_queue = 0U;
#line 1241
  list_add_tail(& io_req->link, & tgt->io_retire_queue);
#line 1243
  init_completion(& io_req->tm_done);
#line 1245
  tmp___8 = test_and_set_bit(2L, (unsigned long volatile   *)(& io_req->req_flags));
#line 1245
  if (tmp___8 != 0) {
#line 1246
    printk("\vbnx2fc: eh_abort: io_req (xid = 0x%x) already in abts processing\n",
           (int )io_req->xid);
#line 1248
    tmp___7 = ldv_cancel_delayed_work_93(& io_req->timeout_work);
#line 1248
    if ((int )tmp___7) {
#line 1249
      kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
    } else {

    }
#line 1251
    rc = bnx2fc_expl_logo(lport, io_req);
#line 1257
    set_bit(6L, (unsigned long volatile   *)(& io_req->req_flags));
#line 1258
    goto out;
  } else {

  }
#line 1262
  tmp___9 = ldv_cancel_delayed_work_94(& io_req->timeout_work);
#line 1262
  if ((int )tmp___9) {
#line 1263
    kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
  } else {

  }
#line 1265
  set_bit(8L, (unsigned long volatile   *)(& io_req->req_flags));
#line 1266
  io_req->wait_for_comp = 1;
#line 1267
  rc = bnx2fc_initiate_abts(io_req);
#line 1268
  if (rc == 8195) {
#line 1269
    bnx2fc_initiate_cleanup(io_req);
#line 1270
    spin_unlock_bh(& tgt->tgt_lock);
#line 1271
    wait_for_completion(& io_req->tm_done);
#line 1272
    spin_lock_bh(& tgt->tgt_lock);
#line 1273
    io_req->wait_for_comp = 0;
#line 1274
    goto done;
  } else {

  }
#line 1276
  spin_unlock_bh(& tgt->tgt_lock);
#line 1278
  wait_for_completion(& io_req->tm_done);
#line 1280
  spin_lock_bh(& tgt->tgt_lock);
#line 1281
  io_req->wait_for_comp = 0;
#line 1282
  tmp___11 = constant_test_bit(9L, (unsigned long const volatile   *)(& io_req->req_flags));
#line 1282
  if (tmp___11 != 0) {
#line 1283
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "IO completed in a different context\n");
#line 1284
    rc = 8194;
  } else {
#line 1285
    tmp___10 = test_and_set_bit(3L, (unsigned long volatile   *)(& io_req->req_flags));
#line 1285
    if (tmp___10 == 0) {
#line 1288
      printk("\vbnx2fc: abort failed, xid = 0x%x\n", (int )io_req->xid);
#line 1290
      rc = bnx2fc_expl_logo(lport, io_req);
#line 1291
      goto out;
    } else {
#line 1298
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "abort succeeded\n");
#line 1299
      rc = 8194;
#line 1300
      bnx2fc_scsi_done(io_req, 5);
#line 1301
      kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
    }
  }
  done: 
#line 1305
  kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
  out: 
#line 1307
  spin_unlock_bh(& tgt->tgt_lock);
#line 1308
  return (rc);
}
}
#line 1311 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
void bnx2fc_process_seq_cleanup_compl(struct bnx2fc_cmd *seq_clnp_req , struct fcoe_task_ctx_entry *task ,
                                      u8 rx_state ) 
{ 
  struct bnx2fc_els_cb_arg *cb_arg ;
  struct bnx2fc_cmd *orig_io_req ;
  u32 offset ;
  enum fc_rctl r_ctl ;
  int rc ;
  struct bnx2fc_rport *tgt ;

  {
#line 1315
  cb_arg = seq_clnp_req->cb_arg;
#line 1316
  orig_io_req = cb_arg->aborted_io_req;
#line 1317
  offset = cb_arg->offset;
#line 1318
  r_ctl = cb_arg->r_ctl;
#line 1319
  rc = 0;
#line 1320
  tgt = orig_io_req->tgt;
#line 1322
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)orig_io_req, "Entered process_cleanup_compl xid = 0x%xcmd_type = %d\n",
                (int )seq_clnp_req->xid, (int )seq_clnp_req->cmd_type);
#line 1326
  if ((unsigned int )rx_state == 11U) {
#line 1327
    printk("\vbnx2fc: seq cleanup ignored - xid = 0x%x\n", (int )seq_clnp_req->xid);
#line 1329
    goto free_cb_arg;
  } else {

  }
#line 1332
  spin_unlock_bh(& tgt->tgt_lock);
#line 1333
  rc = bnx2fc_send_srr(orig_io_req, offset, (int )((u8 )r_ctl));
#line 1334
  spin_lock_bh(& tgt->tgt_lock);
#line 1336
  if (rc != 0) {
#line 1337
    printk("\vbnx2fc: clnup_compl: Unable to send SRR IO will abort\n");
  } else {

  }
#line 1339
  seq_clnp_req->cb_arg = (struct bnx2fc_els_cb_arg *)0;
#line 1340
  kref_put___2(& orig_io_req->refcount, & bnx2fc_cmd_release);
  free_cb_arg: 
#line 1342
  kfree((void const   *)cb_arg);
#line 1343
  return;
}
}
#line 1346 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
void bnx2fc_process_cleanup_compl(struct bnx2fc_cmd *io_req , struct fcoe_task_ctx_entry *task ,
                                  u8 num_rq ) 
{ 


  {
#line 1350
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "Entered process_cleanup_compl refcnt = %d, cmd_type = %d\n",
                io_req->refcount.refcount.counter, (int )io_req->cmd_type);
#line 1353
  bnx2fc_scsi_done(io_req, 7);
#line 1354
  kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
#line 1355
  if (io_req->wait_for_comp != 0) {
#line 1356
    complete(& io_req->tm_done);
  } else {

  }
#line 1357
  return;
}
}
#line 1359 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
void bnx2fc_process_abts_compl(struct bnx2fc_cmd *io_req , struct fcoe_task_ctx_entry *task ,
                               u8 num_rq ) 
{ 
  u32 r_ctl ;
  u32 r_a_tov ;
  u8 issue_rrq ;
  struct bnx2fc_rport *tgt ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1364
  r_a_tov = 10000U;
#line 1365
  issue_rrq = 0U;
#line 1366
  tgt = io_req->tgt;
#line 1368
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "Entered process_abts_compl xid = 0x%xrefcnt = %d, cmd_type = %d\n",
                (int )io_req->xid, io_req->refcount.refcount.counter, (int )io_req->cmd_type);
#line 1373
  tmp = test_and_set_bit(3L, (unsigned long volatile   *)(& io_req->req_flags));
#line 1373
  if (tmp != 0) {
#line 1375
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "Timer context finished processing this io\n");
#line 1377
    return;
  } else {

  }
#line 1381
  tmp___0 = test_and_set_bit(6L, (unsigned long volatile   *)(& io_req->req_flags));
#line 1381
  if (tmp___0 != 0) {
#line 1383
    goto io_compl;
  } else {

  }
#line 1391
  tmp___2 = constant_test_bit(2L, (unsigned long const volatile   *)(& io_req->req_flags));
#line 1391
  if (tmp___2 != 0) {
#line 1392
    tmp___1 = ldv_cancel_delayed_work_95(& io_req->timeout_work);
#line 1392
    if ((int )tmp___1) {
#line 1393
      kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
    } else {

    }
  } else {

  }
#line 1396
  r_ctl = (u32 )task->rxwr_only.union_ctx.comp_info.abts_rsp.r_ctl;
#line 1398
  switch (r_ctl) {
  case 132U: 
#line 1404
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "ABTS response - ACC Send RRQ\n");
#line 1405
  issue_rrq = 1U;
#line 1406
  goto ldv_54948;
  case 133U: 
#line 1409
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "ABTS response - RJT\n");
#line 1410
  goto ldv_54948;
  default: 
#line 1412
  printk("\vbnx2fc: Unknown ABTS response\n");
#line 1413
  goto ldv_54948;
  }
  ldv_54948: ;
#line 1416
  if ((unsigned int )issue_rrq != 0U) {
#line 1417
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "Issue RRQ after R_A_TOV\n");
#line 1418
    set_bit(1L, (unsigned long volatile   *)(& io_req->req_flags));
  } else {

  }
#line 1420
  set_bit(7L, (unsigned long volatile   *)(& io_req->req_flags));
#line 1421
  bnx2fc_cmd_timer_set(io_req, r_a_tov);
  io_compl: ;
#line 1424
  if (io_req->wait_for_comp != 0) {
#line 1425
    tmp___3 = test_and_clear_bit(8L, (unsigned long volatile   *)(& io_req->req_flags));
#line 1425
    if (tmp___3 != 0) {
#line 1427
      complete(& io_req->tm_done);
    } else {

    }
  } else {
#line 1438
    if ((unsigned int )io_req->on_active_queue != 0U) {
#line 1439
      list_del_init(& io_req->link);
#line 1440
      io_req->on_active_queue = 0U;
#line 1442
      list_add_tail(& io_req->link, & tgt->io_retire_queue);
    } else {

    }
#line 1444
    bnx2fc_scsi_done(io_req, 7);
#line 1445
    kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
  }
#line 1447
  return;
}
}
#line 1449 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
static void bnx2fc_lun_reset_cmpl(struct bnx2fc_cmd *io_req ) 
{ 
  struct scsi_cmnd *sc_cmd ;
  struct bnx2fc_rport *tgt ;
  struct bnx2fc_cmd *cmd ;
  struct bnx2fc_cmd *tmp ;
  u64 tm_lun ;
  u64 lun ;
  int rc ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  bool tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;
  int tmp___2 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 1451
  sc_cmd = io_req->sc_cmd;
#line 1452
  tgt = io_req->tgt;
#line 1454
  tm_lun = (sc_cmd->device)->lun;
#line 1456
  rc = 0;
#line 1459
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "Entered bnx2fc_lun_reset_cmpl\n");
#line 1464
  __mptr = (struct list_head  const  *)tgt->active_cmd_queue.next;
#line 1464
  cmd = (struct bnx2fc_cmd *)__mptr;
#line 1464
  __mptr___0 = (struct list_head  const  *)cmd->link.next;
#line 1464
  tmp = (struct bnx2fc_cmd *)__mptr___0;
#line 1464
  goto ldv_54970;
  ldv_54969: 
#line 1465
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "LUN RST cmpl: scan for pending IOs\n");
#line 1466
  lun = ((cmd->sc_cmd)->device)->lun;
#line 1467
  if (lun == tm_lun) {
#line 1469
    tmp___2 = test_and_set_bit(2L, (unsigned long volatile   *)(& cmd->req_flags));
#line 1469
    if (tmp___2 == 0) {
#line 1472
      tmp___0 = ldv_cancel_delayed_work_96(& io_req->timeout_work);
#line 1472
      if ((int )tmp___0) {
#line 1473
        kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
      } else {

      }
#line 1476
      rc = bnx2fc_initiate_abts(cmd);
#line 1478
      __ret_warn_on = rc != 8194;
#line 1478
      tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1478
      if (tmp___1 != 0L) {
#line 1478
        warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c",
                           1478);
      } else {

      }
#line 1478
      ldv__builtin_expect(__ret_warn_on != 0, 0L);
    } else {
#line 1480
      printk("\vbnx2fc: lun_rst: abts already in progress for this IO 0x%x\n", (int )cmd->xid);
    }
  } else {

  }
#line 1464
  cmd = tmp;
#line 1464
  __mptr___1 = (struct list_head  const  *)tmp->link.next;
#line 1464
  tmp = (struct bnx2fc_cmd *)__mptr___1;
  ldv_54970: ;
#line 1464
  if ((unsigned long )(& cmd->link) != (unsigned long )(& tgt->active_cmd_queue)) {
#line 1466
    goto ldv_54969;
  } else {

  }

#line 1471
  return;
}
}
#line 1487 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
static void bnx2fc_tgt_reset_cmpl(struct bnx2fc_cmd *io_req ) 
{ 
  struct bnx2fc_rport *tgt ;
  struct bnx2fc_cmd *cmd ;
  struct bnx2fc_cmd *tmp ;
  int rc ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  bool tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;
  int tmp___2 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 1489
  tgt = io_req->tgt;
#line 1491
  rc = 0;
#line 1494
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "Entered bnx2fc_tgt_reset_cmpl\n");
#line 1499
  __mptr = (struct list_head  const  *)tgt->active_cmd_queue.next;
#line 1499
  cmd = (struct bnx2fc_cmd *)__mptr;
#line 1499
  __mptr___0 = (struct list_head  const  *)cmd->link.next;
#line 1499
  tmp = (struct bnx2fc_cmd *)__mptr___0;
#line 1499
  goto ldv_54988;
  ldv_54987: 
#line 1500
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "TGT RST cmpl: scan for pending IOs\n");
#line 1502
  tmp___2 = test_and_set_bit(2L, (unsigned long volatile   *)(& cmd->req_flags));
#line 1502
  if (tmp___2 == 0) {
#line 1505
    tmp___0 = ldv_cancel_delayed_work_97(& io_req->timeout_work);
#line 1505
    if ((int )tmp___0) {
#line 1506
      kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
    } else {

    }
#line 1508
    rc = bnx2fc_initiate_abts(cmd);
#line 1510
    __ret_warn_on = rc != 8194;
#line 1510
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 1510
    if (tmp___1 != 0L) {
#line 1510
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c",
                         1510);
    } else {

    }
#line 1510
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
  } else {
#line 1513
    printk("\vbnx2fc: tgt_rst: abts already in progress for this IO 0x%x\n", (int )cmd->xid);
  }
#line 1499
  cmd = tmp;
#line 1499
  __mptr___1 = (struct list_head  const  *)tmp->link.next;
#line 1499
  tmp = (struct bnx2fc_cmd *)__mptr___1;
  ldv_54988: ;
#line 1499
  if ((unsigned long )(& cmd->link) != (unsigned long )(& tgt->active_cmd_queue)) {
#line 1501
    goto ldv_54987;
  } else {

  }

#line 1506
  return;
}
}
#line 1518 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
void bnx2fc_process_tm_compl(struct bnx2fc_cmd *io_req , struct fcoe_task_ctx_entry *task ,
                             u8 num_rq ) 
{ 
  struct bnx2fc_mp_req *tm_req ;
  struct fc_frame_header *fc_hdr ;
  struct scsi_cmnd *sc_cmd ;
  u64 *hdr ;
  u64 *temp_hdr ;
  void *rsp_buf ;
  int tmp ;
  __u64 tmp___0 ;
  __u64 tmp___1 ;
  __u64 tmp___2 ;

  {
#line 1523
  sc_cmd = io_req->sc_cmd;
#line 1529
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "Entered process_tm_compl\n");
#line 1531
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& io_req->req_flags));
#line 1531
  if (tmp == 0) {
#line 1532
    set_bit(4L, (unsigned long volatile   *)(& io_req->req_flags));
  } else {
#line 1538
    return;
  }
#line 1541
  tm_req = & io_req->mp_req;
#line 1542
  fc_hdr = & tm_req->resp_fc_hdr;
#line 1543
  hdr = (u64 *)fc_hdr;
#line 1544
  temp_hdr = (u64 *)(& task->rxwr_only.union_ctx.comp_info.mp_rsp.fc_hdr);
#line 1546
  tmp___0 = __fswab64(*temp_hdr);
#line 1546
  *hdr = tmp___0;
#line 1547
  tmp___1 = __fswab64(*(temp_hdr + 1UL));
#line 1547
  *(hdr + 1UL) = tmp___1;
#line 1548
  tmp___2 = __fswab64(*(temp_hdr + 2UL));
#line 1548
  *(hdr + 2UL) = tmp___2;
#line 1550
  tm_req->resp_len = task->rxwr_only.union_ctx.comp_info.mp_rsp.mp_payload_len;
#line 1553
  rsp_buf = tm_req->resp_buf;
#line 1555
  if ((unsigned int )fc_hdr->fh_r_ctl == 7U) {
#line 1556
    bnx2fc_parse_fcp_rsp(io_req, (struct fcoe_fcp_rsp_payload *)rsp_buf, (int )num_rq);
#line 1559
    if ((unsigned int )io_req->fcp_rsp_code == 0U) {
#line 1561
      if (((int )tm_req->tm_flags & 16) != 0) {
#line 1562
        bnx2fc_lun_reset_cmpl(io_req);
      } else
#line 1563
      if (((int )tm_req->tm_flags & 32) != 0) {
#line 1564
        bnx2fc_tgt_reset_cmpl(io_req);
      } else {

      }
    } else {

    }
  } else {
#line 1567
    printk("\vbnx2fc: tmf\'s fc_hdr r_ctl = 0x%x\n", (int )fc_hdr->fh_r_ctl);
  }
#line 1570
  if ((unsigned long )sc_cmd->SCp.ptr == (unsigned long )((char *)0)) {
#line 1571
    printk("\vbnx2fc: tm_compl: SCp.ptr is NULL\n");
#line 1572
    return;
  } else {

  }
#line 1574
  switch ((int )io_req->fcp_status) {
  case 0: ;
#line 1576
  if ((unsigned int )io_req->cdb_status == 0U) {
#line 1578
    sc_cmd->result = 0;
  } else {
#line 1581
    sc_cmd->result = (int )io_req->cdb_status;
  }
#line 1583
  if (io_req->fcp_resid != 0U) {
#line 1584
    scsi_set_resid(sc_cmd, (int )io_req->fcp_resid);
  } else {

  }
#line 1585
  goto ldv_55002;
  default: 
#line 1588
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "process_tm_compl: fcp_status = %d\n",
                (int )io_req->fcp_status);
#line 1590
  goto ldv_55002;
  }
  ldv_55002: 
#line 1593
  sc_cmd = io_req->sc_cmd;
#line 1594
  io_req->sc_cmd = (struct scsi_cmnd *)0;
#line 1597
  if ((unsigned int )io_req->on_tmf_queue != 0U) {
#line 1599
    list_del_init(& io_req->link);
#line 1600
    io_req->on_tmf_queue = 0U;
  } else {
#line 1603
    printk("\vbnx2fc: Command not on active_cmd_queue!\n");
#line 1604
    return;
  }
#line 1607
  sc_cmd->SCp.ptr = (char *)0;
#line 1608
  (*(sc_cmd->scsi_done))(sc_cmd);
#line 1610
  kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
#line 1611
  if (io_req->wait_for_comp != 0) {
#line 1612
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "tm_compl - wake up the waiter\n");
#line 1613
    complete(& io_req->tm_done);
  } else {

  }
#line 1615
  return;
}
}
#line 1617 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
static int bnx2fc_split_bd(struct bnx2fc_cmd *io_req , u64 addr , int sg_len , int bd_index ) 
{ 
  struct fcoe_bd_ctx *bd ;
  int frag_size ;
  int sg_frags ;

  {
#line 1620
  bd = (io_req->bd_tbl)->bd_tbl;
#line 1623
  sg_frags = 0;
#line 1624
  goto ldv_55014;
  ldv_55013: ;
#line 1625
  if (sg_len > 32767) {
#line 1626
    frag_size = 32768;
  } else {
#line 1628
    frag_size = sg_len;
  }
#line 1629
  (bd + (unsigned long )(bd_index + sg_frags))->buf_addr_lo = (__le32 )addr;
#line 1630
  (bd + (unsigned long )(bd_index + sg_frags))->buf_addr_hi = (__le32 )(addr >> 32);
#line 1631
  (bd + (unsigned long )(bd_index + sg_frags))->buf_len = (unsigned short )frag_size;
#line 1632
  (bd + (unsigned long )(bd_index + sg_frags))->flags = 0U;
#line 1634
  addr = (unsigned long long )frag_size + addr;
#line 1635
  sg_frags = sg_frags + 1;
#line 1636
  sg_len = sg_len - frag_size;
  ldv_55014: ;
#line 1624
  if (sg_len != 0) {
#line 1626
    goto ldv_55013;
  } else {

  }

#line 1638
  return (sg_frags);
}
}
#line 1642 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
static int bnx2fc_map_sg(struct bnx2fc_cmd *io_req ) 
{ 
  struct bnx2fc_interface *interface ;
  struct bnx2fc_hba *hba ;
  struct scsi_cmnd *sc ;
  struct fcoe_bd_ctx *bd ;
  struct scatterlist *sg ;
  int byte_count ;
  int sg_count ;
  int bd_count ;
  int sg_frags ;
  unsigned int sg_len ;
  u64 addr ;
  int i ;
  unsigned int tmp ;
  struct scatterlist *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 1644
  interface = (struct bnx2fc_interface *)(io_req->port)->priv;
#line 1645
  hba = interface->hba;
#line 1646
  sc = io_req->sc_cmd;
#line 1647
  bd = (io_req->bd_tbl)->bd_tbl;
#line 1649
  byte_count = 0;
#line 1650
  sg_count = 0;
#line 1651
  bd_count = 0;
#line 1661
  tmp = scsi_sg_count(sc);
#line 1661
  tmp___0 = scsi_sglist(sc);
#line 1661
  sg_count = dma_map_sg_attrs(& (hba->pcidev)->dev, tmp___0, (int )tmp, sc->sc_data_direction,
                              (struct dma_attrs *)0);
#line 1663
  i = 0;
#line 1663
  sg = scsi_sglist(sc);
#line 1663
  goto ldv_55032;
  ldv_55031: 
#line 1664
  sg_len = sg->dma_length;
#line 1665
  addr = sg->dma_address;
#line 1666
  if (sg_len > 65535U) {
#line 1667
    sg_frags = bnx2fc_split_bd(io_req, addr, (int )sg_len, bd_count);
  } else {
#line 1671
    sg_frags = 1;
#line 1672
    (bd + (unsigned long )bd_count)->buf_addr_lo = (__le32 )addr;
#line 1673
    (bd + (unsigned long )bd_count)->buf_addr_hi = (__le32 )(addr >> 32);
#line 1674
    (bd + (unsigned long )bd_count)->buf_len = (unsigned short )sg_len;
#line 1675
    (bd + (unsigned long )bd_count)->flags = 0U;
  }
#line 1677
  bd_count = bd_count + sg_frags;
#line 1678
  byte_count = (int )((unsigned int )byte_count + sg_len);
#line 1663
  i = i + 1;
#line 1663
  sg = sg_next(sg);
  ldv_55032: ;
#line 1663
  if (i < sg_count) {
#line 1665
    goto ldv_55031;
  } else {

  }
#line 1680
  tmp___2 = scsi_bufflen(sc);
#line 1680
  if ((unsigned int )byte_count != tmp___2) {
#line 1681
    tmp___1 = scsi_bufflen(sc);
#line 1681
    printk("\vbnx2fc: byte_count = %d != scsi_bufflen = %d, task_id = 0x%x\n", byte_count,
           tmp___1, (int )io_req->xid);
  } else {

  }
#line 1684
  return (bd_count);
}
}
#line 1687 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
static int bnx2fc_build_bd_list_from_sg(struct bnx2fc_cmd *io_req ) 
{ 
  struct scsi_cmnd *sc ;
  struct fcoe_bd_ctx *bd ;
  int bd_count ;
  __le32 tmp ;
  __le16 tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 1689
  sc = io_req->sc_cmd;
#line 1690
  bd = (io_req->bd_tbl)->bd_tbl;
#line 1693
  tmp___1 = scsi_sg_count(sc);
#line 1693
  if (tmp___1 != 0U) {
#line 1694
    bd_count = bnx2fc_map_sg(io_req);
#line 1695
    if (bd_count == 0) {
#line 1696
      return (-12);
    } else {

    }
  } else {
#line 1698
    bd_count = 0;
#line 1699
    tmp = 0U;
#line 1699
    bd->buf_addr_hi = tmp;
#line 1699
    bd->buf_addr_lo = tmp;
#line 1700
    tmp___0 = 0U;
#line 1700
    bd->flags = tmp___0;
#line 1700
    bd->buf_len = tmp___0;
  }
#line 1702
  (io_req->bd_tbl)->bd_valid = (u16 )bd_count;
#line 1704
  return (0);
}
}
#line 1707 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
static void bnx2fc_unmap_sg_list(struct bnx2fc_cmd *io_req ) 
{ 
  struct scsi_cmnd *sc ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_hba *hba ;
  unsigned int tmp ;
  struct scatterlist *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 1709
  sc = io_req->sc_cmd;
#line 1710
  interface = (struct bnx2fc_interface *)(io_req->port)->priv;
#line 1711
  hba = interface->hba;
#line 1717
  if ((unsigned int )(io_req->bd_tbl)->bd_valid != 0U && (unsigned long )sc != (unsigned long )((struct scsi_cmnd *)0)) {
#line 1717
    tmp___1 = scsi_sg_count(sc);
#line 1717
    if (tmp___1 != 0U) {
#line 1718
      tmp = scsi_sg_count(sc);
#line 1718
      tmp___0 = scsi_sglist(sc);
#line 1718
      dma_unmap_sg_attrs(& (hba->pcidev)->dev, tmp___0, (int )tmp, sc->sc_data_direction,
                         (struct dma_attrs *)0);
#line 1720
      (io_req->bd_tbl)->bd_valid = 0U;
    } else {

    }
  } else {

  }
#line 1722
  return;
}
}
#line 1724 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
void bnx2fc_build_fcp_cmnd(struct bnx2fc_cmd *io_req , struct fcp_cmnd *fcp_cmnd ) 
{ 
  struct scsi_cmnd *sc_cmd ;
  __u32 tmp ;

  {
#line 1727
  sc_cmd = io_req->sc_cmd;
#line 1729
  memset((void *)fcp_cmnd, 0, 32UL);
#line 1731
  int_to_scsilun((sc_cmd->device)->lun, & fcp_cmnd->fc_lun);
#line 1733
  tmp = __fswab32((__u32 )io_req->data_xfer_len);
#line 1733
  fcp_cmnd->fc_dl = tmp;
#line 1734
  memcpy((void *)(& fcp_cmnd->fc_cdb), (void const   *)sc_cmd->cmnd, (size_t )sc_cmd->cmd_len);
#line 1736
  fcp_cmnd->fc_cmdref = 0U;
#line 1737
  fcp_cmnd->fc_pri_ta = 0U;
#line 1738
  fcp_cmnd->fc_tm_flags = io_req->mp_req.tm_flags;
#line 1739
  fcp_cmnd->fc_flags = io_req->io_req_flags;
#line 1740
  fcp_cmnd->fc_pri_ta = 0U;
#line 1741
  return;
}
}
#line 1743 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
static void bnx2fc_parse_fcp_rsp(struct bnx2fc_cmd *io_req , struct fcoe_fcp_rsp_payload *fcp_rsp ,
                                 u8 num_rq ) 
{ 
  struct scsi_cmnd *sc_cmd ;
  struct bnx2fc_rport *tgt ;
  u8 rsp_flags ;
  u32 rq_buff_len ;
  int i ;
  unsigned char *rq_data ;
  unsigned char *dummy ;
  int fcp_sns_len ;
  int fcp_rsp_len ;
  u8 tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 1747
  sc_cmd = io_req->sc_cmd;
#line 1748
  tgt = io_req->tgt;
#line 1749
  rsp_flags = fcp_rsp->fcp_flags.flags;
#line 1750
  rq_buff_len = 0U;
#line 1754
  fcp_sns_len = 0;
#line 1755
  fcp_rsp_len = 0;
#line 1757
  io_req->fcp_status = 0U;
#line 1758
  io_req->fcp_resid = fcp_rsp->fcp_resid;
#line 1760
  io_req->scsi_comp_flags = rsp_flags;
#line 1761
  tmp = fcp_rsp->scsi_status_code;
#line 1761
  io_req->cdb_status = tmp;
#line 1761
  sc_cmd->SCp.Status = (int volatile   )tmp;
#line 1765
  if ((unsigned int )num_rq != 0U) {
#line 1773
    if ((int )rsp_flags & 1) {
#line 1775
      rq_buff_len = fcp_rsp->fcp_rsp_len;
#line 1775
      fcp_rsp_len = (int )rq_buff_len;
    } else {

    }
#line 1779
    if (((int )rsp_flags & 2) != 0) {
#line 1781
      fcp_sns_len = (int )fcp_rsp->fcp_sns_len;
#line 1782
      rq_buff_len = fcp_rsp->fcp_sns_len + rq_buff_len;
    } else {

    }
#line 1785
    io_req->fcp_rsp_len = (u32 )fcp_rsp_len;
#line 1786
    io_req->fcp_sns_len = (u32 )fcp_sns_len;
#line 1788
    if ((u32 )((int )num_rq * 256) < rq_buff_len) {
#line 1790
      printk("\vbnx2fc: invalid sns length %d\n", rq_buff_len);
#line 1793
      rq_buff_len = (u32 )((int )num_rq * 256);
    } else {

    }
#line 1796
    tmp___0 = bnx2fc_get_next_rqe(tgt, 1);
#line 1796
    rq_data = (unsigned char *)tmp___0;
#line 1798
    if ((unsigned int )num_rq > 1U) {
#line 1800
      i = 1;
#line 1800
      goto ldv_55066;
      ldv_55065: 
#line 1801
      tmp___1 = bnx2fc_get_next_rqe(tgt, 1);
#line 1801
      dummy = (unsigned char *)tmp___1;
#line 1800
      i = i + 1;
      ldv_55066: ;
#line 1800
      if ((int )num_rq > i) {
#line 1802
        goto ldv_55065;
      } else {

      }

    } else {

    }
#line 1805
    if (fcp_rsp_len == 4 || fcp_rsp_len == 8) {
#line 1807
      io_req->fcp_rsp_code = *(rq_data + 3UL);
#line 1808
      printk("\vbnx2fc: fcp_rsp_code = %d\n", (int )io_req->fcp_rsp_code);
    } else {

    }
#line 1813
    rq_data = rq_data + (unsigned long )fcp_rsp_len;
#line 1815
    if (fcp_sns_len > 96) {
#line 1816
      printk("\vbnx2fc: Truncating sense buffer\n");
#line 1817
      fcp_sns_len = 96;
    } else {

    }
#line 1820
    memset((void *)sc_cmd->sense_buffer, 0, 96UL);
#line 1821
    if (fcp_sns_len != 0) {
#line 1822
      memcpy((void *)sc_cmd->sense_buffer, (void const   *)rq_data, (size_t )fcp_sns_len);
    } else {

    }
#line 1825
    i = 0;
#line 1825
    goto ldv_55069;
    ldv_55068: 
#line 1826
    bnx2fc_return_rqe(tgt, 1);
#line 1825
    i = i + 1;
    ldv_55069: ;
#line 1825
    if ((int )num_rq > i) {
#line 1827
      goto ldv_55068;
    } else {

    }

  } else {

  }
#line 1833
  return;
}
}
#line 1838 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
int bnx2fc_queuecommand(struct Scsi_Host *host , struct scsi_cmnd *sc_cmd ) 
{ 
  struct fc_lport *lport ;
  void *tmp ;
  struct fc_rport *rport ;
  struct device  const  *__mptr ;
  struct scsi_target *tmp___2 ;
  struct fc_rport *tmp___3 ;
  struct scsi_target *tmp___4 ;
  int tmp___5 ;
  struct fc_rport_libfc_priv *rp ;
  struct bnx2fc_rport *tgt ;
  struct bnx2fc_cmd *io_req ;
  int rc ;
  int rval ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1841
  tmp = shost_priv(host);
#line 1841
  lport = (struct fc_lport *)tmp;
#line 1842
  tmp___4 = scsi_target(sc_cmd->device);
#line 1842
  tmp___5 = scsi_is_fc_rport((struct device  const  *)tmp___4->dev.parent);
#line 1842
  if (tmp___5 != 0) {
#line 1842
    tmp___2 = scsi_target(sc_cmd->device);
#line 1842
    __mptr = (struct device  const  *)tmp___2->dev.parent;
#line 1842
    tmp___3 = (struct fc_rport *)__mptr + 0xffffffffffffffa0UL;
  } else {
#line 1842
    tmp___3 = (struct fc_rport *)0;
  }
#line 1842
  rport = tmp___3;
#line 1843
  rp = (struct fc_rport_libfc_priv *)rport->dd_data;
#line 1846
  rc = 0;
#line 1849
  rval = fc_remote_port_chkready___0(rport);
#line 1850
  if (rval != 0) {
#line 1851
    sc_cmd->result = rval;
#line 1852
    (*(sc_cmd->scsi_done))(sc_cmd);
#line 1853
    return (0);
  } else {

  }
#line 1856
  if ((unsigned int )lport->state != 14U || (unsigned int )lport->link_up == 0U) {
#line 1857
    rc = 4181;
#line 1858
    goto exit_qcmd;
  } else {

  }
#line 1862
  tgt = (struct bnx2fc_rport *)rp + 1U;
#line 1864
  tmp___6 = constant_test_bit(1L, (unsigned long const volatile   *)(& tgt->flags));
#line 1864
  if (tmp___6 == 0) {
#line 1869
    rc = 4184;
#line 1870
    goto exit_qcmd;
  } else {

  }
#line 1872
  if (tgt->retry_delay_timestamp != 0UL) {
#line 1873
    if ((long )(tgt->retry_delay_timestamp - (unsigned long )jiffies) < 0L) {
#line 1874
      tgt->retry_delay_timestamp = 0UL;
    } else {
#line 1877
      rc = 4184;
#line 1878
      goto exit_qcmd;
    }
  } else {

  }
#line 1882
  spin_lock_bh(& tgt->tgt_lock);
#line 1884
  io_req = bnx2fc_cmd_alloc(tgt);
#line 1885
  if ((unsigned long )io_req == (unsigned long )((struct bnx2fc_cmd *)0)) {
#line 1886
    rc = 4181;
#line 1887
    goto exit_qcmd_tgtlock;
  } else {

  }
#line 1889
  io_req->sc_cmd = sc_cmd;
#line 1891
  tmp___7 = bnx2fc_post_io_req(tgt, io_req);
#line 1891
  if (tmp___7 != 0) {
#line 1892
    printk("\vbnx2fc: Unable to post io_req\n");
#line 1893
    rc = 4181;
#line 1894
    goto exit_qcmd_tgtlock;
  } else {

  }
  exit_qcmd_tgtlock: 
#line 1898
  spin_unlock_bh(& tgt->tgt_lock);
  exit_qcmd: ;
#line 1900
  return (rc);
}
}
#line 1903 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
void bnx2fc_process_scsi_cmd_compl(struct bnx2fc_cmd *io_req , struct fcoe_task_ctx_entry *task ,
                                   u8 num_rq ) 
{ 
  struct fcoe_fcp_rsp_payload *fcp_rsp ;
  struct bnx2fc_rport *tgt ;
  struct scsi_cmnd *sc_cmd ;
  struct Scsi_Host *host ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 1908
  tgt = io_req->tgt;
#line 1915
  tmp = test_and_set_bit(9L, (unsigned long volatile   *)(& io_req->req_flags));
#line 1915
  if (tmp != 0) {
#line 1917
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "Timer context finished processing this scsi cmd\n");
  } else {

  }
#line 1922
  tmp___0 = ldv_cancel_delayed_work_98(& io_req->timeout_work);
#line 1922
  if ((int )tmp___0) {
#line 1923
    kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
  } else {

  }
#line 1926
  sc_cmd = io_req->sc_cmd;
#line 1927
  if ((unsigned long )sc_cmd == (unsigned long )((struct scsi_cmnd *)0)) {
#line 1928
    printk("\vbnx2fc: scsi_cmd_compl - sc_cmd is NULL\n");
#line 1929
    return;
  } else {

  }
#line 1933
  fcp_rsp = & task->rxwr_only.union_ctx.comp_info.fcp_rsp.payload;
#line 1937
  bnx2fc_parse_fcp_rsp(io_req, fcp_rsp, (int )num_rq);
#line 1939
  host = (sc_cmd->device)->host;
#line 1940
  if ((unsigned long )sc_cmd->SCp.ptr == (unsigned long )((char *)0)) {
#line 1941
    printk("\vbnx2fc: SCp.ptr is NULL\n");
#line 1942
    return;
  } else {

  }
#line 1945
  if ((unsigned int )io_req->on_active_queue != 0U) {
#line 1946
    list_del_init(& io_req->link);
#line 1947
    io_req->on_active_queue = 0U;
#line 1949
    list_add_tail(& io_req->link, & tgt->io_retire_queue);
  } else {
#line 1955
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "xid not on active_cmd_queue\n");
#line 1956
    if (io_req->wait_for_comp != 0) {
#line 1957
      tmp___1 = test_and_clear_bit(8L, (unsigned long volatile   *)(& io_req->req_flags));
#line 1957
      if (tmp___1 != 0) {
#line 1959
        complete(& io_req->tm_done);
      } else {

      }
    } else {

    }
  }
#line 1962
  bnx2fc_unmap_sg_list(io_req);
#line 1963
  io_req->sc_cmd = (struct scsi_cmnd *)0;
#line 1965
  switch ((int )io_req->fcp_status) {
  case 0: ;
#line 1967
  if ((unsigned int )io_req->cdb_status == 0U) {
#line 1969
    sc_cmd->result = 0;
  } else {
#line 1972
    BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "scsi_cmpl: cdb_status = %d fcp_resid = 0x%x\n",
                  (int )io_req->cdb_status, io_req->fcp_resid);
#line 1975
    sc_cmd->result = (int )io_req->cdb_status;
#line 1977
    if ((unsigned int )io_req->cdb_status == 40U || (unsigned int )io_req->cdb_status == 8U) {
#line 1981
      tgt->retry_delay_timestamp = (unsigned long )(((int )fcp_rsp->retry_delay_timer * 250) / 10) + (unsigned long )jiffies;
    } else {

    }
  }
#line 1986
  if (io_req->fcp_resid != 0U) {
#line 1987
    scsi_set_resid(sc_cmd, (int )io_req->fcp_resid);
  } else {

  }
#line 1988
  goto ldv_55102;
  default: 
#line 1990
  printk("\vbnx2fc: scsi_cmd_compl: fcp_status = %d\n", (int )io_req->fcp_status);
#line 1992
  goto ldv_55102;
  }
  ldv_55102: 
#line 1994
  sc_cmd->SCp.ptr = (char *)0;
#line 1995
  (*(sc_cmd->scsi_done))(sc_cmd);
#line 1996
  kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
#line 1997
  return;
}
}
#line 1999 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.c"
int bnx2fc_post_io_req(struct bnx2fc_rport *tgt , struct bnx2fc_cmd *io_req ) 
{ 
  struct fcoe_task_ctx_entry *task ;
  struct fcoe_task_ctx_entry *task_page ;
  struct scsi_cmnd *sc_cmd ;
  struct fcoe_port *port ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_hba *hba ;
  struct fc_lport *lport ;
  struct fc_stats *stats ;
  int task_idx ;
  int index ;
  u16 xid ;
  unsigned int tmp ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  int pscr_ret__ ;
  void const   *__vpp_verify___0 ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2004
  sc_cmd = io_req->sc_cmd;
#line 2005
  port = tgt->port;
#line 2006
  interface = (struct bnx2fc_interface *)port->priv;
#line 2007
  hba = interface->hba;
#line 2008
  lport = port->lport;
#line 2016
  io_req->cmd_type = 1U;
#line 2017
  io_req->port = port;
#line 2018
  io_req->tgt = tgt;
#line 2019
  tmp = scsi_bufflen(sc_cmd);
#line 2019
  io_req->data_xfer_len = (size_t )tmp;
#line 2020
  sc_cmd->SCp.ptr = (char *)io_req;
#line 2022
  __vpp_verify = (void const   *)0;
#line 2022
  __asm__  ("": "=r" (__ptr): "0" (lport->stats));
#line 2022
  __preempt_count_add(1);
#line 2022
  __asm__  volatile   ("": : : "memory");
#line 2022
  __vpp_verify___0 = (void const   *)0;
#line 2022
  switch (4UL) {
  case 1UL: ;
#line 2022
  switch (4UL) {
  case 1UL: 
#line 2022
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 2022
  goto ldv_55126;
  case 2UL: 
#line 2022
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 2022
  goto ldv_55126;
  case 4UL: 
#line 2022
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 2022
  goto ldv_55126;
  case 8UL: 
#line 2022
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 2022
  goto ldv_55126;
  default: 
#line 2022
  __bad_percpu_size();
  }
  ldv_55126: 
#line 2022
  pscr_ret__ = pfo_ret__;
#line 2022
  goto ldv_55132;
  case 2UL: ;
#line 2022
  switch (4UL) {
  case 1UL: 
#line 2022
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 2022
  goto ldv_55136;
  case 2UL: 
#line 2022
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 2022
  goto ldv_55136;
  case 4UL: 
#line 2022
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 2022
  goto ldv_55136;
  case 8UL: 
#line 2022
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 2022
  goto ldv_55136;
  default: 
#line 2022
  __bad_percpu_size();
  }
  ldv_55136: 
#line 2022
  pscr_ret__ = pfo_ret_____0;
#line 2022
  goto ldv_55132;
  case 4UL: ;
#line 2022
  switch (4UL) {
  case 1UL: 
#line 2022
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 2022
  goto ldv_55145;
  case 2UL: 
#line 2022
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 2022
  goto ldv_55145;
  case 4UL: 
#line 2022
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 2022
  goto ldv_55145;
  case 8UL: 
#line 2022
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 2022
  goto ldv_55145;
  default: 
#line 2022
  __bad_percpu_size();
  }
  ldv_55145: 
#line 2022
  pscr_ret__ = pfo_ret_____1;
#line 2022
  goto ldv_55132;
  case 8UL: ;
#line 2022
  switch (4UL) {
  case 1UL: 
#line 2022
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 2022
  goto ldv_55154;
  case 2UL: 
#line 2022
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 2022
  goto ldv_55154;
  case 4UL: 
#line 2022
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 2022
  goto ldv_55154;
  case 8UL: 
#line 2022
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 2022
  goto ldv_55154;
  default: 
#line 2022
  __bad_percpu_size();
  }
  ldv_55154: 
#line 2022
  pscr_ret__ = pfo_ret_____2;
#line 2022
  goto ldv_55132;
  default: 
#line 2022
  __bad_size_call_parameter();
#line 2022
  goto ldv_55132;
  }
  ldv_55132: 
#line 2022
  stats = (struct fc_stats *)(__per_cpu_offset[pscr_ret__] + __ptr);
#line 2023
  if ((unsigned int )sc_cmd->sc_data_direction == 2U) {
#line 2024
    io_req->io_req_flags = 2U;
#line 2025
    stats->InputRequests = stats->InputRequests + 1ULL;
#line 2026
    stats->InputBytes = stats->InputBytes + (unsigned long long )io_req->data_xfer_len;
  } else
#line 2027
  if ((unsigned int )sc_cmd->sc_data_direction == 1U) {
#line 2028
    io_req->io_req_flags = 1U;
#line 2029
    stats->OutputRequests = stats->OutputRequests + 1ULL;
#line 2030
    stats->OutputBytes = stats->OutputBytes + (unsigned long long )io_req->data_xfer_len;
  } else {
#line 2032
    io_req->io_req_flags = 0U;
#line 2033
    stats->ControlRequests = stats->ControlRequests + 1ULL;
  }
#line 2035
  __asm__  volatile   ("": : : "memory");
#line 2035
  __preempt_count_sub(1);
#line 2037
  xid = io_req->xid;
#line 2040
  tmp___0 = bnx2fc_build_bd_list_from_sg(io_req);
#line 2040
  if (tmp___0 != 0) {
#line 2041
    printk("\vbnx2fc: BD list creation failed\n");
#line 2042
    kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
#line 2043
    return (-11);
  } else {

  }
#line 2046
  task_idx = (int )((unsigned int )xid / 32U);
#line 2047
  index = (int )xid & 31;
#line 2050
  task_page = *(hba->task_ctx + (unsigned long )task_idx);
#line 2051
  task = task_page + (unsigned long )index;
#line 2052
  bnx2fc_init_task(io_req, task);
#line 2054
  if (tgt->flush_in_prog != 0U) {
#line 2055
    printk("\vbnx2fc: Flush in progress..Host Busy\n");
#line 2056
    kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
#line 2057
    return (-11);
  } else {

  }
#line 2060
  tmp___1 = constant_test_bit(1L, (unsigned long const volatile   *)(& tgt->flags));
#line 2060
  if (tmp___1 == 0) {
#line 2061
    printk("\vbnx2fc: Session not ready...post_io\n");
#line 2062
    kref_put___2(& io_req->refcount, & bnx2fc_cmd_release);
#line 2063
    return (-11);
  } else {

  }
#line 2067
  if (tgt->io_timeout != 0U) {
#line 2068
    bnx2fc_cmd_timer_set(io_req, 20000U);
  } else {

  }
#line 2070
  bnx2fc_add_2_sq(tgt, (int )xid);
#line 2074
  io_req->on_active_queue = 1U;
#line 2076
  list_add_tail(& io_req->link, & tgt->active_cmd_queue);
#line 2079
  bnx2fc_ring_doorbell(tgt);
#line 2080
  return (0);
}
}
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
void work_init_3(void) 
{ 


  {
#line 155
  ldv_work_3_0 = 0;
#line 156
  ldv_work_3_1 = 0;
#line 157
  ldv_work_3_2 = 0;
#line 158
  ldv_work_3_3 = 0;
#line 159
  return;
}
}
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
void activate_work_3(struct work_struct *work , int state ) 
{ 


  {
#line 163
  if (ldv_work_3_0 == 0) {
#line 164
    ldv_work_struct_3_0 = work;
#line 165
    ldv_work_3_0 = state;
#line 166
    return;
  } else {

  }
#line 169
  if (ldv_work_3_1 == 0) {
#line 170
    ldv_work_struct_3_1 = work;
#line 171
    ldv_work_3_1 = state;
#line 172
    return;
  } else {

  }
#line 175
  if (ldv_work_3_2 == 0) {
#line 176
    ldv_work_struct_3_2 = work;
#line 177
    ldv_work_3_2 = state;
#line 178
    return;
  } else {

  }
#line 181
  if (ldv_work_3_3 == 0) {
#line 182
    ldv_work_struct_3_3 = work;
#line 183
    ldv_work_3_3 = state;
#line 184
    return;
  } else {

  }
#line 186
  return;
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
void call_and_disable_work_3(struct work_struct *work ) 
{ 


  {
#line 192
  if ((ldv_work_3_0 == 2 || ldv_work_3_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_0) {
#line 194
    bnx2fc_cmd_timeout(work);
#line 195
    ldv_work_3_0 = 1;
#line 196
    return;
  } else {

  }
#line 198
  if ((ldv_work_3_1 == 2 || ldv_work_3_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_1) {
#line 200
    bnx2fc_cmd_timeout(work);
#line 201
    ldv_work_3_1 = 1;
#line 202
    return;
  } else {

  }
#line 204
  if ((ldv_work_3_2 == 2 || ldv_work_3_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_2) {
#line 206
    bnx2fc_cmd_timeout(work);
#line 207
    ldv_work_3_2 = 1;
#line 208
    return;
  } else {

  }
#line 210
  if ((ldv_work_3_3 == 2 || ldv_work_3_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_3) {
#line 212
    bnx2fc_cmd_timeout(work);
#line 213
    ldv_work_3_3 = 1;
#line 214
    return;
  } else {

  }
#line 216
  return;
}
}
#line 219 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
void disable_work_3(struct work_struct *work ) 
{ 


  {
#line 221
  if ((ldv_work_3_0 == 3 || ldv_work_3_0 == 2) && (unsigned long )ldv_work_struct_3_0 == (unsigned long )work) {
#line 223
    ldv_work_3_0 = 1;
  } else {

  }
#line 225
  if ((ldv_work_3_1 == 3 || ldv_work_3_1 == 2) && (unsigned long )ldv_work_struct_3_1 == (unsigned long )work) {
#line 227
    ldv_work_3_1 = 1;
  } else {

  }
#line 229
  if ((ldv_work_3_2 == 3 || ldv_work_3_2 == 2) && (unsigned long )ldv_work_struct_3_2 == (unsigned long )work) {
#line 231
    ldv_work_3_2 = 1;
  } else {

  }
#line 233
  if ((ldv_work_3_3 == 3 || ldv_work_3_3 == 2) && (unsigned long )ldv_work_struct_3_3 == (unsigned long )work) {
#line 235
    ldv_work_3_3 = 1;
  } else {

  }
#line 236
  return;
}
}
#line 240 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
void invoke_work_3(void) 
{ 
  int tmp ;

  {
#line 242
  tmp = __VERIFIER_nondet_int();
#line 242
  switch (tmp) {
  case 0: ;
#line 244
  if (ldv_work_3_0 == 2 || ldv_work_3_0 == 3) {
#line 245
    ldv_work_3_0 = 4;
#line 246
    bnx2fc_cmd_timeout(ldv_work_struct_3_0);
#line 247
    ldv_work_3_0 = 1;
  } else {

  }
#line 250
  goto ldv_55186;
  case 1: ;
#line 252
  if (ldv_work_3_1 == 2 || ldv_work_3_1 == 3) {
#line 253
    ldv_work_3_1 = 4;
#line 254
    bnx2fc_cmd_timeout(ldv_work_struct_3_0);
#line 255
    ldv_work_3_1 = 1;
  } else {

  }
#line 258
  goto ldv_55186;
  case 2: ;
#line 260
  if (ldv_work_3_2 == 2 || ldv_work_3_2 == 3) {
#line 261
    ldv_work_3_2 = 4;
#line 262
    bnx2fc_cmd_timeout(ldv_work_struct_3_0);
#line 263
    ldv_work_3_2 = 1;
  } else {

  }
#line 266
  goto ldv_55186;
  case 3: ;
#line 268
  if (ldv_work_3_3 == 2 || ldv_work_3_3 == 3) {
#line 269
    ldv_work_3_3 = 4;
#line 270
    bnx2fc_cmd_timeout(ldv_work_struct_3_0);
#line 271
    ldv_work_3_3 = 1;
  } else {

  }
#line 274
  goto ldv_55186;
  default: 
#line 275
  ldv_stop();
  }
  ldv_55186: ;
#line 277
  return;
}
}
#line 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
void call_and_disable_all_3(int state ) 
{ 


  {
#line 283
  if (ldv_work_3_0 == state) {
#line 284
    call_and_disable_work_3(ldv_work_struct_3_0);
  } else {

  }
#line 285
  if (ldv_work_3_1 == state) {
#line 286
    call_and_disable_work_3(ldv_work_struct_3_1);
  } else {

  }
#line 287
  if (ldv_work_3_2 == state) {
#line 288
    call_and_disable_work_3(ldv_work_struct_3_2);
  } else {

  }
#line 289
  if (ldv_work_3_3 == state) {
#line 290
    call_and_disable_work_3(ldv_work_struct_3_3);
  } else {

  }
#line 291
  return;
}
}
#line 317 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
bool ldv_queue_work_on_86(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 321
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 321
  ldv_func_res = tmp;
#line 323
  activate_work_2(ldv_func_arg3, 2);
#line 325
  return (ldv_func_res);
}
}
#line 328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
bool ldv_queue_delayed_work_on_87(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 332
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 332
  ldv_func_res = tmp;
#line 334
  activate_work_2(& ldv_func_arg3->work, 2);
#line 336
  return (ldv_func_res);
}
}
#line 339 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
bool ldv_queue_work_on_88(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 343
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 343
  ldv_func_res = tmp;
#line 345
  activate_work_2(ldv_func_arg3, 2);
#line 347
  return (ldv_func_res);
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
void ldv_flush_workqueue_89(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 353
  flush_workqueue(ldv_func_arg1);
#line 355
  call_and_disable_all_2(2);
#line 356
  return;
}
}
#line 358 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
bool ldv_queue_delayed_work_on_90(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 362
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 362
  ldv_func_res = tmp;
#line 364
  activate_work_2(& ldv_func_arg3->work, 2);
#line 366
  return (ldv_func_res);
}
}
#line 369 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
int ldv_scsi_add_host_with_dma_91(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 373
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 373
  ldv_func_res = tmp;
#line 375
  if (ldv_func_res == 0) {
#line 376
    ldv_state_variable_10 = 1;
#line 376
    ldv_initialize_scsi_host_template_10();
  } else {

  }
#line 380
  return (ldv_func_res);
}
}
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
struct Scsi_Host *ldv_scsi_host_alloc_92(struct scsi_host_template *sht , int privsize ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  struct Scsi_Host *tmp ;

  {
#line 387
  tmp = scsi_host_alloc(sht, privsize);
#line 387
  ldv_func_res = tmp;
#line 389
  if ((unsigned long )ldv_func_res != (unsigned long )((ldv_func_ret_type___4 )0)) {
#line 390
    ldv_state_variable_10 = 1;
#line 390
    ldv_initialize_scsi_host_template_10();
  } else {

  }
#line 394
  return (ldv_func_res);
}
}
#line 397 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
bool ldv_cancel_delayed_work_93(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
#line 401
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 401
  ldv_func_res = tmp;
#line 403
  disable_work_2(& ldv_func_arg1->work);
#line 405
  return (ldv_func_res);
}
}
#line 408 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
bool ldv_cancel_delayed_work_94(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  bool tmp ;

  {
#line 412
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 412
  ldv_func_res = tmp;
#line 414
  disable_work_2(& ldv_func_arg1->work);
#line 416
  return (ldv_func_res);
}
}
#line 419 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
bool ldv_cancel_delayed_work_95(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  bool tmp ;

  {
#line 423
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 423
  ldv_func_res = tmp;
#line 425
  disable_work_2(& ldv_func_arg1->work);
#line 427
  return (ldv_func_res);
}
}
#line 430 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
bool ldv_cancel_delayed_work_96(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  bool tmp ;

  {
#line 434
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 434
  ldv_func_res = tmp;
#line 436
  disable_work_2(& ldv_func_arg1->work);
#line 438
  return (ldv_func_res);
}
}
#line 441 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
bool ldv_cancel_delayed_work_97(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  bool tmp ;

  {
#line 445
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 445
  ldv_func_res = tmp;
#line 447
  disable_work_2(& ldv_func_arg1->work);
#line 449
  return (ldv_func_res);
}
}
#line 452 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_io.o.c.prepared"
bool ldv_cancel_delayed_work_98(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  bool tmp ;

  {
#line 456
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 456
  ldv_func_res = tmp;
#line 458
  disable_work_2(& ldv_func_arg1->work);
#line 460
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 170 "include/linux/timer.h"
extern int mod_timer(struct timer_list * , unsigned long  ) ;
#line 173
int ldv_mod_timer_123(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 177
int ldv_mod_timer_128(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 232
int ldv_del_timer_sync_124(struct timer_list *ldv_func_arg1 ) ;
#line 236
int ldv_del_timer_sync_129(struct timer_list *ldv_func_arg1 ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_116(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_118(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_117(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_120(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_119(struct workqueue_struct *ldv_func_arg1 ) ;
#line 470
bool ldv_cancel_delayed_work_125(struct delayed_work *ldv_func_arg1 ) ;
#line 474
bool ldv_cancel_delayed_work_126(struct delayed_work *ldv_func_arg1 ) ;
#line 478
bool ldv_cancel_delayed_work_127(struct delayed_work *ldv_func_arg1 ) ;
#line 195 "./arch/x86/include/asm/io.h"
extern void iounmap(void volatile   * ) ;
#line 68 "include/linux/kref.h"
__inline static int kref_sub___3(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
#line 71
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
#line 71
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 71
  if (tmp != 0L) {
#line 71
    warn_slowpath_null("include/linux/kref.h", 71);
  } else {

  }
#line 71
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 73
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
#line 73
  if (tmp___0 != 0) {
#line 74
    (*release)(kref);
#line 75
    return (1);
  } else {

  }
#line 77
  return (0);
}
}
#line 97 "include/linux/kref.h"
__inline static int kref_put___3(struct kref *kref , void (*release)(struct kref * ) ) 
{ 
  int tmp ;

  {
#line 99
  tmp = kref_sub___3(kref, 1U, release);
#line 99
  return (tmp);
}
}
#line 2847 "include/linux/sched.h"
__inline static int signal_pending___0(struct task_struct *p ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 2849
  tmp = test_tsk_thread_flag(p, 2);
#line 2849
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 2849
  return ((int )tmp___0);
}
}
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
void activate_suitable_timer_6(struct timer_list *timer , unsigned long data ) ;
#line 105
void ldv_timer_5(int state , struct timer_list *timer ) ;
#line 106
void choose_timer_5(void) ;
#line 122
void disable_suitable_timer_5(struct timer_list *timer ) ;
#line 123
void activate_pending_timer_6(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 129
void choose_timer_6(void) ;
#line 135
void ldv_timer_6(int state , struct timer_list *timer ) ;
#line 143
void activate_pending_timer_5(struct timer_list *timer , unsigned long data , int pending_flag ) ;
#line 147
int reg_timer_5(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
#line 149
void activate_suitable_timer_5(struct timer_list *timer , unsigned long data ) ;
#line 47 "include/linux/delay.h"
extern unsigned long msleep_interruptible(unsigned int  ) ;
#line 792 "include/scsi/scsi_host.h"
struct Scsi_Host *ldv_scsi_host_alloc_122(struct scsi_host_template *sht , int privsize ) ;
#line 799
int ldv_scsi_add_host_with_dma_121(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
#line 16 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c"
static void bnx2fc_upld_timer(unsigned long data ) ;
#line 17
static void bnx2fc_ofld_timer(unsigned long data ) ;
#line 18
static int bnx2fc_init_tgt(struct bnx2fc_rport *tgt , struct fcoe_port *port , struct fc_rport_priv *rdata ) ;
#line 21
static u32 bnx2fc_alloc_conn_id(struct bnx2fc_hba *hba , struct bnx2fc_rport *tgt ) ;
#line 23
static int bnx2fc_alloc_session_resc(struct bnx2fc_hba *hba , struct bnx2fc_rport *tgt ) ;
#line 25
static void bnx2fc_free_session_resc(struct bnx2fc_hba *hba , struct bnx2fc_rport *tgt ) ;
#line 27
static void bnx2fc_free_conn_id(struct bnx2fc_hba *hba , u32 conn_id ) ;
#line 29 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c"
static void bnx2fc_upld_timer(unsigned long data ) 
{ 
  struct bnx2fc_rport *tgt ;

  {
#line 32
  tgt = (struct bnx2fc_rport *)data;
#line 34
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "upld_timer - Upload compl not received!!\n");
#line 36
  clear_bit(2L, (unsigned long volatile   *)(& tgt->flags));
#line 37
  clear_bit(10L, (unsigned long volatile   *)(& tgt->flags));
#line 38
  set_bit(7L, (unsigned long volatile   *)(& tgt->flags));
#line 39
  __wake_up(& tgt->upld_wait, 1U, 1, (void *)0);
#line 40
  return;
}
}
#line 42 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c"
static void bnx2fc_ofld_timer(unsigned long data ) 
{ 
  struct bnx2fc_rport *tgt ;

  {
#line 45
  tgt = (struct bnx2fc_rport *)data;
#line 47
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "entered bnx2fc_ofld_timer\n");
#line 59
  clear_bit(2L, (unsigned long volatile   *)(& tgt->flags));
#line 60
  clear_bit(10L, (unsigned long volatile   *)(& tgt->flags));
#line 61
  set_bit(5L, (unsigned long volatile   *)(& tgt->flags));
#line 62
  __wake_up(& tgt->ofld_wait, 1U, 1, (void *)0);
#line 63
  return;
}
}
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c"
static void bnx2fc_ofld_wait(struct bnx2fc_rport *tgt ) 
{ 
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  int tmp___4 ;

  {
#line 67
  reg_timer_6(& tgt->ofld_timer, & bnx2fc_ofld_timer, (unsigned long )tgt);
#line 68
  ldv_mod_timer_123(& tgt->ofld_timer, (unsigned long )jiffies + 750UL);
#line 70
  __ret = 0;
#line 70
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c",
                73, 0);
#line 70
  tmp___1 = constant_test_bit(5L, (unsigned long const volatile   *)(& tgt->flags));
#line 70
  if (tmp___1 == 0) {
#line 70
    __ret___0 = 0L;
#line 70
    INIT_LIST_HEAD(& __wait.task_list);
#line 70
    __wait.flags = 0U;
    ldv_54637: 
#line 70
    tmp = prepare_to_wait_event(& tgt->ofld_wait, & __wait, 1);
#line 70
    __int = tmp;
#line 70
    tmp___0 = constant_test_bit(5L, (unsigned long const volatile   *)(& tgt->flags));
#line 70
    if (tmp___0 != 0) {
#line 70
      goto ldv_54636;
    } else {

    }
#line 70
    if (__int != 0L) {
#line 70
      __ret___0 = __int;
#line 70
      goto ldv_54636;
    } else {

    }
#line 70
    schedule();
#line 70
    goto ldv_54637;
    ldv_54636: 
#line 70
    finish_wait(& tgt->ofld_wait, & __wait);
#line 70
    __ret = (int )__ret___0;
  } else {

  }
#line 74
  tmp___3 = get_current();
#line 74
  tmp___4 = signal_pending___0(tmp___3);
#line 74
  if (tmp___4 != 0) {
#line 75
    tmp___2 = get_current();
#line 75
    flush_signals(tmp___2);
  } else {

  }
#line 76
  ldv_del_timer_sync_124(& tgt->ofld_timer);
#line 77
  return;
}
}
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c"
static void bnx2fc_offload_session(struct fcoe_port *port , struct bnx2fc_rport *tgt ,
                                   struct fc_rport_priv *rdata ) 
{ 
  struct fc_lport *lport ;
  struct fc_rport *rport ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_hba *hba ;
  int rval ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 83
  lport = rdata->local_port;
#line 84
  rport = rdata->rport;
#line 85
  interface = (struct bnx2fc_interface *)port->priv;
#line 86
  hba = interface->hba;
#line 88
  i = 0;
#line 92
  rval = bnx2fc_init_tgt(tgt, port, rdata);
#line 93
  if (rval != 0) {
#line 94
    printk("\vbnx2fc: Failed to allocate conn id for port_id (%6x)\n", rport->port_id);
#line 96
    goto tgt_init_err;
  } else {

  }
#line 100
  rval = bnx2fc_alloc_session_resc(hba, tgt);
#line 101
  if (rval != 0) {
#line 102
    printk("\vbnx2fc: Failed to allocate resources\n");
#line 103
    goto ofld_err;
  } else {

  }
  retry_ofld: 
#line 112
  clear_bit(5L, (unsigned long volatile   *)(& tgt->flags));
#line 113
  rval = bnx2fc_send_session_ofld_req(port, tgt);
#line 114
  if (rval != 0) {
#line 115
    printk("\vbnx2fc: ofld_req failed\n");
#line 116
    goto ofld_err;
  } else {

  }
#line 123
  bnx2fc_ofld_wait(tgt);
#line 125
  tmp___1 = constant_test_bit(2L, (unsigned long const volatile   *)(& tgt->flags));
#line 125
  if (tmp___1 == 0) {
#line 126
    tmp___0 = test_and_clear_bit(6L, (unsigned long volatile   *)(& tgt->flags));
#line 126
    if (tmp___0 != 0) {
#line 128
      tmp = i;
#line 128
      i = i + 1;
#line 128
      BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "ctx_alloc_failure, retry ofld..%d\n",
                     tmp);
#line 130
      msleep_interruptible(1000U);
#line 131
      if (i > 3) {
#line 132
        i = 0;
#line 133
        goto ofld_err;
      } else {

      }
#line 135
      goto retry_ofld;
    } else {

    }
#line 137
    goto ofld_err;
  } else {

  }
#line 139
  tmp___2 = bnx2fc_map_doorbell(tgt);
#line 139
  if (tmp___2 != 0) {
#line 140
    printk("\vbnx2fc: map doorbell failed - no mem\n");
#line 141
    goto ofld_err;
  } else {

  }
#line 143
  clear_bit(5L, (unsigned long volatile   *)(& tgt->flags));
#line 144
  rval = bnx2fc_send_session_enable_req(port, tgt);
#line 145
  if (rval != 0) {
#line 146
    printk("\vbnx2fc: bnx2fc: enable session failed\n");
#line 147
    goto ofld_err;
  } else {

  }
#line 149
  bnx2fc_ofld_wait(tgt);
#line 150
  tmp___3 = constant_test_bit(10L, (unsigned long const volatile   *)(& tgt->flags));
#line 150
  if (tmp___3 == 0) {
#line 151
    goto ofld_err;
  } else {

  }
#line 152
  return;
  ofld_err: 
#line 156
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "bnx2fc_offload_session - offload error\n");
#line 157
  clear_bit(2L, (unsigned long volatile   *)(& tgt->flags));
#line 159
  bnx2fc_free_session_resc(hba, tgt);
  tgt_init_err: ;
#line 161
  if (tgt->fcoe_conn_id != 4294967295U) {
#line 162
    bnx2fc_free_conn_id(hba, tgt->fcoe_conn_id);
  } else {

  }
#line 163
  (*(lport->tt.rport_logoff))(rdata);
#line 164
  return;
}
}
#line 166 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c"
void bnx2fc_flush_active_ios(struct bnx2fc_rport *tgt ) 
{ 
  struct bnx2fc_cmd *io_req ;
  struct bnx2fc_cmd *tmp ;
  int rc ;
  int i ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int tmp___0 ;
  bool tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;
  struct list_head  const  *__mptr___5 ;
  struct list_head  const  *__mptr___6 ;
  bool tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  struct list_head  const  *__mptr___7 ;
  struct list_head  const  *__mptr___8 ;
  struct list_head  const  *__mptr___9 ;
  int tmp___7 ;
  bool tmp___8 ;
  struct list_head  const  *__mptr___10 ;
  int tmp___9 ;

  {
#line 171
  i = 0;
#line 172
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "Entered flush_active_ios - %d\n",
                 tgt->num_active_ios.counter);
#line 175
  spin_lock_bh(& tgt->tgt_lock);
#line 176
  tgt->flush_in_prog = 1U;
#line 178
  __mptr = (struct list_head  const  *)tgt->active_cmd_queue.next;
#line 178
  io_req = (struct bnx2fc_cmd *)__mptr;
#line 178
  __mptr___0 = (struct list_head  const  *)io_req->link.next;
#line 178
  tmp = (struct bnx2fc_cmd *)__mptr___0;
#line 178
  goto ldv_54669;
  ldv_54668: 
#line 179
  i = i + 1;
#line 180
  list_del_init(& io_req->link);
#line 181
  io_req->on_active_queue = 0U;
#line 182
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "cmd_queue cleanup\n");
#line 184
  tmp___1 = ldv_cancel_delayed_work_125(& io_req->timeout_work);
#line 184
  if ((int )tmp___1) {
#line 185
    tmp___0 = test_and_clear_bit(8L, (unsigned long volatile   *)(& io_req->req_flags));
#line 185
    if (tmp___0 != 0) {
#line 188
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "eh_abort for IO cleaned up\n");
#line 190
      complete(& io_req->tm_done);
    } else {

    }
#line 192
    kref_put___3(& io_req->refcount, & bnx2fc_cmd_release);
  } else {

  }
#line 196
  set_bit(9L, (unsigned long volatile   *)(& io_req->req_flags));
#line 197
  set_bit(6L, (unsigned long volatile   *)(& io_req->req_flags));
#line 200
  tmp___3 = constant_test_bit(9L, (unsigned long const volatile   *)(& tgt->flags));
#line 200
  if (tmp___3 != 0) {
#line 201
    bnx2fc_process_cleanup_compl(io_req, io_req->task, 0);
  } else {
#line 203
    rc = bnx2fc_initiate_cleanup(io_req);
#line 204
    tmp___2 = ldv__builtin_expect(rc != 0, 0L);
#line 204
    if (tmp___2 != 0L) {
#line 204
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c"),
                           "i" (204), "i" (12UL));
      ldv_54667: ;
#line 204
      goto ldv_54667;
    } else {

    }
  }
#line 178
  io_req = tmp;
#line 178
  __mptr___1 = (struct list_head  const  *)tmp->link.next;
#line 178
  tmp = (struct bnx2fc_cmd *)__mptr___1;
  ldv_54669: ;
#line 178
  if ((unsigned long )(& io_req->link) != (unsigned long )(& tgt->active_cmd_queue)) {
#line 180
    goto ldv_54668;
  } else {

  }
#line 208
  __mptr___2 = (struct list_head  const  *)tgt->active_tm_queue.next;
#line 208
  io_req = (struct bnx2fc_cmd *)__mptr___2;
#line 208
  __mptr___3 = (struct list_head  const  *)io_req->link.next;
#line 208
  tmp = (struct bnx2fc_cmd *)__mptr___3;
#line 208
  goto ldv_54678;
  ldv_54677: 
#line 209
  i = i + 1;
#line 210
  list_del_init(& io_req->link);
#line 211
  io_req->on_tmf_queue = 0U;
#line 212
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "tm_queue cleanup\n");
#line 213
  if (io_req->wait_for_comp != 0) {
#line 214
    complete(& io_req->tm_done);
  } else {

  }
#line 208
  io_req = tmp;
#line 208
  __mptr___4 = (struct list_head  const  *)tmp->link.next;
#line 208
  tmp = (struct bnx2fc_cmd *)__mptr___4;
  ldv_54678: ;
#line 208
  if ((unsigned long )(& io_req->link) != (unsigned long )(& tgt->active_tm_queue)) {
#line 210
    goto ldv_54677;
  } else {

  }
#line 217
  __mptr___5 = (struct list_head  const  *)tgt->els_queue.next;
#line 217
  io_req = (struct bnx2fc_cmd *)__mptr___5;
#line 217
  __mptr___6 = (struct list_head  const  *)io_req->link.next;
#line 217
  tmp = (struct bnx2fc_cmd *)__mptr___6;
#line 217
  goto ldv_54688;
  ldv_54687: 
#line 218
  i = i + 1;
#line 219
  list_del_init(& io_req->link);
#line 220
  io_req->on_active_queue = 0U;
#line 222
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "els_queue cleanup\n");
#line 224
  tmp___4 = ldv_cancel_delayed_work_126(& io_req->timeout_work);
#line 224
  if ((int )tmp___4) {
#line 225
    kref_put___3(& io_req->refcount, & bnx2fc_cmd_release);
  } else {

  }
#line 228
  if ((unsigned long )io_req->cb_func != (unsigned long )((void (*)(struct bnx2fc_els_cb_arg * ))0) && (unsigned long )io_req->cb_arg != (unsigned long )((struct bnx2fc_els_cb_arg *)0)) {
#line 229
    (*(io_req->cb_func))(io_req->cb_arg);
#line 230
    io_req->cb_arg = (struct bnx2fc_els_cb_arg *)0;
  } else {

  }
#line 234
  tmp___6 = constant_test_bit(9L, (unsigned long const volatile   *)(& tgt->flags));
#line 234
  if (tmp___6 != 0) {
#line 235
    bnx2fc_process_cleanup_compl(io_req, io_req->task, 0);
  } else {
#line 237
    rc = bnx2fc_initiate_cleanup(io_req);
#line 238
    tmp___5 = ldv__builtin_expect(rc != 0, 0L);
#line 238
    if (tmp___5 != 0L) {
#line 238
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c"),
                           "i" (238), "i" (12UL));
      ldv_54686: ;
#line 238
      goto ldv_54686;
    } else {

    }
  }
#line 217
  io_req = tmp;
#line 217
  __mptr___7 = (struct list_head  const  *)tmp->link.next;
#line 217
  tmp = (struct bnx2fc_cmd *)__mptr___7;
  ldv_54688: ;
#line 217
  if ((unsigned long )(& io_req->link) != (unsigned long )(& tgt->els_queue)) {
#line 219
    goto ldv_54687;
  } else {

  }
#line 242
  __mptr___8 = (struct list_head  const  *)tgt->io_retire_queue.next;
#line 242
  io_req = (struct bnx2fc_cmd *)__mptr___8;
#line 242
  __mptr___9 = (struct list_head  const  *)io_req->link.next;
#line 242
  tmp = (struct bnx2fc_cmd *)__mptr___9;
#line 242
  goto ldv_54697;
  ldv_54696: 
#line 243
  i = i + 1;
#line 244
  list_del_init(& io_req->link);
#line 246
  BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "retire_queue flush\n");
#line 248
  tmp___8 = ldv_cancel_delayed_work_127(& io_req->timeout_work);
#line 248
  if ((int )tmp___8) {
#line 249
    tmp___7 = test_and_clear_bit(8L, (unsigned long volatile   *)(& io_req->req_flags));
#line 249
    if (tmp___7 != 0) {
#line 252
      BNX2FC_IO_DBG((struct bnx2fc_cmd  const  *)io_req, "eh_abort for IO in retire_q\n");
#line 254
      if (io_req->wait_for_comp != 0) {
#line 255
        complete(& io_req->tm_done);
      } else {

      }
    } else {

    }
#line 257
    kref_put___3(& io_req->refcount, & bnx2fc_cmd_release);
  } else {

  }
#line 260
  clear_bit(1L, (unsigned long volatile   *)(& io_req->req_flags));
#line 242
  io_req = tmp;
#line 242
  __mptr___10 = (struct list_head  const  *)tmp->link.next;
#line 242
  tmp = (struct bnx2fc_cmd *)__mptr___10;
  ldv_54697: ;
#line 242
  if ((unsigned long )(& io_req->link) != (unsigned long )(& tgt->io_retire_queue)) {
#line 244
    goto ldv_54696;
  } else {

  }
#line 263
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "IOs flushed = %d\n", i);
#line 264
  i = 0;
#line 265
  spin_unlock_bh(& tgt->tgt_lock);
#line 267
  goto ldv_54700;
  ldv_54699: 
#line 268
  msleep(25U);
  ldv_54700: ;
#line 267
  if (tgt->num_active_ios.counter != 0) {
#line 267
    tmp___9 = i;
#line 267
    i = i + 1;
#line 267
    if (tmp___9 <= 1199) {
#line 269
      goto ldv_54699;
    } else {
#line 272
      goto ldv_54701;
    }
  } else {

  }
  ldv_54701: ;
#line 269
  if (tgt->num_active_ios.counter != 0) {
#line 270
    printk("\vbnx2fc: CLEANUP on port 0x%x: active_ios = %d\n", (tgt->rdata)->ids.port_id,
           tgt->num_active_ios.counter);
  } else {

  }
#line 273
  spin_lock_bh(& tgt->tgt_lock);
#line 274
  tgt->flush_in_prog = 0U;
#line 275
  spin_unlock_bh(& tgt->tgt_lock);
#line 276
  return;
}
}
#line 278 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c"
static void bnx2fc_upld_wait(struct bnx2fc_rport *tgt ) 
{ 
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  int tmp___4 ;

  {
#line 280
  reg_timer_6(& tgt->upld_timer, & bnx2fc_upld_timer, (unsigned long )tgt);
#line 281
  ldv_mod_timer_128(& tgt->upld_timer, (unsigned long )jiffies + 750UL);
#line 282
  __ret = 0;
#line 282
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c",
                285, 0);
#line 282
  tmp___1 = constant_test_bit(7L, (unsigned long const volatile   *)(& tgt->flags));
#line 282
  if (tmp___1 == 0) {
#line 282
    __ret___0 = 0L;
#line 282
    INIT_LIST_HEAD(& __wait.task_list);
#line 282
    __wait.flags = 0U;
    ldv_54711: 
#line 282
    tmp = prepare_to_wait_event(& tgt->upld_wait, & __wait, 1);
#line 282
    __int = tmp;
#line 282
    tmp___0 = constant_test_bit(7L, (unsigned long const volatile   *)(& tgt->flags));
#line 282
    if (tmp___0 != 0) {
#line 282
      goto ldv_54710;
    } else {

    }
#line 282
    if (__int != 0L) {
#line 282
      __ret___0 = __int;
#line 282
      goto ldv_54710;
    } else {

    }
#line 282
    schedule();
#line 282
    goto ldv_54711;
    ldv_54710: 
#line 282
    finish_wait(& tgt->upld_wait, & __wait);
#line 282
    __ret = (int )__ret___0;
  } else {

  }
#line 286
  tmp___3 = get_current();
#line 286
  tmp___4 = signal_pending___0(tmp___3);
#line 286
  if (tmp___4 != 0) {
#line 287
    tmp___2 = get_current();
#line 287
    flush_signals(tmp___2);
  } else {

  }
#line 288
  ldv_del_timer_sync_129(& tgt->upld_timer);
#line 289
  return;
}
}
#line 291 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c"
static void bnx2fc_upload_session(struct fcoe_port *port , struct bnx2fc_rport *tgt ) 
{ 
  struct bnx2fc_interface *interface ;
  struct bnx2fc_hba *hba ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 294
  interface = (struct bnx2fc_interface *)port->priv;
#line 295
  hba = interface->hba;
#line 297
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "upload_session: active_ios = %d\n",
                 tgt->num_active_ios.counter);
#line 304
  clear_bit(7L, (unsigned long volatile   *)(& tgt->flags));
#line 305
  bnx2fc_send_session_disable_req(port, tgt);
#line 311
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "waiting for disable compl\n");
#line 312
  bnx2fc_upld_wait(tgt);
#line 318
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "flush/upload - disable wait flags = 0x%lx\n",
                 tgt->flags);
#line 320
  bnx2fc_flush_active_ios(tgt);
#line 323
  tmp___1 = constant_test_bit(3L, (unsigned long const volatile   *)(& tgt->flags));
#line 323
  if (tmp___1 != 0) {
#line 324
    BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "send destroy req\n");
#line 325
    clear_bit(7L, (unsigned long volatile   *)(& tgt->flags));
#line 326
    bnx2fc_send_session_destroy_req(hba, tgt);
#line 329
    bnx2fc_upld_wait(tgt);
#line 331
    tmp = constant_test_bit(4L, (unsigned long const volatile   *)(& tgt->flags));
#line 331
    if (tmp == 0) {
#line 332
      printk("\vbnx2fc: OLD_ERROR!! destroy timed out\n");
    } else {

    }
#line 334
    BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "destroy wait complete flags = 0x%lx\n",
                   tgt->flags);
  } else {
#line 337
    tmp___0 = constant_test_bit(9L, (unsigned long const volatile   *)(& tgt->flags));
#line 337
    if (tmp___0 != 0) {
#line 338
      printk("\vbnx2fc: OLD_ERROR!! DISABLE req failed, destroy not sent to FW\n");
    } else {
#line 341
      printk("\vbnx2fc: OLD_ERROR!! DISABLE req timed out, destroy not sent to FW\n");
    }
  }
#line 346
  bnx2fc_free_session_resc(hba, tgt);
#line 347
  bnx2fc_free_conn_id(hba, tgt->fcoe_conn_id);
#line 348
  return;
}
}
#line 350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c"
static int bnx2fc_init_tgt(struct bnx2fc_rport *tgt , struct fcoe_port *port , struct fc_rport_priv *rdata ) 
{ 
  struct fc_rport *rport ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_hba *hba ;
  struct b577xx_doorbell_set_prod *sq_db ;
  struct b577xx_fcoe_rx_doorbell *rx_db ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;

  {
#line 355
  rport = rdata->rport;
#line 356
  interface = (struct bnx2fc_interface *)port->priv;
#line 357
  hba = interface->hba;
#line 358
  sq_db = & tgt->sq_db;
#line 359
  rx_db = & tgt->rx_db;
#line 361
  tgt->rport = rport;
#line 362
  tgt->rdata = rdata;
#line 363
  tgt->port = port;
#line 365
  if (hba->num_ofld_sess > 1023) {
#line 366
    BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "exceeded max sessions. logoff this tgt\n");
#line 367
    tgt->fcoe_conn_id = 4294967295U;
#line 368
    return (-1);
  } else {

  }
#line 371
  tgt->fcoe_conn_id = bnx2fc_alloc_conn_id(hba, tgt);
#line 372
  if (tgt->fcoe_conn_id == 4294967295U) {
#line 373
    return (-1);
  } else {

  }
#line 375
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "init_tgt - conn_id = 0x%x\n",
                 tgt->fcoe_conn_id);
#line 377
  tgt->max_sqes = 256U;
#line 378
  tgt->max_rqes = 16U;
#line 379
  tgt->max_cqes = 272U;
#line 380
  atomic_set(& tgt->free_sqes, 256);
#line 383
  tgt->sq_curr_toggle_bit = 1U;
#line 384
  tgt->cq_curr_toggle_bit = 1U;
#line 385
  tgt->sq_prod_idx = 0U;
#line 386
  tgt->cq_cons_idx = 0U;
#line 387
  tgt->rq_prod_idx = 32768U;
#line 388
  tgt->rq_cons_idx = 0U;
#line 389
  atomic_set(& tgt->num_active_ios, 0);
#line 390
  tgt->retry_delay_timestamp = 0UL;
#line 392
  if ((((int )rdata->flags & 2) != 0 && (int )rdata->ids.roles & 1) && (rdata->ids.roles & 2U) == 0U) {
#line 395
    tgt->dev_type = 1;
#line 396
    tgt->io_timeout = 0U;
  } else {
#line 398
    tgt->dev_type = 0;
#line 399
    tgt->io_timeout = 20000U;
  }
#line 403
  sq_db->header.header = 2U;
#line 404
  sq_db->header.header = (u8 )((unsigned int )sq_db->header.header | 64U);
#line 407
  rx_db->hdr.header = 67U;
#line 411
  rx_db->params = 98U;
#line 414
  spinlock_check(& tgt->tgt_lock);
#line 414
  __raw_spin_lock_init(& tgt->tgt_lock.__annonCompField18.rlock, "&(&tgt->tgt_lock)->rlock",
                       & __key);
#line 415
  spinlock_check(& tgt->cq_lock);
#line 415
  __raw_spin_lock_init(& tgt->cq_lock.__annonCompField18.rlock, "&(&tgt->cq_lock)->rlock",
                       & __key___0);
#line 418
  INIT_LIST_HEAD(& tgt->active_cmd_queue);
#line 421
  INIT_LIST_HEAD(& tgt->io_retire_queue);
#line 423
  INIT_LIST_HEAD(& tgt->els_queue);
#line 426
  INIT_LIST_HEAD(& tgt->active_tm_queue);
#line 428
  __init_waitqueue_head(& tgt->ofld_wait, "&tgt->ofld_wait", & __key___1);
#line 429
  __init_waitqueue_head(& tgt->upld_wait, "&tgt->upld_wait", & __key___2);
#line 431
  return (0);
}
}
#line 439 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c"
void bnx2fc_rport_event_handler(struct fc_lport *lport , struct fc_rport_priv *rdata ,
                                enum fc_rport_event event ) 
{ 
  struct fcoe_port *port ;
  void *tmp ;
  struct bnx2fc_interface *interface ;
  struct bnx2fc_hba *hba ;
  struct fc_rport *rport ;
  struct fc_rport_libfc_priv *rp ;
  struct bnx2fc_rport *tgt ;
  u32 port_id ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 443
  tmp = lport_priv((struct fc_lport  const  *)lport);
#line 443
  port = (struct fcoe_port *)tmp;
#line 444
  interface = (struct bnx2fc_interface *)port->priv;
#line 445
  hba = interface->hba;
#line 446
  rport = rdata->rport;
#line 451
  BNX2FC_HBA_DBG((struct fc_lport  const  *)lport, "rport_event_hdlr: event = %d, port_id = 0x%x\n",
                 (unsigned int )event, rdata->ids.port_id);
#line 453
  switch ((unsigned int )event) {
  case 1U: ;
#line 455
  if ((unsigned long )rport == (unsigned long )((struct fc_rport *)0)) {
#line 456
    printk("\vbnx2fc: rport is NULL: OLD_ERROR!\n");
#line 457
    goto ldv_54747;
  } else {

  }
#line 460
  rp = (struct fc_rport_libfc_priv *)rport->dd_data;
#line 461
  if (rport->port_id == 16777212U) {
#line 468
    printk("\vbnx2fc: %x - rport_event_handler OLD_ERROR\n", rdata->ids.port_id);
#line 470
    goto ldv_54747;
  } else {

  }
#line 473
  if ((unsigned int )rdata->spp_type != 8U) {
#line 474
    BNX2FC_HBA_DBG((struct fc_lport  const  *)lport, "not FCP type target. not offloading\n");
#line 476
    goto ldv_54747;
  } else {

  }
#line 478
  if ((rdata->ids.roles & 1U) == 0U) {
#line 479
    BNX2FC_HBA_DBG((struct fc_lport  const  *)lport, "not FCP_TARGET not offloading\n");
#line 481
    goto ldv_54747;
  } else {

  }
#line 488
  mutex_lock_nested(& hba->hba_mutex, 0U);
#line 489
  tgt = (struct bnx2fc_rport *)rp + 1U;
#line 492
  tmp___0 = constant_test_bit(10L, (unsigned long const volatile   *)(& tgt->flags));
#line 492
  if (tmp___0 != 0) {
#line 493
    BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "already offloaded\n");
#line 494
    mutex_unlock(& hba->hba_mutex);
#line 495
    return;
  } else {

  }
#line 502
  bnx2fc_offload_session(port, tgt, rdata);
#line 504
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "OFFLOAD num_ofld_sess = %d\n",
                 hba->num_ofld_sess);
#line 507
  tmp___1 = constant_test_bit(10L, (unsigned long const volatile   *)(& tgt->flags));
#line 507
  if (tmp___1 != 0) {
#line 509
    BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "sess offloaded\n");
#line 511
    hba->num_ofld_sess = hba->num_ofld_sess + 1;
#line 513
    set_bit(1L, (unsigned long volatile   *)(& tgt->flags));
  } else {
#line 520
    BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "Port is being logged off as offloaded flag not set\n");
  }
#line 523
  mutex_unlock(& hba->hba_mutex);
#line 524
  goto ldv_54747;
  case 4U: ;
  case 2U: ;
  case 3U: 
#line 528
  port_id = rdata->ids.port_id;
#line 529
  if (port_id == 16777212U) {
#line 530
    goto ldv_54747;
  } else {

  }
#line 532
  if ((unsigned long )rport == (unsigned long )((struct fc_rport *)0)) {
#line 533
    printk("\016bnx2fc: %x - rport not created Yet!!\n", port_id);
#line 535
    goto ldv_54747;
  } else {

  }
#line 537
  rp = (struct fc_rport_libfc_priv *)rport->dd_data;
#line 538
  mutex_lock_nested(& hba->hba_mutex, 0U);
#line 543
  tgt = (struct bnx2fc_rport *)rp + 1U;
#line 545
  tmp___2 = constant_test_bit(10L, (unsigned long const volatile   *)(& tgt->flags));
#line 545
  if (tmp___2 == 0) {
#line 546
    mutex_unlock(& hba->hba_mutex);
#line 547
    goto ldv_54747;
  } else {

  }
#line 549
  clear_bit(1L, (unsigned long volatile   *)(& tgt->flags));
#line 551
  bnx2fc_upload_session(port, tgt);
#line 552
  hba->num_ofld_sess = hba->num_ofld_sess - 1;
#line 553
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "UPLOAD num_ofld_sess = %d\n",
                 hba->num_ofld_sess);
#line 559
  if (hba->wait_for_link_down != 0 && hba->num_ofld_sess == 0) {
#line 561
    __wake_up(& hba->shutdown_wait, 1U, 1, (void *)0);
  } else {

  }
#line 563
  tmp___3 = constant_test_bit(8L, (unsigned long const volatile   *)(& tgt->flags));
#line 563
  if (tmp___3 != 0) {
#line 564
    printk("\vbnx2fc: Relogin to the tgt\n");
#line 565
    mutex_lock_nested(& lport->disc.disc_mutex, 0U);
#line 566
    (*(lport->tt.rport_login))(rdata);
#line 567
    mutex_unlock(& lport->disc.disc_mutex);
  } else {

  }
#line 569
  mutex_unlock(& hba->hba_mutex);
#line 571
  goto ldv_54747;
  case 0U: ;
#line 574
  goto ldv_54747;
  }
  ldv_54747: ;
#line 577
  return;
}
}
#line 584 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c"
struct bnx2fc_rport *bnx2fc_tgt_lookup(struct fcoe_port *port , u32 port_id ) 
{ 
  struct bnx2fc_interface *interface ;
  struct bnx2fc_hba *hba ;
  struct bnx2fc_rport *tgt ;
  struct fc_rport_priv *rdata ;
  int i ;

  {
#line 587
  interface = (struct bnx2fc_interface *)port->priv;
#line 588
  hba = interface->hba;
#line 593
  i = 0;
#line 593
  goto ldv_54762;
  ldv_54761: 
#line 594
  tgt = *(hba->tgt_ofld_list + (unsigned long )i);
#line 595
  if ((unsigned long )tgt != (unsigned long )((struct bnx2fc_rport *)0) && (unsigned long )tgt->port == (unsigned long )port) {
#line 596
    rdata = tgt->rdata;
#line 597
    if (rdata->ids.port_id == port_id) {
#line 598
      if ((unsigned int )rdata->rp_state != 8U) {
#line 599
        BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "rport obtained\n");
#line 601
        return (tgt);
      } else {
#line 603
        BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "rport 0x%x is in DELETED state\n",
                       rdata->ids.port_id);
#line 606
        return ((struct bnx2fc_rport *)0);
      }
    } else {

    }
  } else {

  }
#line 593
  i = i + 1;
  ldv_54762: ;
#line 593
  if (i <= 1023) {
#line 595
    goto ldv_54761;
  } else {

  }

#line 611
  return ((struct bnx2fc_rport *)0);
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c"
static u32 bnx2fc_alloc_conn_id(struct bnx2fc_hba *hba , struct bnx2fc_rport *tgt ) 
{ 
  u32 conn_id ;
  u32 next ;
  u32 tmp ;

  {
#line 634
  spin_lock_bh(& hba->hba_lock);
#line 635
  next = hba->next_conn_id;
#line 636
  tmp = hba->next_conn_id;
#line 636
  hba->next_conn_id = hba->next_conn_id + 1U;
#line 636
  conn_id = tmp;
#line 637
  if (hba->next_conn_id == 1024U) {
#line 638
    hba->next_conn_id = 0U;
  } else {

  }
#line 640
  goto ldv_54771;
  ldv_54770: 
#line 641
  conn_id = conn_id + 1U;
#line 642
  if (conn_id == 1024U) {
#line 643
    conn_id = 0U;
  } else {

  }
#line 645
  if (conn_id == next) {
#line 647
    spin_unlock_bh(& hba->hba_lock);
#line 648
    return (4294967295U);
  } else {

  }
  ldv_54771: ;
#line 640
  if ((unsigned long )*(hba->tgt_ofld_list + (unsigned long )conn_id) != (unsigned long )((struct bnx2fc_rport *)0)) {
#line 642
    goto ldv_54770;
  } else {

  }
#line 651
  *(hba->tgt_ofld_list + (unsigned long )conn_id) = tgt;
#line 652
  tgt->fcoe_conn_id = conn_id;
#line 653
  spin_unlock_bh(& hba->hba_lock);
#line 654
  return (conn_id);
}
}
#line 657 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c"
static void bnx2fc_free_conn_id(struct bnx2fc_hba *hba , u32 conn_id ) 
{ 


  {
#line 660
  spin_lock_bh(& hba->hba_lock);
#line 661
  *(hba->tgt_ofld_list + (unsigned long )conn_id) = (struct bnx2fc_rport *)0;
#line 662
  spin_unlock_bh(& hba->hba_lock);
#line 663
  return;
}
}
#line 669 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c"
static int bnx2fc_alloc_session_resc(struct bnx2fc_hba *hba , struct bnx2fc_rport *tgt ) 
{ 
  dma_addr_t page ;
  int num_pages ;
  u32 *pbl ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 677
  tgt->sq_mem_size = tgt->max_sqes * 2U;
#line 678
  tgt->sq_mem_size = (tgt->sq_mem_size + 4095U) & 4294963200U;
#line 681
  tmp = dma_alloc_attrs(& (hba->pcidev)->dev, (size_t )tgt->sq_mem_size, & tgt->sq_dma,
                        208U, (struct dma_attrs *)0);
#line 681
  tgt->sq = (struct fcoe_sqe *)tmp;
#line 683
  if ((unsigned long )tgt->sq == (unsigned long )((struct fcoe_sqe *)0)) {
#line 684
    printk("\vbnx2fc: unable to allocate SQ memory %d\n", tgt->sq_mem_size);
#line 686
    goto mem_alloc_failure;
  } else {

  }
#line 688
  memset((void *)tgt->sq, 0, (size_t )tgt->sq_mem_size);
#line 691
  tgt->cq_mem_size = tgt->max_cqes * 2U;
#line 692
  tgt->cq_mem_size = (tgt->cq_mem_size + 4095U) & 4294963200U;
#line 695
  tmp___0 = dma_alloc_attrs(& (hba->pcidev)->dev, (size_t )tgt->cq_mem_size, & tgt->cq_dma,
                            208U, (struct dma_attrs *)0);
#line 695
  tgt->cq = (struct fcoe_cqe *)tmp___0;
#line 697
  if ((unsigned long )tgt->cq == (unsigned long )((struct fcoe_cqe *)0)) {
#line 698
    printk("\vbnx2fc: unable to allocate CQ memory %d\n", tgt->cq_mem_size);
#line 700
    goto mem_alloc_failure;
  } else {

  }
#line 702
  memset((void *)tgt->cq, 0, (size_t )tgt->cq_mem_size);
#line 705
  tgt->rq_mem_size = tgt->max_rqes * 256U;
#line 706
  tgt->rq_mem_size = (tgt->rq_mem_size + 4095U) & 4294963200U;
#line 709
  tgt->rq = dma_alloc_attrs(& (hba->pcidev)->dev, (size_t )tgt->rq_mem_size, & tgt->rq_dma,
                            208U, (struct dma_attrs *)0);
#line 711
  if ((unsigned long )tgt->rq == (unsigned long )((void *)0)) {
#line 712
    printk("\vbnx2fc: unable to allocate RQ memory %d\n", tgt->rq_mem_size);
#line 714
    goto mem_alloc_failure;
  } else {

  }
#line 716
  memset(tgt->rq, 0, (size_t )tgt->rq_mem_size);
#line 718
  tgt->rq_pbl_size = (tgt->rq_mem_size / 4096U) * 8U;
#line 719
  tgt->rq_pbl_size = (tgt->rq_pbl_size + 4095U) & 4294963200U;
#line 722
  tgt->rq_pbl = dma_alloc_attrs(& (hba->pcidev)->dev, (size_t )tgt->rq_pbl_size, & tgt->rq_pbl_dma,
                                208U, (struct dma_attrs *)0);
#line 724
  if ((unsigned long )tgt->rq_pbl == (unsigned long )((void *)0)) {
#line 725
    printk("\vbnx2fc: unable to allocate RQ PBL %d\n", tgt->rq_pbl_size);
#line 727
    goto mem_alloc_failure;
  } else {

  }
#line 730
  memset(tgt->rq_pbl, 0, (size_t )tgt->rq_pbl_size);
#line 731
  num_pages = (int )(tgt->rq_mem_size / 4096U);
#line 732
  page = tgt->rq_dma;
#line 733
  pbl = (u32 *)tgt->rq_pbl;
#line 735
  goto ldv_54786;
  ldv_54785: 
#line 736
  *pbl = (unsigned int )page;
#line 737
  pbl = pbl + 1;
#line 738
  *pbl = (unsigned int )(page >> 32);
#line 739
  pbl = pbl + 1;
#line 740
  page = page + 4096ULL;
  ldv_54786: 
#line 735
  tmp___1 = num_pages;
#line 735
  num_pages = num_pages - 1;
#line 735
  if (tmp___1 != 0) {
#line 737
    goto ldv_54785;
  } else {

  }
#line 744
  tgt->xferq_mem_size = tgt->max_sqes * 2U;
#line 745
  tgt->xferq_mem_size = (tgt->xferq_mem_size + 4095U) & 4294963200U;
#line 748
  tmp___2 = dma_alloc_attrs(& (hba->pcidev)->dev, (size_t )tgt->xferq_mem_size, & tgt->xferq_dma,
                            208U, (struct dma_attrs *)0);
#line 748
  tgt->xferq = (struct fcoe_xfrqe *)tmp___2;
#line 750
  if ((unsigned long )tgt->xferq == (unsigned long )((struct fcoe_xfrqe *)0)) {
#line 751
    printk("\vbnx2fc: unable to allocate XFERQ %d\n", tgt->xferq_mem_size);
#line 753
    goto mem_alloc_failure;
  } else {

  }
#line 755
  memset((void *)tgt->xferq, 0, (size_t )tgt->xferq_mem_size);
#line 758
  tgt->confq_mem_size = tgt->max_sqes * 8U;
#line 759
  tgt->confq_mem_size = (tgt->confq_mem_size + 4095U) & 4294963200U;
#line 762
  tmp___3 = dma_alloc_attrs(& (hba->pcidev)->dev, (size_t )tgt->confq_mem_size, & tgt->confq_dma,
                            208U, (struct dma_attrs *)0);
#line 762
  tgt->confq = (struct fcoe_confqe *)tmp___3;
#line 764
  if ((unsigned long )tgt->confq == (unsigned long )((struct fcoe_confqe *)0)) {
#line 765
    printk("\vbnx2fc: unable to allocate CONFQ %d\n", tgt->confq_mem_size);
#line 767
    goto mem_alloc_failure;
  } else {

  }
#line 769
  memset((void *)tgt->confq, 0, (size_t )tgt->confq_mem_size);
#line 771
  tgt->confq_pbl_size = (tgt->confq_mem_size / 4096U) * 8U;
#line 773
  tgt->confq_pbl_size = (tgt->confq_pbl_size + 4095U) & 4294963200U;
#line 776
  tgt->confq_pbl = dma_alloc_attrs(& (hba->pcidev)->dev, (size_t )tgt->confq_pbl_size,
                                   & tgt->confq_pbl_dma, 208U, (struct dma_attrs *)0);
#line 779
  if ((unsigned long )tgt->confq_pbl == (unsigned long )((void *)0)) {
#line 780
    printk("\vbnx2fc: unable to allocate CONFQ PBL %d\n", tgt->confq_pbl_size);
#line 782
    goto mem_alloc_failure;
  } else {

  }
#line 785
  memset(tgt->confq_pbl, 0, (size_t )tgt->confq_pbl_size);
#line 786
  num_pages = (int )(tgt->confq_mem_size / 4096U);
#line 787
  page = tgt->confq_dma;
#line 788
  pbl = (u32 *)tgt->confq_pbl;
#line 790
  goto ldv_54789;
  ldv_54788: 
#line 791
  *pbl = (unsigned int )page;
#line 792
  pbl = pbl + 1;
#line 793
  *pbl = (unsigned int )(page >> 32);
#line 794
  pbl = pbl + 1;
#line 795
  page = page + 4096ULL;
  ldv_54789: 
#line 790
  tmp___4 = num_pages;
#line 790
  num_pages = num_pages - 1;
#line 790
  if (tmp___4 != 0) {
#line 792
    goto ldv_54788;
  } else {

  }
#line 799
  tgt->conn_db_mem_size = 16U;
#line 801
  tmp___5 = dma_alloc_attrs(& (hba->pcidev)->dev, (size_t )tgt->conn_db_mem_size,
                            & tgt->conn_db_dma, 208U, (struct dma_attrs *)0);
#line 801
  tgt->conn_db = (struct fcoe_conn_db *)tmp___5;
#line 804
  if ((unsigned long )tgt->conn_db == (unsigned long )((struct fcoe_conn_db *)0)) {
#line 805
    printk("\vbnx2fc: unable to allocate conn_db %d\n", tgt->conn_db_mem_size);
#line 807
    goto mem_alloc_failure;
  } else {

  }
#line 809
  memset((void *)tgt->conn_db, 0, (size_t )tgt->conn_db_mem_size);
#line 813
  tgt->lcq_mem_size = (tgt->max_sqes + 8U) * 2U;
#line 814
  tgt->lcq_mem_size = (tgt->lcq_mem_size + 4095U) & 4294963200U;
#line 817
  tmp___6 = dma_alloc_attrs(& (hba->pcidev)->dev, (size_t )tgt->lcq_mem_size, & tgt->lcq_dma,
                            208U, (struct dma_attrs *)0);
#line 817
  tgt->lcq = (struct fcoe_sqe *)tmp___6;
#line 820
  if ((unsigned long )tgt->lcq == (unsigned long )((struct fcoe_sqe *)0)) {
#line 821
    printk("\vbnx2fc: unable to allocate lcq %d\n", tgt->lcq_mem_size);
#line 823
    goto mem_alloc_failure;
  } else {

  }
#line 825
  memset((void *)tgt->lcq, 0, (size_t )tgt->lcq_mem_size);
#line 827
  (tgt->conn_db)->rq_prod = 32768U;
#line 829
  return (0);
  mem_alloc_failure: ;
#line 832
  return (-12);
}
}
#line 843 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.c"
static void bnx2fc_free_session_resc(struct bnx2fc_hba *hba , struct bnx2fc_rport *tgt ) 
{ 
  void *ctx_base_ptr ;

  {
#line 848
  BNX2FC_TGT_DBG((struct bnx2fc_rport  const  *)tgt, "Freeing up session resources\n");
#line 850
  spin_lock_bh(& tgt->cq_lock);
#line 851
  ctx_base_ptr = tgt->ctx_base;
#line 852
  tgt->ctx_base = (void *)0;
#line 855
  if ((unsigned long )tgt->lcq != (unsigned long )((struct fcoe_sqe *)0)) {
#line 856
    dma_free_attrs(& (hba->pcidev)->dev, (size_t )tgt->lcq_mem_size, (void *)tgt->lcq,
                   tgt->lcq_dma, (struct dma_attrs *)0);
#line 858
    tgt->lcq = (struct fcoe_sqe *)0;
  } else {

  }
#line 861
  if ((unsigned long )tgt->conn_db != (unsigned long )((struct fcoe_conn_db *)0)) {
#line 862
    dma_free_attrs(& (hba->pcidev)->dev, (size_t )tgt->conn_db_mem_size, (void *)tgt->conn_db,
                   tgt->conn_db_dma, (struct dma_attrs *)0);
#line 864
    tgt->conn_db = (struct fcoe_conn_db *)0;
  } else {

  }
#line 867
  if ((unsigned long )tgt->confq_pbl != (unsigned long )((void *)0)) {
#line 868
    dma_free_attrs(& (hba->pcidev)->dev, (size_t )tgt->confq_pbl_size, tgt->confq_pbl,
                   tgt->confq_pbl_dma, (struct dma_attrs *)0);
#line 870
    tgt->confq_pbl = (void *)0;
  } else {

  }
#line 872
  if ((unsigned long )tgt->confq != (unsigned long )((struct fcoe_confqe *)0)) {
#line 873
    dma_free_attrs(& (hba->pcidev)->dev, (size_t )tgt->confq_mem_size, (void *)tgt->confq,
                   tgt->confq_dma, (struct dma_attrs *)0);
#line 875
    tgt->confq = (struct fcoe_confqe *)0;
  } else {

  }
#line 878
  if ((unsigned long )tgt->xferq != (unsigned long )((struct fcoe_xfrqe *)0)) {
#line 879
    dma_free_attrs(& (hba->pcidev)->dev, (size_t )tgt->xferq_mem_size, (void *)tgt->xferq,
                   tgt->xferq_dma, (struct dma_attrs *)0);
#line 881
    tgt->xferq = (struct fcoe_xfrqe *)0;
  } else {

  }
#line 884
  if ((unsigned long )tgt->rq_pbl != (unsigned long )((void *)0)) {
#line 885
    dma_free_attrs(& (hba->pcidev)->dev, (size_t )tgt->rq_pbl_size, tgt->rq_pbl, tgt->rq_pbl_dma,
                   (struct dma_attrs *)0);
#line 887
    tgt->rq_pbl = (void *)0;
  } else {

  }
#line 889
  if ((unsigned long )tgt->rq != (unsigned long )((void *)0)) {
#line 890
    dma_free_attrs(& (hba->pcidev)->dev, (size_t )tgt->rq_mem_size, tgt->rq, tgt->rq_dma,
                   (struct dma_attrs *)0);
#line 892
    tgt->rq = (void *)0;
  } else {

  }
#line 895
  if ((unsigned long )tgt->cq != (unsigned long )((struct fcoe_cqe *)0)) {
#line 896
    dma_free_attrs(& (hba->pcidev)->dev, (size_t )tgt->cq_mem_size, (void *)tgt->cq,
                   tgt->cq_dma, (struct dma_attrs *)0);
#line 898
    tgt->cq = (struct fcoe_cqe *)0;
  } else {

  }
#line 901
  if ((unsigned long )tgt->sq != (unsigned long )((struct fcoe_sqe *)0)) {
#line 902
    dma_free_attrs(& (hba->pcidev)->dev, (size_t )tgt->sq_mem_size, (void *)tgt->sq,
                   tgt->sq_dma, (struct dma_attrs *)0);
#line 904
    tgt->sq = (struct fcoe_sqe *)0;
  } else {

  }
#line 906
  spin_unlock_bh(& tgt->cq_lock);
#line 908
  if ((unsigned long )ctx_base_ptr != (unsigned long )((void *)0)) {
#line 909
    iounmap((void volatile   *)ctx_base_ptr);
  } else {

  }
#line 910
  return;
}
}
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
void activate_suitable_timer_6(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 155
  if (ldv_timer_6_0 == 0 || ldv_timer_6_0 == 2) {
#line 156
    ldv_timer_list_6_0 = timer;
#line 157
    ldv_timer_list_6_0->data = data;
#line 158
    ldv_timer_6_0 = 1;
#line 159
    return;
  } else {

  }
#line 161
  if (ldv_timer_6_1 == 0 || ldv_timer_6_1 == 2) {
#line 162
    ldv_timer_list_6_1 = timer;
#line 163
    ldv_timer_list_6_1->data = data;
#line 164
    ldv_timer_6_1 = 1;
#line 165
    return;
  } else {

  }
#line 167
  if (ldv_timer_6_2 == 0 || ldv_timer_6_2 == 2) {
#line 168
    ldv_timer_list_6_2 = timer;
#line 169
    ldv_timer_list_6_2->data = data;
#line 170
    ldv_timer_6_2 = 1;
#line 171
    return;
  } else {

  }
#line 173
  if (ldv_timer_6_3 == 0 || ldv_timer_6_3 == 2) {
#line 174
    ldv_timer_list_6_3 = timer;
#line 175
    ldv_timer_list_6_3->data = data;
#line 176
    ldv_timer_6_3 = 1;
#line 177
    return;
  } else {

  }
#line 179
  return;
}
}
#line 183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
void ldv_timer_5(int state , struct timer_list *timer ) 
{ 


  {
#line 184
  LDV_IN_INTERRUPT = 2;
#line 185
  bnx2fc_ofld_timer(timer->data);
#line 186
  LDV_IN_INTERRUPT = 1;
#line 187
  return;
}
}
#line 190 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
void choose_timer_5(void) 
{ 
  int tmp ;

  {
#line 191
  tmp = __VERIFIER_nondet_int();
#line 191
  switch (tmp) {
  case 0: ;
#line 193
  if (ldv_timer_5_0 == 1) {
#line 194
    ldv_timer_5_0 = 2;
#line 195
    ldv_timer_5(ldv_timer_5_0, ldv_timer_list_5_0);
  } else {

  }
#line 198
  goto ldv_54808;
  case 1: ;
#line 200
  if (ldv_timer_5_1 == 1) {
#line 201
    ldv_timer_5_1 = 2;
#line 202
    ldv_timer_5(ldv_timer_5_1, ldv_timer_list_5_1);
  } else {

  }
#line 205
  goto ldv_54808;
  case 2: ;
#line 207
  if (ldv_timer_5_2 == 1) {
#line 208
    ldv_timer_5_2 = 2;
#line 209
    ldv_timer_5(ldv_timer_5_2, ldv_timer_list_5_2);
  } else {

  }
#line 212
  goto ldv_54808;
  case 3: ;
#line 214
  if (ldv_timer_5_3 == 1) {
#line 215
    ldv_timer_5_3 = 2;
#line 216
    ldv_timer_5(ldv_timer_5_3, ldv_timer_list_5_3);
  } else {

  }
#line 219
  goto ldv_54808;
  default: 
#line 220
  ldv_stop();
  }
  ldv_54808: ;
#line 222
  return;
}
}
#line 226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
void timer_init_6(void) 
{ 


  {
#line 227
  ldv_timer_6_0 = 0;
#line 228
  ldv_timer_6_1 = 0;
#line 229
  ldv_timer_6_2 = 0;
#line 230
  ldv_timer_6_3 = 0;
#line 231
  return;
}
}
#line 234 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
void timer_init_5(void) 
{ 


  {
#line 235
  ldv_timer_5_0 = 0;
#line 236
  ldv_timer_5_1 = 0;
#line 237
  ldv_timer_5_2 = 0;
#line 238
  ldv_timer_5_3 = 0;
#line 239
  return;
}
}
#line 242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
void disable_suitable_timer_6(struct timer_list *timer ) 
{ 


  {
#line 243
  if (ldv_timer_6_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_0) {
#line 244
    ldv_timer_6_0 = 0;
#line 245
    return;
  } else {

  }
#line 247
  if (ldv_timer_6_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_1) {
#line 248
    ldv_timer_6_1 = 0;
#line 249
    return;
  } else {

  }
#line 251
  if (ldv_timer_6_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_2) {
#line 252
    ldv_timer_6_2 = 0;
#line 253
    return;
  } else {

  }
#line 255
  if (ldv_timer_6_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_6_3) {
#line 256
    ldv_timer_6_3 = 0;
#line 257
    return;
  } else {

  }
#line 259
  return;
}
}
#line 263 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
void disable_suitable_timer_5(struct timer_list *timer ) 
{ 


  {
#line 264
  if (ldv_timer_5_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_0) {
#line 265
    ldv_timer_5_0 = 0;
#line 266
    return;
  } else {

  }
#line 268
  if (ldv_timer_5_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_1) {
#line 269
    ldv_timer_5_1 = 0;
#line 270
    return;
  } else {

  }
#line 272
  if (ldv_timer_5_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_2) {
#line 273
    ldv_timer_5_2 = 0;
#line 274
    return;
  } else {

  }
#line 276
  if (ldv_timer_5_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_5_3) {
#line 277
    ldv_timer_5_3 = 0;
#line 278
    return;
  } else {

  }
#line 280
  return;
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
void activate_pending_timer_6(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 285
  if ((unsigned long )ldv_timer_list_6_0 == (unsigned long )timer) {
#line 286
    if (ldv_timer_6_0 == 2 || pending_flag != 0) {
#line 287
      ldv_timer_list_6_0 = timer;
#line 288
      ldv_timer_list_6_0->data = data;
#line 289
      ldv_timer_6_0 = 1;
    } else {

    }
#line 291
    return;
  } else {

  }
#line 294
  if ((unsigned long )ldv_timer_list_6_1 == (unsigned long )timer) {
#line 295
    if (ldv_timer_6_1 == 2 || pending_flag != 0) {
#line 296
      ldv_timer_list_6_1 = timer;
#line 297
      ldv_timer_list_6_1->data = data;
#line 298
      ldv_timer_6_1 = 1;
    } else {

    }
#line 300
    return;
  } else {

  }
#line 303
  if ((unsigned long )ldv_timer_list_6_2 == (unsigned long )timer) {
#line 304
    if (ldv_timer_6_2 == 2 || pending_flag != 0) {
#line 305
      ldv_timer_list_6_2 = timer;
#line 306
      ldv_timer_list_6_2->data = data;
#line 307
      ldv_timer_6_2 = 1;
    } else {

    }
#line 309
    return;
  } else {

  }
#line 312
  if ((unsigned long )ldv_timer_list_6_3 == (unsigned long )timer) {
#line 313
    if (ldv_timer_6_3 == 2 || pending_flag != 0) {
#line 314
      ldv_timer_list_6_3 = timer;
#line 315
      ldv_timer_list_6_3->data = data;
#line 316
      ldv_timer_6_3 = 1;
    } else {

    }
#line 318
    return;
  } else {

  }
#line 320
  activate_suitable_timer_6(timer, data);
#line 321
  return;
}
}
#line 324 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
void choose_timer_6(void) 
{ 
  int tmp ;

  {
#line 325
  tmp = __VERIFIER_nondet_int();
#line 325
  switch (tmp) {
  case 0: ;
#line 327
  if (ldv_timer_6_0 == 1) {
#line 328
    ldv_timer_6_0 = 2;
#line 329
    ldv_timer_6(ldv_timer_6_0, ldv_timer_list_6_0);
  } else {

  }
#line 332
  goto ldv_54834;
  case 1: ;
#line 334
  if (ldv_timer_6_1 == 1) {
#line 335
    ldv_timer_6_1 = 2;
#line 336
    ldv_timer_6(ldv_timer_6_1, ldv_timer_list_6_1);
  } else {

  }
#line 339
  goto ldv_54834;
  case 2: ;
#line 341
  if (ldv_timer_6_2 == 1) {
#line 342
    ldv_timer_6_2 = 2;
#line 343
    ldv_timer_6(ldv_timer_6_2, ldv_timer_list_6_2);
  } else {

  }
#line 346
  goto ldv_54834;
  case 3: ;
#line 348
  if (ldv_timer_6_3 == 1) {
#line 349
    ldv_timer_6_3 = 2;
#line 350
    ldv_timer_6(ldv_timer_6_3, ldv_timer_list_6_3);
  } else {

  }
#line 353
  goto ldv_54834;
  default: 
#line 354
  ldv_stop();
  }
  ldv_54834: ;
#line 356
  return;
}
}
#line 360 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
int reg_timer_6(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 361
  if ((unsigned long )function == (unsigned long )(& bnx2fc_upld_timer)) {
#line 362
    activate_suitable_timer_6(timer, data);
  } else {

  }
#line 363
  return (0);
}
}
#line 367 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
void ldv_timer_6(int state , struct timer_list *timer ) 
{ 


  {
#line 368
  LDV_IN_INTERRUPT = 2;
#line 369
  bnx2fc_upld_timer(timer->data);
#line 370
  LDV_IN_INTERRUPT = 1;
#line 371
  return;
}
}
#line 374 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
void activate_pending_timer_5(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
#line 375
  if ((unsigned long )ldv_timer_list_5_0 == (unsigned long )timer) {
#line 376
    if (ldv_timer_5_0 == 2 || pending_flag != 0) {
#line 377
      ldv_timer_list_5_0 = timer;
#line 378
      ldv_timer_list_5_0->data = data;
#line 379
      ldv_timer_5_0 = 1;
    } else {

    }
#line 381
    return;
  } else {

  }
#line 384
  if ((unsigned long )ldv_timer_list_5_1 == (unsigned long )timer) {
#line 385
    if (ldv_timer_5_1 == 2 || pending_flag != 0) {
#line 386
      ldv_timer_list_5_1 = timer;
#line 387
      ldv_timer_list_5_1->data = data;
#line 388
      ldv_timer_5_1 = 1;
    } else {

    }
#line 390
    return;
  } else {

  }
#line 393
  if ((unsigned long )ldv_timer_list_5_2 == (unsigned long )timer) {
#line 394
    if (ldv_timer_5_2 == 2 || pending_flag != 0) {
#line 395
      ldv_timer_list_5_2 = timer;
#line 396
      ldv_timer_list_5_2->data = data;
#line 397
      ldv_timer_5_2 = 1;
    } else {

    }
#line 399
    return;
  } else {

  }
#line 402
  if ((unsigned long )ldv_timer_list_5_3 == (unsigned long )timer) {
#line 403
    if (ldv_timer_5_3 == 2 || pending_flag != 0) {
#line 404
      ldv_timer_list_5_3 = timer;
#line 405
      ldv_timer_list_5_3->data = data;
#line 406
      ldv_timer_5_3 = 1;
    } else {

    }
#line 408
    return;
  } else {

  }
#line 410
  activate_suitable_timer_5(timer, data);
#line 411
  return;
}
}
#line 414 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
int reg_timer_5(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 415
  if ((unsigned long )function == (unsigned long )(& bnx2fc_ofld_timer)) {
#line 416
    activate_suitable_timer_5(timer, data);
  } else {

  }
#line 417
  return (0);
}
}
#line 421 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
void activate_suitable_timer_5(struct timer_list *timer , unsigned long data ) 
{ 


  {
#line 422
  if (ldv_timer_5_0 == 0 || ldv_timer_5_0 == 2) {
#line 423
    ldv_timer_list_5_0 = timer;
#line 424
    ldv_timer_list_5_0->data = data;
#line 425
    ldv_timer_5_0 = 1;
#line 426
    return;
  } else {

  }
#line 428
  if (ldv_timer_5_1 == 0 || ldv_timer_5_1 == 2) {
#line 429
    ldv_timer_list_5_1 = timer;
#line 430
    ldv_timer_list_5_1->data = data;
#line 431
    ldv_timer_5_1 = 1;
#line 432
    return;
  } else {

  }
#line 434
  if (ldv_timer_5_2 == 0 || ldv_timer_5_2 == 2) {
#line 435
    ldv_timer_list_5_2 = timer;
#line 436
    ldv_timer_list_5_2->data = data;
#line 437
    ldv_timer_5_2 = 1;
#line 438
    return;
  } else {

  }
#line 440
  if (ldv_timer_5_3 == 0 || ldv_timer_5_3 == 2) {
#line 441
    ldv_timer_list_5_3 = timer;
#line 442
    ldv_timer_list_5_3->data = data;
#line 443
    ldv_timer_5_3 = 1;
#line 444
    return;
  } else {

  }
#line 446
  return;
}
}
#line 473 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
bool ldv_queue_work_on_116(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 477
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 477
  ldv_func_res = tmp;
#line 479
  activate_work_2(ldv_func_arg3, 2);
#line 481
  return (ldv_func_res);
}
}
#line 484 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
bool ldv_queue_delayed_work_on_117(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 488
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 488
  ldv_func_res = tmp;
#line 490
  activate_work_2(& ldv_func_arg3->work, 2);
#line 492
  return (ldv_func_res);
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
bool ldv_queue_work_on_118(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 499
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 499
  ldv_func_res = tmp;
#line 501
  activate_work_2(ldv_func_arg3, 2);
#line 503
  return (ldv_func_res);
}
}
#line 506 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
void ldv_flush_workqueue_119(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 509
  flush_workqueue(ldv_func_arg1);
#line 511
  call_and_disable_all_2(2);
#line 512
  return;
}
}
#line 514 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
bool ldv_queue_delayed_work_on_120(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 518
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 518
  ldv_func_res = tmp;
#line 520
  activate_work_2(& ldv_func_arg3->work, 2);
#line 522
  return (ldv_func_res);
}
}
#line 525 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
int ldv_scsi_add_host_with_dma_121(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 529
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 529
  ldv_func_res = tmp;
#line 531
  if (ldv_func_res == 0) {
#line 532
    ldv_state_variable_10 = 1;
#line 532
    ldv_initialize_scsi_host_template_10();
  } else {

  }
#line 536
  return (ldv_func_res);
}
}
#line 539 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
struct Scsi_Host *ldv_scsi_host_alloc_122(struct scsi_host_template *sht , int privsize ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  struct Scsi_Host *tmp ;

  {
#line 543
  tmp = scsi_host_alloc(sht, privsize);
#line 543
  ldv_func_res = tmp;
#line 545
  if ((unsigned long )ldv_func_res != (unsigned long )((ldv_func_ret_type___4 )0)) {
#line 546
    ldv_state_variable_10 = 1;
#line 546
    ldv_initialize_scsi_host_template_10();
  } else {

  }
#line 550
  return (ldv_func_res);
}
}
#line 553 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
int ldv_mod_timer_123(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
#line 557
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 557
  ldv_func_res = tmp;
#line 559
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 561
  return (ldv_func_res);
}
}
#line 564 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
int ldv_del_timer_sync_124(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
#line 568
  tmp = del_timer_sync(ldv_func_arg1);
#line 568
  ldv_func_res = tmp;
#line 570
  disable_suitable_timer_6(ldv_func_arg1);
#line 572
  return (ldv_func_res);
}
}
#line 575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
bool ldv_cancel_delayed_work_125(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  bool tmp ;

  {
#line 579
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 579
  ldv_func_res = tmp;
#line 581
  disable_work_2(& ldv_func_arg1->work);
#line 583
  return (ldv_func_res);
}
}
#line 586 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
bool ldv_cancel_delayed_work_126(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  bool tmp ;

  {
#line 590
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 590
  ldv_func_res = tmp;
#line 592
  disable_work_2(& ldv_func_arg1->work);
#line 594
  return (ldv_func_res);
}
}
#line 597 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
bool ldv_cancel_delayed_work_127(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  bool tmp ;

  {
#line 601
  tmp = cancel_delayed_work(ldv_func_arg1);
#line 601
  ldv_func_res = tmp;
#line 603
  disable_work_2(& ldv_func_arg1->work);
#line 605
  return (ldv_func_res);
}
}
#line 608 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
int ldv_mod_timer_128(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
#line 612
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 612
  ldv_func_res = tmp;
#line 614
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
#line 616
  return (ldv_func_res);
}
}
#line 619 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_tgt.o.c.prepared"
int ldv_del_timer_sync_129(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;

  {
#line 623
  tmp = del_timer_sync(ldv_func_arg1);
#line 623
  ldv_func_res = tmp;
#line 625
  disable_suitable_timer_6(ldv_func_arg1);
#line 627
  return (ldv_func_res);
}
}
#line 1 "<compiler builtins>"
void ldv__builtin_va_end(__builtin_va_list * ) ;
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 1
void ldv__builtin_va_start(__builtin_va_list * ) ;
#line 433 "include/linux/workqueue.h"
bool ldv_queue_work_on_148(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 437
bool ldv_queue_work_on_150(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
#line 443
bool ldv_queue_delayed_work_on_149(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 447
bool ldv_queue_delayed_work_on_152(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
void ldv_flush_workqueue_151(struct workqueue_struct *ldv_func_arg1 ) ;
#line 1075 "include/linux/device.h"
extern void dev_printk(char const   * , struct device  const  * , char const   * 
                       , ...) ;
#line 792 "include/scsi/scsi_host.h"
struct Scsi_Host *ldv_scsi_host_alloc_154(struct scsi_host_template *sht , int privsize ) ;
#line 799
int ldv_scsi_add_host_with_dma_153(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
#line 16 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_debug.c"
void BNX2FC_IO_DBG(struct bnx2fc_cmd  const  *io_req , char const   *fmt  , ...) 
{ 
  struct va_format vaf ;
  va_list args ;
  long tmp ;

  {
#line 21
  tmp = ldv__builtin_expect((bnx2fc_debug_level & 1U) == 0U, 1L);
#line 21
  if (tmp != 0L) {
#line 22
    return;
  } else {

  }
#line 24
  ldv__builtin_va_start((va_list *)(& args));
#line 26
  vaf.fmt = fmt;
#line 27
  vaf.va = & args;
#line 29
  if ((((unsigned long )io_req != (unsigned long )((struct bnx2fc_cmd  const  *)0) && (unsigned long )io_req->port != (unsigned long )((struct fcoe_port */* const  */)0)) && (unsigned long )(io_req->port)->lport != (unsigned long )((struct fc_lport *)0)) && (unsigned long )((io_req->port)->lport)->host != (unsigned long )((struct Scsi_Host *)0)) {
#line 31
    dev_printk("\016", (struct device  const  *)(& (((io_req->port)->lport)->host)->shost_gendev),
               "bnx2fc: xid:0x%x %pV", (int )io_req->xid, & vaf);
  } else {
#line 35
    printk("\016bnx2fc: NULL %pV", & vaf);
  }
#line 37
  ldv__builtin_va_end((va_list *)(& args));
#line 38
  return;
}
}
#line 40 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_debug.c"
void BNX2FC_TGT_DBG(struct bnx2fc_rport  const  *tgt , char const   *fmt  , ...) 
{ 
  struct va_format vaf ;
  va_list args ;
  long tmp ;

  {
#line 45
  tmp = ldv__builtin_expect((bnx2fc_debug_level & 2U) == 0U, 1L);
#line 45
  if (tmp != 0L) {
#line 46
    return;
  } else {

  }
#line 48
  ldv__builtin_va_start((va_list *)(& args));
#line 50
  vaf.fmt = fmt;
#line 51
  vaf.va = & args;
#line 53
  if (((((unsigned long )tgt != (unsigned long )((struct bnx2fc_rport  const  *)0) && (unsigned long )tgt->port != (unsigned long )((struct fcoe_port */* const  */)0)) && (unsigned long )(tgt->port)->lport != (unsigned long )((struct fc_lport *)0)) && (unsigned long )((tgt->port)->lport)->host != (unsigned long )((struct Scsi_Host *)0)) && (unsigned long )tgt->rport != (unsigned long )((struct fc_rport */* const  */)0)) {
#line 55
    dev_printk("\016", (struct device  const  *)(& (((tgt->port)->lport)->host)->shost_gendev),
               "bnx2fc: port:%x %pV", (tgt->rport)->port_id, & vaf);
  } else {
#line 59
    printk("\016bnx2fc: NULL %pV", & vaf);
  }
#line 61
  ldv__builtin_va_end((va_list *)(& args));
#line 62
  return;
}
}
#line 64 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_debug.c"
void BNX2FC_HBA_DBG(struct fc_lport  const  *lport , char const   *fmt  , ...) 
{ 
  struct va_format vaf ;
  va_list args ;
  long tmp ;

  {
#line 69
  tmp = ldv__builtin_expect((bnx2fc_debug_level & 4U) == 0U, 1L);
#line 69
  if (tmp != 0L) {
#line 70
    return;
  } else {

  }
#line 72
  ldv__builtin_va_start((va_list *)(& args));
#line 74
  vaf.fmt = fmt;
#line 75
  vaf.va = & args;
#line 77
  if ((unsigned long )lport != (unsigned long )((struct fc_lport  const  *)0) && (unsigned long )lport->host != (unsigned long )((struct Scsi_Host */* const  */)0)) {
#line 78
    dev_printk("\016", (struct device  const  *)(& (lport->host)->shost_gendev), "bnx2fc: %pV",
               & vaf);
  } else {
#line 80
    printk("\016bnx2fc: NULL %pV", & vaf);
  }
#line 82
  ldv__builtin_va_end((va_list *)(& args));
#line 83
  return;
}
}
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_debug.o.c.prepared"
bool ldv_queue_work_on_148(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 181
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 181
  ldv_func_res = tmp;
#line 183
  activate_work_2(ldv_func_arg3, 2);
#line 185
  return (ldv_func_res);
}
}
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_debug.o.c.prepared"
bool ldv_queue_delayed_work_on_149(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 192
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 192
  ldv_func_res = tmp;
#line 194
  activate_work_2(& ldv_func_arg3->work, 2);
#line 196
  return (ldv_func_res);
}
}
#line 199 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_debug.o.c.prepared"
bool ldv_queue_work_on_150(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 203
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 203
  ldv_func_res = tmp;
#line 205
  activate_work_2(ldv_func_arg3, 2);
#line 207
  return (ldv_func_res);
}
}
#line 210 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_debug.o.c.prepared"
void ldv_flush_workqueue_151(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 213
  flush_workqueue(ldv_func_arg1);
#line 215
  call_and_disable_all_2(2);
#line 216
  return;
}
}
#line 218 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_debug.o.c.prepared"
bool ldv_queue_delayed_work_on_152(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 222
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 222
  ldv_func_res = tmp;
#line 224
  activate_work_2(& ldv_func_arg3->work, 2);
#line 226
  return (ldv_func_res);
}
}
#line 229 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_debug.o.c.prepared"
int ldv_scsi_add_host_with_dma_153(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
#line 233
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
#line 233
  ldv_func_res = tmp;
#line 235
  if (ldv_func_res == 0) {
#line 236
    ldv_state_variable_10 = 1;
#line 236
    ldv_initialize_scsi_host_template_10();
  } else {

  }
#line 240
  return (ldv_func_res);
}
}
#line 243 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/dscv/ri/08_1a/drivers/scsi/bnx2fc/bnx2fc_debug.o.c.prepared"
struct Scsi_Host *ldv_scsi_host_alloc_154(struct scsi_host_template *sht , int privsize ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  struct Scsi_Host *tmp ;

  {
#line 247
  tmp = scsi_host_alloc(sht, privsize);
#line 247
  ldv_func_res = tmp;
#line 249
  if ((unsigned long )ldv_func_res != (unsigned long )((ldv_func_ret_type___4 )0)) {
#line 250
    ldv_state_variable_10 = 1;
#line 250
    ldv_initialize_scsi_host_template_10();
  } else {

  }
#line 254
  return (ldv_func_res);
}
}
#line 8 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *memset(void * , int  , size_t  ) ;
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 7 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
int ldv_module_refcounter  =    1;
#line 10 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_get(struct module *module ) 
{ 


  {
#line 13
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 15
    ldv_module_refcounter = ldv_module_refcounter + 1;
  } else {

  }
#line 16
  return;
}
}
#line 20 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
int ldv_try_module_get(struct module *module ) 
{ 
  int module_get_succeeded ;

  {
#line 25
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 28
    module_get_succeeded = ldv_undef_int();
#line 30
    if (module_get_succeeded == 1) {
#line 32
      ldv_module_refcounter = ldv_module_refcounter + 1;
#line 34
      return (1);
    } else {
#line 39
      return (0);
    }
  } else {

  }
#line 41
  return (0);
}
}
#line 45 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_put(struct module *module ) 
{ 


  {
#line 48
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 50
    if (ldv_module_refcounter <= 1) {
#line 50
      ldv_error();
    } else {

    }
#line 52
    ldv_module_refcounter = ldv_module_refcounter - 1;
  } else {

  }
#line 54
  return;
}
}
#line 57 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_module_put_and_exit(void) 
{ 


  {
#line 59
  ldv_module_put((struct module *)1);
  LDV_STOP: ;
#line 61
  goto LDV_STOP;
}
}
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
unsigned int ldv_module_refcount(void) 
{ 


  {
#line 68
  return ((unsigned int )(ldv_module_refcounter + -1));
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6203/dscv_tempdir/rule-instrumentor/08_1a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 75
  if (ldv_module_refcounter != 1) {
#line 75
    ldv_error();
  } else {

  }
#line 79
  return;
}
}
