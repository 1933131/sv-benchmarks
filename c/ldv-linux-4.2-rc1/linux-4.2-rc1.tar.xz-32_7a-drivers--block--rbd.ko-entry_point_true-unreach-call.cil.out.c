extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c"
struct va_list;
#line 6 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c"

#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 32 "include/uapi/linux/types.h"
typedef __u16 __le16;
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 36 "include/uapi/linux/types.h"
typedef __u64 __le64;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 428 "./arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 197 "./arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 63 "include/linux/printk.h"
struct va_format {
   char const   *fmt ;
   va_list *va ;
};
#line 234 "include/linux/printk.h"
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   unsigned int lineno : 18 ;
   unsigned char flags ;
};
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 420 "include/linux/printk.h"
struct file_operations;
#line 432
struct completion;
#line 687 "include/linux/list.h"
struct lockdep_map;
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_15 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 328 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_25 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_24 {
   struct __anonstruct____missing_field_name_25 __annonCompField11 ;
   struct __anonstruct____missing_field_name_26 __annonCompField12 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_24 __annonCompField13 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_27 __annonCompField14 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_31 __annonCompField16 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_30 __annonCompField17 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
struct timespec;
#line 84
struct compat_timespec;
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
struct __anonstruct_futex_34 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
struct __anonstruct_nanosleep_35 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 85
struct pollfd;
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
struct __anonstruct_poll_36 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
union __anonunion____missing_field_name_33 {
   struct __anonstruct_futex_34 futex ;
   struct __anonstruct_nanosleep_35 nanosleep ;
   struct __anonstruct_poll_36 poll ;
};
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_33 __annonCompField18 ;
};
#line 72 "./arch/x86/include/asm/preempt.h"
typedef int pao_T__;
#line 77 "./arch/x86/include/asm/preempt.h"
typedef int pao_T_____0;
#line 426 "include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 598 "include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 106 "include/linux/debugobjects.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 238 "include/linux/timer.h"
struct hrtimer;
#line 239
enum hrtimer_restart;
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 1170 "include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 1120 "include/linux/rcupdate.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 838 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 616
struct vm_area_struct;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
#line 796 "include/linux/mmzone.h"
struct rw_semaphore;
#line 797 "include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_113 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_113 mm_context_t;
#line 22 "include/xen/features.h"
struct bio_vec;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 17 "include/linux/smp.h"
struct call_single_data {
   struct llist_node llist ;
   void (*func)(void * ) ;
   void *info ;
   unsigned int flags ;
};
#line 60 "include/linux/kmemleak.h"
struct kmem_cache;
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 33
struct inode;
#line 34
struct dentry;
#line 35
struct user_namespace;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_146 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_147 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_145 {
   struct __anonstruct____missing_field_name_146 __annonCompField33 ;
   struct __anonstruct____missing_field_name_147 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_145 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_148 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_154 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_152 {
   union __anonunion____missing_field_name_153 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_151 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_152 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_149 {
   union __anonunion____missing_field_name_150 __annonCompField37 ;
   union __anonunion____missing_field_name_151 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_157 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_156 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_157 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_158 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_148 __annonCompField36 ;
   struct __anonstruct____missing_field_name_149 __annonCompField42 ;
   union __anonunion____missing_field_name_155 __annonCompField45 ;
   union __anonunion____missing_field_name_158 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_159 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_159 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_161 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_161 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_162 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_162 kgid_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_163 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_163 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_165 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_166 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_167 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_168 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_170 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_169 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_170 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_171 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_172 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_164 {
   int _pad[28U] ;
   struct __anonstruct__kill_165 _kill ;
   struct __anonstruct__timer_166 _timer ;
   struct __anonstruct__rt_167 _rt ;
   struct __anonstruct__sigchld_168 _sigchld ;
   struct __anonstruct__sigfault_169 _sigfault ;
   struct __anonstruct__sigpoll_171 _sigpoll ;
   struct __anonstruct__sigsys_172 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_164 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct cred;
#line 38
struct key_type;
#line 42 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_179 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_180 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_182 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_181 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_182 __annonCompField49 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_183 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_185 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_184 {
   union __anonunion_payload_185 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_179 __annonCompField47 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_180 __annonCompField48 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_181 __annonCompField50 ;
   union __anonunion_type_data_183 type_data ;
   union __anonunion____missing_field_name_184 __annonCompField51 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369 "include/linux/cred.h"
union __anonunion____missing_field_name_186 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 369 "include/linux/cred.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_186 __annonCompField52 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 31
struct kernfs_node;
#line 32
struct kernfs_ops;
#line 33
struct kernfs_open_file;
#line 75 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270
struct kernfs_root;
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
struct block_device;
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_node;
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_208 {
   spinlock_t lock ;
   int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion____missing_field_name_207 {
   struct __anonstruct____missing_field_name_208 __annonCompField56 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_207 __annonCompField57 ;
};
#line 50 "include/linux/lockref.h"
struct path;
#line 51
struct vfsmount;
#line 52 "include/linux/lockref.h"
struct __anonstruct____missing_field_name_210 {
   u32 hash ;
   u32 len ;
};
#line 52 "include/linux/lockref.h"
union __anonunion____missing_field_name_209 {
   struct __anonstruct____missing_field_name_210 __annonCompField58 ;
   u64 hash_len ;
};
#line 52 "include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_209 __annonCompField59 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90
struct super_block;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_211 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_211 d_u ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
#line 585 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 135 "./arch/x86/include/uapi/asm/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "include/linux/stat.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 80 "include/linux/shrinker.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_215 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion____missing_field_name_214 {
   struct __anonstruct____missing_field_name_215 __annonCompField60 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_214 __annonCompField61 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 44
struct bio_set;
#line 45
struct bio;
#line 46
struct bio_integrity_payload;
#line 17 "include/linux/blk_types.h"
typedef void bio_end_io_t(struct bio * , int  );
#line 19 "include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 28 "include/linux/blk_types.h"
struct bvec_iter {
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned int bi_idx ;
   unsigned int bi_bvec_done ;
};
#line 40 "include/linux/blk_types.h"
union __anonunion____missing_field_name_218 {
   struct bio_integrity_payload *bi_integrity ;
};
#line 40 "include/linux/blk_types.h"
struct bio {
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   struct bvec_iter bi_iter ;
   unsigned int bi_phys_segments ;
   unsigned int bi_seg_front_size ;
   unsigned int bi_seg_back_size ;
   atomic_t __bi_remaining ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct io_context *bi_ioc ;
   struct cgroup_subsys_state *bi_css ;
   union __anonunion____missing_field_name_218 __annonCompField62 ;
   unsigned short bi_vcnt ;
   unsigned short bi_max_vecs ;
   atomic_t __bi_cnt ;
   struct bio_vec *bi_io_vec ;
   struct bio_set *bi_pool ;
   struct bio_vec bi_inline_vecs[0U] ;
};
#line 60 "include/uapi/linux/fs.h"
struct bdi_writeback;
#line 61
struct export_operations;
#line 62
struct hd_geometry;
#line 63
struct iovec;
#line 64
struct kiocb;
#line 65
struct kobject;
#line 66
struct poll_table_struct;
#line 67
struct kstatfs;
#line 68
struct swap_info_struct;
#line 69
struct iov_iter;
#line 70
struct vm_fault;
#line 74 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 212 "./include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_219 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_219 kprojid_t;
#line 166 "include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 66 "include/linux/quota.h"
typedef long long qsize_t;
#line 67 "include/linux/quota.h"
union __anonunion____missing_field_name_220 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 67 "include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_220 __annonCompField63 ;
   enum quota_type type ;
};
#line 184 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 206
struct quota_format_type;
#line 207 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 272 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
#line 325 "include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 348 "include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 394 "include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 405 "include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 418 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 432 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 496 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
#line 526
struct writeback_control;
#line 527 "include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
#line 365 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 422 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 442
struct request_queue;
#line 443
struct hd_struct;
#line 443
struct gendisk;
#line 443 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 559
struct posix_acl;
#line 560
struct inode_operations;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_223 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_224 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 560
struct file_lock_context;
#line 560
struct cdev;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_225 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
#line 560 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_223 __annonCompField64 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_224 __annonCompField65 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_225 __annonCompField66 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 806 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 814 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 837 "include/linux/fs.h"
union __anonunion_f_u_226 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 837 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_226 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 922 "include/linux/fs.h"
typedef void *fl_owner_t;
#line 923
struct file_lock;
#line 924 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 930 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 951
struct nlm_lockowner;
#line 952 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_228 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_227 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_228 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_227 fl_u ;
};
#line 1004 "include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1062 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1240 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1271
struct file_system_type;
#line 1271
struct super_operations;
#line 1271
struct xattr_handler;
#line 1271
struct mtd_info;
#line 1271 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1510 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1524
struct dir_context;
#line 1549 "include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1555
struct block_device_operations;
#line 1556 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1617 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1910 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 24 "include/linux/genhd.h"
struct device_type;
#line 26
struct class;
#line 50
struct kernfs_open_node;
#line 51
struct kernfs_iattrs;
#line 74 "include/linux/genhd.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_229 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_229 __annonCompField67 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 484 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct subsys_private;
#line 18
struct bus_type;
#line 19
struct device_node;
#line 20
struct fwnode_handle;
#line 21
struct iommu_ops;
#line 22
struct iommu_group;
#line 23 "./arch/x86/include/asm/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type * , char * ) ;
   ssize_t (*store)(struct bus_type * , char const   * , size_t  ) ;
};
#line 61 "include/linux/device.h"
struct device_attribute;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203
struct of_device_id;
#line 203
struct acpi_device_id;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 80 "include/linux/genhd.h"
struct disk_stats {
   unsigned long sectors[2U] ;
   unsigned long ios[2U] ;
   unsigned long merges[2U] ;
   unsigned long ticks[2U] ;
   unsigned long io_ticks ;
   unsigned long time_in_queue ;
};
#line 89 "include/linux/genhd.h"
struct partition_meta_info {
   char uuid[37U] ;
   u8 volname[64U] ;
};
#line 101 "include/linux/genhd.h"
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   seqcount_t nr_sects_seq ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
   atomic_t in_flight[2U] ;
   struct disk_stats *dkstats ;
   atomic_t ref ;
   struct callback_head callback_head ;
};
#line 155 "include/linux/genhd.h"
struct disk_part_tbl {
   struct callback_head callback_head ;
   int len ;
   struct hd_struct *last_lookup ;
   struct hd_struct *part[] ;
};
#line 162
struct disk_events;
#line 163
struct timer_rand_state;
#line 163
struct blk_integrity;
#line 163 "include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32U] ;
   char *(*devnode)(struct gendisk * , umode_t * ) ;
   unsigned int events ;
   unsigned int async_events ;
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations  const  *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct blk_integrity *integrity ;
   int node_id ;
};
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 1200
struct kvec;
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 72 "include/linux/flex_proportions.h"
struct fprop_local_percpu {
   struct percpu_counter events ;
   unsigned int period ;
   raw_spinlock_t lock ;
};
#line 32 "include/linux/backing-dev-defs.h"
typedef int congested_fn(void * , int  );
#line 41 "include/linux/backing-dev-defs.h"
struct bdi_writeback_congested {
   unsigned long state ;
   atomic_t refcnt ;
   struct backing_dev_info *bdi ;
   int blkcg_id ;
   struct rb_node rb_node ;
};
#line 60 "include/linux/backing-dev-defs.h"
union __anonunion____missing_field_name_238 {
   struct work_struct release_work ;
   struct callback_head rcu ;
};
#line 60 "include/linux/backing-dev-defs.h"
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned long state ;
   unsigned long last_old_flush ;
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   struct list_head b_dirty_time ;
   spinlock_t list_lock ;
   struct percpu_counter stat[4U] ;
   struct bdi_writeback_congested *congested ;
   unsigned long bw_time_stamp ;
   unsigned long dirtied_stamp ;
   unsigned long written_stamp ;
   unsigned long write_bandwidth ;
   unsigned long avg_write_bandwidth ;
   unsigned long dirty_ratelimit ;
   unsigned long balanced_dirty_ratelimit ;
   struct fprop_local_percpu completions ;
   int dirty_exceeded ;
   spinlock_t work_lock ;
   struct list_head work_list ;
   struct delayed_work dwork ;
   struct percpu_ref refcnt ;
   struct fprop_local_percpu memcg_completions ;
   struct cgroup_subsys_state *memcg_css ;
   struct cgroup_subsys_state *blkcg_css ;
   struct list_head memcg_node ;
   struct list_head blkcg_node ;
   union __anonunion____missing_field_name_238 __annonCompField75 ;
};
#line 132 "include/linux/backing-dev-defs.h"
struct backing_dev_info {
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned int capabilities ;
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   unsigned int min_ratio ;
   unsigned int max_ratio ;
   unsigned int max_prop_frac ;
   atomic_long_t tot_write_bandwidth ;
   struct bdi_writeback wb ;
   struct radix_tree_root cgwb_tree ;
   struct rb_root cgwb_congested_tree ;
   atomic_t usage_cnt ;
   wait_queue_head_t wb_waitq ;
   struct device *dev ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
   struct dentry *debug_stats ;
};
#line 11 "include/linux/mempool.h"
typedef void *mempool_alloc_t(gfp_t  , void * );
#line 12 "include/linux/mempool.h"
typedef void mempool_free_t(void * , void * );
#line 13 "include/linux/mempool.h"
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
   int curr_nr ;
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};
#line 24 "include/linux/mempool.h"
typedef struct mempool_s mempool_t;
#line 78 "include/linux/mempool.h"
union __anonunion____missing_field_name_239 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};
#line 78 "include/linux/mempool.h"
union __anonunion____missing_field_name_240 {
   struct hlist_node ioc_node ;
   struct callback_head __rcu_head ;
};
#line 78 "include/linux/mempool.h"
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion____missing_field_name_239 __annonCompField76 ;
   union __anonunion____missing_field_name_240 __annonCompField77 ;
   unsigned int flags ;
};
#line 92 "include/linux/iocontext.h"
struct io_context {
   atomic_long_t refcount ;
   atomic_t active_ref ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
   int nr_batch_requests ;
   unsigned long last_waited ;
   struct radix_tree_root icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};
#line 326 "include/linux/bio.h"
struct bio_integrity_payload {
   struct bio *bip_bio ;
   struct bvec_iter bip_iter ;
   bio_end_io_t *bip_end_io ;
   unsigned short bip_slab ;
   unsigned short bip_vcnt ;
   unsigned short bip_max_vcnt ;
   unsigned short bip_flags ;
   struct work_struct bip_work ;
   struct bio_vec *bip_vec ;
   struct bio_vec bip_inline_vecs[0U] ;
};
#line 541 "include/linux/bio.h"
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};
#line 662 "include/linux/bio.h"
struct bio_set {
   struct kmem_cache *bio_slab ;
   unsigned int front_pad ;
   mempool_t *bio_pool ;
   mempool_t *bvec_pool ;
   mempool_t *bio_integrity_pool ;
   mempool_t *bvec_integrity_pool ;
   spinlock_t rescue_lock ;
   struct bio_list rescue_list ;
   struct work_struct rescue_work ;
   struct workqueue_struct *rescue_workqueue ;
};
#line 64 "include/uapi/linux/bsg.h"
struct bsg_class_device {
   struct device *class_dev ;
   struct device *parent ;
   int minor ;
   struct request_queue *queue ;
   struct kref ref ;
   void (*release)(struct device * ) ;
};
#line 381 "include/linux/scatterlist.h"
struct elevator_queue;
#line 383
struct request;
#line 385
struct bsg_job;
#line 386
struct blkcg_gq;
#line 387
struct blk_flush_queue;
#line 49 "include/linux/blkdev.h"
typedef void rq_end_io_fn(struct request * , int  );
#line 50 "include/linux/blkdev.h"
struct request_list {
   struct request_queue *q ;
   struct blkcg_gq *blkg ;
   int count[2U] ;
   int starved[2U] ;
   mempool_t *rq_pool ;
   wait_queue_head_t wait[2U] ;
   unsigned int flags ;
};
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_241 {
   struct call_single_data csd ;
   unsigned long fifo_time ;
};
#line 75
struct blk_mq_ctx;
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_242 {
   struct hlist_node hash ;
   struct list_head ipi_list ;
};
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_243 {
   struct rb_node rb_node ;
   void *completion_data ;
};
#line 75 "include/linux/blkdev.h"
struct __anonstruct_elv_245 {
   struct io_cq *icq ;
   void *priv[2U] ;
};
#line 75 "include/linux/blkdev.h"
struct __anonstruct_flush_246 {
   unsigned int seq ;
   struct list_head list ;
   rq_end_io_fn *saved_end_io ;
};
#line 75 "include/linux/blkdev.h"
union __anonunion____missing_field_name_244 {
   struct __anonstruct_elv_245 elv ;
   struct __anonstruct_flush_246 flush ;
};
#line 75 "include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   union __anonunion____missing_field_name_241 __annonCompField78 ;
   struct request_queue *q ;
   struct blk_mq_ctx *mq_ctx ;
   u64 cmd_flags ;
   unsigned int cmd_type ;
   unsigned long atomic_flags ;
   int cpu ;
   unsigned int __data_len ;
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   union __anonunion____missing_field_name_242 __annonCompField79 ;
   union __anonunion____missing_field_name_243 __annonCompField80 ;
   union __anonunion____missing_field_name_244 __annonCompField81 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   unsigned long start_time ;
   struct request_list *rl ;
   unsigned long long start_time_ns ;
   unsigned long long io_start_time_ns ;
   unsigned short nr_phys_segments ;
   unsigned short nr_integrity_segments ;
   unsigned short ioprio ;
   void *special ;
   int tag ;
   int errors ;
   unsigned char __cmd[16U] ;
   unsigned char *cmd ;
   unsigned short cmd_len ;
   unsigned int extra_len ;
   unsigned int sense_len ;
   unsigned int resid_len ;
   void *sense ;
   unsigned long deadline ;
   struct list_head timeout_list ;
   unsigned int timeout ;
   int retries ;
   rq_end_io_fn *end_io ;
   void *end_io_data ;
   struct request *next_rq ;
};
#line 113 "include/linux/hashtable.h"
struct elevator_type;
#line 12 "include/linux/elevator.h"
typedef int elevator_merge_fn(struct request_queue * , struct request ** , struct bio * );
#line 15 "include/linux/elevator.h"
typedef void elevator_merge_req_fn(struct request_queue * , struct request * , struct request * );
#line 17 "include/linux/elevator.h"
typedef void elevator_merged_fn(struct request_queue * , struct request * , int  );
#line 19 "include/linux/elevator.h"
typedef int elevator_allow_merge_fn(struct request_queue * , struct request * , struct bio * );
#line 21 "include/linux/elevator.h"
typedef void elevator_bio_merged_fn(struct request_queue * , struct request * , struct bio * );
#line 24 "include/linux/elevator.h"
typedef int elevator_dispatch_fn(struct request_queue * , int  );
#line 26 "include/linux/elevator.h"
typedef void elevator_add_req_fn(struct request_queue * , struct request * );
#line 27 "include/linux/elevator.h"
typedef struct request *elevator_request_list_fn(struct request_queue * , struct request * );
#line 28 "include/linux/elevator.h"
typedef void elevator_completed_req_fn(struct request_queue * , struct request * );
#line 29 "include/linux/elevator.h"
typedef int elevator_may_queue_fn(struct request_queue * , int  );
#line 31 "include/linux/elevator.h"
typedef void elevator_init_icq_fn(struct io_cq * );
#line 32 "include/linux/elevator.h"
typedef void elevator_exit_icq_fn(struct io_cq * );
#line 33 "include/linux/elevator.h"
typedef int elevator_set_req_fn(struct request_queue * , struct request * , struct bio * ,
                                gfp_t  );
#line 35 "include/linux/elevator.h"
typedef void elevator_put_req_fn(struct request * );
#line 36 "include/linux/elevator.h"
typedef void elevator_activate_req_fn(struct request_queue * , struct request * );
#line 37 "include/linux/elevator.h"
typedef void elevator_deactivate_req_fn(struct request_queue * , struct request * );
#line 39 "include/linux/elevator.h"
typedef int elevator_init_fn(struct request_queue * , struct elevator_type * );
#line 41 "include/linux/elevator.h"
typedef void elevator_exit_fn(struct elevator_queue * );
#line 42 "include/linux/elevator.h"
typedef void elevator_registered_fn(struct request_queue * );
#line 43 "include/linux/elevator.h"
struct elevator_ops {
   elevator_merge_fn *elevator_merge_fn ;
   elevator_merged_fn *elevator_merged_fn ;
   elevator_merge_req_fn *elevator_merge_req_fn ;
   elevator_allow_merge_fn *elevator_allow_merge_fn ;
   elevator_bio_merged_fn *elevator_bio_merged_fn ;
   elevator_dispatch_fn *elevator_dispatch_fn ;
   elevator_add_req_fn *elevator_add_req_fn ;
   elevator_activate_req_fn *elevator_activate_req_fn ;
   elevator_deactivate_req_fn *elevator_deactivate_req_fn ;
   elevator_completed_req_fn *elevator_completed_req_fn ;
   elevator_request_list_fn *elevator_former_req_fn ;
   elevator_request_list_fn *elevator_latter_req_fn ;
   elevator_init_icq_fn *elevator_init_icq_fn ;
   elevator_exit_icq_fn *elevator_exit_icq_fn ;
   elevator_set_req_fn *elevator_set_req_fn ;
   elevator_put_req_fn *elevator_put_req_fn ;
   elevator_may_queue_fn *elevator_may_queue_fn ;
   elevator_init_fn *elevator_init_fn ;
   elevator_exit_fn *elevator_exit_fn ;
   elevator_registered_fn *elevator_registered_fn ;
};
#line 74 "include/linux/elevator.h"
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue * , char * ) ;
   ssize_t (*store)(struct elevator_queue * , char const   * , size_t  ) ;
};
#line 82 "include/linux/elevator.h"
struct elevator_type {
   struct kmem_cache *icq_cache ;
   struct elevator_ops ops ;
   size_t icq_size ;
   size_t icq_align ;
   struct elv_fs_entry *elevator_attrs ;
   char elevator_name[16U] ;
   struct module *elevator_owner ;
   char icq_cache_name[21U] ;
   struct list_head list ;
};
#line 103 "include/linux/elevator.h"
struct elevator_queue {
   struct elevator_type *type ;
   void *elevator_data ;
   struct kobject kobj ;
   struct mutex sysfs_lock ;
   unsigned char registered : 1 ;
   struct hlist_head hash[64U] ;
};
#line 210 "include/linux/blkdev.h"
typedef void request_fn_proc(struct request_queue * );
#line 211 "include/linux/blkdev.h"
typedef void make_request_fn(struct request_queue * , struct bio * );
#line 212 "include/linux/blkdev.h"
typedef int prep_rq_fn(struct request_queue * , struct request * );
#line 213 "include/linux/blkdev.h"
typedef void unprep_rq_fn(struct request_queue * , struct request * );
#line 214 "include/linux/blkdev.h"
struct bvec_merge_data {
   struct block_device *bi_bdev ;
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned long bi_rw ;
};
#line 222 "include/linux/blkdev.h"
typedef int merge_bvec_fn(struct request_queue * , struct bvec_merge_data * , struct bio_vec * );
#line 224 "include/linux/blkdev.h"
typedef void softirq_done_fn(struct request * );
#line 225 "include/linux/blkdev.h"
typedef int dma_drain_needed_fn(struct request * );
#line 226 "include/linux/blkdev.h"
typedef int lld_busy_fn(struct request_queue * );
#line 227 "include/linux/blkdev.h"
typedef int bsg_job_fn(struct bsg_job * );
#line 228
enum blk_eh_timer_return {
    BLK_EH_NOT_HANDLED = 0,
    BLK_EH_HANDLED = 1,
    BLK_EH_RESET_TIMER = 2
} ;
#line 235 "include/linux/blkdev.h"
typedef enum blk_eh_timer_return rq_timed_out_fn(struct request * );
#line 241 "include/linux/blkdev.h"
struct blk_queue_tag {
   struct request **tag_index ;
   unsigned long *tag_map ;
   int busy ;
   int max_depth ;
   int real_max_depth ;
   atomic_t refcnt ;
   int alloc_policy ;
   int next_tag ;
};
#line 252 "include/linux/blkdev.h"
struct queue_limits {
   unsigned long bounce_pfn ;
   unsigned long seg_boundary_mask ;
   unsigned int max_hw_sectors ;
   unsigned int chunk_sectors ;
   unsigned int max_sectors ;
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
   unsigned int alignment_offset ;
   unsigned int io_min ;
   unsigned int io_opt ;
   unsigned int max_discard_sectors ;
   unsigned int max_write_same_sectors ;
   unsigned int discard_granularity ;
   unsigned int discard_alignment ;
   unsigned short logical_block_size ;
   unsigned short max_segments ;
   unsigned short max_integrity_segments ;
   unsigned char misaligned ;
   unsigned char discard_misaligned ;
   unsigned char cluster ;
   unsigned char discard_zeroes_data ;
   unsigned char raid_partial_stripes_expensive ;
};
#line 285
struct blk_mq_ops;
#line 285
struct blk_mq_hw_ctx;
#line 285
struct throtl_data;
#line 285
struct blk_mq_tag_set;
#line 285 "include/linux/blkdev.h"
struct request_queue {
   struct list_head queue_head ;
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   int nr_rqs[2U] ;
   int nr_rqs_elvpriv ;
   struct request_list root_rl ;
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   prep_rq_fn *prep_rq_fn ;
   unprep_rq_fn *unprep_rq_fn ;
   merge_bvec_fn *merge_bvec_fn ;
   softirq_done_fn *softirq_done_fn ;
   rq_timed_out_fn *rq_timed_out_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   lld_busy_fn *lld_busy_fn ;
   struct blk_mq_ops *mq_ops ;
   unsigned int *mq_map ;
   struct blk_mq_ctx *queue_ctx ;
   unsigned int nr_queues ;
   struct blk_mq_hw_ctx **queue_hw_ctx ;
   unsigned int nr_hw_queues ;
   sector_t end_sector ;
   struct request *boundary_rq ;
   struct delayed_work delay_work ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   int id ;
   gfp_t bounce_gfp ;
   spinlock_t __queue_lock ;
   spinlock_t *queue_lock ;
   struct kobject kobj ;
   struct kobject mq_kobj ;
   struct device *dev ;
   int rpm_status ;
   unsigned int nr_pending ;
   unsigned long nr_requests ;
   unsigned int nr_congestion_on ;
   unsigned int nr_congestion_off ;
   unsigned int nr_batching ;
   unsigned int dma_drain_size ;
   void *dma_drain_buffer ;
   unsigned int dma_pad_mask ;
   unsigned int dma_alignment ;
   struct blk_queue_tag *queue_tags ;
   struct list_head tag_busy_list ;
   unsigned int nr_sorted ;
   unsigned int in_flight[2U] ;
   unsigned int request_fn_active ;
   unsigned int rq_timeout ;
   struct timer_list timeout ;
   struct list_head timeout_list ;
   struct list_head icq_list ;
   unsigned long blkcg_pols[1U] ;
   struct blkcg_gq *root_blkg ;
   struct list_head blkg_list ;
   struct queue_limits limits ;
   unsigned int sg_timeout ;
   unsigned int sg_reserved_size ;
   int node ;
   unsigned int flush_flags ;
   unsigned char flush_not_queueable : 1 ;
   struct blk_flush_queue *fq ;
   struct list_head requeue_list ;
   spinlock_t requeue_lock ;
   struct work_struct requeue_work ;
   struct mutex sysfs_lock ;
   int bypass_depth ;
   atomic_t mq_freeze_depth ;
   bsg_job_fn *bsg_job_fn ;
   int bsg_job_size ;
   struct bsg_class_device bsg_dev ;
   struct throtl_data *td ;
   struct callback_head callback_head ;
   wait_queue_head_t mq_freeze_wq ;
   struct percpu_ref mq_usage_counter ;
   struct list_head all_q_node ;
   struct blk_mq_tag_set *tag_set ;
   struct list_head tag_set_list ;
};
#line 1020 "include/linux/blkdev.h"
struct blk_plug {
   struct list_head list ;
   struct list_head mq_list ;
   struct list_head cb_list ;
};
#line 1398 "include/linux/blkdev.h"
struct blk_integrity_iter {
   void *prot_buf ;
   void *data_buf ;
   sector_t seed ;
   unsigned int data_size ;
   unsigned short interval ;
   char const   *disk_name ;
};
#line 1427 "include/linux/blkdev.h"
typedef int integrity_processing_fn(struct blk_integrity_iter * );
#line 1428 "include/linux/blkdev.h"
struct blk_integrity {
   integrity_processing_fn *generate_fn ;
   integrity_processing_fn *verify_fn ;
   unsigned short flags ;
   unsigned short tuple_size ;
   unsigned short interval ;
   unsigned short tag_size ;
   char const   *name ;
   struct kobject kobj ;
};
#line 1482 "include/linux/blkdev.h"
struct block_device_operations {
   int (*open)(struct block_device * , fmode_t  ) ;
   void (*release)(struct gendisk * , fmode_t  ) ;
   int (*rw_page)(struct block_device * , sector_t  , struct page * , int  ) ;
   int (*ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   long (*direct_access)(struct block_device * , sector_t  , void ** , unsigned long * ,
                         long  ) ;
   unsigned int (*check_events)(struct gendisk * , unsigned int  ) ;
   int (*media_changed)(struct gendisk * ) ;
   void (*unlock_native_capacity)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   void (*swap_slot_free_notify)(struct block_device * , unsigned long  ) ;
   struct module *owner ;
};
#line 14 "include/linux/writeback.h"
enum writeback_sync_modes {
    WB_SYNC_NONE = 0,
    WB_SYNC_ALL = 1
} ;
#line 31 "include/linux/writeback.h"
struct writeback_control {
   long nr_to_write ;
   long pages_skipped ;
   loff_t range_start ;
   loff_t range_end ;
   enum writeback_sync_modes sync_mode ;
   unsigned char for_kupdate : 1 ;
   unsigned char for_background : 1 ;
   unsigned char tagged_writepages : 1 ;
   unsigned char for_reclaim : 1 ;
   unsigned char range_cyclic : 1 ;
   unsigned char for_sync : 1 ;
   struct bdi_writeback *wb ;
   struct inode *inode ;
   int wb_id ;
   int wb_lcand_id ;
   int wb_tcand_id ;
   size_t wb_bytes ;
   size_t wb_lcand_bytes ;
   size_t wb_tcand_bytes ;
};
#line 188 "include/linux/writeback.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 155 "include/linux/u64_stats_sync.h"
struct blkcg_policy_data;
#line 155 "include/linux/u64_stats_sync.h"
struct blkcg {
   struct cgroup_subsys_state css ;
   spinlock_t lock ;
   struct radix_tree_root blkg_tree ;
   struct blkcg_gq *blkg_hint ;
   struct hlist_head blkg_list ;
   struct blkcg_policy_data *pd[2U] ;
   struct list_head cgwb_list ;
};
#line 64 "include/linux/blk-cgroup.h"
struct blkg_policy_data {
   struct blkcg_gq *blkg ;
   int plid ;
   struct list_head alloc_node ;
};
#line 86 "include/linux/blk-cgroup.h"
struct blkcg_policy_data {
   int plid ;
   struct list_head alloc_node ;
};
#line 104 "include/linux/blk-cgroup.h"
struct blkcg_gq {
   struct request_queue *q ;
   struct list_head q_node ;
   struct hlist_node blkcg_node ;
   struct blkcg *blkcg ;
   struct bdi_writeback_congested *wb_congested ;
   struct blkcg_gq *parent ;
   struct request_list rl ;
   atomic_t refcnt ;
   bool online ;
   struct blkg_policy_data *pd[2U] ;
   struct callback_head callback_head ;
};
#line 584 "include/linux/backing-dev.h"
struct __anonstruct_i32_255 {
   u32 ino ;
   u32 gen ;
   u32 parent_ino ;
   u32 parent_gen ;
};
#line 584 "include/linux/backing-dev.h"
struct __anonstruct_udf_256 {
   u32 block ;
   u16 partref ;
   u16 parent_partref ;
   u32 generation ;
   u32 parent_block ;
   u32 parent_generation ;
};
#line 584 "include/linux/backing-dev.h"
union __anonunion____missing_field_name_254 {
   struct __anonstruct_i32_255 i32 ;
   struct __anonstruct_udf_256 udf ;
   __u32 raw[0U] ;
};
#line 584 "include/linux/backing-dev.h"
struct fid {
   union __anonunion____missing_field_name_254 __annonCompField82 ;
};
#line 124 "include/linux/exportfs.h"
struct iomap {
   sector_t blkno ;
   loff_t offset ;
   u64 length ;
   int type ;
};
#line 198 "include/linux/exportfs.h"
struct export_operations {
   int (*encode_fh)(struct inode * , __u32 * , int * , struct inode * ) ;
   struct dentry *(*fh_to_dentry)(struct super_block * , struct fid * , int  , int  ) ;
   struct dentry *(*fh_to_parent)(struct super_block * , struct fid * , int  , int  ) ;
   int (*get_name)(struct dentry * , char * , struct dentry * ) ;
   struct dentry *(*get_parent)(struct dentry * ) ;
   int (*commit_metadata)(struct inode * ) ;
   int (*get_uuid)(struct super_block * , u8 * , u32 * , u64 * ) ;
   int (*map_blocks)(struct inode * , loff_t  , u64  , struct iomap * , bool  , u32 * ) ;
   int (*commit_blocks)(struct inode * , struct iomap * , int  , struct iattr * ) ;
};
#line 234 "include/linux/exportfs.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 21 "include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 27 "include/linux/uio.h"
union __anonunion____missing_field_name_257 {
   struct iovec  const  *iov ;
   struct kvec  const  *kvec ;
   struct bio_vec  const  *bvec ;
};
#line 27 "include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion____missing_field_name_257 __annonCompField83 ;
   unsigned long nr_segs ;
};
#line 11 "include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 12 "include/uapi/linux/socket.h"
struct __kernel_sockaddr_storage {
   __kernel_sa_family_t ss_family ;
   char __data[126U] ;
};
#line 23 "include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 38 "include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
   struct kiocb *msg_iocb ;
};
#line 38 "include/linux/ceph/msgr.h"
struct ceph_entity_name {
   __u8 type ;
   __le64 num ;
};
#line 58 "include/linux/ceph/msgr.h"
struct ceph_entity_addr {
   __le32 type ;
   __le32 nonce ;
   struct __kernel_sockaddr_storage in_addr ;
};
#line 67 "include/linux/ceph/msgr.h"
struct ceph_entity_inst {
   struct ceph_entity_name name ;
   struct ceph_entity_addr addr ;
};
#line 72 "include/linux/ceph/msgr.h"
struct ceph_msg_connect {
   __le64 features ;
   __le32 host_type ;
   __le32 global_seq ;
   __le32 connect_seq ;
   __le32 protocol_version ;
   __le32 authorizer_protocol ;
   __le32 authorizer_len ;
   __u8 flags ;
};
#line 106 "include/linux/ceph/msgr.h"
struct ceph_msg_connect_reply {
   __u8 tag ;
   __le64 features ;
   __le32 global_seq ;
   __le32 connect_seq ;
   __le32 protocol_version ;
   __le32 authorizer_len ;
   __u8 flags ;
};
#line 140 "include/linux/ceph/msgr.h"
struct ceph_msg_header {
   __le64 seq ;
   __le64 tid ;
   __le16 type ;
   __le16 priority ;
   __le16 version ;
   __le32 front_len ;
   __le32 middle_len ;
   __le32 data_len ;
   __le16 data_off ;
   struct ceph_entity_name src ;
   __le16 compat_version ;
   __le16 reserved ;
   __le32 crc ;
};
#line 159 "include/linux/ceph/msgr.h"
struct ceph_msg_footer_old {
   __le32 front_crc ;
   __le32 middle_crc ;
   __le32 data_crc ;
   __u8 flags ;
};
#line 172 "include/linux/ceph/msgr.h"
struct ceph_msg_footer {
   __le32 front_crc ;
   __le32 middle_crc ;
   __le32 data_crc ;
   __le64 sig ;
   __u8 flags ;
};
#line 179 "include/linux/ceph/msgr.h"
struct ceph_fsid {
   unsigned char fsid[16U] ;
};
#line 28 "include/linux/ceph/rados.h"
struct ceph_timespec {
   __le32 tv_sec ;
   __le32 tv_nsec ;
};
#line 112 "include/linux/ceph/rados.h"
struct ceph_eversion {
   __le32 epoch ;
   __le64 version ;
};
#line 467 "include/linux/ceph/rados.h"
struct ceph_file_layout {
   __le32 fl_stripe_unit ;
   __le32 fl_stripe_count ;
   __le32 fl_object_size ;
   __le32 fl_cas_hash ;
   __le32 fl_object_stripe_unit ;
   __le32 fl_unused ;
   __le32 fl_pg_pool ;
};
#line 158 "include/linux/kmemcheck.h"
enum ldv_26051 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
} ;
#line 53 "include/uapi/linux/net.h"
typedef enum ldv_26051 socket_state;
#line 70 "include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};
#line 93 "include/linux/net.h"
struct proto_ops;
#line 93 "include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops  const  *ops ;
};
#line 119 "include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket * ) ;
   int (*bind)(struct socket * , struct sockaddr * , int  ) ;
   int (*connect)(struct socket * , struct sockaddr * , int  , int  ) ;
   int (*socketpair)(struct socket * , struct socket * ) ;
   int (*accept)(struct socket * , struct socket * , int  ) ;
   int (*getname)(struct socket * , struct sockaddr * , int * , int  ) ;
   unsigned int (*poll)(struct file * , struct socket * , struct poll_table_struct * ) ;
   int (*ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*listen)(struct socket * , int  ) ;
   int (*shutdown)(struct socket * , int  ) ;
   int (*setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*sendmsg)(struct socket * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct socket * , struct msghdr * , size_t  , int  ) ;
   int (*mmap)(struct file * , struct socket * , struct vm_area_struct * ) ;
   ssize_t (*sendpage)(struct socket * , struct page * , int  , size_t  , int  ) ;
   ssize_t (*splice_read)(struct socket * , loff_t * , struct pipe_inode_info * ,
                          size_t  , unsigned int  ) ;
   int (*set_peek_off)(struct sock * , int  ) ;
};
#line 193 "include/linux/vmalloc.h"
struct ceph_buffer {
   struct kref kref ;
   struct kvec vec ;
   size_t alloc_len ;
};
#line 36 "include/linux/ceph/buffer.h"
struct ceph_msg;
#line 37
struct ceph_connection;
#line 38
struct ceph_auth_handshake;
#line 38 "include/linux/ceph/buffer.h"
struct ceph_connection_operations {
   struct ceph_connection *(*get)(struct ceph_connection * ) ;
   void (*put)(struct ceph_connection * ) ;
   void (*dispatch)(struct ceph_connection * , struct ceph_msg * ) ;
   struct ceph_auth_handshake *(*get_authorizer)(struct ceph_connection * , int * ,
                                                 int  ) ;
   int (*verify_authorizer_reply)(struct ceph_connection * , int  ) ;
   int (*invalidate_authorizer)(struct ceph_connection * ) ;
   void (*fault)(struct ceph_connection * ) ;
   void (*peer_reset)(struct ceph_connection * ) ;
   struct ceph_msg *(*alloc_msg)(struct ceph_connection * , struct ceph_msg_header * ,
                                 int * ) ;
   int (*sign_message)(struct ceph_connection * , struct ceph_msg * ) ;
   int (*check_message_signature)(struct ceph_connection * , struct ceph_msg * ) ;
};
#line 49 "include/linux/ceph/messenger.h"
struct ceph_messenger {
   struct ceph_entity_inst inst ;
   struct ceph_entity_addr my_enc_addr ;
   atomic_t stopping ;
   bool nocrc ;
   bool tcp_nodelay ;
   u32 global_seq ;
   spinlock_t global_seq_lock ;
   u64 supported_features ;
   u64 required_features ;
};
#line 72
enum ceph_msg_data_type {
    CEPH_MSG_DATA_NONE = 0,
    CEPH_MSG_DATA_PAGES = 1,
    CEPH_MSG_DATA_PAGELIST = 2,
    CEPH_MSG_DATA_BIO = 3
} ;
#line 96 "include/linux/ceph/messenger.h"
struct __anonstruct____missing_field_name_277 {
   struct bio *bio ;
   size_t bio_length ;
};
#line 96 "include/linux/ceph/messenger.h"
struct __anonstruct____missing_field_name_278 {
   struct page **pages ;
   size_t length ;
   unsigned int alignment ;
};
#line 96
struct ceph_pagelist;
#line 96 "include/linux/ceph/messenger.h"
union __anonunion____missing_field_name_276 {
   struct __anonstruct____missing_field_name_277 __annonCompField85 ;
   struct __anonstruct____missing_field_name_278 __annonCompField86 ;
   struct ceph_pagelist *pagelist ;
};
#line 96 "include/linux/ceph/messenger.h"
struct ceph_msg_data {
   struct list_head links ;
   enum ceph_msg_data_type type ;
   union __anonunion____missing_field_name_276 __annonCompField87 ;
};
#line 115 "include/linux/ceph/messenger.h"
struct __anonstruct____missing_field_name_280 {
   struct bio *bio ;
   struct bvec_iter bvec_iter ;
};
#line 115 "include/linux/ceph/messenger.h"
struct __anonstruct____missing_field_name_281 {
   unsigned int page_offset ;
   unsigned short page_index ;
   unsigned short page_count ;
};
#line 115 "include/linux/ceph/messenger.h"
struct __anonstruct____missing_field_name_282 {
   struct page *page ;
   size_t offset ;
};
#line 115 "include/linux/ceph/messenger.h"
union __anonunion____missing_field_name_279 {
   struct __anonstruct____missing_field_name_280 __annonCompField88 ;
   struct __anonstruct____missing_field_name_281 __annonCompField89 ;
   struct __anonstruct____missing_field_name_282 __annonCompField90 ;
};
#line 115 "include/linux/ceph/messenger.h"
struct ceph_msg_data_cursor {
   size_t total_resid ;
   struct list_head *data_head ;
   struct ceph_msg_data *data ;
   size_t resid ;
   bool last_piece ;
   bool need_crc ;
   union __anonunion____missing_field_name_279 __annonCompField91 ;
};
#line 142 "include/linux/ceph/messenger.h"
union __anonunion____missing_field_name_283 {
   struct ceph_msg_footer footer ;
   struct ceph_msg_footer_old old_footer ;
};
#line 142
struct ceph_msgpool;
#line 142 "include/linux/ceph/messenger.h"
struct ceph_msg {
   struct ceph_msg_header hdr ;
   union __anonunion____missing_field_name_283 __annonCompField92 ;
   struct kvec front ;
   struct ceph_buffer *middle ;
   size_t data_length ;
   struct list_head data ;
   struct ceph_msg_data_cursor cursor ;
   struct ceph_connection *con ;
   struct list_head list_head ;
   struct kref kref ;
   bool more_to_follow ;
   bool needs_out_seq ;
   int front_alloc_len ;
   unsigned long ack_stamp ;
   struct ceph_msgpool *pool ;
};
#line 172 "include/linux/ceph/messenger.h"
struct ceph_connection {
   void *private ;
   struct ceph_connection_operations  const  *ops ;
   struct ceph_messenger *msgr ;
   atomic_t sock_state ;
   struct socket *sock ;
   struct ceph_entity_addr peer_addr ;
   struct ceph_entity_addr peer_addr_for_me ;
   unsigned long flags ;
   unsigned long state ;
   char const   *error_msg ;
   struct ceph_entity_name peer_name ;
   u64 peer_features ;
   u32 connect_seq ;
   u32 peer_global_seq ;
   int auth_retry ;
   void *auth_reply_buf ;
   int auth_reply_buf_len ;
   struct mutex mutex ;
   struct list_head out_queue ;
   struct list_head out_sent ;
   u64 out_seq ;
   u64 in_seq ;
   u64 in_seq_acked ;
   char in_banner[30U] ;
   struct ceph_msg_connect out_connect ;
   struct ceph_msg_connect_reply in_reply ;
   struct ceph_entity_addr actual_peer_addr ;
   struct ceph_msg *out_msg ;
   bool out_msg_done ;
   struct kvec out_kvec[8U] ;
   struct kvec *out_kvec_cur ;
   int out_kvec_left ;
   int out_skip ;
   int out_kvec_bytes ;
   bool out_kvec_is_msg ;
   int out_more ;
   __le64 out_temp_ack ;
   struct ceph_msg_header in_hdr ;
   struct ceph_msg *in_msg ;
   u32 in_front_crc ;
   u32 in_middle_crc ;
   u32 in_data_crc ;
   char in_tag ;
   int in_base_pos ;
   __le64 in_temp_ack ;
   struct delayed_work work ;
   unsigned long delay ;
};
#line 302 "include/linux/ceph/messenger.h"
struct ceph_msgpool {
   char const   *name ;
   mempool_t *pool ;
   int type ;
   int front_len ;
};
#line 25 "include/linux/ceph/msgpool.h"
struct ceph_client;
#line 27
struct ceph_auth_client;
#line 28 "include/linux/ceph/msgpool.h"
struct ceph_monmap {
   struct ceph_fsid fsid ;
   u32 epoch ;
   u32 num_mon ;
   struct ceph_entity_inst mon_inst[0U] ;
};
#line 23 "include/linux/ceph/mon_client.h"
struct ceph_mon_client;
#line 57 "include/linux/ceph/mon_client.h"
struct ceph_mon_client {
   struct ceph_client *client ;
   struct ceph_monmap *monmap ;
   struct mutex mutex ;
   struct delayed_work delayed_work ;
   struct ceph_auth_client *auth ;
   struct ceph_msg *m_auth ;
   struct ceph_msg *m_auth_reply ;
   struct ceph_msg *m_subscribe ;
   struct ceph_msg *m_subscribe_ack ;
   int pending_auth ;
   bool hunting ;
   int cur_mon ;
   unsigned long sub_sent ;
   unsigned long sub_renew_after ;
   struct ceph_connection con ;
   struct rb_root generic_request_tree ;
   int num_generic_requests ;
   u64 last_tid ;
   int want_mdsmap ;
   int want_next_osdmap ;
   u32 have_osdmap ;
   u32 have_mdsmap ;
   struct dentry *debugfs_file ;
};
#line 219 "include/linux/ceph/decode.h"
struct crush_rule_step {
   __u32 op ;
   __s32 arg1 ;
   __s32 arg2 ;
};
#line 61 "include/linux/crush/crush.h"
struct crush_rule_mask {
   __u8 ruleset ;
   __u8 type ;
   __u8 min_size ;
   __u8 max_size ;
};
#line 83 "include/linux/crush/crush.h"
struct crush_rule {
   __u32 len ;
   struct crush_rule_mask mask ;
   struct crush_rule_step steps[0U] ;
};
#line 118 "include/linux/crush/crush.h"
struct crush_bucket {
   __s32 id ;
   __u16 type ;
   __u8 alg ;
   __u8 hash ;
   __u32 weight ;
   __u32 size ;
   __s32 *items ;
   __u32 perm_x ;
   __u32 perm_n ;
   __u32 *perm ;
};
#line 175 "include/linux/crush/crush.h"
struct crush_map {
   struct crush_bucket **buckets ;
   struct crush_rule **rules ;
   __s32 max_buckets ;
   __u32 max_rules ;
   __s32 max_devices ;
   __u32 choose_local_tries ;
   __u32 choose_local_fallback_tries ;
   __u32 choose_total_tries ;
   __u32 chooseleaf_descend_once ;
   __u8 chooseleaf_vary_r ;
};
#line 244 "include/linux/crush/crush.h"
struct ceph_pg {
   uint64_t pool ;
   uint32_t seed ;
};
#line 56 "include/linux/ceph/osdmap.h"
struct ceph_object_locator {
   s64 pool ;
};
#line 59 "include/linux/ceph/osdmap.h"
struct ceph_object_id {
   char name[100U] ;
   int name_len ;
};
#line 86 "include/linux/ceph/osdmap.h"
struct ceph_osdmap {
   struct ceph_fsid fsid ;
   u32 epoch ;
   u32 mkfs_epoch ;
   struct ceph_timespec created ;
   struct ceph_timespec modified ;
   u32 flags ;
   u32 max_osd ;
   u8 *osd_state ;
   u32 *osd_weight ;
   struct ceph_entity_addr *osd_addr ;
   struct rb_root pg_temp ;
   struct rb_root primary_temp ;
   u32 *osd_primary_affinity ;
   struct rb_root pg_pools ;
   u32 pool_max ;
   struct crush_map *crush ;
   struct mutex crush_scratch_mutex ;
   int crush_scratch_ary[48U] ;
};
#line 223
struct ceph_authorizer;
#line 224 "include/linux/ceph/osdmap.h"
struct ceph_auth_handshake {
   struct ceph_authorizer *authorizer ;
   void *authorizer_buf ;
   size_t authorizer_buf_len ;
   void *authorizer_reply_buf ;
   size_t authorizer_reply_buf_len ;
   int (*sign_message)(struct ceph_auth_handshake * , struct ceph_msg * ) ;
   int (*check_message_signature)(struct ceph_auth_handshake * , struct ceph_msg * ) ;
};
#line 28 "include/linux/ceph/auth.h"
struct ceph_auth_client_ops {
   char const   *name ;
   int (*is_authenticated)(struct ceph_auth_client * ) ;
   int (*should_authenticate)(struct ceph_auth_client * ) ;
   int (*build_request)(struct ceph_auth_client * , void * , void * ) ;
   int (*handle_reply)(struct ceph_auth_client * , int  , void * , void * ) ;
   int (*create_authorizer)(struct ceph_auth_client * , int  , struct ceph_auth_handshake * ) ;
   int (*update_authorizer)(struct ceph_auth_client * , int  , struct ceph_auth_handshake * ) ;
   int (*verify_authorizer_reply)(struct ceph_auth_client * , struct ceph_authorizer * ,
                                  size_t  ) ;
   void (*destroy_authorizer)(struct ceph_auth_client * , struct ceph_authorizer * ) ;
   void (*invalidate_authorizer)(struct ceph_auth_client * , int  ) ;
   void (*reset)(struct ceph_auth_client * ) ;
   void (*destroy)(struct ceph_auth_client * ) ;
   int (*sign_message)(struct ceph_auth_handshake * , struct ceph_msg * ) ;
   int (*check_message_signature)(struct ceph_auth_handshake * , struct ceph_msg * ) ;
};
#line 79
struct ceph_crypto_key;
#line 79 "include/linux/ceph/auth.h"
struct ceph_auth_client {
   u32 protocol ;
   void *private ;
   struct ceph_auth_client_ops  const  *ops ;
   bool negotiating ;
   char const   *name ;
   u64 global_id ;
   struct ceph_crypto_key  const  *key ;
   unsigned int want_keys ;
   struct mutex mutex ;
};
#line 142 "include/linux/ceph/auth.h"
struct ceph_pagelist {
   struct list_head head ;
   void *mapped_tail ;
   size_t length ;
   size_t room ;
   struct list_head free_list ;
   size_t num_pages_free ;
   atomic_t refcnt ;
};
#line 79 "include/linux/ceph/pagelist.h"
struct ceph_snap_context;
#line 80
struct ceph_osd_request;
#line 81
struct ceph_osd_client;
#line 27 "include/linux/ceph/osd_client.h"
struct ceph_osd {
   atomic_t o_ref ;
   struct ceph_osd_client *o_osdc ;
   int o_osd ;
   int o_incarnation ;
   struct rb_node o_node ;
   struct ceph_connection o_con ;
   struct list_head o_requests ;
   struct list_head o_linger_requests ;
   struct list_head o_osd_lru ;
   struct ceph_auth_handshake o_auth ;
   unsigned long lru_ttl ;
   int o_marked_for_keepalive ;
   struct list_head o_keepalive_item ;
};
#line 44
enum ceph_osd_data_type {
    CEPH_OSD_DATA_TYPE_NONE = 0,
    CEPH_OSD_DATA_TYPE_PAGES = 1,
    CEPH_OSD_DATA_TYPE_PAGELIST = 2,
    CEPH_OSD_DATA_TYPE_BIO = 3
} ;
#line 51 "include/linux/ceph/osd_client.h"
struct __anonstruct____missing_field_name_288 {
   struct page **pages ;
   u64 length ;
   u32 alignment ;
   bool pages_from_pool ;
   bool own_pages ;
};
#line 51 "include/linux/ceph/osd_client.h"
struct __anonstruct____missing_field_name_289 {
   struct bio *bio ;
   size_t bio_length ;
};
#line 51 "include/linux/ceph/osd_client.h"
union __anonunion____missing_field_name_287 {
   struct __anonstruct____missing_field_name_288 __annonCompField94 ;
   struct ceph_pagelist *pagelist ;
   struct __anonstruct____missing_field_name_289 __annonCompField95 ;
};
#line 51 "include/linux/ceph/osd_client.h"
struct ceph_osd_data {
   enum ceph_osd_data_type type ;
   union __anonunion____missing_field_name_287 __annonCompField96 ;
};
#line 75 "include/linux/ceph/osd_client.h"
struct __anonstruct_extent_291 {
   u64 offset ;
   u64 length ;
   u64 truncate_size ;
   u32 truncate_seq ;
   struct ceph_osd_data osd_data ;
};
#line 75 "include/linux/ceph/osd_client.h"
struct __anonstruct_xattr_292 {
   u32 name_len ;
   u32 value_len ;
   __u8 cmp_op ;
   __u8 cmp_mode ;
   struct ceph_osd_data osd_data ;
};
#line 75 "include/linux/ceph/osd_client.h"
struct __anonstruct_cls_293 {
   char const   *class_name ;
   char const   *method_name ;
   struct ceph_osd_data request_info ;
   struct ceph_osd_data request_data ;
   struct ceph_osd_data response_data ;
   __u8 class_len ;
   __u8 method_len ;
   __u8 argc ;
};
#line 75 "include/linux/ceph/osd_client.h"
struct __anonstruct_watch_294 {
   u64 cookie ;
   u64 ver ;
   u32 prot_ver ;
   u32 timeout ;
   __u8 flag ;
};
#line 75 "include/linux/ceph/osd_client.h"
struct __anonstruct_alloc_hint_295 {
   u64 expected_object_size ;
   u64 expected_write_size ;
};
#line 75 "include/linux/ceph/osd_client.h"
union __anonunion____missing_field_name_290 {
   struct ceph_osd_data raw_data_in ;
   struct __anonstruct_extent_291 extent ;
   struct __anonstruct_xattr_292 xattr ;
   struct __anonstruct_cls_293 cls ;
   struct __anonstruct_watch_294 watch ;
   struct __anonstruct_alloc_hint_295 alloc_hint ;
};
#line 75 "include/linux/ceph/osd_client.h"
struct ceph_osd_req_op {
   u16 op ;
   u32 flags ;
   u32 payload_len ;
   union __anonunion____missing_field_name_290 __annonCompField97 ;
};
#line 119 "include/linux/ceph/osd_client.h"
struct ceph_osd_request {
   u64 r_tid ;
   struct rb_node r_node ;
   struct list_head r_req_lru_item ;
   struct list_head r_osd_item ;
   struct list_head r_linger_item ;
   struct list_head r_linger_osd_item ;
   struct ceph_osd *r_osd ;
   struct ceph_pg r_pgid ;
   int r_pg_osds[16U] ;
   int r_num_pg_osds ;
   struct ceph_msg *r_request ;
   struct ceph_msg *r_reply ;
   int r_flags ;
   u32 r_sent ;
   unsigned int r_num_ops ;
   struct ceph_osd_req_op r_ops[3U] ;
   __le32 *r_request_osdmap_epoch ;
   __le32 *r_request_flags ;
   __le64 *r_request_pool ;
   void *r_request_pgid ;
   __le32 *r_request_attempts ;
   bool r_paused ;
   struct ceph_eversion *r_request_reassert_version ;
   int r_result ;
   int r_reply_op_len[3U] ;
   s32 r_reply_op_result[3U] ;
   int r_got_reply ;
   int r_linger ;
   struct ceph_osd_client *r_osdc ;
   struct kref r_kref ;
   bool r_mempool ;
   struct completion r_completion ;
   struct completion r_safe_completion ;
   void (*r_callback)(struct ceph_osd_request * , struct ceph_msg * ) ;
   void (*r_unsafe_callback)(struct ceph_osd_request * , bool  ) ;
   struct ceph_eversion r_reassert_version ;
   struct list_head r_unsafe_item ;
   struct inode *r_inode ;
   void *r_priv ;
   struct ceph_object_locator r_base_oloc ;
   struct ceph_object_id r_base_oid ;
   struct ceph_object_locator r_target_oloc ;
   struct ceph_object_id r_target_oid ;
   u64 r_snapid ;
   unsigned long r_stamp ;
   struct ceph_snap_context *r_snapc ;
};
#line 182 "include/linux/ceph/osd_client.h"
struct ceph_osd_event {
   u64 cookie ;
   int one_shot ;
   struct ceph_osd_client *osdc ;
   void (*cb)(u64  , u64  , u8  , void * ) ;
   void *data ;
   struct rb_node node ;
   struct list_head osd_node ;
   struct kref kref ;
};
#line 201 "include/linux/ceph/osd_client.h"
struct ceph_osd_client {
   struct ceph_client *client ;
   struct ceph_osdmap *osdmap ;
   struct rw_semaphore map_sem ;
   struct completion map_waiters ;
   u64 last_requested_map ;
   struct mutex request_mutex ;
   struct rb_root osds ;
   struct list_head osd_lru ;
   u64 timeout_tid ;
   u64 last_tid ;
   struct rb_root requests ;
   struct list_head req_lru ;
   struct list_head req_unsent ;
   struct list_head req_notarget ;
   struct list_head req_linger ;
   int num_requests ;
   struct delayed_work timeout_work ;
   struct delayed_work osds_timeout_work ;
   struct dentry *debugfs_file ;
   mempool_t *req_mempool ;
   struct ceph_msgpool msgpool_op ;
   struct ceph_msgpool msgpool_op_reply ;
   spinlock_t event_lock ;
   struct rb_root event_tree ;
   u64 event_count ;
   struct workqueue_struct *notify_wq ;
};
#line 376 "include/linux/ceph/osd_client.h"
struct ceph_options {
   int flags ;
   struct ceph_fsid fsid ;
   struct ceph_entity_addr my_addr ;
   unsigned long mount_timeout ;
   unsigned long osd_idle_ttl ;
   unsigned long osd_keepalive_timeout ;
   struct ceph_entity_addr *mon_addr ;
   int num_mon ;
   char *name ;
   struct ceph_crypto_key *key ;
};
#line 101 "include/linux/ceph/libceph.h"
struct ceph_client {
   struct ceph_fsid fsid ;
   bool have_fsid ;
   void *private ;
   struct ceph_options *options ;
   struct mutex mount_mutex ;
   wait_queue_head_t auth_wq ;
   int auth_err ;
   int (*extra_mon_dispatch)(struct ceph_client * , struct ceph_msg * ) ;
   u64 supported_features ;
   u64 required_features ;
   struct ceph_messenger msgr ;
   struct ceph_mon_client monc ;
   struct ceph_osd_client osdc ;
   struct dentry *debugfs_dir ;
   struct dentry *debugfs_monmap ;
   struct dentry *debugfs_osdmap ;
   struct dentry *debugfs_options ;
};
#line 136 "include/linux/ceph/libceph.h"
struct ceph_snap_context {
   atomic_t nref ;
   u64 seq ;
   u32 num_snaps ;
   u64 snaps[] ;
};
#line 225 "include/linux/ceph/libceph.h"
struct match_token {
   int token ;
   char const   *pattern ;
};
#line 26 "include/linux/parser.h"
struct __anonstruct_substring_t_296 {
   char *from ;
   char *to ;
};
#line 26 "include/linux/parser.h"
typedef struct __anonstruct_substring_t_296 substring_t;
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
struct kernel_param;
#line 58 "include/linux/elf.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_301 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_301 __annonCompField98 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 712
struct blk_mq_tags;
#line 713 "include/linux/module.h"
struct blk_mq_cpu_notifier {
   struct list_head list ;
   void *data ;
   int (*notify)(void * , unsigned long  , unsigned int  ) ;
};
#line 14 "include/linux/blk-mq.h"
struct blk_align_bitmap;
#line 14 "include/linux/blk-mq.h"
struct blk_mq_ctxmap {
   unsigned int size ;
   unsigned int bits_per_word ;
   struct blk_align_bitmap *map ;
};
#line 20 "include/linux/blk-mq.h"
struct __anonstruct____missing_field_name_308 {
   spinlock_t lock ;
   struct list_head dispatch ;
};
#line 20 "include/linux/blk-mq.h"
struct blk_mq_hw_ctx {
   struct __anonstruct____missing_field_name_308 __annonCompField99 ;
   unsigned long state ;
   struct delayed_work run_work ;
   struct delayed_work delay_work ;
   cpumask_var_t cpumask ;
   int next_cpu ;
   int next_cpu_batch ;
   unsigned long flags ;
   struct request_queue *queue ;
   struct blk_flush_queue *fq ;
   void *driver_data ;
   struct blk_mq_ctxmap ctx_map ;
   unsigned int nr_ctx ;
   struct blk_mq_ctx **ctxs ;
   atomic_t wait_index ;
   struct blk_mq_tags *tags ;
   unsigned long queued ;
   unsigned long run ;
   unsigned long dispatched[10U] ;
   unsigned int numa_node ;
   unsigned int queue_num ;
   atomic_t nr_active ;
   struct blk_mq_cpu_notifier cpu_notifier ;
   struct kobject kobj ;
};
#line 63 "include/linux/blk-mq.h"
struct blk_mq_tag_set {
   struct blk_mq_ops *ops ;
   unsigned int nr_hw_queues ;
   unsigned int queue_depth ;
   unsigned int reserved_tags ;
   unsigned int cmd_size ;
   int numa_node ;
   unsigned int timeout ;
   unsigned int flags ;
   void *driver_data ;
   struct blk_mq_tags **tags ;
   struct mutex tag_list_lock ;
   struct list_head tag_list ;
};
#line 80 "include/linux/blk-mq.h"
struct blk_mq_queue_data {
   struct request *rq ;
   struct list_head *list ;
   bool last ;
};
#line 87 "include/linux/blk-mq.h"
typedef int queue_rq_fn(struct blk_mq_hw_ctx * , struct blk_mq_queue_data  const  * );
#line 88 "include/linux/blk-mq.h"
typedef struct blk_mq_hw_ctx *map_queue_fn(struct request_queue * , int const    );
#line 89 "include/linux/blk-mq.h"
typedef enum blk_eh_timer_return timeout_fn(struct request * , bool  );
#line 90 "include/linux/blk-mq.h"
typedef int init_hctx_fn(struct blk_mq_hw_ctx * , void * , unsigned int  );
#line 91 "include/linux/blk-mq.h"
typedef void exit_hctx_fn(struct blk_mq_hw_ctx * , unsigned int  );
#line 92 "include/linux/blk-mq.h"
typedef int init_request_fn(void * , struct request * , unsigned int  , unsigned int  ,
                            unsigned int  );
#line 94 "include/linux/blk-mq.h"
typedef void exit_request_fn(void * , struct request * , unsigned int  , unsigned int  );
#line 100 "include/linux/blk-mq.h"
struct blk_mq_ops {
   queue_rq_fn *queue_rq ;
   map_queue_fn *map_queue ;
   timeout_fn *timeout ;
   softirq_done_fn *complete ;
   init_hctx_fn *init_hctx ;
   exit_hctx_fn *exit_hctx ;
   init_request_fn *init_request ;
   exit_request_fn *exit_request ;
};
#line 247 "include/linux/blk-mq.h"
struct rbd_image_snap_ondisk {
   __le64 id ;
   __le64 image_size ;
};
#line 60 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/block/rbd_types.h"
struct __anonstruct_options_309 {
   __u8 order ;
   __u8 crypt_type ;
   __u8 comp_type ;
   __u8 unused ;
};
#line 60 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/block/rbd_types.h"
struct rbd_image_header_ondisk {
   char text[40U] ;
   char object_prefix[24U] ;
   char signature[4U] ;
   char version[8U] ;
   struct __anonstruct_options_309 options ;
   __le64 image_size ;
   __le64 snap_seq ;
   __le32 snap_count ;
   __le32 reserved ;
   __le64 snap_names_len ;
   struct rbd_image_snap_ondisk snaps[0U] ;
};
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
struct rbd_image_header {
   char *object_prefix ;
   __u8 obj_order ;
   __u8 crypt_type ;
   __u8 comp_type ;
   u64 stripe_unit ;
   u64 stripe_count ;
   u64 features ;
   u64 image_size ;
   struct ceph_snap_context *snapc ;
   char *snap_names ;
   u64 *snap_sizes ;
};
#line 154 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
struct rbd_spec {
   u64 pool_id ;
   char const   *pool_name ;
   char const   *image_id ;
   char const   *image_name ;
   u64 snap_id ;
   char const   *snap_name ;
   struct kref kref ;
};
#line 192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
struct rbd_client {
   struct ceph_client *client ;
   struct kref kref ;
   struct list_head node ;
};
#line 201
struct rbd_img_request;
#line 204
struct rbd_obj_request;
#line 209
enum obj_request_type {
    OBJ_REQUEST_NODATA = 0,
    OBJ_REQUEST_BIO = 1,
    OBJ_REQUEST_PAGES = 2
} ;
#line 215
enum obj_operation_type {
    OBJ_OP_WRITE = 0,
    OBJ_OP_READ = 1,
    OBJ_OP_DISCARD = 2
} ;
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
struct __anonstruct____missing_field_name_311 {
   struct rbd_img_request *img_request ;
   u64 img_offset ;
   struct list_head links ;
};
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
union __anonunion____missing_field_name_310 {
   struct rbd_obj_request *obj_request ;
   struct __anonstruct____missing_field_name_311 __annonCompField100 ;
};
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
struct __anonstruct____missing_field_name_313 {
   struct page **pages ;
   u32 page_count ;
};
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
union __anonunion____missing_field_name_312 {
   struct bio *bio_list ;
   struct __anonstruct____missing_field_name_313 __annonCompField102 ;
};
#line 228 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
struct rbd_obj_request {
   char const   *object_name ;
   u64 offset ;
   u64 length ;
   unsigned long flags ;
   union __anonunion____missing_field_name_310 __annonCompField101 ;
   u32 which ;
   enum obj_request_type type ;
   union __anonunion____missing_field_name_312 __annonCompField103 ;
   struct page **copyup_pages ;
   u32 copyup_page_count ;
   struct ceph_osd_request *osd_req ;
   u64 xferred ;
   int result ;
   void (*callback)(struct rbd_obj_request * ) ;
   struct completion completion ;
   struct kref kref ;
};
#line 288
struct rbd_device;
#line 288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
union __anonunion____missing_field_name_314 {
   u64 snap_id ;
   struct ceph_snap_context *snapc ;
};
#line 288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
union __anonunion____missing_field_name_315 {
   struct request *rq ;
   struct rbd_obj_request *obj_request ;
};
#line 288 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
struct rbd_img_request {
   struct rbd_device *rbd_dev ;
   u64 offset ;
   u64 length ;
   unsigned long flags ;
   union __anonunion____missing_field_name_314 __annonCompField104 ;
   union __anonunion____missing_field_name_315 __annonCompField105 ;
   struct page **copyup_pages ;
   u32 copyup_page_count ;
   spinlock_t completion_lock ;
   u32 next_completion ;
   void (*callback)(struct rbd_img_request * ) ;
   u64 xferred ;
   int result ;
   u32 obj_request_count ;
   struct list_head obj_requests ;
   struct kref kref ;
};
#line 315 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
struct rbd_mapping {
   u64 size ;
   u64 features ;
   bool read_only ;
};
#line 328
struct rbd_options;
#line 328 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
struct rbd_device {
   int dev_id ;
   int major ;
   int minor ;
   struct gendisk *disk ;
   u32 image_format ;
   struct rbd_client *rbd_client ;
   char name[32U] ;
   spinlock_t lock ;
   struct rbd_image_header header ;
   unsigned long flags ;
   struct rbd_spec *spec ;
   struct rbd_options *opts ;
   char *header_name ;
   struct ceph_file_layout layout ;
   struct ceph_osd_event *watch_event ;
   struct rbd_obj_request *watch_request ;
   struct rbd_spec *parent_spec ;
   u64 parent_overlap ;
   atomic_t parent_ref ;
   struct rbd_device *parent ;
   struct blk_mq_tag_set tag_set ;
   struct rw_semaphore header_rwsem ;
   struct rbd_mapping mapping ;
   struct list_head node ;
   struct device dev ;
   unsigned long open_count ;
};
#line 749 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
struct rbd_options {
   int queue_depth ;
   bool read_only ;
};
#line 4119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
struct __anonstruct_size_buf_317 {
   u8 order ;
   __le64 size ;
};
#line 4192 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
struct __anonstruct_features_buf_319 {
   __le64 features ;
   __le64 incompat ;
};
#line 4350 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
struct __anonstruct_striping_info_buf_321 {
   __le64 stripe_unit ;
   __le64 stripe_count ;
};
#line 1016 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
typedef bool ldv_func_ret_type;
#line 1027 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
typedef bool ldv_func_ret_type___0;
#line 1038 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
typedef bool ldv_func_ret_type___1;
#line 1057 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
typedef bool ldv_func_ret_type___2;
#line 1108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
typedef int ldv_func_ret_type___3;
#line 1 "<compiler builtins>"
void ldv__builtin_va_end(__builtin_va_list  ) ;
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 1
void ldv__builtin_va_start(__builtin_va_list  ) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 369 "./arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 72 "./arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 94 "./arch/x86/include/asm/bitops.h"
__inline static void __set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 96
  __asm__  volatile   ("bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 97
  return;
}
}
#line 110 "./arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 204 "./arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
#line 206
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
#line 206
  return ((int )((signed char )c) != 0);
}
}
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 47 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u64 __le64_to_cpup(__le64 const   *p ) 
{ 


  {
#line 49
  return ((__u64 )*p);
}
}
#line 55 "include/uapi/linux/byteorder/little_endian.h"
__inline static __u32 __le32_to_cpup(__le32 const   *p ) 
{ 


  {
#line 57
  return ((__u32 )*p);
}
}
#line 142 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 45 "include/linux/dynamic_debug.h"
extern void __dynamic_pr_debug(struct _ddebug * , char const   *  , ...) ;
#line 248 "include/linux/kernel.h"
extern void __might_fault(char const   * , int  ) ;
#line 271
extern int kstrtoull(char const   * , unsigned int  , unsigned long long * ) ;
#line 290 "include/linux/kernel.h"
__inline static int kstrtoul(char const   *s , unsigned int base , unsigned long *res ) 
{ 
  int tmp ;

  {
#line 298
  tmp = kstrtoull(s, base, (unsigned long long *)res);
#line 298
  return (tmp);
}
}
#line 402
extern int sprintf(char * , char const   *  , ...) ;
#line 405
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 3 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
bool ldv_is_err(void const   *ptr ) ;
#line 5
void *ldv_err_ptr(long error ) ;
#line 6
long ldv_ptr_err(void const   *ptr ) ;
#line 87 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "./arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_2696: ;
#line 14
  return (pfo_ret__);
}
}
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 48
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 75 "include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
#line 77
  __list_add(new, head->prev, head);
#line 78
  return;
}
}
#line 112
extern void __list_del_entry(struct list_head * ) ;
#line 113
extern void list_del(struct list_head * ) ;
#line 143 "include/linux/list.h"
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
#line 145
  __list_del_entry(entry);
#line 146
  INIT_LIST_HEAD(entry);
#line 147
  return;
}
}
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 57
extern void *memset(void * , int  , size_t  ) ;
#line 63
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 64
extern size_t strlen(char const   * ) ;
#line 67
extern int strcmp(char const   * , char const   * ) ;
#line 80 "include/linux/string.h"
extern __kernel_size_t strnlen(char const   * , __kernel_size_t  ) ;
#line 89
extern __kernel_size_t strspn(char const   * , char const   * ) ;
#line 92
extern __kernel_size_t strcspn(char const   * , char const   * ) ;
#line 118
extern char *kstrdup(char const   * , gfp_t  ) ;
#line 121
extern void *kmemdup(void const   * , size_t  , gfp_t  ) ;
#line 66 "include/asm-generic/bug.h"
extern void warn_slowpath_fmt(char const   * , int const    , char const   *  , ...) ;
#line 71
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 829 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 831
  __edi = __edi;
#line 831
  __esi = __esi;
#line 831
  __edx = __edx;
#line 831
  __ecx = __ecx;
#line 831
  __eax = __eax;
#line 831
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
#line 831
  if (tmp != 0L) {
#line 831
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4801: ;
#line 831
    goto ldv_4801;
  } else {

  }
#line 831
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 831
  __ret = __eax;
#line 831
  return (__ret);
}
}
#line 834 "./arch/x86/include/asm/paravirt.h"
__inline static void arch_local_irq_restore(unsigned long f ) 
{ 
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 836
  __edi = __edi;
#line 836
  __esi = __esi;
#line 836
  __edx = __edx;
#line 836
  __ecx = __ecx;
#line 836
  __eax = __eax;
#line 836
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.restore_fl.func == (unsigned long )((void *)0),
                         0L);
#line 836
  if (tmp != 0L) {
#line 836
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (836), "i" (12UL));
    ldv_4811: ;
#line 836
    goto ldv_4811;
  } else {

  }
#line 836
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (44UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.restore_fl.func), [paravirt_clobber] "i" (1),
                       "D" (f): "memory", "cc");
#line 838
  return;
}
}
#line 839 "./arch/x86/include/asm/paravirt.h"
__inline static void arch_local_irq_disable(void) 
{ 
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
#line 841
  __edi = __edi;
#line 841
  __esi = __esi;
#line 841
  __edx = __edx;
#line 841
  __ecx = __ecx;
#line 841
  __eax = __eax;
#line 841
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.irq_disable.func == (unsigned long )((void *)0),
                         0L);
#line 841
  if (tmp != 0L) {
#line 841
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (841), "i" (12UL));
    ldv_4820: ;
#line 841
    goto ldv_4820;
  } else {

  }
#line 841
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (45UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.irq_disable.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 843
  return;
}
}
#line 849 "./arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_irq_save(void) 
{ 
  unsigned long f ;

  {
#line 853
  f = arch_local_save_flags();
#line 854
  arch_local_irq_disable();
#line 855
  return (f);
}
}
#line 23 "include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 32
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41
__inline static bool IS_ERR(void const   *ptr ) ;
#line 60 "include/linux/err.h"
__inline static int PTR_ERR_OR_ZERO(void const   *ptr ) 
{ 
  long tmp ;
  bool tmp___0 ;

  {
#line 62
  tmp___0 = IS_ERR(ptr);
#line 62
  if ((int )tmp___0) {
#line 63
    tmp = PTR_ERR(ptr);
#line 63
    return ((int )tmp);
  } else {
#line 65
    return (0);
  }
}
}
#line 151 "./arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 


  {
#line 153
  return ((flags & 512UL) == 0UL);
}
}
#line 20 "include/linux/irqflags.h"
extern void trace_hardirqs_on(void) ;
#line 21
extern void trace_hardirqs_off(void) ;
#line 13 "./arch/x86/include/asm/cmpxchg.h"
extern void __cmpxchg_wrong_size(void) ;
#line 15
extern void __xadd_wrong_size(void) ;
#line 25 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 37 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 79 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_and_test(int i , atomic_t *v ) 
{ 
  char c ;

  {
#line 81
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; subl %2, %0; sete %1": "+m" (v->counter),
                       "=qm" (c): "er" (i): "memory");
#line 81
  return ((int )((signed char )c) != 0);
}
}
#line 90 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 92
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 94
  return;
}
}
#line 102 "./arch/x86/include/asm/atomic.h"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
#line 104
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; decl %0": "+m" (v->counter));
#line 106
  return;
}
}
#line 155 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
#line 157
  __ret = i;
#line 157
  switch (4UL) {
  case 1UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5596;
  case 2UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5596;
  case 4UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5596;
  case 8UL: 
#line 157
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
#line 157
  goto ldv_5596;
  default: 
#line 157
  __xadd_wrong_size();
  }
  ldv_5596: ;
#line 157
  return (__ret + i);
}
}
#line 167 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_return(int i , atomic_t *v ) 
{ 
  int tmp ;

  {
#line 169
  tmp = atomic_add_return(- i, v);
#line 169
  return (tmp);
}
}
#line 175 "./arch/x86/include/asm/atomic.h"
__inline static int atomic_cmpxchg(atomic_t *v , int old , int new ) 
{ 
  int __ret ;
  int __old ;
  int __new ;
  u8 volatile   *__ptr ;
  u16 volatile   *__ptr___0 ;
  u32 volatile   *__ptr___1 ;
  u64 volatile   *__ptr___2 ;

  {
#line 177
  __old = old;
#line 177
  __new = new;
#line 177
  switch (4UL) {
  case 1UL: 
#line 177
  __ptr = (u8 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgb %2,%1": "=a" (__ret),
                       "+m" (*__ptr): "q" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5616;
  case 2UL: 
#line 177
  __ptr___0 = (u16 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgw %2,%1": "=a" (__ret),
                       "+m" (*__ptr___0): "r" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5616;
  case 4UL: 
#line 177
  __ptr___1 = (u32 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgl %2,%1": "=a" (__ret),
                       "+m" (*__ptr___1): "r" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5616;
  case 8UL: 
#line 177
  __ptr___2 = (u64 volatile   *)(& v->counter);
#line 177
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; cmpxchgq %2,%1": "=a" (__ret),
                       "+m" (*__ptr___2): "r" (__new), "0" (__old): "memory");
#line 177
  goto ldv_5616;
  default: 
#line 177
  __cmpxchg_wrong_size();
  }
  ldv_5616: ;
#line 177
  return (__ret);
}
}
#line 194 "./arch/x86/include/asm/atomic.h"
__inline static int __atomic_add_unless(atomic_t *v , int a , int u ) 
{ 
  int c ;
  int old ;
  long tmp ;
  long tmp___0 ;

  {
#line 197
  c = atomic_read((atomic_t const   *)v);
  ldv_5645: 
#line 199
  tmp = ldv__builtin_expect(c == u, 0L);
#line 199
  if (tmp != 0L) {
#line 200
    goto ldv_5644;
  } else {

  }
#line 201
  old = atomic_cmpxchg(v, c, c + a);
#line 202
  tmp___0 = ldv__builtin_expect(old == c, 1L);
#line 202
  if (tmp___0 != 0L) {
#line 203
    goto ldv_5644;
  } else {

  }
#line 204
  c = old;
#line 205
  goto ldv_5645;
  ldv_5644: ;
#line 206
  return (c);
}
}
#line 280 "include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 138 "include/linux/mutex.h"
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 141
void ldv_mutex_lock_nested_17(struct mutex *ldv_func_arg1 , unsigned int ldv_func_arg2 ) ;
#line 173
extern int mutex_trylock(struct mutex * ) ;
#line 176
int ldv_mutex_trylock_15(struct mutex *ldv_func_arg1 ) ;
#line 178
extern void mutex_unlock(struct mutex * ) ;
#line 181
void ldv_mutex_unlock_10(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_13(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_18(struct mutex *ldv_func_arg1 ) ;
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 18 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
extern void mutex_lock(struct mutex * ) ;
#line 21
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_12(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_14(struct mutex *ldv_func_arg1 ) ;
#line 34
void ldv_mutex_lock_client_mutex(struct mutex *lock ) ;
#line 38
void ldv_mutex_unlock_client_mutex(struct mutex *lock ) ;
#line 47
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) ;
#line 51
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) ;
#line 60
void ldv_mutex_lock_lock(struct mutex *lock ) ;
#line 64
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
#line 73
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) ;
#line 74
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) ;
#line 77
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) ;
#line 8 "./arch/x86/include/asm/preempt.h"
extern int __preempt_count ;
#line 70 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
#line 72
  switch (4UL) {
  case 1UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_6567;
  case 2UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6567;
  case 4UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_6567;
  case 8UL: ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_6567;
  default: 
#line 72
  __bad_percpu_size();
  }
  ldv_6567: ;
#line 74
  return;
}
}
#line 75 "./arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
#line 77
  switch (4UL) {
  case 1UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_6579;
  case 2UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6579;
  case 4UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_6579;
  case 8UL: ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_6579;
  default: 
#line 77
  __bad_percpu_size();
  }
  ldv_6579: ;
#line 79
  return;
}
}
#line 93 "include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 31
extern void _raw_spin_lock_irq(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 43
extern void _raw_spin_unlock_irq(raw_spinlock_t * ) ;
#line 299 "include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField17.rlock);
}
}
#line 310 "include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 312
  _raw_spin_lock(& lock->__annonCompField17.rlock);
#line 313
  return;
}
}
#line 340 "include/linux/spinlock.h"
__inline static void spin_lock_irq(spinlock_t *lock ) 
{ 


  {
#line 342
  _raw_spin_lock_irq(& lock->__annonCompField17.rlock);
#line 343
  return;
}
}
#line 355 "include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 357
  _raw_spin_unlock(& lock->__annonCompField17.rlock);
#line 358
  return;
}
}
#line 365 "include/linux/spinlock.h"
__inline static void spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
#line 367
  _raw_spin_unlock_irq(& lock->__annonCompField17.rlock);
#line 368
  return;
}
}
#line 21 "include/linux/timekeeping.h"
extern struct timespec current_kernel_time(void) ;
#line 72 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 73 "include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
#line 78
  return;
}
}
#line 99
extern long wait_for_completion_interruptible_timeout(struct completion * , unsigned long  ) ;
#line 107
extern void complete_all(struct completion * ) ;
#line 181 "include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 361
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
#line 421
extern void destroy_workqueue(struct workqueue_struct * ) ;
#line 424
void ldv_destroy_workqueue_19(struct workqueue_struct *ldv_func_arg1 ) ;
#line 428
void ldv_destroy_workqueue_20(struct workqueue_struct *ldv_func_arg1 ) ;
#line 437
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 441
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 445
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
#line 447
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 451
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 455
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
#line 460
extern void flush_workqueue(struct workqueue_struct * ) ;
#line 463
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) ;
#line 469 "include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
#line 472
  tmp = ldv_queue_work_on_5(8192, wq, work);
#line 472
  return (tmp);
}
}
#line 84 "include/linux/rwsem.h"
extern void __init_rwsem(struct rw_semaphore * , char const   * , struct lock_class_key * ) ;
#line 108
extern void down_read(struct rw_semaphore * ) ;
#line 118
extern void down_write(struct rw_semaphore * ) ;
#line 128
extern void up_read(struct rw_semaphore * ) ;
#line 133
extern void up_write(struct rw_semaphore * ) ;
#line 165 "include/linux/idr.h"
extern void ida_destroy(struct ida * ) ;
#line 168
extern int ida_simple_get(struct ida * , unsigned int  , unsigned int  , gfp_t  ) ;
#line 170
extern void ida_simple_remove(struct ida * , unsigned int  ) ;
#line 116 "include/linux/slab.h"
extern struct kmem_cache *kmem_cache_create(char const   * , size_t  , size_t  , unsigned long  ,
                                            void (*)(void * ) ) ;
#line 119
extern void kmem_cache_destroy(struct kmem_cache * ) ;
#line 143
extern void kfree(void const   * ) ;
#line 289
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 290
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
#line 291
extern void kmem_cache_free(struct kmem_cache * , void * ) ;
#line 418 "include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 435
  tmp___2 = __kmalloc(size, flags);
#line 435
  return (tmp___2);
}
}
#line 571 "include/linux/slab.h"
__inline static void *kmem_cache_zalloc(struct kmem_cache *k , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 573
  tmp = kmem_cache_alloc(k, flags | 32768U);
#line 573
  return (tmp);
}
}
#line 581 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 583
  tmp = kmalloc(size, flags | 32768U);
#line 583
  return (tmp);
}
}
#line 76 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_8  ;
#line 77 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
struct work_struct *ldv_work_struct_1_0  ;
#line 78 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_15  ;
#line 79 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
struct work_struct *ldv_work_struct_1_1  ;
#line 80 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_20  ;
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_10  ;
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
struct block_device *rbd_bd_ops_group0  ;
#line 83 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
struct work_struct *ldv_work_struct_1_3  ;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_work_1_3  ;
#line 85 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_6  ;
#line 86 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_0  ;
#line 87 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_21  ;
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_5  ;
#line 89 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_16  ;
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_13  ;
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_work_1_1  ;
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_2  ;
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_12  ;
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_22  ;
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_14  ;
#line 96 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_11  ;
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_work_1_2  ;
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_17  ;
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_18  ;
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
struct work_struct *ldv_work_struct_1_2  ;
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_19  ;
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_9  ;
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_3  ;
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ref_cnt  ;
#line 107 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_work_1_0  ;
#line 108 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_1  ;
#line 109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_7  ;
#line 110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_state_variable_4  ;
#line 111
void ldv_initialize_block_device_operations_16(void) ;
#line 112
void call_and_disable_work_1(struct work_struct *work ) ;
#line 113
void disable_work_1(struct work_struct *work ) ;
#line 114
void work_init_1(void) ;
#line 115
void call_and_disable_all_1(int state ) ;
#line 116
void invoke_work_1(void) ;
#line 118
void activate_work_1(struct work_struct *work , int state ) ;
#line 15 "include/linux/ceph/ceph_debug.h"
extern char const   *ceph_file_part(char const   * , int  ) ;
#line 12 "include/linux/unaligned/access_ok.h"
__inline static u32 get_unaligned_le32(void const   *p ) 
{ 
  __u32 tmp ;

  {
#line 14
  tmp = __le32_to_cpup((__le32 const   *)p);
#line 14
  return (tmp);
}
}
#line 17 "include/linux/unaligned/access_ok.h"
__inline static u64 get_unaligned_le64(void const   *p ) 
{ 
  __u64 tmp ;

  {
#line 19
  tmp = __le64_to_cpup((__le64 const   *)p);
#line 19
  return (tmp);
}
}
#line 42 "include/linux/unaligned/access_ok.h"
__inline static void put_unaligned_le32(u32 val , void *p ) 
{ 


  {
#line 44
  *((__le32 *)p) = val;
#line 45
  return;
}
}
#line 2246 "include/linux/fs.h"
extern int register_blkdev(unsigned int  , char const   * ) ;
#line 2247
extern void unregister_blkdev(unsigned int  , char const   * ) ;
#line 2383
extern int revalidate_disk(struct gendisk * ) ;
#line 32 "include/linux/kref.h"
__inline static void kref_init(struct kref *kref ) 
{ 


  {
#line 34
  atomic_set(& kref->refcount, 1);
#line 35
  return;
}
}
#line 41 "include/linux/kref.h"
__inline static void kref_get(struct kref *kref ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 47
  tmp = atomic_add_return(1, & kref->refcount);
#line 47
  __ret_warn_once = tmp <= 1;
#line 47
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 47
  if (tmp___2 != 0L) {
#line 47
    __ret_warn_on = ! __warned;
#line 47
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___0 != 0L) {
#line 47
      warn_slowpath_null("include/linux/kref.h", 47);
    } else {

    }
#line 47
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 47
    if (tmp___1 != 0L) {
#line 47
      __warned = 1;
    } else {

    }
  } else {

  }
#line 47
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 49
  return;
}
}
#line 68 "include/linux/kref.h"
__inline static int kref_sub(struct kref *kref , unsigned int count , void (*release)(struct kref * ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
#line 71
  __ret_warn_on = (unsigned long )release == (unsigned long )((void (*)(struct kref * ))0);
#line 71
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 71
  if (tmp != 0L) {
#line 71
    warn_slowpath_null("include/linux/kref.h", 71);
  } else {

  }
#line 71
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 73
  tmp___0 = atomic_sub_and_test((int )count, & kref->refcount);
#line 73
  if (tmp___0 != 0) {
#line 74
    (*release)(kref);
#line 75
    return (1);
  } else {

  }
#line 77
  return (0);
}
}
#line 97 "include/linux/kref.h"
__inline static int kref_put(struct kref *kref , void (*release)(struct kref * ) ) 
{ 
  int tmp ;

  {
#line 99
  tmp = kref_sub(kref, 1U, release);
#line 99
  return (tmp);
}
}
#line 134 "include/linux/device.h"
extern int bus_register(struct bus_type * ) ;
#line 136
extern void bus_unregister(struct bus_type * ) ;
#line 842
extern int dev_set_name(struct device * , char const   *  , ...) ;
#line 954
extern int device_register(struct device * ) ;
#line 955
extern void device_unregister(struct device * ) ;
#line 1046
extern struct device *get_device(struct device * ) ;
#line 1047
extern void put_device(struct device * ) ;
#line 419 "include/linux/genhd.h"
extern void add_disk(struct gendisk * ) ;
#line 420
extern void del_gendisk(struct gendisk * ) ;
#line 425
extern void set_disk_ro(struct gendisk * , int  ) ;
#line 441 "include/linux/genhd.h"
__inline static sector_t get_start_sect(struct block_device *bdev ) 
{ 


  {
#line 443
  return ((bdev->bd_part)->start_sect);
}
}
#line 449 "include/linux/genhd.h"
__inline static void set_capacity(struct gendisk *disk , sector_t size ) 
{ 


  {
#line 451
  disk->part0.nr_sects = size;
#line 452
  return;
}
}
#line 619
extern struct gendisk *alloc_disk(int  ) ;
#line 621
extern void put_disk(struct gendisk * ) ;
#line 924 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 926
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 7 "include/linux/uaccess.h"
__inline static void pagefault_disabled_inc(void) 
{ 
  struct task_struct *tmp ;

  {
#line 9
  tmp = get_current();
#line 9
  tmp->pagefault_disabled = tmp->pagefault_disabled + 1;
#line 10
  return;
}
}
#line 12 "include/linux/uaccess.h"
__inline static void pagefault_disabled_dec(void) 
{ 
  struct task_struct *tmp ;
  int __ret_warn_on ;
  struct task_struct *tmp___0 ;
  long tmp___1 ;

  {
#line 14
  tmp = get_current();
#line 14
  tmp->pagefault_disabled = tmp->pagefault_disabled - 1;
#line 15
  tmp___0 = get_current();
#line 15
  __ret_warn_on = tmp___0->pagefault_disabled < 0;
#line 15
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 15
  if (tmp___1 != 0L) {
#line 15
    warn_slowpath_null("include/linux/uaccess.h", 15);
  } else {

  }
#line 15
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 17
  return;
}
}
#line 25 "include/linux/uaccess.h"
__inline static void pagefault_disable(void) 
{ 


  {
#line 27
  pagefault_disabled_inc();
#line 32
  __asm__  volatile   ("": : : "memory");
#line 33
  return;
}
}
#line 35 "include/linux/uaccess.h"
__inline static void pagefault_enable(void) 
{ 


  {
#line 41
  __asm__  volatile   ("": : : "memory");
#line 42
  pagefault_disabled_dec();
#line 43
  return;
}
}
#line 66 "include/linux/highmem.h"
__inline static void *kmap_atomic(struct page *page ) 
{ 
  void *tmp ;

  {
#line 68
  __preempt_count_add(1);
#line 68
  __asm__  volatile   ("": : : "memory");
#line 69
  pagefault_disable();
#line 70
  tmp = lowmem_page_address((struct page  const  *)page);
#line 70
  return (tmp);
}
}
#line 74 "include/linux/highmem.h"
__inline static void __kunmap_atomic(void *addr ) 
{ 


  {
#line 76
  pagefault_enable();
#line 77
  __asm__  volatile   ("": : : "memory");
#line 77
  __preempt_count_sub(1);
#line 78
  return;
}
}
#line 207 "include/linux/bio.h"
__inline static void bvec_iter_advance(struct bio_vec *bv , struct bvec_iter *iter ,
                                       unsigned int bytes ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  unsigned int len ;
  unsigned int _min1 ;
  unsigned int _min2 ;
  unsigned int _min1___0 ;
  unsigned int _min2___0 ;

  {
#line 210
  __ret_warn_once = iter->bi_size < bytes;
#line 210
  tmp___1 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 210
  if (tmp___1 != 0L) {
#line 210
    __ret_warn_on = ! __warned;
#line 210
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 210
    if (tmp != 0L) {
#line 210
      warn_slowpath_fmt("include/linux/bio.h", 211, "Attempted to advance past end of bvec iter\n");
    } else {

    }
#line 210
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 210
    if (tmp___0 != 0L) {
#line 210
      __warned = 1;
    } else {

    }
  } else {

  }
#line 210
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
#line 213
  goto ldv_29916;
  ldv_29915: 
#line 214
  _min1 = bytes;
#line 214
  _min1___0 = iter->bi_size;
#line 214
  _min2___0 = (bv + (unsigned long )iter->bi_idx)->bv_len - iter->bi_bvec_done;
#line 214
  _min2 = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 214
  len = _min1 < _min2 ? _min1 : _min2;
#line 216
  bytes = bytes - len;
#line 217
  iter->bi_size = iter->bi_size - len;
#line 218
  iter->bi_bvec_done = iter->bi_bvec_done + len;
#line 220
  if (iter->bi_bvec_done == (bv + (unsigned long )iter->bi_idx)->bv_len) {
#line 221
    iter->bi_bvec_done = 0U;
#line 222
    iter->bi_idx = iter->bi_idx + 1U;
  } else {

  }
  ldv_29916: ;
#line 213
  if (bytes != 0U) {
#line 215
    goto ldv_29915;
  } else {

  }

#line 220
  return;
}
}
#line 234 "include/linux/bio.h"
__inline static void bio_advance_iter(struct bio *bio , struct bvec_iter *iter , unsigned int bytes ) 
{ 


  {
#line 237
  iter->bi_sector = iter->bi_sector + (sector_t )(bytes >> 9);
#line 239
  if (((unsigned long long )bio->bi_rw & 640ULL) != 0ULL) {
#line 240
    iter->bi_size = iter->bi_size - bytes;
  } else {
#line 242
    bvec_iter_advance(bio->bi_io_vec, iter, bytes);
  }
#line 243
  return;
}
}
#line 400
extern void bio_put(struct bio * ) ;
#line 404
extern struct bio *bio_clone_bioset(struct bio * , gfp_t  , struct bio_set * ) ;
#line 406
extern struct bio_set *fs_bio_set ;
#line 413 "include/linux/bio.h"
__inline static struct bio *bio_clone(struct bio *bio , gfp_t gfp_mask ) 
{ 
  struct bio *tmp ;

  {
#line 415
  tmp = bio_clone_bioset(bio, gfp_mask, fs_bio_set);
#line 415
  return (tmp);
}
}
#line 434
extern void bio_advance(struct bio * , unsigned int  ) ;
#line 525 "include/linux/bio.h"
__inline static char *bvec_kmap_irq(struct bio_vec *bvec , unsigned long *flags ) 
{ 
  void *tmp ;

  {
#line 527
  tmp = lowmem_page_address((struct page  const  *)bvec->bv_page);
#line 527
  return ((char *)tmp + (unsigned long )bvec->bv_offset);
}
}
#line 530 "include/linux/bio.h"
__inline static void bvec_kunmap_irq(char *buffer , unsigned long *flags ) 
{ 


  {
#line 532
  *flags = 0UL;
#line 533
  return;
}
}
#line 506 "include/linux/blkdev.h"
__inline static void queue_flag_set_unlocked(unsigned int flag , struct request_queue *q ) 
{ 


  {
#line 509
  __set_bit((long )flag, (unsigned long volatile   *)(& q->queue_flags));
#line 510
  return;
}
}
#line 828 "include/linux/blkdev.h"
__inline static sector_t blk_rq_pos(struct request  const  *rq ) 
{ 


  {
#line 830
  return ((sector_t )rq->__sector);
}
}
#line 833 "include/linux/blkdev.h"
__inline static unsigned int blk_rq_bytes(struct request  const  *rq ) 
{ 


  {
#line 835
  return ((unsigned int )rq->__data_len);
}
}
#line 926
extern bool blk_update_request(struct request * , int  , unsigned int  ) ;
#line 953
extern void blk_cleanup_queue(struct request_queue * ) ;
#line 957
extern void blk_queue_max_hw_sectors(struct request_queue * , unsigned int  ) ;
#line 959
extern void blk_queue_max_segments(struct request_queue * , unsigned short  ) ;
#line 960
extern void blk_queue_max_segment_size(struct request_queue * , unsigned int  ) ;
#line 970
extern void blk_queue_io_min(struct request_queue * , unsigned int  ) ;
#line 972
extern void blk_queue_io_opt(struct request_queue * , unsigned int  ) ;
#line 991
extern void blk_queue_merge_bvec(struct request_queue * , merge_bvec_fn * ) ;
#line 105 "include/linux/ceph/mon_client.h"
extern void ceph_monc_request_next_osdmap(struct ceph_mon_client * ) ;
#line 106
extern int ceph_monc_wait_osdmap(struct ceph_mon_client * , u32  , unsigned long  ) ;
#line 112
extern int ceph_monc_do_get_version(struct ceph_mon_client * , char const   * , u64 * ) ;
#line 17 "include/linux/ceph/decode.h"
__inline static u64 ceph_decode_64(void **p ) 
{ 
  u64 v ;
  u64 tmp ;

  {
#line 19
  tmp = get_unaligned_le64((void const   *)*p);
#line 19
  v = tmp;
#line 20
  *p = *p + 8UL;
#line 21
  return (v);
}
}
#line 23 "include/linux/ceph/decode.h"
__inline static u32 ceph_decode_32(void **p ) 
{ 
  u32 v ;
  u32 tmp ;

  {
#line 25
  tmp = get_unaligned_le32((void const   *)*p);
#line 25
  v = tmp;
#line 26
  *p = *p + 4UL;
#line 27
  return (v);
}
}
#line 50 "include/linux/ceph/decode.h"
__inline static int ceph_has_room(void **p , void *end , size_t n ) 
{ 


  {
#line 52
  return ((unsigned long )*p <= (unsigned long )end && (unsigned long )((long )end - (long )*p) >= n);
}
}
#line 105 "include/linux/ceph/decode.h"
__inline static char *ceph_extract_encoded_string(void **p , void *end , size_t *lenp ,
                                                  gfp_t gfp ) 
{ 
  u32 len ;
  void *sp ;
  char *buf ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 109
  sp = *p;
#line 112
  tmp = ceph_has_room(& sp, end, 4UL);
#line 112
  tmp___0 = ldv__builtin_expect(tmp != 0, 1L);
#line 112
  if (tmp___0 == 0L) {
#line 112
    goto bad;
  } else {

  }
#line 112
  len = ceph_decode_32(& sp);
#line 113
  tmp___1 = ceph_has_room(& sp, end, (size_t )len);
#line 113
  if (tmp___1 == 0) {
#line 114
    goto bad;
  } else {

  }
#line 116
  tmp___2 = kmalloc((size_t )(len + 1U), gfp);
#line 116
  buf = (char *)tmp___2;
#line 117
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 118
    tmp___3 = ERR_PTR(-12L);
#line 118
    return ((char *)tmp___3);
  } else {

  }
#line 120
  if (len != 0U) {
#line 121
    memcpy((void *)buf, (void const   *)sp, (size_t )len);
  } else {

  }
#line 122
  *(buf + (unsigned long )len) = 0;
#line 124
  *p = *p + ((unsigned long )len + 4UL);
#line 125
  if ((unsigned long )lenp != (unsigned long )((size_t *)0UL)) {
#line 126
    *lenp = (unsigned long )len;
  } else {

  }
#line 128
  return (buf);
  bad: 
#line 131
  tmp___4 = ERR_PTR(-34L);
#line 131
  return ((char *)tmp___4);
}
}
#line 173 "include/linux/ceph/decode.h"
__inline static void ceph_encode_32(void **p , u32 v ) 
{ 


  {
#line 175
  put_unaligned_le32(v, *p);
#line 176
  *p = *p + 4UL;
#line 177
  return;
}
}
#line 210 "include/linux/ceph/decode.h"
__inline static void ceph_encode_string(void **p , void *end , char const   *s , u32 len ) 
{ 
  long tmp ;

  {
#line 213
  tmp = ldv__builtin_expect((unsigned long )(*p + ((unsigned long )len + 4UL)) > (unsigned long )end,
                         0L);
#line 213
  if (tmp != 0L) {
#line 213
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/ceph/decode.h"),
                         "i" (213), "i" (12UL));
    ldv_35032: ;
#line 213
    goto ldv_35032;
  } else {

  }
#line 214
  ceph_encode_32(p, len);
#line 215
  if (len != 0U) {
#line 216
    memcpy(*p, (void const   *)s, (size_t )len);
  } else {

  }
#line 217
  *p = *p + (unsigned long )len;
#line 218
  return;
}
}
#line 116 "include/linux/ceph/osdmap.h"
__inline static void ceph_oid_set_name(struct ceph_object_id *oid , char const   *name ) 
{ 
  int len ;
  size_t tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
#line 121
  tmp = strlen(name);
#line 121
  len = (int )tmp;
#line 122
  if ((unsigned int )len > 100U) {
#line 123
    __ret_warn_on = 1;
#line 123
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 123
    if (tmp___0 != 0L) {
#line 123
      warn_slowpath_fmt("include/linux/ceph/osdmap.h", 124, "ceph_oid_set_name \'%s\' len %d vs %zu, truncating\n",
                        name, len, 100UL);
    } else {

    }
#line 123
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
#line 125
    len = 100;
  } else {

  }
#line 128
  memcpy((void *)(& oid->name), (void const   *)name, (size_t )len);
#line 129
  oid->name_len = len;
#line 130
  return;
}
}
#line 221
extern char const   *ceph_pg_pool_name_by_id(struct ceph_osdmap * , u64  ) ;
#line 222
extern int ceph_pg_poolid_by_name(struct ceph_osdmap * , char const   * ) ;
#line 25 "include/linux/ceph/pagelist.h"
__inline static void ceph_pagelist_init(struct ceph_pagelist *pl ) 
{ 


  {
#line 27
  INIT_LIST_HEAD(& pl->head);
#line 28
  pl->mapped_tail = (void *)0;
#line 29
  pl->length = 0UL;
#line 30
  pl->room = 0UL;
#line 31
  INIT_LIST_HEAD(& pl->free_list);
#line 32
  pl->num_pages_free = 0UL;
#line 33
  atomic_set(& pl->refcnt, 1);
#line 34
  return;
}
}
#line 38
extern int ceph_pagelist_append(struct ceph_pagelist * , void const   * , size_t  ) ;
#line 251 "include/linux/ceph/osd_client.h"
extern void osd_req_op_init(struct ceph_osd_request * , unsigned int  , u16  , u32  ) ;
#line 254
extern void osd_req_op_raw_data_in_pages(struct ceph_osd_request * , unsigned int  ,
                                         struct page ** , u64  , u32  , bool  , bool  ) ;
#line 260
extern void osd_req_op_extent_init(struct ceph_osd_request * , unsigned int  , u16  ,
                                   u64  , u64  , u64  , u32  ) ;
#line 274
extern void osd_req_op_extent_osd_data_pages(struct ceph_osd_request * , unsigned int  ,
                                             struct page ** , u64  , u32  , bool  ,
                                             bool  ) ;
#line 283
extern void osd_req_op_extent_osd_data_bio(struct ceph_osd_request * , unsigned int  ,
                                           struct bio * , size_t  ) ;
#line 288
extern void osd_req_op_cls_request_data_pagelist(struct ceph_osd_request * , unsigned int  ,
                                                 struct ceph_pagelist * ) ;
#line 291
extern void osd_req_op_cls_request_data_pages(struct ceph_osd_request * , unsigned int  ,
                                              struct page ** , u64  , u32  , bool  ,
                                              bool  ) ;
#line 296
extern void osd_req_op_cls_response_data_pages(struct ceph_osd_request * , unsigned int  ,
                                               struct page ** , u64  , u32  , bool  ,
                                               bool  ) ;
#line 302
extern void osd_req_op_cls_init(struct ceph_osd_request * , unsigned int  , u16  ,
                                char const   * , char const   * ) ;
#line 308
extern void osd_req_op_watch_init(struct ceph_osd_request * , unsigned int  , u16  ,
                                  u64  , u64  , int  ) ;
#line 311
extern void osd_req_op_alloc_hint_init(struct ceph_osd_request * , unsigned int  ,
                                       u64  , u64  ) ;
#line 316
extern struct ceph_osd_request *ceph_osdc_alloc_request(struct ceph_osd_client * ,
                                                        struct ceph_snap_context * ,
                                                        unsigned int  , bool  , gfp_t  ) ;
#line 322
extern void ceph_osdc_build_request(struct ceph_osd_request * , u64  , struct ceph_snap_context * ,
                                    u64  , struct timespec * ) ;
#line 337
extern void ceph_osdc_set_request_linger(struct ceph_osd_client * , struct ceph_osd_request * ) ;
#line 341
extern void ceph_osdc_put_request(struct ceph_osd_request * ) ;
#line 343
extern int ceph_osdc_start_request(struct ceph_osd_client * , struct ceph_osd_request * ,
                                   bool  ) ;
#line 346
extern void ceph_osdc_cancel_request(struct ceph_osd_request * ) ;
#line 351
extern void ceph_osdc_flush_notifies(struct ceph_osd_client * ) ;
#line 371
extern int ceph_osdc_create_event(struct ceph_osd_client * , void (*)(u64  , u64  ,
                                                                      u8  , void * ) ,
                                  void * , struct ceph_osd_event ** ) ;
#line 374
extern void ceph_osdc_cancel_event(struct ceph_osd_event * ) ;
#line 96 "include/linux/ceph/libceph.h"
__inline static unsigned long ceph_timeout_jiffies(unsigned long timeout ) 
{ 


  {
#line 98
  return (timeout != 0UL ? timeout != 0UL : 9223372036854775807UL);
}
}
#line 159
extern struct ceph_snap_context *ceph_create_snap_context(u32  , gfp_t  ) ;
#line 161
extern struct ceph_snap_context *ceph_get_snap_context(struct ceph_snap_context * ) ;
#line 163
extern void ceph_put_snap_context(struct ceph_snap_context * ) ;
#line 169 "include/linux/ceph/libceph.h"
__inline static int calc_pages_for(u64 off , u64 len ) 
{ 


  {
#line 171
  return ((int )((unsigned int )(((off + len) + 4095ULL) >> 12) - (unsigned int )(off >> 12)));
}
}
#line 182
extern bool libceph_compatible(void * ) ;
#line 188
extern struct ceph_options *ceph_parse_options(char * , char const   * , char const   * ,
                                               int (*)(char * , void * ) , void * ) ;
#line 193
extern void ceph_destroy_options(struct ceph_options * ) ;
#line 194
extern int ceph_compare_options(struct ceph_options * , struct ceph_client * ) ;
#line 196
extern struct ceph_client *ceph_create_client(struct ceph_options * , void * , u64  ,
                                              u64  ) ;
#line 200
extern u64 ceph_client_id(struct ceph_client * ) ;
#line 201
extern void ceph_destroy_client(struct ceph_client * ) ;
#line 204
extern int ceph_open_session(struct ceph_client * ) ;
#line 207
extern void ceph_release_page_vector(struct page ** , int  ) ;
#line 214
extern struct page **ceph_alloc_page_vector(int  , gfp_t  ) ;
#line 221
extern void ceph_copy_from_page_vector(struct page ** , void * , loff_t  , size_t  ) ;
#line 28 "include/linux/parser.h"
extern int match_token(char * , struct match_token  const  * , substring_t * ) ;
#line 29
extern int match_int(substring_t * , int * ) ;
#line 6 "include/linux/bsearch.h"
extern void *bsearch(void const   * , void const   * , size_t  , size_t  , int (*)(void const   * ,
                                                                                   void const   * ) ) ;
#line 502 "include/linux/module.h"
extern bool try_module_get(struct module * ) ;
#line 504
extern void module_put(struct module * ) ;
#line 167 "include/linux/blk-mq.h"
extern struct request_queue *blk_mq_init_queue(struct blk_mq_tag_set * ) ;
#line 174
extern int blk_mq_alloc_tag_set(struct blk_mq_tag_set * ) ;
#line 175
extern void blk_mq_free_tag_set(struct blk_mq_tag_set * ) ;
#line 205
extern struct blk_mq_hw_ctx *blk_mq_map_queue(struct request_queue * , int const    ) ;
#line 209
extern void blk_mq_start_request(struct request * ) ;
#line 210
extern void blk_mq_end_request(struct request * , int  ) ;
#line 211
extern void __blk_mq_end_request(struct request * , int  ) ;
#line 239 "include/linux/blk-mq.h"
__inline static struct request *blk_mq_rq_from_pdu(void *pdu ) 
{ 


  {
#line 241
  return ((struct request *)pdu + 0xfffffffffffffe90UL);
}
}
#line 243 "include/linux/blk-mq.h"
__inline static void *blk_mq_rq_to_pdu(struct request *rq ) 
{ 


  {
#line 245
  return ((void *)rq + 1U);
}
}
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int atomic_inc_return_safe(atomic_t *v ) 
{ 
  unsigned int counter ;
  int tmp ;

  {
#line 71
  tmp = __atomic_add_unless(v, 1, 0);
#line 71
  counter = (unsigned int )tmp;
#line 72
  if ((int )counter >= 0) {
#line 73
    return ((int )counter);
  } else {

  }
#line 75
  atomic_dec(v);
#line 77
  return (-22);
}
}
#line 81 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int atomic_dec_return_safe(atomic_t *v ) 
{ 
  int counter ;

  {
#line 85
  counter = atomic_sub_return(1, v);
#line 86
  if (counter >= 0) {
#line 87
    return (counter);
  } else {

  }
#line 89
  atomic_inc(v);
#line 91
  return (-22);
}
}
#line 390 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct mutex client_mutex  =    {{1}, {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "client_mutex.wait_lock",
                                                          0, 0UL}}}}, {& client_mutex.wait_list,
                                                                       & client_mutex.wait_list},
    0, (void *)(& client_mutex), {0, {0, 0}, "client_mutex", 0, 0UL}};
#line 392 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct list_head rbd_dev_list  =    {& rbd_dev_list, & rbd_dev_list};
#line 393 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static spinlock_t rbd_dev_list_lock  =    {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "rbd_dev_list_lock",
                                                    0, 0UL}}}};
#line 395 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct list_head rbd_client_list  =    {& rbd_client_list, & rbd_client_list};
#line 396 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static spinlock_t rbd_client_list_lock  =    {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "rbd_client_list_lock",
                                                    0, 0UL}}}};
#line 400 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct kmem_cache *rbd_img_request_cache  ;
#line 401 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct kmem_cache *rbd_obj_request_cache  ;
#line 402 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct kmem_cache *rbd_segment_name_cache  ;
#line 404 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_major  ;
#line 405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct ida rbd_dev_id_ida  =    {{0, 0, 0, 0, {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "(rbd_dev_id_ida).idr.lock",
                                                                  0, 0UL}}}}, 0, 0},
    (struct ida_bitmap *)0};
#line 407 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct workqueue_struct *rbd_wq  ;
#line 413 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static bool single_major  =    0;
#line 417
static int rbd_img_request_submit(struct rbd_img_request *img_request ) ;
#line 419
static void rbd_dev_device_release(struct device *dev ) ;
#line 421
static ssize_t rbd_add(struct bus_type *bus , char const   *buf , size_t count ) ;
#line 423
static ssize_t rbd_remove(struct bus_type *bus , char const   *buf , size_t count ) ;
#line 425
static ssize_t rbd_add_single_major(struct bus_type *bus , char const   *buf , size_t count ) ;
#line 427
static ssize_t rbd_remove_single_major(struct bus_type *bus , char const   *buf ,
                                       size_t count ) ;
#line 429
static int rbd_dev_image_probe(struct rbd_device *rbd_dev , bool mapping ) ;
#line 430
static void rbd_spec_put(struct rbd_spec *spec ) ;
#line 432 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_id_to_minor(int dev_id ) 
{ 


  {
#line 434
  return (dev_id << 4);
}
}
#line 437 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int minor_to_rbd_dev_id(int minor ) 
{ 


  {
#line 439
  return (minor >> 4);
}
}
#line 442 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct bus_attribute bus_attr_add  =    {{"add", 128U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                 {(char)0}, {(char)0}, {(char)0}}}}, (ssize_t (*)(struct bus_type * ,
                                                                                  char * ))0,
    & rbd_add};
#line 443 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct bus_attribute bus_attr_remove  =    {{"remove", 128U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, (ssize_t (*)(struct bus_type * ,
                                                                                     char * ))0,
    & rbd_remove};
#line 444 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct bus_attribute bus_attr_add_single_major  =    {{"add_single_major", 128U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                              {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    (ssize_t (*)(struct bus_type * , char * ))0, & rbd_add_single_major};
#line 445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct bus_attribute bus_attr_remove_single_major  =    {{"remove_single_major", 128U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                 {(char)0}, {(char)0}, {(char)0},
                                                 {(char)0}, {(char)0}}}}, (ssize_t (*)(struct bus_type * ,
                                                                                       char * ))0,
    & rbd_remove_single_major};
#line 447 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct attribute *rbd_bus_attrs[5U]  = {      & bus_attr_add.attr,      & bus_attr_remove.attr,      & bus_attr_add_single_major.attr,      & bus_attr_remove_single_major.attr, 
        (struct attribute *)0};
#line 455 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static umode_t rbd_bus_is_visible(struct kobject *kobj , struct attribute *attr ,
                                  int index ) 
{ 


  {
#line 458
  if (! single_major && ((unsigned long )attr == (unsigned long )(& bus_attr_add_single_major.attr) || (unsigned long )attr == (unsigned long )(& bus_attr_remove_single_major.attr))) {
#line 461
    return (0U);
  } else {

  }
#line 463
  return (attr->mode);
}
}
#line 466 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct attribute_group  const  rbd_bus_group  =    {0, & rbd_bus_is_visible, (struct attribute **)(& rbd_bus_attrs), 0};
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct attribute_group  const  *rbd_bus_groups[2U]  = {      & rbd_bus_group,      (struct attribute_group  const  *)0};
#line 472 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct bus_type rbd_bus_type  = 
#line 472
     {"rbd", 0, 0, 0, (struct attribute_group  const  **)(& rbd_bus_groups), 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                       {(char)0}, {(char)0}, {(char)0}, {(char)0}}}};
#line 477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_root_dev_release(struct device *dev ) 
{ 


  {
#line 479
  return;
}
}
#line 481 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct device rbd_root_dev  = 
#line 481
     {0, 0, {0, {0, 0}, 0, 0, 0, 0, {{0}}, {{{0L}, {0, 0}, 0, {0, {0, 0}, 0, 0, 0UL}},
                                          {{0, 0}, 0UL, 0, 0UL, 0U, 0, 0, 0, {(char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0},
                                           {0, {0, 0}, 0, 0, 0UL}}, 0, 0}, (unsigned char)0,
           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
    "rbd", 0, {{0}, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 0,
               {0, {0, 0}, 0, 0, 0UL}}, 0, 0, 0, 0, {{0}, (unsigned char)0, (unsigned char)0,
                                                     (_Bool)0, (_Bool)0, (_Bool)0,
                                                     (_Bool)0, (_Bool)0, (_Bool)0,
                                                     (_Bool)0, {{{{{0}}, 0U, 0U, 0,
                                                                  {0, {0, 0}, 0, 0,
                                                                   0UL}}}}, {0, 0},
                                                     {0U, {{{{{{0}}, 0U, 0U, 0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}}}},
                                                           {0, 0}}}, 0, (_Bool)0,
                                                     (_Bool)0, {{0, 0}, 0UL, 0, 0UL,
                                                                0U, 0, 0, 0, {(char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0},
                                                                {0, {0, 0}, 0, 0,
                                                                 0UL}}, 0UL, {{0L},
                                                                              {0,
                                                                               0},
                                                                              0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}},
                                                     {{{{{{0}}, 0U, 0U, 0, {0, {0,
                                                                                0},
                                                                            0, 0,
                                                                            0UL}}}},
                                                      {0, 0}}, 0, {0}, {0}, (unsigned char)0,
                                                     (unsigned char)0, (unsigned char)0,
                                                     (unsigned char)0, (unsigned char)0,
                                                     (unsigned char)0, (unsigned char)0,
                                                     (unsigned char)0, (unsigned char)0,
                                                     (unsigned char)0, (unsigned char)0,
                                                     0, 0, 0, 0, 0UL, 0UL, 0UL, 0UL,
                                                     0, 0, 0}, 0, 0, 0, 0, 0ULL, 0UL,
    0, {0, 0}, 0, 0, {0, 0}, 0, 0, 0U, 0U, {{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0,
                                                                 0UL}}}}, {0, 0},
    {0, {0, 0}, {{0}}}, 0, 0, & rbd_root_dev_release, 0, (_Bool)0, (_Bool)0};
#line 487 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_warn(struct rbd_device *rbd_dev , char const   *fmt  , ...) 
{ 
  struct va_format vaf ;
  va_list args ;

  {
#line 492
  ldv__builtin_va_start((va_list *)(& args));
#line 493
  vaf.fmt = fmt;
#line 494
  vaf.va = & args;
#line 496
  if ((unsigned long )rbd_dev == (unsigned long )((struct rbd_device *)0)) {
#line 497
    printk("\f%s: %pV\n", (char *)"rbd", & vaf);
  } else
#line 498
  if ((unsigned long )rbd_dev->disk != (unsigned long )((struct gendisk *)0)) {
#line 499
    printk("\f%s: %s: %pV\n", (char *)"rbd", (char *)(& (rbd_dev->disk)->disk_name),
           & vaf);
  } else
#line 501
  if ((unsigned long )rbd_dev->spec != (unsigned long )((struct rbd_spec *)0) && (unsigned long )(rbd_dev->spec)->image_name != (unsigned long )((char const   *)0)) {
#line 502
    printk("\f%s: image %s: %pV\n", (char *)"rbd", (rbd_dev->spec)->image_name, & vaf);
  } else
#line 504
  if ((unsigned long )rbd_dev->spec != (unsigned long )((struct rbd_spec *)0) && (unsigned long )(rbd_dev->spec)->image_id != (unsigned long )((char const   *)0)) {
#line 505
    printk("\f%s: id %s: %pV\n", (char *)"rbd", (rbd_dev->spec)->image_id, & vaf);
  } else {
#line 508
    printk("\f%s: rbd_dev %p: %pV\n", (char *)"rbd", rbd_dev, & vaf);
  }
#line 510
  ldv__builtin_va_end((va_list *)(& args));
#line 511
  return;
}
}
#line 526
static int rbd_img_obj_request_submit(struct rbd_obj_request *obj_request ) ;
#line 527
static void rbd_img_parent_read(struct rbd_obj_request *obj_request ) ;
#line 528
static void rbd_dev_remove_parent(struct rbd_device *rbd_dev ) ;
#line 530
static int rbd_dev_refresh(struct rbd_device *rbd_dev ) ;
#line 531
static int rbd_dev_v2_header_onetime(struct rbd_device *rbd_dev ) ;
#line 532
static int rbd_dev_header_info(struct rbd_device *rbd_dev ) ;
#line 533
static int rbd_dev_v2_parent_info(struct rbd_device *rbd_dev ) ;
#line 534
static char const   *rbd_dev_v2_snap_name(struct rbd_device *rbd_dev , u64 snap_id ) ;
#line 536
static int _rbd_dev_v2_snap_size(struct rbd_device *rbd_dev , u64 snap_id , u8 *order ,
                                 u64 *snap_size ) ;
#line 538
static int _rbd_dev_v2_snap_features(struct rbd_device *rbd_dev , u64 snap_id , u64 *snap_features ) ;
#line 540
static u64 rbd_snap_id_by_name(struct rbd_device *rbd_dev , char const   *name ) ;
#line 542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_open(struct block_device *bdev , fmode_t mode ) 
{ 
  struct rbd_device *rbd_dev ;
  bool removing ;
  int tmp ;

  {
#line 544
  rbd_dev = (struct rbd_device *)(bdev->bd_disk)->private_data;
#line 545
  removing = 0;
#line 547
  if ((mode & 2U) != 0U && (int )rbd_dev->mapping.read_only) {
#line 548
    return (-30);
  } else {

  }
#line 550
  spin_lock_irq(& rbd_dev->lock);
#line 551
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& rbd_dev->flags));
#line 551
  if (tmp != 0) {
#line 552
    removing = 1;
  } else {
#line 554
    rbd_dev->open_count = rbd_dev->open_count + 1UL;
  }
#line 555
  spin_unlock_irq(& rbd_dev->lock);
#line 556
  if ((int )removing) {
#line 557
    return (-2);
  } else {

  }
#line 559
  get_device(& rbd_dev->dev);
#line 561
  return (0);
}
}
#line 564 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_release(struct gendisk *disk , fmode_t mode ) 
{ 
  struct rbd_device *rbd_dev ;
  unsigned long open_count_before ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 566
  rbd_dev = (struct rbd_device *)disk->private_data;
#line 569
  spin_lock_irq(& rbd_dev->lock);
#line 570
  tmp = rbd_dev->open_count;
#line 570
  rbd_dev->open_count = rbd_dev->open_count - 1UL;
#line 570
  open_count_before = tmp;
#line 571
  spin_unlock_irq(& rbd_dev->lock);
#line 572
  tmp___0 = ldv__builtin_expect(open_count_before == 0UL, 0L);
#line 572
  if (tmp___0 != 0L) {
#line 572
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_release",
           572, (char *)"open_count_before > 0");
#line 572
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (572), "i" (12UL));
    ldv_37463: ;
#line 572
    goto ldv_37463;
  } else {

  }
#line 574
  put_device(& rbd_dev->dev);
#line 575
  return;
}
}
#line 577 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_ioctl_set_ro(struct rbd_device *rbd_dev , unsigned long arg ) 
{ 
  int ret ;
  int val ;
  bool ro ;
  bool ro_changed ;
  int __ret_gu ;
  register unsigned long __val_gu ;

  {
#line 579
  ret = 0;
#line 582
  ro_changed = 0;
#line 585
  __might_fault("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                585);
#line 585
  __asm__  volatile   ("call __get_user_%P3": "=a" (__ret_gu), "=r" (__val_gu): "0" ((int *)arg),
                       "i" (4UL));
#line 585
  val = (int )__val_gu;
#line 585
  if (__ret_gu != 0) {
#line 586
    return (-14);
  } else {

  }
#line 588
  ro = val != 0;
#line 590
  if ((rbd_dev->spec)->snap_id != 0xfffffffffffffffeULL && ! ro) {
#line 591
    return (-30);
  } else {

  }
#line 593
  spin_lock_irq(& rbd_dev->lock);
#line 595
  if (rbd_dev->open_count > 1UL) {
#line 596
    ret = -16;
#line 597
    goto out;
  } else {

  }
#line 600
  if ((int )rbd_dev->mapping.read_only != (int )ro) {
#line 601
    rbd_dev->mapping.read_only = ro;
#line 602
    ro_changed = 1;
  } else {

  }
  out: 
#line 606
  spin_unlock_irq(& rbd_dev->lock);
#line 608
  if (ret == 0 && (int )ro_changed) {
#line 609
    set_disk_ro(rbd_dev->disk, (int )ro);
  } else {

  }
#line 611
  return (ret);
}
}
#line 614 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_ioctl(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                     unsigned long arg ) 
{ 
  struct rbd_device *rbd_dev ;
  int ret ;

  {
#line 617
  rbd_dev = (struct rbd_device *)(bdev->bd_disk)->private_data;
#line 618
  ret = 0;
#line 620
  switch (cmd) {
  case 4701U: 
#line 622
  ret = rbd_ioctl_set_ro(rbd_dev, arg);
#line 623
  goto ldv_37485;
  default: 
#line 625
  ret = -25;
  }
  ldv_37485: ;
#line 628
  return (ret);
}
}
#line 632 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_compat_ioctl(struct block_device *bdev , fmode_t mode , unsigned int cmd ,
                            unsigned long arg ) 
{ 
  int tmp ;

  {
#line 635
  tmp = rbd_ioctl(bdev, mode, cmd, arg);
#line 635
  return (tmp);
}
}
#line 639 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct block_device_operations  const  rbd_bd_ops  = 
#line 639
     {& rbd_open, & rbd_release, 0, & rbd_ioctl, & rbd_compat_ioctl, 0, 0, 0, 0, 0,
    0, 0, & __this_module};
#line 653 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct rbd_client *rbd_client_create(struct ceph_options *ceph_opts ) 
{ 
  struct rbd_client *rbdc ;
  int ret ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  bool tmp___2 ;
  struct _ddebug descriptor___0 ;
  char const   *tmp___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___1 ;
  char const   *tmp___5 ;
  long tmp___6 ;
  void *tmp___7 ;

  {
#line 656
  ret = -12;
#line 658
  descriptor.modname = "rbd";
#line 658
  descriptor.function = "rbd_client_create";
#line 658
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 658
  descriptor.format = "%.*s %12.12s:%-4d : %s:\n";
#line 658
  descriptor.lineno = 658U;
#line 658
  descriptor.flags = 0U;
#line 658
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 658
  if (tmp___0 != 0L) {
#line 658
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 658
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s:\n", 4, (char *)"    ",
                       tmp, 658, "rbd_client_create");
  } else {

  }
#line 659
  tmp___1 = kmalloc(32UL, 208U);
#line 659
  rbdc = (struct rbd_client *)tmp___1;
#line 660
  if ((unsigned long )rbdc == (unsigned long )((struct rbd_client *)0)) {
#line 661
    goto out_opt;
  } else {

  }
#line 663
  kref_init(& rbdc->kref);
#line 664
  INIT_LIST_HEAD(& rbdc->node);
#line 666
  rbdc->client = ceph_create_client(ceph_opts, (void *)rbdc, 0ULL, 0ULL);
#line 667
  tmp___2 = IS_ERR((void const   *)rbdc->client);
#line 667
  if ((int )tmp___2) {
#line 668
    goto out_rbdc;
  } else {

  }
#line 669
  ceph_opts = (struct ceph_options *)0;
#line 671
  ret = ceph_open_session(rbdc->client);
#line 672
  if (ret < 0) {
#line 673
    goto out_client;
  } else {

  }
#line 675
  spin_lock(& rbd_client_list_lock);
#line 676
  list_add_tail(& rbdc->node, & rbd_client_list);
#line 677
  spin_unlock(& rbd_client_list_lock);
#line 679
  descriptor___0.modname = "rbd";
#line 679
  descriptor___0.function = "rbd_client_create";
#line 679
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 679
  descriptor___0.format = "%.*s %12.12s:%-4d : %s: rbdc %p\n";
#line 679
  descriptor___0.lineno = 679U;
#line 679
  descriptor___0.flags = 0U;
#line 679
  tmp___4 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 679
  if (tmp___4 != 0L) {
#line 679
    tmp___3 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 679
    __dynamic_pr_debug(& descriptor___0, "rbd: %.*s %12.12s:%-4d : %s: rbdc %p\n",
                       4, (char *)"    ", tmp___3, 679, "rbd_client_create", rbdc);
  } else {

  }
#line 681
  return (rbdc);
  out_client: 
#line 683
  ceph_destroy_client(rbdc->client);
  out_rbdc: 
#line 685
  kfree((void const   *)rbdc);
  out_opt: ;
#line 687
  if ((unsigned long )ceph_opts != (unsigned long )((struct ceph_options *)0)) {
#line 688
    ceph_destroy_options(ceph_opts);
  } else {

  }
#line 689
  descriptor___1.modname = "rbd";
#line 689
  descriptor___1.function = "rbd_client_create";
#line 689
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 689
  descriptor___1.format = "%.*s %12.12s:%-4d : %s: error %d\n";
#line 689
  descriptor___1.lineno = 689U;
#line 689
  descriptor___1.flags = 0U;
#line 689
  tmp___6 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 689
  if (tmp___6 != 0L) {
#line 689
    tmp___5 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 689
    __dynamic_pr_debug(& descriptor___1, "rbd: %.*s %12.12s:%-4d : %s: error %d\n",
                       4, (char *)"    ", tmp___5, 689, "rbd_client_create", ret);
  } else {

  }
#line 691
  tmp___7 = ERR_PTR((long )ret);
#line 691
  return ((struct rbd_client *)tmp___7);
}
}
#line 694 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct rbd_client *__rbd_get_client(struct rbd_client *rbdc ) 
{ 


  {
#line 696
  kref_get(& rbdc->kref);
#line 698
  return (rbdc);
}
}
#line 705 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct rbd_client *rbd_client_find(struct ceph_options *ceph_opts ) 
{ 
  struct rbd_client *client_node ;
  bool found ;
  struct list_head  const  *__mptr ;
  int tmp ;
  struct list_head  const  *__mptr___0 ;

  {
#line 708
  found = 0;
#line 710
  if ((ceph_opts->flags & 2) != 0) {
#line 711
    return ((struct rbd_client *)0);
  } else {

  }
#line 713
  spin_lock(& rbd_client_list_lock);
#line 714
  __mptr = (struct list_head  const  *)rbd_client_list.next;
#line 714
  client_node = (struct rbd_client *)__mptr + 0xfffffffffffffff0UL;
#line 714
  goto ldv_37520;
  ldv_37519: 
#line 715
  tmp = ceph_compare_options(ceph_opts, client_node->client);
#line 715
  if (tmp == 0) {
#line 716
    __rbd_get_client(client_node);
#line 718
    found = 1;
#line 719
    goto ldv_37518;
  } else {

  }
#line 714
  __mptr___0 = (struct list_head  const  *)client_node->node.next;
#line 714
  client_node = (struct rbd_client *)__mptr___0 + 0xfffffffffffffff0UL;
  ldv_37520: ;
#line 714
  if ((unsigned long )(& client_node->node) != (unsigned long )(& rbd_client_list)) {
#line 716
    goto ldv_37519;
  } else {

  }
  ldv_37518: 
#line 722
  spin_unlock(& rbd_client_list_lock);
#line 724
  return ((int )found ? client_node : (struct rbd_client *)0);
}
}
#line 741 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct match_token rbd_opts_tokens[6U]  = {      {0, "queue_depth=%d"}, 
        {3, "read_only"}, 
        {3, "ro"}, 
        {4, "read_write"}, 
        {4, "rw"}, 
        {5, (char const   *)0}};
#line 760 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int parse_rbd_opts_token(char *c , void *private ) 
{ 
  struct rbd_options *rbd_opts ;
  substring_t argstr[3U] ;
  int token ;
  int intval ;
  int ret ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  char const   *tmp___3 ;
  long tmp___4 ;

  {
#line 762
  rbd_opts = (struct rbd_options *)private;
#line 766
  token = match_token(c, (struct match_token  const  *)(& rbd_opts_tokens), (substring_t *)(& argstr));
#line 767
  if (token <= 0) {
#line 768
    ret = match_int((substring_t *)(& argstr), & intval);
#line 769
    if (ret < 0) {
#line 770
      printk("\vrbd: bad mount option arg (not int) at \'%s\'\n", c);
#line 771
      return (ret);
    } else {

    }
#line 773
    descriptor.modname = "rbd";
#line 773
    descriptor.function = "parse_rbd_opts_token";
#line 773
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 773
    descriptor.format = "%.*s %12.12s:%-4d : got int token %d val %d\n";
#line 773
    descriptor.lineno = 773U;
#line 773
    descriptor.flags = 0U;
#line 773
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 773
    if (tmp___0 != 0L) {
#line 773
      tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                           199);
#line 773
      __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : got int token %d val %d\n",
                         4, (char *)"    ", tmp, 773, token, intval);
    } else {

    }
  } else
#line 774
  if (token > 1 && token <= 1) {
#line 775
    descriptor___0.modname = "rbd";
#line 775
    descriptor___0.function = "parse_rbd_opts_token";
#line 775
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 775
    descriptor___0.format = "%.*s %12.12s:%-4d : got string token %d val %s\n";
#line 775
    descriptor___0.lineno = 775U;
#line 775
    descriptor___0.flags = 0U;
#line 775
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 775
    if (tmp___2 != 0L) {
#line 775
      tmp___1 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                               199);
#line 775
      __dynamic_pr_debug(& descriptor___0, "rbd: %.*s %12.12s:%-4d : got string token %d val %s\n",
                         4, (char *)"    ", tmp___1, 775, token, argstr[0].from);
    } else {

    }
  } else {
#line 777
    descriptor___1.modname = "rbd";
#line 777
    descriptor___1.function = "parse_rbd_opts_token";
#line 777
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 777
    descriptor___1.format = "%.*s %12.12s:%-4d : got token %d\n";
#line 777
    descriptor___1.lineno = 777U;
#line 777
    descriptor___1.flags = 0U;
#line 777
    tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 777
    if (tmp___4 != 0L) {
#line 777
      tmp___3 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                               199);
#line 777
      __dynamic_pr_debug(& descriptor___1, "rbd: %.*s %12.12s:%-4d : got token %d\n",
                         4, (char *)"    ", tmp___3, 777, token);
    } else {

    }
  }
#line 780
  switch (token) {
  case 0: ;
#line 782
  if (intval <= 0) {
#line 783
    printk("\vrbd: queue_depth out of range\n");
#line 784
    return (-22);
  } else {

  }
#line 786
  rbd_opts->queue_depth = intval;
#line 787
  goto ldv_37545;
  case 3: 
#line 789
  rbd_opts->read_only = 1;
#line 790
  goto ldv_37545;
  case 4: 
#line 792
  rbd_opts->read_only = 0;
#line 793
  goto ldv_37545;
  default: ;
#line 796
  return (-22);
  }
  ldv_37545: ;
#line 799
  return (0);
}
}
#line 802 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static char *obj_op_name(enum obj_operation_type op_type ) 
{ 


  {
#line 804
  switch ((unsigned int )op_type) {
  case 1U: ;
#line 806
  return ((char *)"read");
  case 0U: ;
#line 808
  return ((char *)"write");
  case 2U: ;
#line 810
  return ((char *)"discard");
  default: ;
#line 812
  return ((char *)"???");
  }
}
}
#line 821 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct rbd_client *rbd_get_client(struct ceph_options *ceph_opts ) 
{ 
  struct rbd_client *rbdc ;

  {
#line 825
  ldv_mutex_lock_nested_17(& client_mutex, 1U);
#line 826
  rbdc = rbd_client_find(ceph_opts);
#line 827
  if ((unsigned long )rbdc != (unsigned long )((struct rbd_client *)0)) {
#line 828
    ceph_destroy_options(ceph_opts);
  } else {
#line 830
    rbdc = rbd_client_create(ceph_opts);
  }
#line 831
  ldv_mutex_unlock_18(& client_mutex);
#line 833
  return (rbdc);
}
}
#line 841 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_client_release(struct kref *kref ) 
{ 
  struct rbd_client *rbdc ;
  struct kref  const  *__mptr ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;

  {
#line 843
  __mptr = (struct kref  const  *)kref;
#line 843
  rbdc = (struct rbd_client *)__mptr + 0xfffffffffffffff8UL;
#line 845
  descriptor.modname = "rbd";
#line 845
  descriptor.function = "rbd_client_release";
#line 845
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 845
  descriptor.format = "%.*s %12.12s:%-4d : %s: rbdc %p\n";
#line 845
  descriptor.lineno = 845U;
#line 845
  descriptor.flags = 0U;
#line 845
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 845
  if (tmp___0 != 0L) {
#line 845
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 845
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: rbdc %p\n", 4,
                       (char *)"    ", tmp, 845, "rbd_client_release", rbdc);
  } else {

  }
#line 846
  spin_lock(& rbd_client_list_lock);
#line 847
  list_del(& rbdc->node);
#line 848
  spin_unlock(& rbd_client_list_lock);
#line 850
  ceph_destroy_client(rbdc->client);
#line 851
  kfree((void const   *)rbdc);
#line 852
  return;
}
}
#line 858 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_put_client(struct rbd_client *rbdc ) 
{ 


  {
#line 860
  if ((unsigned long )rbdc != (unsigned long )((struct rbd_client *)0)) {
#line 861
    kref_put(& rbdc->kref, & rbd_client_release);
  } else {

  }
#line 862
  return;
}
}
#line 864 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static bool rbd_image_format_valid(u32 image_format ) 
{ 


  {
#line 866
  return ((bool )(image_format == 1U || image_format == 2U));
}
}
#line 869 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static bool rbd_dev_ondisk_valid(struct rbd_image_header_ondisk *ondisk ) 
{ 
  size_t size ;
  u32 snap_count ;
  int tmp ;

  {
#line 875
  tmp = memcmp((void const   *)(& ondisk->text), (void const   *)"<<< Rados Block Device Image >>>\n",
               34UL);
#line 875
  if (tmp != 0) {
#line 876
    return (0);
  } else {

  }
#line 880
  if ((unsigned int )ondisk->options.order <= 8U) {
#line 881
    return (0);
  } else {

  }
#line 885
  if ((unsigned int )ondisk->options.order > 31U) {
#line 886
    return (0);
  } else {

  }
#line 892
  snap_count = ondisk->snap_count;
#line 893
  size = 0xffffffffffffffe7UL;
#line 894
  if ((unsigned long )snap_count > size / 8UL) {
#line 895
    return (0);
  } else {

  }
#line 901
  size = size - (unsigned long )snap_count * 8UL;
#line 902
  if (ondisk->snap_names_len > (unsigned long long )size) {
#line 903
    return (0);
  } else {

  }
#line 905
  return (1);
}
}
#line 912 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_header_from_disk(struct rbd_device *rbd_dev , struct rbd_image_header_ondisk *ondisk ) 
{ 
  struct rbd_image_header *header ;
  bool first_time ;
  struct ceph_snap_context *snapc ;
  char *object_prefix ;
  char *snap_names ;
  u64 *snap_sizes ;
  u32 snap_count ;
  size_t size ;
  int ret ;
  u32 i ;
  size_t len ;
  void *tmp ;
  struct rbd_image_snap_ondisk *snaps ;
  u64 snap_names_len ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 915
  header = & rbd_dev->header;
#line 916
  first_time = (unsigned long )header->object_prefix == (unsigned long )((char *)0);
#line 918
  object_prefix = (char *)0;
#line 919
  snap_names = (char *)0;
#line 920
  snap_sizes = (u64 *)0ULL;
#line 923
  ret = -12;
#line 928
  if ((int )first_time) {
#line 931
    len = strnlen((char const   *)(& ondisk->object_prefix), 24UL);
#line 933
    tmp = kmalloc(len + 1UL, 208U);
#line 933
    object_prefix = (char *)tmp;
#line 934
    if ((unsigned long )object_prefix == (unsigned long )((char *)0)) {
#line 935
      return (-12);
    } else {

    }
#line 936
    memcpy((void *)object_prefix, (void const   *)(& ondisk->object_prefix), len);
#line 937
    *(object_prefix + len) = 0;
  } else {

  }
#line 942
  snap_count = ondisk->snap_count;
#line 943
  snapc = ceph_create_snap_context(snap_count, 208U);
#line 944
  if ((unsigned long )snapc == (unsigned long )((struct ceph_snap_context *)0)) {
#line 945
    goto out_err;
  } else {

  }
#line 946
  snapc->seq = ondisk->snap_seq;
#line 947
  if (snap_count != 0U) {
#line 949
    snap_names_len = ondisk->snap_names_len;
#line 955
    tmp___0 = kmalloc((size_t )snap_names_len, 208U);
#line 955
    snap_names = (char *)tmp___0;
#line 956
    if ((unsigned long )snap_names == (unsigned long )((char *)0)) {
#line 957
      goto out_err;
    } else {

    }
#line 961
    size = (unsigned long )snap_count * 8UL;
#line 962
    tmp___1 = kmalloc(size, 208U);
#line 962
    snap_sizes = (u64 *)tmp___1;
#line 963
    if ((unsigned long )snap_sizes == (unsigned long )((u64 *)0ULL)) {
#line 964
      goto out_err;
    } else {

    }
#line 975
    memcpy((void *)snap_names, (void const   *)(& ondisk->snaps) + (unsigned long )snap_count,
             (size_t )snap_names_len);
#line 976
    snaps = (struct rbd_image_snap_ondisk *)(& ondisk->snaps);
#line 977
    i = 0U;
#line 977
    goto ldv_37599;
    ldv_37598: 
#line 978
    snapc->snaps[i] = (snaps + (unsigned long )i)->id;
#line 979
    *(snap_sizes + (unsigned long )i) = (snaps + (unsigned long )i)->image_size;
#line 977
    i = i + 1U;
    ldv_37599: ;
#line 977
    if (i < snap_count) {
#line 979
      goto ldv_37598;
    } else {

    }

  } else {

  }
#line 985
  if ((int )first_time) {
#line 986
    header->object_prefix = object_prefix;
#line 987
    header->obj_order = ondisk->options.order;
#line 988
    header->crypt_type = ondisk->options.crypt_type;
#line 989
    header->comp_type = ondisk->options.comp_type;
#line 991
    header->stripe_unit = 0ULL;
#line 992
    header->stripe_count = 0ULL;
#line 993
    header->features = 0ULL;
  } else {
#line 995
    ceph_put_snap_context(header->snapc);
#line 996
    kfree((void const   *)header->snap_names);
#line 997
    kfree((void const   *)header->snap_sizes);
  }
#line 1002
  header->image_size = ondisk->image_size;
#line 1003
  header->snapc = snapc;
#line 1004
  header->snap_names = snap_names;
#line 1005
  header->snap_sizes = snap_sizes;
#line 1007
  return (0);
#line 1009
  ret = -5;
  out_err: 
#line 1011
  kfree((void const   *)snap_sizes);
#line 1012
  kfree((void const   *)snap_names);
#line 1013
  ceph_put_snap_context(snapc);
#line 1014
  kfree((void const   *)object_prefix);
#line 1016
  return (ret);
}
}
#line 1019 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static char const   *_rbd_dev_v1_snap_name(struct rbd_device *rbd_dev , u32 which ) 
{ 
  char const   *snap_name ;
  long tmp ;
  size_t tmp___0 ;
  u32 tmp___1 ;
  char *tmp___2 ;

  {
#line 1023
  tmp = ldv__builtin_expect((rbd_dev->header.snapc)->num_snaps <= which, 0L);
#line 1023
  if (tmp != 0L) {
#line 1023
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "_rbd_dev_v1_snap_name",
           1023, (char *)"which < rbd_dev->header.snapc->num_snaps");
#line 1023
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1023), "i" (12UL));
    ldv_37607: ;
#line 1023
    goto ldv_37607;
  } else {

  }
#line 1027
  snap_name = (char const   *)rbd_dev->header.snap_names;
#line 1028
  goto ldv_37609;
  ldv_37608: 
#line 1029
  tmp___0 = strlen(snap_name);
#line 1029
  snap_name = snap_name + (tmp___0 + 1UL);
  ldv_37609: 
#line 1028
  tmp___1 = which;
#line 1028
  which = which - 1U;
#line 1028
  if (tmp___1 != 0U) {
#line 1030
    goto ldv_37608;
  } else {

  }
#line 1031
  tmp___2 = kstrdup(snap_name, 208U);
#line 1031
  return ((char const   *)tmp___2);
}
}
#line 1038 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int snapid_compare_reverse(void const   *s1 , void const   *s2 ) 
{ 
  u64 snap_id1 ;
  u64 snap_id2 ;

  {
#line 1040
  snap_id1 = *((u64 *)s1);
#line 1041
  snap_id2 = *((u64 *)s2);
#line 1043
  if (snap_id1 < snap_id2) {
#line 1044
    return (1);
  } else {

  }
#line 1045
  return (snap_id1 == snap_id2 ? 0 : -1);
}
}
#line 1058 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static u32 rbd_dev_snap_index(struct rbd_device *rbd_dev , u64 snap_id ) 
{ 
  struct ceph_snap_context *snapc ;
  u64 *found ;
  void *tmp ;

  {
#line 1060
  snapc = rbd_dev->header.snapc;
#line 1063
  tmp = bsearch((void const   *)(& snap_id), (void const   *)(& snapc->snaps), (size_t )snapc->num_snaps,
                8UL, & snapid_compare_reverse);
#line 1063
  found = (u64 *)tmp;
#line 1066
  return ((unsigned long )found != (unsigned long )((u64 *)0ULL) ? (u32 )(((long )found - (long )(& snapc->snaps)) / 8L) : 4294967295U);
}
}
#line 1069 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static char const   *rbd_dev_v1_snap_name(struct rbd_device *rbd_dev , u64 snap_id ) 
{ 
  u32 which ;
  char const   *snap_name ;
  void *tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1075
  which = rbd_dev_snap_index(rbd_dev, snap_id);
#line 1076
  if (which == 4294967295U) {
#line 1077
    tmp = ERR_PTR(-2L);
#line 1077
    return ((char const   *)tmp);
  } else {

  }
#line 1079
  snap_name = _rbd_dev_v1_snap_name(rbd_dev, which);
#line 1080
  if ((unsigned long )snap_name == (unsigned long )((char const   *)0)) {
#line 1080
    tmp___0 = ERR_PTR(-12L);
#line 1080
    tmp___1 = (char const   *)tmp___0;
  } else {
#line 1080
    tmp___1 = snap_name;
  }
#line 1080
  return (tmp___1);
}
}
#line 1083 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static char const   *rbd_snap_name(struct rbd_device *rbd_dev , u64 snap_id ) 
{ 
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 1085
  if (snap_id == 0xfffffffffffffffeULL) {
#line 1086
    return ("-");
  } else {

  }
#line 1088
  tmp = rbd_image_format_valid(rbd_dev->image_format);
#line 1088
  if (tmp) {
#line 1088
    tmp___0 = 0;
  } else {
#line 1088
    tmp___0 = 1;
  }
#line 1088
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 1088
  if (tmp___1 != 0L) {
#line 1088
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_snap_name",
           1088, (char *)"rbd_image_format_valid(rbd_dev->image_format)");
#line 1088
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1088), "i" (12UL));
    ldv_37634: ;
#line 1088
    goto ldv_37634;
  } else {

  }
#line 1089
  if (rbd_dev->image_format == 1U) {
#line 1090
    tmp___2 = rbd_dev_v1_snap_name(rbd_dev, snap_id);
#line 1090
    return (tmp___2);
  } else {

  }
#line 1092
  tmp___3 = rbd_dev_v2_snap_name(rbd_dev, snap_id);
#line 1092
  return (tmp___3);
}
}
#line 1095 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_snap_size(struct rbd_device *rbd_dev , u64 snap_id , u64 *snap_size ) 
{ 
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  u32 which ;
  u64 size ;
  int ret ;

  {
#line 1098
  tmp = rbd_image_format_valid(rbd_dev->image_format);
#line 1098
  if (tmp) {
#line 1098
    tmp___0 = 0;
  } else {
#line 1098
    tmp___0 = 1;
  }
#line 1098
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 1098
  if (tmp___1 != 0L) {
#line 1098
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_snap_size",
           1098, (char *)"rbd_image_format_valid(rbd_dev->image_format)");
#line 1098
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1098), "i" (12UL));
    ldv_37641: ;
#line 1098
    goto ldv_37641;
  } else {

  }
#line 1099
  if (snap_id == 0xfffffffffffffffeULL) {
#line 1100
    *snap_size = rbd_dev->header.image_size;
  } else
#line 1101
  if (rbd_dev->image_format == 1U) {
#line 1104
    which = rbd_dev_snap_index(rbd_dev, snap_id);
#line 1105
    if (which == 4294967295U) {
#line 1106
      return (-2);
    } else {

    }
#line 1108
    *snap_size = *(rbd_dev->header.snap_sizes + (unsigned long )which);
  } else {
#line 1110
    size = 0ULL;
#line 1113
    ret = _rbd_dev_v2_snap_size(rbd_dev, snap_id, (u8 *)0U, & size);
#line 1114
    if (ret != 0) {
#line 1115
      return (ret);
    } else {

    }
#line 1117
    *snap_size = size;
  }
#line 1119
  return (0);
}
}
#line 1122 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_snap_features(struct rbd_device *rbd_dev , u64 snap_id , u64 *snap_features ) 
{ 
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  u64 features ;
  int ret ;

  {
#line 1125
  tmp = rbd_image_format_valid(rbd_dev->image_format);
#line 1125
  if (tmp) {
#line 1125
    tmp___0 = 0;
  } else {
#line 1125
    tmp___0 = 1;
  }
#line 1125
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 1125
  if (tmp___1 != 0L) {
#line 1125
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_snap_features",
           1125, (char *)"rbd_image_format_valid(rbd_dev->image_format)");
#line 1125
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1125), "i" (12UL));
    ldv_37651: ;
#line 1125
    goto ldv_37651;
  } else {

  }
#line 1126
  if (snap_id == 0xfffffffffffffffeULL) {
#line 1127
    *snap_features = rbd_dev->header.features;
  } else
#line 1128
  if (rbd_dev->image_format == 1U) {
#line 1129
    *snap_features = 0ULL;
  } else {
#line 1131
    features = 0ULL;
#line 1134
    ret = _rbd_dev_v2_snap_features(rbd_dev, snap_id, & features);
#line 1135
    if (ret != 0) {
#line 1136
      return (ret);
    } else {

    }
#line 1138
    *snap_features = features;
  }
#line 1140
  return (0);
}
}
#line 1143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_mapping_set(struct rbd_device *rbd_dev ) 
{ 
  u64 snap_id ;
  u64 size ;
  u64 features ;
  int ret ;

  {
#line 1145
  snap_id = (rbd_dev->spec)->snap_id;
#line 1146
  size = 0ULL;
#line 1147
  features = 0ULL;
#line 1150
  ret = rbd_snap_size(rbd_dev, snap_id, & size);
#line 1151
  if (ret != 0) {
#line 1152
    return (ret);
  } else {

  }
#line 1153
  ret = rbd_snap_features(rbd_dev, snap_id, & features);
#line 1154
  if (ret != 0) {
#line 1155
    return (ret);
  } else {

  }
#line 1157
  rbd_dev->mapping.size = size;
#line 1158
  rbd_dev->mapping.features = features;
#line 1160
  return (0);
}
}
#line 1163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_dev_mapping_clear(struct rbd_device *rbd_dev ) 
{ 


  {
#line 1165
  rbd_dev->mapping.size = 0ULL;
#line 1166
  rbd_dev->mapping.features = 0ULL;
#line 1167
  return;
}
}
#line 1169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_segment_name_free(char const   *name ) 
{ 


  {
#line 1173
  kmem_cache_free(rbd_segment_name_cache, (void *)name);
#line 1174
  return;
}
}
#line 1176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static char const   *rbd_segment_name(struct rbd_device *rbd_dev , u64 offset ) 
{ 
  char *name ;
  u64 segment ;
  int ret ;
  char *name_format ;
  void *tmp ;

  {
#line 1183
  tmp = kmem_cache_alloc(rbd_segment_name_cache, 16U);
#line 1183
  name = (char *)tmp;
#line 1184
  if ((unsigned long )name == (unsigned long )((char *)0)) {
#line 1185
    return ((char const   *)0);
  } else {

  }
#line 1186
  segment = offset >> (int )rbd_dev->header.obj_order;
#line 1187
  name_format = (char *)"%s.%012llx";
#line 1188
  if (rbd_dev->image_format == 2U) {
#line 1189
    name_format = (char *)"%s.%016llx";
  } else {

  }
#line 1190
  ret = snprintf(name, 101UL, (char const   *)name_format, rbd_dev->header.object_prefix,
                 segment);
#line 1192
  if (ret < 0 || ret > 100) {
#line 1193
    printk("\vrbd: error formatting segment name for #%llu (%d)\n", segment, ret);
#line 1195
    rbd_segment_name_free((char const   *)name);
#line 1196
    name = (char *)0;
  } else {

  }
#line 1199
  return ((char const   *)name);
}
}
#line 1202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static u64 rbd_segment_offset(struct rbd_device *rbd_dev , u64 offset ) 
{ 
  u64 segment_size ;

  {
#line 1204
  segment_size = 1ULL << (int )rbd_dev->header.obj_order;
#line 1206
  return ((segment_size - 1ULL) & offset);
}
}
#line 1209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static u64 rbd_segment_length(struct rbd_device *rbd_dev , u64 offset , u64 length ) 
{ 
  u64 segment_size ;
  long tmp ;

  {
#line 1212
  segment_size = 1ULL << (int )rbd_dev->header.obj_order;
#line 1214
  offset = (segment_size - 1ULL) & offset;
#line 1216
  tmp = ldv__builtin_expect(~ offset < length, 0L);
#line 1216
  if (tmp != 0L) {
#line 1216
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_segment_length",
           1216, (char *)"length <= U64_MAX - offset");
#line 1216
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1216), "i" (12UL));
    ldv_37687: ;
#line 1216
    goto ldv_37687;
  } else {

  }
#line 1217
  if (offset + length > segment_size) {
#line 1218
    length = segment_size - offset;
  } else {

  }
#line 1220
  return (length);
}
}
#line 1226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static u64 rbd_obj_bytes(struct rbd_image_header *header ) 
{ 


  {
#line 1228
  return ((u64 )(1 << (int )header->obj_order));
}
}
#line 1235 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void bio_chain_put(struct bio *chain ) 
{ 
  struct bio *tmp ;

  {
#line 1239
  goto ldv_37696;
  ldv_37695: 
#line 1240
  tmp = chain;
#line 1241
  chain = chain->bi_next;
#line 1242
  bio_put(tmp);
  ldv_37696: ;
#line 1239
  if ((unsigned long )chain != (unsigned long )((struct bio *)0)) {
#line 1241
    goto ldv_37695;
  } else {

  }

#line 1246
  return;
}
}
#line 1249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void zero_bio_chain(struct bio *chain , int start_ofs ) 
{ 
  struct bio_vec bv ;
  struct bvec_iter iter ;
  unsigned long flags ;
  void *buf ;
  int pos ;
  int remainder ;
  int _max1 ;
  int _max2 ;
  char *tmp ;
  struct bio_vec __constr_expr_0 ;
  unsigned int _min1 ;
  unsigned int _min2 ;

  {
#line 1255
  pos = 0;
#line 1257
  goto ldv_37719;
  ldv_37718: 
#line 1258
  iter = chain->bi_iter;
#line 1258
  goto ldv_37716;
  ldv_37715: ;
#line 1259
  if (bv.bv_len + (unsigned int )pos > (unsigned int )start_ofs) {
#line 1260
    _max1 = start_ofs - pos;
#line 1260
    _max2 = 0;
#line 1260
    remainder = _max1 > _max2 ? _max1 : _max2;
#line 1261
    tmp = bvec_kmap_irq(& bv, & flags);
#line 1261
    buf = (void *)tmp;
#line 1262
    memset(buf + (unsigned long )remainder, 0, (size_t )(bv.bv_len - (unsigned int )remainder));
#line 1265
    bvec_kunmap_irq((char *)buf, & flags);
  } else {

  }
#line 1267
  pos = (int )(bv.bv_len + (unsigned int )pos);
#line 1258
  bio_advance_iter(chain, & iter, bv.bv_len);
  ldv_37716: ;
#line 1258
  if (iter.bi_size != 0U) {
#line 1258
    _min1 = iter.bi_size;
#line 1258
    _min2 = (chain->bi_io_vec + (unsigned long )iter.bi_idx)->bv_len - iter.bi_bvec_done;
#line 1258
    __constr_expr_0.bv_page = (chain->bi_io_vec + (unsigned long )iter.bi_idx)->bv_page;
#line 1258
    __constr_expr_0.bv_len = _min1 < _min2 ? _min1 : _min2;
#line 1258
    __constr_expr_0.bv_offset = (chain->bi_io_vec + (unsigned long )iter.bi_idx)->bv_offset + iter.bi_bvec_done;
#line 1258
    bv = __constr_expr_0;
#line 1260
    goto ldv_37715;
  } else {

  }
#line 1270
  chain = chain->bi_next;
  ldv_37719: ;
#line 1257
  if ((unsigned long )chain != (unsigned long )((struct bio *)0)) {
#line 1259
    goto ldv_37718;
  } else {

  }

#line 1264
  return;
}
}
#line 1280 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void zero_pages(struct page **pages , u64 offset , u64 end ) 
{ 
  struct page **page ;
  long tmp ;
  long tmp___0 ;
  size_t page_offset___0 ;
  size_t length ;
  unsigned long flags ;
  void *kaddr ;
  size_t __min1 ;
  size_t __min2 ;
  int tmp___1 ;

  {
#line 1282
  page = pages + (offset >> 12);
#line 1284
  tmp = ldv__builtin_expect(end <= offset, 0L);
#line 1284
  if (tmp != 0L) {
#line 1284
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "zero_pages",
           1284, (char *)"end > offset");
#line 1284
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1284), "i" (12UL));
    ldv_37728: ;
#line 1284
    goto ldv_37728;
  } else {

  }
#line 1285
  tmp___0 = ldv__builtin_expect(0L, 0L);
#line 1285
  if (tmp___0 != 0L) {
#line 1285
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "zero_pages",
           1285, (char *)"end - offset <= (u64)SIZE_MAX");
#line 1285
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1285), "i" (12UL));
    ldv_37729: ;
#line 1285
    goto ldv_37729;
  } else {

  }
#line 1286
  goto ldv_37751;
  ldv_37750: 
#line 1292
  page_offset___0 = (size_t )offset & 4095UL;
#line 1293
  __min1 = 4096UL - page_offset___0;
#line 1293
  __min2 = (size_t )(end - offset);
#line 1293
  length = __min1 < __min2 ? __min1 : __min2;
#line 1294
  flags = arch_local_irq_save();
#line 1294
  trace_hardirqs_off();
#line 1295
  kaddr = kmap_atomic(*page);
#line 1296
  memset(kaddr + page_offset___0, 0, length);
#line 1298
  __kunmap_atomic(kaddr);
#line 1299
  tmp___1 = arch_irqs_disabled_flags(flags);
#line 1299
  if (tmp___1 != 0) {
#line 1299
    arch_local_irq_restore(flags);
#line 1299
    trace_hardirqs_off();
  } else {
#line 1299
    trace_hardirqs_on();
#line 1299
    arch_local_irq_restore(flags);
  }
#line 1301
  offset = offset + (unsigned long long )length;
#line 1302
  page = page + 1;
  ldv_37751: ;
#line 1286
  if (offset < end) {
#line 1288
    goto ldv_37750;
  } else {

  }

#line 1293
  return;
}
}
#line 1310 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct bio *bio_clone_range(struct bio *bio_src , unsigned int offset , unsigned int len ,
                                   gfp_t gfpmask ) 
{ 
  struct bio *bio ;

  {
#line 1317
  bio = bio_clone(bio_src, gfpmask);
#line 1318
  if ((unsigned long )bio == (unsigned long )((struct bio *)0)) {
#line 1319
    return ((struct bio *)0);
  } else {

  }
#line 1321
  bio_advance(bio, offset);
#line 1322
  bio->bi_iter.bi_size = len;
#line 1324
  return (bio);
}
}
#line 1341 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct bio *bio_chain_clone_range(struct bio **bio_src , unsigned int *offset ,
                                         unsigned int len , gfp_t gfpmask ) 
{ 
  struct bio *bi ;
  unsigned int off ;
  struct bio *chain ;
  struct bio **end ;
  unsigned int bi_size ;
  struct bio *bio ;
  unsigned int __min1 ;
  unsigned int __min2 ;

  {
#line 1346
  bi = *bio_src;
#line 1347
  off = *offset;
#line 1348
  chain = (struct bio *)0;
#line 1353
  if (((unsigned long )bi == (unsigned long )((struct bio *)0) || bi->bi_iter.bi_size <= off) || len == 0U) {
#line 1354
    return ((struct bio *)0);
  } else {

  }
#line 1356
  end = & chain;
#line 1357
  goto ldv_37777;
  ldv_37776: ;
#line 1361
  if ((unsigned long )bi == (unsigned long )((struct bio *)0)) {
#line 1362
    rbd_warn((struct rbd_device *)0, "bio_chain exhausted with %u left", len);
#line 1363
    goto out_err;
  } else {

  }
#line 1365
  __min1 = bi->bi_iter.bi_size - off;
#line 1365
  __min2 = len;
#line 1365
  bi_size = __min1 < __min2 ? __min1 : __min2;
#line 1366
  bio = bio_clone_range(bi, off, bi_size, gfpmask);
#line 1367
  if ((unsigned long )bio == (unsigned long )((struct bio *)0)) {
#line 1368
    goto out_err;
  } else {

  }
#line 1370
  *end = bio;
#line 1371
  end = & bio->bi_next;
#line 1373
  off = off + bi_size;
#line 1374
  if (bi->bi_iter.bi_size == off) {
#line 1375
    bi = bi->bi_next;
#line 1376
    off = 0U;
  } else {

  }
#line 1378
  len = len - bi_size;
  ldv_37777: ;
#line 1357
  if (len != 0U) {
#line 1359
    goto ldv_37776;
  } else {

  }
#line 1380
  *bio_src = bi;
#line 1381
  *offset = off;
#line 1383
  return (chain);
  out_err: 
#line 1385
  bio_chain_put(chain);
#line 1387
  return ((struct bio *)0);
}
}
#line 1395 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void obj_request_img_data_set(struct rbd_obj_request *obj_request ) 
{ 
  struct rbd_device *rbd_dev ;
  int tmp ;

  {
#line 1397
  tmp = test_and_set_bit(1L, (unsigned long volatile   *)(& obj_request->flags));
#line 1397
  if (tmp != 0) {
#line 1400
    rbd_dev = (obj_request->__annonCompField101.__annonCompField100.img_request)->rbd_dev;
#line 1401
    rbd_warn(rbd_dev, "obj_request %p already marked img_data", obj_request);
  } else {

  }
#line 1403
  return;
}
}
#line 1406 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static bool obj_request_img_data_test(struct rbd_obj_request *obj_request ) 
{ 
  int tmp ;

  {
#line 1408
  __asm__  volatile   ("mfence": : : "memory");
#line 1409
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& obj_request->flags));
#line 1409
  return (tmp != 0);
}
}
#line 1412 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void obj_request_done_set(struct rbd_obj_request *obj_request ) 
{ 
  struct rbd_device *rbd_dev ;
  bool tmp ;
  int tmp___0 ;

  {
#line 1414
  tmp___0 = test_and_set_bit(0L, (unsigned long volatile   *)(& obj_request->flags));
#line 1414
  if (tmp___0 != 0) {
#line 1415
    rbd_dev = (struct rbd_device *)0;
#line 1417
    tmp = obj_request_img_data_test(obj_request);
#line 1417
    if ((int )tmp) {
#line 1418
      rbd_dev = (obj_request->__annonCompField101.__annonCompField100.img_request)->rbd_dev;
    } else {

    }
#line 1419
    rbd_warn(rbd_dev, "obj_request %p already marked done", obj_request);
  } else {

  }
#line 1421
  return;
}
}
#line 1424 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static bool obj_request_done_test(struct rbd_obj_request *obj_request ) 
{ 
  int tmp ;

  {
#line 1426
  __asm__  volatile   ("mfence": : : "memory");
#line 1427
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& obj_request->flags));
#line 1427
  return (tmp != 0);
}
}
#line 1440 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void obj_request_existence_set(struct rbd_obj_request *obj_request , bool exists ) 
{ 


  {
#line 1443
  if ((int )exists) {
#line 1444
    set_bit(3L, (unsigned long volatile   *)(& obj_request->flags));
  } else {

  }
#line 1445
  set_bit(2L, (unsigned long volatile   *)(& obj_request->flags));
#line 1446
  __asm__  volatile   ("mfence": : : "memory");
#line 1447
  return;
}
}
#line 1449 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static bool obj_request_known_test(struct rbd_obj_request *obj_request ) 
{ 
  int tmp ;

  {
#line 1451
  __asm__  volatile   ("mfence": : : "memory");
#line 1452
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& obj_request->flags));
#line 1452
  return (tmp != 0);
}
}
#line 1455 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static bool obj_request_exists_test(struct rbd_obj_request *obj_request ) 
{ 
  int tmp ;

  {
#line 1457
  __asm__  volatile   ("mfence": : : "memory");
#line 1458
  tmp = constant_test_bit(3L, (unsigned long const volatile   *)(& obj_request->flags));
#line 1458
  return (tmp != 0);
}
}
#line 1461 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static bool obj_request_overlaps_parent(struct rbd_obj_request *obj_request ) 
{ 
  struct rbd_device *rbd_dev ;
  u64 tmp ;

  {
#line 1463
  rbd_dev = (obj_request->__annonCompField101.__annonCompField100.img_request)->rbd_dev;
#line 1465
  tmp = rbd_obj_bytes(& rbd_dev->header);
#line 1465
  return (obj_request->__annonCompField101.__annonCompField100.img_offset < ((rbd_dev->parent_overlap - 1ULL) | (tmp - 1ULL)) + 1ULL);
}
}
#line 1469 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_obj_request_get(struct rbd_obj_request *obj_request ) 
{ 
  struct _ddebug descriptor ;
  int tmp ;
  char const   *tmp___0 ;
  long tmp___1 ;

  {
#line 1471
  descriptor.modname = "rbd";
#line 1471
  descriptor.function = "rbd_obj_request_get";
#line 1471
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1471
  descriptor.format = "%.*s %12.12s:%-4d : %s: obj %p (was %d)\n";
#line 1471
  descriptor.lineno = 1472U;
#line 1471
  descriptor.flags = 0U;
#line 1471
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1471
  if (tmp___1 != 0L) {
#line 1471
    tmp = atomic_read((atomic_t const   *)(& obj_request->kref.refcount));
#line 1471
    tmp___0 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 1471
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: obj %p (was %d)\n",
                       4, (char *)"    ", tmp___0, 1472, "rbd_obj_request_get", obj_request,
                       tmp);
  } else {

  }
#line 1473
  kref_get(& obj_request->kref);
#line 1474
  return;
}
}
#line 1476
static void rbd_obj_request_destroy(struct kref *kref ) ;
#line 1477 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_obj_request_put(struct rbd_obj_request *obj_request ) 
{ 
  long tmp ;
  struct _ddebug descriptor ;
  int tmp___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;

  {
#line 1479
  tmp = ldv__builtin_expect((unsigned long )obj_request == (unsigned long )((struct rbd_obj_request *)0),
                         0L);
#line 1479
  if (tmp != 0L) {
#line 1479
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_obj_request_put",
           1479, (char *)"obj_request != NULL");
#line 1479
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1479), "i" (12UL));
    ldv_37818: ;
#line 1479
    goto ldv_37818;
  } else {

  }
#line 1480
  descriptor.modname = "rbd";
#line 1480
  descriptor.function = "rbd_obj_request_put";
#line 1480
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1480
  descriptor.format = "%.*s %12.12s:%-4d : %s: obj %p (was %d)\n";
#line 1480
  descriptor.lineno = 1481U;
#line 1480
  descriptor.flags = 0U;
#line 1480
  tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1480
  if (tmp___2 != 0L) {
#line 1480
    tmp___0 = atomic_read((atomic_t const   *)(& obj_request->kref.refcount));
#line 1480
    tmp___1 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 1480
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: obj %p (was %d)\n",
                       4, (char *)"    ", tmp___1, 1481, "rbd_obj_request_put", obj_request,
                       tmp___0);
  } else {

  }
#line 1482
  kref_put(& obj_request->kref, & rbd_obj_request_destroy);
#line 1483
  return;
}
}
#line 1485 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_img_request_get(struct rbd_img_request *img_request ) 
{ 
  struct _ddebug descriptor ;
  int tmp ;
  char const   *tmp___0 ;
  long tmp___1 ;

  {
#line 1487
  descriptor.modname = "rbd";
#line 1487
  descriptor.function = "rbd_img_request_get";
#line 1487
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1487
  descriptor.format = "%.*s %12.12s:%-4d : %s: img %p (was %d)\n";
#line 1487
  descriptor.lineno = 1488U;
#line 1487
  descriptor.flags = 0U;
#line 1487
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1487
  if (tmp___1 != 0L) {
#line 1487
    tmp = atomic_read((atomic_t const   *)(& img_request->kref.refcount));
#line 1487
    tmp___0 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 1487
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: img %p (was %d)\n",
                       4, (char *)"    ", tmp___0, 1488, "rbd_img_request_get", img_request,
                       tmp);
  } else {

  }
#line 1489
  kref_get(& img_request->kref);
#line 1490
  return;
}
}
#line 1492
static bool img_request_child_test(struct rbd_img_request *img_request ) ;
#line 1493
static void rbd_parent_request_destroy(struct kref *kref ) ;
#line 1494
static void rbd_img_request_destroy(struct kref *kref ) ;
#line 1495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_img_request_put(struct rbd_img_request *img_request ) 
{ 
  long tmp ;
  struct _ddebug descriptor ;
  int tmp___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;

  {
#line 1497
  tmp = ldv__builtin_expect((unsigned long )img_request == (unsigned long )((struct rbd_img_request *)0),
                         0L);
#line 1497
  if (tmp != 0L) {
#line 1497
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_request_put",
           1497, (char *)"img_request != NULL");
#line 1497
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1497), "i" (12UL));
    ldv_37835: ;
#line 1497
    goto ldv_37835;
  } else {

  }
#line 1498
  descriptor.modname = "rbd";
#line 1498
  descriptor.function = "rbd_img_request_put";
#line 1498
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1498
  descriptor.format = "%.*s %12.12s:%-4d : %s: img %p (was %d)\n";
#line 1498
  descriptor.lineno = 1499U;
#line 1498
  descriptor.flags = 0U;
#line 1498
  tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1498
  if (tmp___2 != 0L) {
#line 1498
    tmp___0 = atomic_read((atomic_t const   *)(& img_request->kref.refcount));
#line 1498
    tmp___1 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 1498
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: img %p (was %d)\n",
                       4, (char *)"    ", tmp___1, 1499, "rbd_img_request_put", img_request,
                       tmp___0);
  } else {

  }
#line 1500
  tmp___3 = img_request_child_test(img_request);
#line 1500
  if ((int )tmp___3) {
#line 1501
    kref_put(& img_request->kref, & rbd_parent_request_destroy);
  } else {
#line 1503
    kref_put(& img_request->kref, & rbd_img_request_destroy);
  }
#line 1504
  return;
}
}
#line 1506 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
__inline static void rbd_img_obj_request_add(struct rbd_img_request *img_request ,
                                             struct rbd_obj_request *obj_request ) 
{ 
  long tmp ;
  bool tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor ;
  char const   *tmp___3 ;
  long tmp___4 ;

  {
#line 1509
  tmp = ldv__builtin_expect((unsigned long )obj_request->__annonCompField101.__annonCompField100.img_request != (unsigned long )((struct rbd_img_request *)0),
                         0L);
#line 1509
  if (tmp != 0L) {
#line 1509
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_request_add",
           1509, (char *)"obj_request->img_request == NULL");
#line 1509
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1509), "i" (12UL));
    ldv_37842: ;
#line 1509
    goto ldv_37842;
  } else {

  }
#line 1512
  obj_request->__annonCompField101.__annonCompField100.img_request = img_request;
#line 1513
  obj_request->which = img_request->obj_request_count;
#line 1514
  tmp___0 = obj_request_img_data_test(obj_request);
#line 1514
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 1514
  if (tmp___1 != 0L) {
#line 1514
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_request_add",
           1514, (char *)"!obj_request_img_data_test(obj_request)");
#line 1514
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1514), "i" (12UL));
    ldv_37843: ;
#line 1514
    goto ldv_37843;
  } else {

  }
#line 1515
  obj_request_img_data_set(obj_request);
#line 1516
  tmp___2 = ldv__builtin_expect(obj_request->which == 4294967295U, 0L);
#line 1516
  if (tmp___2 != 0L) {
#line 1516
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_request_add",
           1516, (char *)"obj_request->which != BAD_WHICH");
#line 1516
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1516), "i" (12UL));
    ldv_37844: ;
#line 1516
    goto ldv_37844;
  } else {

  }
#line 1517
  img_request->obj_request_count = img_request->obj_request_count + 1U;
#line 1518
  list_add_tail(& obj_request->__annonCompField101.__annonCompField100.links, & img_request->obj_requests);
#line 1519
  descriptor.modname = "rbd";
#line 1519
  descriptor.function = "rbd_img_obj_request_add";
#line 1519
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1519
  descriptor.format = "%.*s %12.12s:%-4d : %s: img %p obj %p w=%u\n";
#line 1519
  descriptor.lineno = 1520U;
#line 1519
  descriptor.flags = 0U;
#line 1519
  tmp___4 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1519
  if (tmp___4 != 0L) {
#line 1519
    tmp___3 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 1519
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: img %p obj %p w=%u\n",
                       4, (char *)"    ", tmp___3, 1520, "rbd_img_obj_request_add",
                       img_request, obj_request, obj_request->which);
  } else {

  }
#line 1521
  return;
}
}
#line 1523 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
__inline static void rbd_img_obj_request_del(struct rbd_img_request *img_request ,
                                             struct rbd_obj_request *obj_request ) 
{ 
  long tmp ;
  struct _ddebug descriptor ;
  char const   *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
#line 1526
  tmp = ldv__builtin_expect(obj_request->which == 4294967295U, 0L);
#line 1526
  if (tmp != 0L) {
#line 1526
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_request_del",
           1526, (char *)"obj_request->which != BAD_WHICH");
#line 1526
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1526), "i" (12UL));
    ldv_37851: ;
#line 1526
    goto ldv_37851;
  } else {

  }
#line 1528
  descriptor.modname = "rbd";
#line 1528
  descriptor.function = "rbd_img_obj_request_del";
#line 1528
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1528
  descriptor.format = "%.*s %12.12s:%-4d : %s: img %p obj %p w=%u\n";
#line 1528
  descriptor.lineno = 1529U;
#line 1528
  descriptor.flags = 0U;
#line 1528
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1528
  if (tmp___1 != 0L) {
#line 1528
    tmp___0 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 1528
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: img %p obj %p w=%u\n",
                       4, (char *)"    ", tmp___0, 1529, "rbd_img_obj_request_del",
                       img_request, obj_request, obj_request->which);
  } else {

  }
#line 1530
  list_del(& obj_request->__annonCompField101.__annonCompField100.links);
#line 1531
  tmp___2 = ldv__builtin_expect(img_request->obj_request_count == 0U, 0L);
#line 1531
  if (tmp___2 != 0L) {
#line 1531
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_request_del",
           1531, (char *)"img_request->obj_request_count > 0");
#line 1531
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1531), "i" (12UL));
    ldv_37853: ;
#line 1531
    goto ldv_37853;
  } else {

  }
#line 1532
  img_request->obj_request_count = img_request->obj_request_count - 1U;
#line 1533
  tmp___3 = ldv__builtin_expect(obj_request->which != img_request->obj_request_count,
                             0L);
#line 1533
  if (tmp___3 != 0L) {
#line 1533
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_request_del",
           1533, (char *)"obj_request->which == img_request->obj_request_count");
#line 1533
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1533), "i" (12UL));
    ldv_37854: ;
#line 1533
    goto ldv_37854;
  } else {

  }
#line 1534
  obj_request->which = 4294967295U;
#line 1535
  tmp___4 = obj_request_img_data_test(obj_request);
#line 1535
  if (tmp___4) {
#line 1535
    tmp___5 = 0;
  } else {
#line 1535
    tmp___5 = 1;
  }
#line 1535
  tmp___6 = ldv__builtin_expect((long )tmp___5, 0L);
#line 1535
  if (tmp___6 != 0L) {
#line 1535
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_request_del",
           1535, (char *)"obj_request_img_data_test(obj_request)");
#line 1535
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1535), "i" (12UL));
    ldv_37855: ;
#line 1535
    goto ldv_37855;
  } else {

  }
#line 1536
  tmp___7 = ldv__builtin_expect((unsigned long )obj_request->__annonCompField101.__annonCompField100.img_request != (unsigned long )img_request,
                             0L);
#line 1536
  if (tmp___7 != 0L) {
#line 1536
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_request_del",
           1536, (char *)"obj_request->img_request == img_request");
#line 1536
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1536), "i" (12UL));
    ldv_37856: ;
#line 1536
    goto ldv_37856;
  } else {

  }
#line 1537
  obj_request->__annonCompField101.__annonCompField100.img_request = (struct rbd_img_request *)0;
#line 1538
  obj_request->callback = (void (*)(struct rbd_obj_request * ))0;
#line 1539
  rbd_obj_request_put(obj_request);
#line 1540
  return;
}
}
#line 1542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static bool obj_request_type_valid(enum obj_request_type type ) 
{ 


  {
#line 1544
  switch ((unsigned int )type) {
  case 0U: ;
  case 1U: ;
  case 2U: ;
#line 1548
  return (1);
  default: ;
#line 1550
  return (0);
  }
}
}
#line 1554 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_obj_request_submit(struct ceph_osd_client *osdc , struct rbd_obj_request *obj_request ) 
{ 
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 1557
  descriptor.modname = "rbd";
#line 1557
  descriptor.function = "rbd_obj_request_submit";
#line 1557
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1557
  descriptor.format = "%.*s %12.12s:%-4d : %s %p\n";
#line 1557
  descriptor.lineno = 1557U;
#line 1557
  descriptor.flags = 0U;
#line 1557
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1557
  if (tmp___0 != 0L) {
#line 1557
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 1557
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s %p\n", 4, (char *)"    ",
                       tmp, 1557, "rbd_obj_request_submit", obj_request);
  } else {

  }
#line 1558
  tmp___1 = ceph_osdc_start_request(osdc, obj_request->osd_req, 0);
#line 1558
  return (tmp___1);
}
}
#line 1561 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_obj_request_end(struct rbd_obj_request *obj_request ) 
{ 
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;

  {
#line 1563
  descriptor.modname = "rbd";
#line 1563
  descriptor.function = "rbd_obj_request_end";
#line 1563
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1563
  descriptor.format = "%.*s %12.12s:%-4d : %s %p\n";
#line 1563
  descriptor.lineno = 1563U;
#line 1563
  descriptor.flags = 0U;
#line 1563
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1563
  if (tmp___0 != 0L) {
#line 1563
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 1563
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s %p\n", 4, (char *)"    ",
                       tmp, 1563, "rbd_obj_request_end", obj_request);
  } else {

  }
#line 1564
  ceph_osdc_cancel_request(obj_request->osd_req);
#line 1565
  return;
}
}
#line 1573 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int __rbd_obj_request_wait(struct rbd_obj_request *obj_request , unsigned long timeout ) 
{ 
  long ret ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;
  unsigned long tmp___1 ;
  struct _ddebug descriptor___0 ;
  char const   *tmp___2 ;
  long tmp___3 ;

  {
#line 1578
  descriptor.modname = "rbd";
#line 1578
  descriptor.function = "__rbd_obj_request_wait";
#line 1578
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1578
  descriptor.format = "%.*s %12.12s:%-4d : %s %p\n";
#line 1578
  descriptor.lineno = 1578U;
#line 1578
  descriptor.flags = 0U;
#line 1578
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1578
  if (tmp___0 != 0L) {
#line 1578
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 1578
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s %p\n", 4, (char *)"    ",
                       tmp, 1578, "__rbd_obj_request_wait", obj_request);
  } else {

  }
#line 1579
  tmp___1 = ceph_timeout_jiffies(timeout);
#line 1579
  ret = wait_for_completion_interruptible_timeout(& obj_request->completion, tmp___1);
#line 1582
  if (ret <= 0L) {
#line 1583
    if (ret == 0L) {
#line 1584
      ret = -110L;
    } else {

    }
#line 1585
    rbd_obj_request_end(obj_request);
  } else {
#line 1587
    ret = 0L;
  }
#line 1590
  descriptor___0.modname = "rbd";
#line 1590
  descriptor___0.function = "__rbd_obj_request_wait";
#line 1590
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1590
  descriptor___0.format = "%.*s %12.12s:%-4d : %s %p ret %d\n";
#line 1590
  descriptor___0.lineno = 1590U;
#line 1590
  descriptor___0.flags = 0U;
#line 1590
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 1590
  if (tmp___3 != 0L) {
#line 1590
    tmp___2 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 1590
    __dynamic_pr_debug(& descriptor___0, "rbd: %.*s %12.12s:%-4d : %s %p ret %d\n",
                       4, (char *)"    ", tmp___2, 1590, "__rbd_obj_request_wait",
                       obj_request, (int )ret);
  } else {

  }
#line 1591
  return ((int )ret);
}
}
#line 1594 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_obj_request_wait(struct rbd_obj_request *obj_request ) 
{ 
  int tmp ;

  {
#line 1596
  tmp = __rbd_obj_request_wait(obj_request, 0UL);
#line 1596
  return (tmp);
}
}
#line 1599 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_obj_request_wait_timeout(struct rbd_obj_request *obj_request , unsigned long timeout ) 
{ 
  int tmp ;

  {
#line 1602
  tmp = __rbd_obj_request_wait(obj_request, timeout);
#line 1602
  return (tmp);
}
}
#line 1605 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_img_request_complete(struct rbd_img_request *img_request ) 
{ 
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;
  struct rbd_obj_request *obj_request ;
  u64 xferred ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1608
  descriptor.modname = "rbd";
#line 1608
  descriptor.function = "rbd_img_request_complete";
#line 1608
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1608
  descriptor.format = "%.*s %12.12s:%-4d : %s: img %p\n";
#line 1608
  descriptor.lineno = 1608U;
#line 1608
  descriptor.flags = 0U;
#line 1608
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1608
  if (tmp___0 != 0L) {
#line 1608
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 1608
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: img %p\n", 4, (char *)"    ",
                       tmp, 1608, "rbd_img_request_complete", img_request);
  } else {

  }
#line 1616
  if (img_request->result == 0) {
#line 1618
    xferred = 0ULL;
#line 1620
    __mptr = (struct list_head  const  *)img_request->obj_requests.next;
#line 1620
    obj_request = (struct rbd_obj_request *)__mptr + 0xffffffffffffffd0UL;
#line 1620
    goto ldv_37902;
    ldv_37901: 
#line 1621
    xferred = obj_request->xferred + xferred;
#line 1620
    __mptr___0 = (struct list_head  const  *)obj_request->__annonCompField101.__annonCompField100.links.next;
#line 1620
    obj_request = (struct rbd_obj_request *)__mptr___0 + 0xffffffffffffffd0UL;
    ldv_37902: ;
#line 1620
    if ((unsigned long )(& obj_request->__annonCompField101.__annonCompField100.links) != (unsigned long )(& img_request->obj_requests)) {
#line 1622
      goto ldv_37901;
    } else {

    }
#line 1622
    img_request->xferred = xferred;
  } else {

  }
#line 1625
  if ((unsigned long )img_request->callback != (unsigned long )((void (*)(struct rbd_img_request * ))0)) {
#line 1626
    (*(img_request->callback))(img_request);
  } else {
#line 1628
    rbd_img_request_put(img_request);
  }
#line 1629
  return;
}
}
#line 1636 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void img_request_write_set(struct rbd_img_request *img_request ) 
{ 


  {
#line 1638
  set_bit(0L, (unsigned long volatile   *)(& img_request->flags));
#line 1639
  __asm__  volatile   ("mfence": : : "memory");
#line 1640
  return;
}
}
#line 1642 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static bool img_request_write_test(struct rbd_img_request *img_request ) 
{ 
  int tmp ;

  {
#line 1644
  __asm__  volatile   ("mfence": : : "memory");
#line 1645
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& img_request->flags));
#line 1645
  return (tmp != 0);
}
}
#line 1651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void img_request_discard_set(struct rbd_img_request *img_request ) 
{ 


  {
#line 1653
  set_bit(3L, (unsigned long volatile   *)(& img_request->flags));
#line 1654
  __asm__  volatile   ("mfence": : : "memory");
#line 1655
  return;
}
}
#line 1657 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static bool img_request_discard_test(struct rbd_img_request *img_request ) 
{ 
  int tmp ;

  {
#line 1659
  __asm__  volatile   ("mfence": : : "memory");
#line 1660
  tmp = constant_test_bit(3L, (unsigned long const volatile   *)(& img_request->flags));
#line 1660
  return (tmp != 0);
}
}
#line 1663 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void img_request_child_set(struct rbd_img_request *img_request ) 
{ 


  {
#line 1665
  set_bit(1L, (unsigned long volatile   *)(& img_request->flags));
#line 1666
  __asm__  volatile   ("mfence": : : "memory");
#line 1667
  return;
}
}
#line 1669 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void img_request_child_clear(struct rbd_img_request *img_request ) 
{ 


  {
#line 1671
  clear_bit(1L, (unsigned long volatile   *)(& img_request->flags));
#line 1672
  __asm__  volatile   ("mfence": : : "memory");
#line 1673
  return;
}
}
#line 1675 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static bool img_request_child_test(struct rbd_img_request *img_request ) 
{ 
  int tmp ;

  {
#line 1677
  __asm__  volatile   ("mfence": : : "memory");
#line 1678
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& img_request->flags));
#line 1678
  return (tmp != 0);
}
}
#line 1681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void img_request_layered_set(struct rbd_img_request *img_request ) 
{ 


  {
#line 1683
  set_bit(2L, (unsigned long volatile   *)(& img_request->flags));
#line 1684
  __asm__  volatile   ("mfence": : : "memory");
#line 1685
  return;
}
}
#line 1687 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void img_request_layered_clear(struct rbd_img_request *img_request ) 
{ 


  {
#line 1689
  clear_bit(2L, (unsigned long volatile   *)(& img_request->flags));
#line 1690
  __asm__  volatile   ("mfence": : : "memory");
#line 1691
  return;
}
}
#line 1693 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static bool img_request_layered_test(struct rbd_img_request *img_request ) 
{ 
  int tmp ;

  {
#line 1695
  __asm__  volatile   ("mfence": : : "memory");
#line 1696
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& img_request->flags));
#line 1696
  return (tmp != 0);
}
}
#line 1700 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static enum obj_operation_type rbd_img_request_op_type(struct rbd_img_request *img_request ) 
{ 
  bool tmp ;
  bool tmp___0 ;

  {
#line 1702
  tmp___0 = img_request_write_test(img_request);
#line 1702
  if ((int )tmp___0) {
#line 1703
    return (0);
  } else {
#line 1704
    tmp = img_request_discard_test(img_request);
#line 1704
    if ((int )tmp) {
#line 1705
      return (2);
    } else {
#line 1707
      return (1);
    }
  }
}
}
#line 1711 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_img_obj_request_read_callback(struct rbd_obj_request *obj_request ) 
{ 
  u64 xferred ;
  u64 length ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 1713
  xferred = obj_request->xferred;
#line 1714
  length = obj_request->length;
#line 1716
  descriptor.modname = "rbd";
#line 1716
  descriptor.function = "rbd_img_obj_request_read_callback";
#line 1716
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1716
  descriptor.format = "%.*s %12.12s:%-4d : %s: obj %p img %p result %d %llu/%llu\n";
#line 1716
  descriptor.lineno = 1718U;
#line 1716
  descriptor.flags = 0U;
#line 1716
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1716
  if (tmp___0 != 0L) {
#line 1716
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 1716
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: obj %p img %p result %d %llu/%llu\n",
                       4, (char *)"    ", tmp, 1718, "rbd_img_obj_request_read_callback",
                       obj_request, obj_request->__annonCompField101.__annonCompField100.img_request,
                       obj_request->result, xferred, length);
  } else {

  }
#line 1727
  tmp___1 = ldv__builtin_expect((unsigned int )obj_request->type == 0U, 0L);
#line 1727
  if (tmp___1 != 0L) {
#line 1727
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_request_read_callback",
           1727, (char *)"obj_request->type != OBJ_REQUEST_NODATA");
#line 1727
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1727), "i" (12UL));
    ldv_37944: ;
#line 1727
    goto ldv_37944;
  } else {

  }
#line 1728
  if (obj_request->result == -2) {
#line 1729
    if ((unsigned int )obj_request->type == 1U) {
#line 1730
      zero_bio_chain(obj_request->__annonCompField103.bio_list, 0);
    } else {
#line 1732
      zero_pages(obj_request->__annonCompField103.__annonCompField102.pages, 0ULL,
                 length);
    }
#line 1733
    obj_request->result = 0;
  } else
#line 1734
  if (xferred < length && obj_request->result == 0) {
#line 1735
    if ((unsigned int )obj_request->type == 1U) {
#line 1736
      zero_bio_chain(obj_request->__annonCompField103.bio_list, (int )xferred);
    } else {
#line 1738
      zero_pages(obj_request->__annonCompField103.__annonCompField102.pages, xferred,
                 length);
    }
  } else {

  }
#line 1740
  obj_request->xferred = length;
#line 1741
  obj_request_done_set(obj_request);
#line 1742
  return;
}
}
#line 1744 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_obj_request_complete(struct rbd_obj_request *obj_request ) 
{ 
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;

  {
#line 1746
  descriptor.modname = "rbd";
#line 1746
  descriptor.function = "rbd_obj_request_complete";
#line 1746
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1746
  descriptor.format = "%.*s %12.12s:%-4d : %s: obj %p cb %p\n";
#line 1746
  descriptor.lineno = 1747U;
#line 1746
  descriptor.flags = 0U;
#line 1746
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1746
  if (tmp___0 != 0L) {
#line 1746
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 1746
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: obj %p cb %p\n",
                       4, (char *)"    ", tmp, 1747, "rbd_obj_request_complete", obj_request,
                       obj_request->callback);
  } else {

  }
#line 1748
  if ((unsigned long )obj_request->callback != (unsigned long )((void (*)(struct rbd_obj_request * ))0)) {
#line 1749
    (*(obj_request->callback))(obj_request);
  } else {
#line 1751
    complete_all(& obj_request->completion);
  }
#line 1752
  return;
}
}
#line 1754 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_osd_trivial_callback(struct rbd_obj_request *obj_request ) 
{ 
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;

  {
#line 1756
  descriptor.modname = "rbd";
#line 1756
  descriptor.function = "rbd_osd_trivial_callback";
#line 1756
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1756
  descriptor.format = "%.*s %12.12s:%-4d : %s: obj %p\n";
#line 1756
  descriptor.lineno = 1756U;
#line 1756
  descriptor.flags = 0U;
#line 1756
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1756
  if (tmp___0 != 0L) {
#line 1756
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 1756
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: obj %p\n", 4, (char *)"    ",
                       tmp, 1756, "rbd_osd_trivial_callback", obj_request);
  } else {

  }
#line 1757
  obj_request_done_set(obj_request);
#line 1758
  return;
}
}
#line 1760 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_osd_read_callback(struct rbd_obj_request *obj_request ) 
{ 
  struct rbd_img_request *img_request ;
  struct rbd_device *rbd_dev ;
  bool layered ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct _ddebug descriptor ;
  char const   *tmp___2 ;
  long tmp___3 ;

  {
#line 1762
  img_request = (struct rbd_img_request *)0;
#line 1763
  rbd_dev = (struct rbd_device *)0;
#line 1764
  layered = 0;
#line 1766
  tmp___1 = obj_request_img_data_test(obj_request);
#line 1766
  if ((int )tmp___1) {
#line 1767
    img_request = obj_request->__annonCompField101.__annonCompField100.img_request;
#line 1768
    if ((unsigned long )img_request != (unsigned long )((struct rbd_img_request *)0)) {
#line 1768
      tmp = img_request_layered_test(img_request);
#line 1768
      if ((int )tmp) {
#line 1768
        tmp___0 = 1;
      } else {
#line 1768
        tmp___0 = 0;
      }
    } else {
#line 1768
      tmp___0 = 0;
    }
#line 1768
    layered = (bool )tmp___0;
#line 1769
    rbd_dev = img_request->rbd_dev;
  } else {

  }
#line 1772
  descriptor.modname = "rbd";
#line 1772
  descriptor.function = "rbd_osd_read_callback";
#line 1772
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1772
  descriptor.format = "%.*s %12.12s:%-4d : %s: obj %p img %p result %d %llu/%llu\n";
#line 1772
  descriptor.lineno = 1774U;
#line 1772
  descriptor.flags = 0U;
#line 1772
  tmp___3 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1772
  if (tmp___3 != 0L) {
#line 1772
    tmp___2 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 1772
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: obj %p img %p result %d %llu/%llu\n",
                       4, (char *)"    ", tmp___2, 1774, "rbd_osd_read_callback",
                       obj_request, img_request, obj_request->result, obj_request->xferred,
                       obj_request->length);
  } else {

  }
#line 1775
  if (((int )layered && obj_request->result == -2) && obj_request->__annonCompField101.__annonCompField100.img_offset < rbd_dev->parent_overlap) {
#line 1777
    rbd_img_parent_read(obj_request);
  } else
#line 1778
  if ((unsigned long )img_request != (unsigned long )((struct rbd_img_request *)0)) {
#line 1779
    rbd_img_obj_request_read_callback(obj_request);
  } else {
#line 1781
    obj_request_done_set(obj_request);
  }
#line 1782
  return;
}
}
#line 1784 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_osd_write_callback(struct rbd_obj_request *obj_request ) 
{ 
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;

  {
#line 1786
  descriptor.modname = "rbd";
#line 1786
  descriptor.function = "rbd_osd_write_callback";
#line 1786
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1786
  descriptor.format = "%.*s %12.12s:%-4d : %s: obj %p result %d %llu\n";
#line 1786
  descriptor.lineno = 1787U;
#line 1786
  descriptor.flags = 0U;
#line 1786
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1786
  if (tmp___0 != 0L) {
#line 1786
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 1786
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: obj %p result %d %llu\n",
                       4, (char *)"    ", tmp, 1787, "rbd_osd_write_callback", obj_request,
                       obj_request->result, obj_request->length);
  } else {

  }
#line 1792
  obj_request->xferred = obj_request->length;
#line 1793
  obj_request_done_set(obj_request);
#line 1794
  return;
}
}
#line 1796 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_osd_discard_callback(struct rbd_obj_request *obj_request ) 
{ 
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;

  {
#line 1798
  descriptor.modname = "rbd";
#line 1798
  descriptor.function = "rbd_osd_discard_callback";
#line 1798
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1798
  descriptor.format = "%.*s %12.12s:%-4d : %s: obj %p result %d %llu\n";
#line 1798
  descriptor.lineno = 1799U;
#line 1798
  descriptor.flags = 0U;
#line 1798
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1798
  if (tmp___0 != 0L) {
#line 1798
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 1798
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: obj %p result %d %llu\n",
                       4, (char *)"    ", tmp, 1799, "rbd_osd_discard_callback", obj_request,
                       obj_request->result, obj_request->length);
  } else {

  }
#line 1804
  obj_request->xferred = obj_request->length;
#line 1806
  if (obj_request->result == -2) {
#line 1807
    obj_request->result = 0;
  } else {

  }
#line 1808
  obj_request_done_set(obj_request);
#line 1809
  return;
}
}
#line 1815 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_osd_stat_callback(struct rbd_obj_request *obj_request ) 
{ 
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;

  {
#line 1817
  descriptor.modname = "rbd";
#line 1817
  descriptor.function = "rbd_osd_stat_callback";
#line 1817
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1817
  descriptor.format = "%.*s %12.12s:%-4d : %s: obj %p\n";
#line 1817
  descriptor.lineno = 1817U;
#line 1817
  descriptor.flags = 0U;
#line 1817
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1817
  if (tmp___0 != 0L) {
#line 1817
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 1817
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: obj %p\n", 4, (char *)"    ",
                       tmp, 1817, "rbd_osd_stat_callback", obj_request);
  } else {

  }
#line 1818
  obj_request_done_set(obj_request);
#line 1819
  return;
}
}
#line 1821 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_osd_req_callback(struct ceph_osd_request *osd_req , struct ceph_msg *msg ) 
{ 
  struct rbd_obj_request *obj_request ;
  u16 opcode ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  bool tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  bool tmp___9 ;

  {
#line 1824
  obj_request = (struct rbd_obj_request *)osd_req->r_priv;
#line 1827
  descriptor.modname = "rbd";
#line 1827
  descriptor.function = "rbd_osd_req_callback";
#line 1827
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 1827
  descriptor.format = "%.*s %12.12s:%-4d : %s: osd_req %p msg %p\n";
#line 1827
  descriptor.lineno = 1827U;
#line 1827
  descriptor.flags = 0U;
#line 1827
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 1827
  if (tmp___0 != 0L) {
#line 1827
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 1827
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: osd_req %p msg %p\n",
                       4, (char *)"    ", tmp, 1827, "rbd_osd_req_callback", osd_req,
                       msg);
  } else {

  }
#line 1828
  tmp___1 = ldv__builtin_expect((unsigned long )obj_request->osd_req != (unsigned long )osd_req,
                             0L);
#line 1828
  if (tmp___1 != 0L) {
#line 1828
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_osd_req_callback",
           1828, (char *)"osd_req == obj_request->osd_req");
#line 1828
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1828), "i" (12UL));
    ldv_37986: ;
#line 1828
    goto ldv_37986;
  } else {

  }
#line 1829
  tmp___5 = obj_request_img_data_test(obj_request);
#line 1829
  if ((int )tmp___5) {
#line 1830
    tmp___2 = ldv__builtin_expect((unsigned long )obj_request->__annonCompField101.__annonCompField100.img_request == (unsigned long )((struct rbd_img_request *)0),
                               0L);
#line 1830
    if (tmp___2 != 0L) {
#line 1830
      printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n",
             "rbd_osd_req_callback", 1830, (char *)"obj_request->img_request");
#line 1830
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                           "i" (1830), "i" (12UL));
      ldv_37987: ;
#line 1830
      goto ldv_37987;
    } else {

    }
#line 1831
    tmp___3 = ldv__builtin_expect(obj_request->which == 4294967295U, 0L);
#line 1831
    if (tmp___3 != 0L) {
#line 1831
      printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n",
             "rbd_osd_req_callback", 1831, (char *)"obj_request->which != BAD_WHICH");
#line 1831
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                           "i" (1831), "i" (12UL));
      ldv_37988: ;
#line 1831
      goto ldv_37988;
    } else {

    }
  } else {
#line 1833
    tmp___4 = ldv__builtin_expect(obj_request->which != 4294967295U, 0L);
#line 1833
    if (tmp___4 != 0L) {
#line 1833
      printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n",
             "rbd_osd_req_callback", 1833, (char *)"obj_request->which == BAD_WHICH");
#line 1833
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                           "i" (1833), "i" (12UL));
      ldv_37989: ;
#line 1833
      goto ldv_37989;
    } else {

    }
  }
#line 1836
  if (osd_req->r_result < 0) {
#line 1837
    obj_request->result = osd_req->r_result;
  } else {

  }
#line 1839
  tmp___6 = ldv__builtin_expect(osd_req->r_num_ops > 3U, 0L);
#line 1839
  if (tmp___6 != 0L) {
#line 1839
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_osd_req_callback",
           1839, (char *)"osd_req->r_num_ops <= CEPH_OSD_MAX_OP");
#line 1839
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1839), "i" (12UL));
    ldv_37990: ;
#line 1839
    goto ldv_37990;
  } else {

  }
#line 1846
  obj_request->xferred = (u64 )osd_req->r_reply_op_len[0];
#line 1847
  tmp___7 = ldv__builtin_expect(obj_request->xferred > 4294967294ULL, 0L);
#line 1847
  if (tmp___7 != 0L) {
#line 1847
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_osd_req_callback",
           1847, (char *)"obj_request->xferred < (u64)UINT_MAX");
#line 1847
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1847), "i" (12UL));
    ldv_37991: ;
#line 1847
    goto ldv_37991;
  } else {

  }
#line 1849
  opcode = osd_req->r_ops[0].op;
#line 1850
  switch ((int )opcode) {
  case 4609: 
#line 1852
  rbd_osd_read_callback(obj_request);
#line 1853
  goto ldv_37993;
  case 8739: 
#line 1855
  tmp___8 = ldv__builtin_expect((unsigned int )osd_req->r_ops[1].op != 8705U, 0L);
#line 1855
  if (tmp___8 != 0L) {
#line 1855
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_osd_req_callback",
           1855, (char *)"osd_req->r_ops[1].op == CEPH_OSD_OP_WRITE");
#line 1855
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1855), "i" (12UL));
    ldv_37995: ;
#line 1855
    goto ldv_37995;
  } else {

  }
  case 8705: 
#line 1858
  rbd_osd_write_callback(obj_request);
#line 1859
  goto ldv_37993;
  case 4610: 
#line 1861
  rbd_osd_stat_callback(obj_request);
#line 1862
  goto ldv_37993;
  case 8709: ;
  case 8707: ;
  case 8708: 
#line 1866
  rbd_osd_discard_callback(obj_request);
#line 1867
  goto ldv_37993;
  case 5121: ;
  case 4615: ;
  case 8719: 
#line 1871
  rbd_osd_trivial_callback(obj_request);
#line 1872
  goto ldv_37993;
  default: 
#line 1874
  rbd_warn((struct rbd_device *)0, "%s: unsupported op %hu", obj_request->object_name,
           (int )opcode);
#line 1876
  goto ldv_37993;
  }
  ldv_37993: 
#line 1879
  tmp___9 = obj_request_done_test(obj_request);
#line 1879
  if ((int )tmp___9) {
#line 1880
    rbd_obj_request_complete(obj_request);
  } else {

  }
#line 1881
  return;
}
}
#line 1883 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_osd_req_format_read(struct rbd_obj_request *obj_request ) 
{ 
  struct rbd_img_request *img_request ;
  struct ceph_osd_request *osd_req ;
  u64 snap_id ;
  long tmp ;

  {
#line 1885
  img_request = obj_request->__annonCompField101.__annonCompField100.img_request;
#line 1886
  osd_req = obj_request->osd_req;
#line 1889
  tmp = ldv__builtin_expect((unsigned long )osd_req == (unsigned long )((struct ceph_osd_request *)0),
                         0L);
#line 1889
  if (tmp != 0L) {
#line 1889
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_osd_req_format_read",
           1889, (char *)"osd_req != NULL");
#line 1889
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1889), "i" (12UL));
    ldv_38012: ;
#line 1889
    goto ldv_38012;
  } else {

  }
#line 1891
  snap_id = (unsigned long )img_request != (unsigned long )((struct rbd_img_request *)0) ? img_request->__annonCompField104.snap_id : 0xfffffffffffffffeULL;
#line 1892
  ceph_osdc_build_request(osd_req, obj_request->offset, (struct ceph_snap_context *)0,
                          snap_id, (struct timespec *)0);
#line 1893
  return;
}
}
#line 1896 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_osd_req_format_write(struct rbd_obj_request *obj_request ) 
{ 
  struct rbd_img_request *img_request ;
  struct ceph_osd_request *osd_req ;
  struct ceph_snap_context *snapc ;
  struct timespec mtime ;
  struct timespec tmp ;
  long tmp___0 ;

  {
#line 1898
  img_request = obj_request->__annonCompField101.__annonCompField100.img_request;
#line 1899
  osd_req = obj_request->osd_req;
#line 1901
  tmp = current_kernel_time();
#line 1901
  mtime = tmp;
#line 1903
  tmp___0 = ldv__builtin_expect((unsigned long )osd_req == (unsigned long )((struct ceph_osd_request *)0),
                             0L);
#line 1903
  if (tmp___0 != 0L) {
#line 1903
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_osd_req_format_write",
           1903, (char *)"osd_req != NULL");
#line 1903
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1903), "i" (12UL));
    ldv_38021: ;
#line 1903
    goto ldv_38021;
  } else {

  }
#line 1905
  snapc = (unsigned long )img_request != (unsigned long )((struct rbd_img_request *)0) ? img_request->__annonCompField104.snapc : (struct ceph_snap_context *)0;
#line 1906
  ceph_osdc_build_request(osd_req, obj_request->offset, snapc, 0xfffffffffffffffeULL,
                          & mtime);
#line 1908
  return;
}
}
#line 1916 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct ceph_osd_request *rbd_osd_req_create(struct rbd_device *rbd_dev , enum obj_operation_type op_type ,
                                                   unsigned int num_ops , struct rbd_obj_request *obj_request ) 
{ 
  struct ceph_snap_context *snapc ;
  struct ceph_osd_client *osdc ;
  struct ceph_osd_request *osd_req ;
  struct rbd_img_request *img_request ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  bool tmp___5 ;
  long tmp___6 ;

  {
#line 1922
  snapc = (struct ceph_snap_context *)0;
#line 1926
  tmp___5 = obj_request_img_data_test(obj_request);
#line 1926
  if ((int )tmp___5 && ((unsigned int )op_type == 2U || (unsigned int )op_type == 0U)) {
#line 1928
    img_request = obj_request->__annonCompField101.__annonCompField100.img_request;
#line 1929
    if ((unsigned int )op_type == 0U) {
#line 1930
      tmp = img_request_write_test(img_request);
#line 1930
      if (tmp) {
#line 1930
        tmp___0 = 0;
      } else {
#line 1930
        tmp___0 = 1;
      }
#line 1930
      tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 1930
      if (tmp___1 != 0L) {
#line 1930
        printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n",
               "rbd_osd_req_create", 1930, (char *)"img_request_write_test(img_request)");
#line 1930
        __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                             "i" (1930), "i" (12UL));
        ldv_38033: ;
#line 1930
        goto ldv_38033;
      } else {

      }
    } else {
#line 1932
      tmp___2 = img_request_discard_test(img_request);
#line 1932
      if (tmp___2) {
#line 1932
        tmp___3 = 0;
      } else {
#line 1932
        tmp___3 = 1;
      }
#line 1932
      tmp___4 = ldv__builtin_expect((long )tmp___3, 0L);
#line 1932
      if (tmp___4 != 0L) {
#line 1932
        printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n",
               "rbd_osd_req_create", 1932, (char *)"img_request_discard_test(img_request)");
#line 1932
        __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                             "i" (1932), "i" (12UL));
        ldv_38034: ;
#line 1932
        goto ldv_38034;
      } else {

      }
    }
#line 1934
    snapc = img_request->__annonCompField104.snapc;
  } else {

  }
#line 1937
  tmp___6 = ldv__builtin_expect((long )(num_ops != 1U && ((unsigned int )op_type != 0U || num_ops != 2U)),
                             0L);
#line 1937
  if (tmp___6 != 0L) {
#line 1937
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_osd_req_create",
           1937, (char *)"num_ops == 1 || ((op_type == OBJ_OP_WRITE) && num_ops == 2)");
#line 1937
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1937), "i" (12UL));
    ldv_38035: ;
#line 1937
    goto ldv_38035;
  } else {

  }
#line 1941
  osdc = & ((rbd_dev->rbd_client)->client)->osdc;
#line 1942
  osd_req = ceph_osdc_alloc_request(osdc, snapc, num_ops, 0, 32U);
#line 1944
  if ((unsigned long )osd_req == (unsigned long )((struct ceph_osd_request *)0)) {
#line 1945
    return ((struct ceph_osd_request *)0);
  } else {

  }
#line 1947
  if ((unsigned int )op_type == 0U || (unsigned int )op_type == 2U) {
#line 1948
    osd_req->r_flags = 36;
  } else {
#line 1950
    osd_req->r_flags = 16;
  }
#line 1952
  osd_req->r_callback = & rbd_osd_req_callback;
#line 1953
  osd_req->r_priv = (void *)obj_request;
#line 1955
  osd_req->r_base_oloc.pool = (s64 )((int )rbd_dev->layout.fl_pg_pool);
#line 1956
  ceph_oid_set_name(& osd_req->r_base_oid, obj_request->object_name);
#line 1958
  return (osd_req);
}
}
#line 1968 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct ceph_osd_request *rbd_osd_req_create_copyup(struct rbd_obj_request *obj_request ) 
{ 
  struct rbd_img_request *img_request ;
  struct ceph_snap_context *snapc ;
  struct rbd_device *rbd_dev ;
  struct ceph_osd_client *osdc ;
  struct ceph_osd_request *osd_req ;
  int num_osd_ops ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  bool tmp___9 ;

  {
#line 1975
  num_osd_ops = 3;
#line 1977
  tmp = obj_request_img_data_test(obj_request);
#line 1977
  if (tmp) {
#line 1977
    tmp___0 = 0;
  } else {
#line 1977
    tmp___0 = 1;
  }
#line 1977
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 1977
  if (tmp___1 != 0L) {
#line 1977
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_osd_req_create_copyup",
           1977, (char *)"obj_request_img_data_test(obj_request)");
#line 1977
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1977), "i" (12UL));
    ldv_38046: ;
#line 1977
    goto ldv_38046;
  } else {

  }
#line 1978
  img_request = obj_request->__annonCompField101.__annonCompField100.img_request;
#line 1979
  tmp___2 = ldv__builtin_expect((unsigned long )img_request == (unsigned long )((struct rbd_img_request *)0),
                             0L);
#line 1979
  if (tmp___2 != 0L) {
#line 1979
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_osd_req_create_copyup",
           1979, (char *)"img_request");
#line 1979
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1979), "i" (12UL));
    ldv_38047: ;
#line 1979
    goto ldv_38047;
  } else {

  }
#line 1980
  tmp___3 = img_request_write_test(img_request);
#line 1980
  if (tmp___3) {
#line 1980
    tmp___4 = 0;
  } else {
#line 1980
    tmp___4 = 1;
  }
#line 1980
  if (tmp___4) {
#line 1980
    tmp___5 = img_request_discard_test(img_request);
#line 1980
    if (tmp___5) {
#line 1980
      tmp___6 = 0;
    } else {
#line 1980
      tmp___6 = 1;
    }
#line 1980
    if (tmp___6) {
#line 1980
      tmp___7 = 1;
    } else {
#line 1980
      tmp___7 = 0;
    }
  } else {
#line 1980
    tmp___7 = 0;
  }
#line 1980
  tmp___8 = ldv__builtin_expect((long )tmp___7, 0L);
#line 1980
  if (tmp___8 != 0L) {
#line 1980
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_osd_req_create_copyup",
           1981, (char *)"img_request_write_test(img_request) || img_request_discard_test(img_request)");
#line 1980
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (1981), "i" (12UL));
    ldv_38048: ;
#line 1980
    goto ldv_38048;
  } else {

  }
#line 1983
  tmp___9 = img_request_discard_test(img_request);
#line 1983
  if ((int )tmp___9) {
#line 1984
    num_osd_ops = 2;
  } else {

  }
#line 1988
  snapc = img_request->__annonCompField104.snapc;
#line 1989
  rbd_dev = img_request->rbd_dev;
#line 1990
  osdc = & ((rbd_dev->rbd_client)->client)->osdc;
#line 1991
  osd_req = ceph_osdc_alloc_request(osdc, snapc, (unsigned int )num_osd_ops, 0, 32U);
#line 1993
  if ((unsigned long )osd_req == (unsigned long )((struct ceph_osd_request *)0)) {
#line 1994
    return ((struct ceph_osd_request *)0);
  } else {

  }
#line 1996
  osd_req->r_flags = 36;
#line 1997
  osd_req->r_callback = & rbd_osd_req_callback;
#line 1998
  osd_req->r_priv = (void *)obj_request;
#line 2000
  osd_req->r_base_oloc.pool = (s64 )((int )rbd_dev->layout.fl_pg_pool);
#line 2001
  ceph_oid_set_name(& osd_req->r_base_oid, obj_request->object_name);
#line 2003
  return (osd_req);
}
}
#line 2007 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_osd_req_destroy(struct ceph_osd_request *osd_req ) 
{ 


  {
#line 2009
  ceph_osdc_put_request(osd_req);
#line 2010
  return;
}
}
#line 2014 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct rbd_obj_request *rbd_obj_request_create(char const   *object_name ,
                                                      u64 offset , u64 length , enum obj_request_type type ) 
{ 
  struct rbd_obj_request *obj_request ;
  size_t size ;
  char *name ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  struct _ddebug descriptor ;
  char const   *tmp___6 ;
  long tmp___7 ;

  {
#line 2022
  tmp = obj_request_type_valid(type);
#line 2022
  if (tmp) {
#line 2022
    tmp___0 = 0;
  } else {
#line 2022
    tmp___0 = 1;
  }
#line 2022
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 2022
  if (tmp___1 != 0L) {
#line 2022
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_obj_request_create",
           2022, (char *)"obj_request_type_valid(type)");
#line 2022
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2022), "i" (12UL));
    ldv_38062: ;
#line 2022
    goto ldv_38062;
  } else {

  }
#line 2024
  tmp___2 = strlen(object_name);
#line 2024
  size = tmp___2 + 1UL;
#line 2025
  tmp___3 = kmalloc(size, 16U);
#line 2025
  name = (char *)tmp___3;
#line 2026
  if ((unsigned long )name == (unsigned long )((char *)0)) {
#line 2027
    return ((struct rbd_obj_request *)0);
  } else {

  }
#line 2029
  tmp___4 = kmem_cache_zalloc(rbd_obj_request_cache, 16U);
#line 2029
  obj_request = (struct rbd_obj_request *)tmp___4;
#line 2030
  if ((unsigned long )obj_request == (unsigned long )((struct rbd_obj_request *)0)) {
#line 2031
    kfree((void const   *)name);
#line 2032
    return ((struct rbd_obj_request *)0);
  } else {

  }
#line 2035
  tmp___5 = memcpy((void *)name, (void const   *)object_name, size);
#line 2035
  obj_request->object_name = (char const   *)tmp___5;
#line 2036
  obj_request->offset = offset;
#line 2037
  obj_request->length = length;
#line 2038
  obj_request->flags = 0UL;
#line 2039
  obj_request->which = 4294967295U;
#line 2040
  obj_request->type = type;
#line 2041
  INIT_LIST_HEAD(& obj_request->__annonCompField101.__annonCompField100.links);
#line 2042
  init_completion(& obj_request->completion);
#line 2043
  kref_init(& obj_request->kref);
#line 2045
  descriptor.modname = "rbd";
#line 2045
  descriptor.function = "rbd_obj_request_create";
#line 2045
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 2045
  descriptor.format = "%.*s %12.12s:%-4d : %s: \"%s\" %llu/%llu %d -> obj %p\n";
#line 2045
  descriptor.lineno = 2046U;
#line 2045
  descriptor.flags = 0U;
#line 2045
  tmp___7 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2045
  if (tmp___7 != 0L) {
#line 2045
    tmp___6 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 2045
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: \"%s\" %llu/%llu %d -> obj %p\n",
                       4, (char *)"    ", tmp___6, 2046, "rbd_obj_request_create",
                       object_name, offset, length, (int )type, obj_request);
  } else {

  }
#line 2048
  return (obj_request);
}
}
#line 2051 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_obj_request_destroy(struct kref *kref ) 
{ 
  struct rbd_obj_request *obj_request ;
  struct kref  const  *__mptr ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;

  {
#line 2055
  __mptr = (struct kref  const  *)kref;
#line 2055
  obj_request = (struct rbd_obj_request *)__mptr + 0xffffffffffffff18UL;
#line 2057
  descriptor.modname = "rbd";
#line 2057
  descriptor.function = "rbd_obj_request_destroy";
#line 2057
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 2057
  descriptor.format = "%.*s %12.12s:%-4d : %s: obj %p\n";
#line 2057
  descriptor.lineno = 2057U;
#line 2057
  descriptor.flags = 0U;
#line 2057
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2057
  if (tmp___0 != 0L) {
#line 2057
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 2057
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: obj %p\n", 4, (char *)"    ",
                       tmp, 2057, "rbd_obj_request_destroy", obj_request);
  } else {

  }
#line 2059
  tmp___1 = ldv__builtin_expect((unsigned long )obj_request->__annonCompField101.__annonCompField100.img_request != (unsigned long )((struct rbd_img_request *)0),
                             0L);
#line 2059
  if (tmp___1 != 0L) {
#line 2059
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_obj_request_destroy",
           2059, (char *)"obj_request->img_request == NULL");
#line 2059
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2059), "i" (12UL));
    ldv_38072: ;
#line 2059
    goto ldv_38072;
  } else {

  }
#line 2060
  tmp___2 = ldv__builtin_expect(obj_request->which != 4294967295U, 0L);
#line 2060
  if (tmp___2 != 0L) {
#line 2060
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_obj_request_destroy",
           2060, (char *)"obj_request->which == BAD_WHICH");
#line 2060
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2060), "i" (12UL));
    ldv_38073: ;
#line 2060
    goto ldv_38073;
  } else {

  }
#line 2062
  if ((unsigned long )obj_request->osd_req != (unsigned long )((struct ceph_osd_request *)0)) {
#line 2063
    rbd_osd_req_destroy(obj_request->osd_req);
  } else {

  }
#line 2065
  tmp___3 = obj_request_type_valid(obj_request->type);
#line 2065
  if (tmp___3) {
#line 2065
    tmp___4 = 0;
  } else {
#line 2065
    tmp___4 = 1;
  }
#line 2065
  tmp___5 = ldv__builtin_expect((long )tmp___4, 0L);
#line 2065
  if (tmp___5 != 0L) {
#line 2065
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_obj_request_destroy",
           2065, (char *)"obj_request_type_valid(obj_request->type)");
#line 2065
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2065), "i" (12UL));
    ldv_38074: ;
#line 2065
    goto ldv_38074;
  } else {

  }
#line 2066
  switch ((unsigned int )obj_request->type) {
  case 0U: ;
#line 2068
  goto ldv_38076;
  case 1U: ;
#line 2070
  if ((unsigned long )obj_request->__annonCompField103.bio_list != (unsigned long )((struct bio *)0)) {
#line 2071
    bio_chain_put(obj_request->__annonCompField103.bio_list);
  } else {

  }
#line 2072
  goto ldv_38076;
  case 2U: ;
#line 2074
  if ((unsigned long )obj_request->__annonCompField103.__annonCompField102.pages != (unsigned long )((struct page **)0)) {
#line 2075
    ceph_release_page_vector(obj_request->__annonCompField103.__annonCompField102.pages,
                             (int )obj_request->__annonCompField103.__annonCompField102.page_count);
  } else {

  }
#line 2077
  goto ldv_38076;
  }
  ldv_38076: 
#line 2080
  kfree((void const   *)obj_request->object_name);
#line 2081
  obj_request->object_name = (char const   *)0;
#line 2082
  kmem_cache_free(rbd_obj_request_cache, (void *)obj_request);
#line 2083
  return;
}
}
#line 2088 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_dev_unparent(struct rbd_device *rbd_dev ) 
{ 


  {
#line 2090
  rbd_dev_remove_parent(rbd_dev);
#line 2091
  rbd_spec_put(rbd_dev->parent_spec);
#line 2092
  rbd_dev->parent_spec = (struct rbd_spec *)0;
#line 2093
  rbd_dev->parent_overlap = 0ULL;
#line 2094
  return;
}
}
#line 2102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_dev_parent_put(struct rbd_device *rbd_dev ) 
{ 
  int counter ;

  {
#line 2106
  if ((unsigned long )rbd_dev->parent_spec == (unsigned long )((struct rbd_spec *)0)) {
#line 2107
    return;
  } else {

  }
#line 2109
  counter = atomic_dec_return_safe(& rbd_dev->parent_ref);
#line 2110
  if (counter > 0) {
#line 2111
    return;
  } else {

  }
#line 2115
  if (counter == 0) {
#line 2116
    rbd_dev_unparent(rbd_dev);
  } else {
#line 2118
    rbd_warn(rbd_dev, "parent reference underflow");
  }
#line 2119
  return;
}
}
#line 2129 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static bool rbd_dev_parent_get(struct rbd_device *rbd_dev ) 
{ 
  int counter ;

  {
#line 2131
  counter = 0;
#line 2133
  if ((unsigned long )rbd_dev->parent_spec == (unsigned long )((struct rbd_spec *)0)) {
#line 2134
    return (0);
  } else {

  }
#line 2136
  down_read(& rbd_dev->header_rwsem);
#line 2137
  if (rbd_dev->parent_overlap != 0ULL) {
#line 2138
    counter = atomic_inc_return_safe(& rbd_dev->parent_ref);
  } else {

  }
#line 2139
  up_read(& rbd_dev->header_rwsem);
#line 2141
  if (counter < 0) {
#line 2142
    rbd_warn(rbd_dev, "parent reference overflow");
  } else {

  }
#line 2144
  return (counter > 0);
}
}
#line 2152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct rbd_img_request *rbd_img_request_create(struct rbd_device *rbd_dev ,
                                                      u64 offset , u64 length , enum obj_operation_type op_type ,
                                                      struct ceph_snap_context *snapc ) 
{ 
  struct rbd_img_request *img_request ;
  void *tmp ;
  bool tmp___0 ;
  struct lock_class_key __key ;
  struct _ddebug descriptor ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;

  {
#line 2160
  tmp = kmem_cache_alloc(rbd_img_request_cache, 16U);
#line 2160
  img_request = (struct rbd_img_request *)tmp;
#line 2161
  if ((unsigned long )img_request == (unsigned long )((struct rbd_img_request *)0)) {
#line 2162
    return ((struct rbd_img_request *)0);
  } else {

  }
#line 2164
  img_request->__annonCompField105.rq = (struct request *)0;
#line 2165
  img_request->rbd_dev = rbd_dev;
#line 2166
  img_request->offset = offset;
#line 2167
  img_request->length = length;
#line 2168
  img_request->flags = 0UL;
#line 2169
  if ((unsigned int )op_type == 2U) {
#line 2170
    img_request_discard_set(img_request);
#line 2171
    img_request->__annonCompField104.snapc = snapc;
  } else
#line 2172
  if ((unsigned int )op_type == 0U) {
#line 2173
    img_request_write_set(img_request);
#line 2174
    img_request->__annonCompField104.snapc = snapc;
  } else {
#line 2176
    img_request->__annonCompField104.snap_id = (rbd_dev->spec)->snap_id;
  }
#line 2178
  tmp___0 = rbd_dev_parent_get(rbd_dev);
#line 2178
  if ((int )tmp___0) {
#line 2179
    img_request_layered_set(img_request);
  } else {

  }
#line 2180
  spinlock_check(& img_request->completion_lock);
#line 2180
  __raw_spin_lock_init(& img_request->completion_lock.__annonCompField17.rlock, "&(&img_request->completion_lock)->rlock",
                       & __key);
#line 2181
  img_request->next_completion = 0U;
#line 2182
  img_request->callback = (void (*)(struct rbd_img_request * ))0;
#line 2183
  img_request->result = 0;
#line 2184
  img_request->obj_request_count = 0U;
#line 2185
  INIT_LIST_HEAD(& img_request->obj_requests);
#line 2186
  kref_init(& img_request->kref);
#line 2188
  descriptor.modname = "rbd";
#line 2188
  descriptor.function = "rbd_img_request_create";
#line 2188
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 2188
  descriptor.format = "%.*s %12.12s:%-4d : %s: rbd_dev %p %s %llu/%llu -> img %p\n";
#line 2188
  descriptor.lineno = 2189U;
#line 2188
  descriptor.flags = 0U;
#line 2188
  tmp___3 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2188
  if (tmp___3 != 0L) {
#line 2188
    tmp___1 = obj_op_name(op_type);
#line 2188
    tmp___2 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 2188
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: rbd_dev %p %s %llu/%llu -> img %p\n",
                       4, (char *)"    ", tmp___2, 2189, "rbd_img_request_create",
                       rbd_dev, tmp___1, offset, length, img_request);
  } else {

  }
#line 2191
  return (img_request);
}
}
#line 2194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_img_request_destroy(struct kref *kref ) 
{ 
  struct rbd_img_request *img_request ;
  struct rbd_obj_request *obj_request ;
  struct rbd_obj_request *next_obj_request ;
  struct kref  const  *__mptr ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  long tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;

  {
#line 2200
  __mptr = (struct kref  const  *)kref;
#line 2200
  img_request = (struct rbd_img_request *)__mptr + 0xffffffffffffff48UL;
#line 2202
  descriptor.modname = "rbd";
#line 2202
  descriptor.function = "rbd_img_request_destroy";
#line 2202
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 2202
  descriptor.format = "%.*s %12.12s:%-4d : %s: img %p\n";
#line 2202
  descriptor.lineno = 2202U;
#line 2202
  descriptor.flags = 0U;
#line 2202
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2202
  if (tmp___0 != 0L) {
#line 2202
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 2202
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: img %p\n", 4, (char *)"    ",
                       tmp, 2202, "rbd_img_request_destroy", img_request);
  } else {

  }
#line 2204
  __mptr___0 = (struct list_head  const  *)img_request->obj_requests.prev;
#line 2204
  obj_request = (struct rbd_obj_request *)__mptr___0 + 0xffffffffffffffd0UL;
#line 2204
  __mptr___1 = (struct list_head  const  *)obj_request->__annonCompField101.__annonCompField100.links.prev;
#line 2204
  next_obj_request = (struct rbd_obj_request *)__mptr___1 + 0xffffffffffffffd0UL;
#line 2204
  goto ldv_38120;
  ldv_38119: 
#line 2205
  rbd_img_obj_request_del(img_request, obj_request);
#line 2204
  obj_request = next_obj_request;
#line 2204
  __mptr___2 = (struct list_head  const  *)next_obj_request->__annonCompField101.__annonCompField100.links.prev;
#line 2204
  next_obj_request = (struct rbd_obj_request *)__mptr___2 + 0xffffffffffffffd0UL;
  ldv_38120: ;
#line 2204
  if ((unsigned long )(& obj_request->__annonCompField101.__annonCompField100.links) != (unsigned long )(& img_request->obj_requests)) {
#line 2206
    goto ldv_38119;
  } else {

  }
#line 2206
  tmp___1 = ldv__builtin_expect(img_request->obj_request_count != 0U, 0L);
#line 2206
  if (tmp___1 != 0L) {
#line 2206
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_request_destroy",
           2206, (char *)"img_request->obj_request_count == 0");
#line 2206
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2206), "i" (12UL));
    ldv_38122: ;
#line 2206
    goto ldv_38122;
  } else {

  }
#line 2208
  tmp___2 = img_request_layered_test(img_request);
#line 2208
  if ((int )tmp___2) {
#line 2209
    img_request_layered_clear(img_request);
#line 2210
    rbd_dev_parent_put(img_request->rbd_dev);
  } else {

  }
#line 2213
  tmp___3 = img_request_write_test(img_request);
#line 2213
  if ((int )tmp___3) {
#line 2215
    ceph_put_snap_context(img_request->__annonCompField104.snapc);
  } else {
#line 2213
    tmp___4 = img_request_discard_test(img_request);
#line 2213
    if ((int )tmp___4) {
#line 2215
      ceph_put_snap_context(img_request->__annonCompField104.snapc);
    } else {

    }
  }
#line 2217
  kmem_cache_free(rbd_img_request_cache, (void *)img_request);
#line 2218
  return;
}
}
#line 2220 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct rbd_img_request *rbd_parent_request_create(struct rbd_obj_request *obj_request ,
                                                         u64 img_offset , u64 length ) 
{ 
  struct rbd_img_request *parent_request ;
  struct rbd_device *rbd_dev ;
  long tmp ;

  {
#line 2227
  tmp = ldv__builtin_expect((unsigned long )obj_request->__annonCompField101.__annonCompField100.img_request == (unsigned long )((struct rbd_img_request *)0),
                         0L);
#line 2227
  if (tmp != 0L) {
#line 2227
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_parent_request_create",
           2227, (char *)"obj_request->img_request");
#line 2227
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2227), "i" (12UL));
    ldv_38131: ;
#line 2227
    goto ldv_38131;
  } else {

  }
#line 2228
  rbd_dev = (obj_request->__annonCompField101.__annonCompField100.img_request)->rbd_dev;
#line 2230
  parent_request = rbd_img_request_create(rbd_dev->parent, img_offset, length, 1,
                                          (struct ceph_snap_context *)0);
#line 2232
  if ((unsigned long )parent_request == (unsigned long )((struct rbd_img_request *)0)) {
#line 2233
    return ((struct rbd_img_request *)0);
  } else {

  }
#line 2235
  img_request_child_set(parent_request);
#line 2236
  rbd_obj_request_get(obj_request);
#line 2237
  parent_request->__annonCompField105.obj_request = obj_request;
#line 2239
  return (parent_request);
}
}
#line 2242 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_parent_request_destroy(struct kref *kref ) 
{ 
  struct rbd_img_request *parent_request ;
  struct rbd_obj_request *orig_request ;
  struct kref  const  *__mptr ;

  {
#line 2247
  __mptr = (struct kref  const  *)kref;
#line 2247
  parent_request = (struct rbd_img_request *)__mptr + 0xffffffffffffff48UL;
#line 2248
  orig_request = parent_request->__annonCompField105.obj_request;
#line 2250
  parent_request->__annonCompField105.obj_request = (struct rbd_obj_request *)0;
#line 2251
  rbd_obj_request_put(orig_request);
#line 2252
  img_request_child_clear(parent_request);
#line 2254
  rbd_img_request_destroy(kref);
#line 2255
  return;
}
}
#line 2257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static bool rbd_img_obj_end_request(struct rbd_obj_request *obj_request ) 
{ 
  struct rbd_img_request *img_request ;
  unsigned int xferred ;
  int result ;
  bool more ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  struct rbd_device *rbd_dev ;
  enum obj_operation_type op_type ;
  bool tmp___3 ;
  bool tmp___4 ;
  char *tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  bool tmp___8 ;

  {
#line 2264
  tmp = obj_request_img_data_test(obj_request);
#line 2264
  if (tmp) {
#line 2264
    tmp___0 = 0;
  } else {
#line 2264
    tmp___0 = 1;
  }
#line 2264
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 2264
  if (tmp___1 != 0L) {
#line 2264
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_end_request",
           2264, (char *)"obj_request_img_data_test(obj_request)");
#line 2264
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2264), "i" (12UL));
    ldv_38147: ;
#line 2264
    goto ldv_38147;
  } else {

  }
#line 2265
  img_request = obj_request->__annonCompField101.__annonCompField100.img_request;
#line 2267
  tmp___2 = ldv__builtin_expect(obj_request->xferred > 4294967295ULL, 0L);
#line 2267
  if (tmp___2 != 0L) {
#line 2267
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_end_request",
           2267, (char *)"obj_request->xferred <= (u64)UINT_MAX");
#line 2267
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2267), "i" (12UL));
    ldv_38148: ;
#line 2267
    goto ldv_38148;
  } else {

  }
#line 2268
  xferred = (unsigned int )obj_request->xferred;
#line 2269
  result = obj_request->result;
#line 2270
  if (result != 0) {
#line 2271
    rbd_dev = img_request->rbd_dev;
#line 2274
    tmp___4 = img_request_discard_test(img_request);
#line 2274
    if ((int )tmp___4) {
#line 2275
      op_type = 2;
    } else {
#line 2276
      tmp___3 = img_request_write_test(img_request);
#line 2276
      if ((int )tmp___3) {
#line 2277
        op_type = 0;
      } else {
#line 2279
        op_type = 1;
      }
    }
#line 2281
    tmp___5 = obj_op_name(op_type);
#line 2281
    rbd_warn(rbd_dev, "%s %llx at %llx (%llx)", tmp___5, obj_request->length, obj_request->__annonCompField101.__annonCompField100.img_offset,
             obj_request->offset);
#line 2284
    rbd_warn(rbd_dev, "  result %d xferred %x", result, xferred);
#line 2286
    if (img_request->result == 0) {
#line 2287
      img_request->result = result;
    } else {

    }
#line 2292
    xferred = (unsigned int )obj_request->length;
  } else {

  }
#line 2297
  if ((unsigned int )obj_request->type == 2U) {
#line 2298
    obj_request->__annonCompField103.__annonCompField102.pages = (struct page **)0;
#line 2299
    obj_request->__annonCompField103.__annonCompField102.page_count = 0U;
  } else {

  }
#line 2302
  tmp___8 = img_request_child_test(img_request);
#line 2302
  if ((int )tmp___8) {
#line 2303
    tmp___6 = ldv__builtin_expect((unsigned long )img_request->__annonCompField105.obj_request == (unsigned long )((struct rbd_obj_request *)0),
                               0L);
#line 2303
    if (tmp___6 != 0L) {
#line 2303
      printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n",
             "rbd_img_obj_end_request", 2303, (char *)"img_request->obj_request != NULL");
#line 2303
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                           "i" (2303), "i" (12UL));
      ldv_38151: ;
#line 2303
      goto ldv_38151;
    } else {

    }
#line 2304
    more = obj_request->which < img_request->obj_request_count - 1U;
  } else {
#line 2306
    tmp___7 = ldv__builtin_expect((unsigned long )img_request->__annonCompField105.rq == (unsigned long )((struct request *)0),
                               0L);
#line 2306
    if (tmp___7 != 0L) {
#line 2306
      printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n",
             "rbd_img_obj_end_request", 2306, (char *)"img_request->rq != NULL");
#line 2306
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                           "i" (2306), "i" (12UL));
      ldv_38152: ;
#line 2306
      goto ldv_38152;
    } else {

    }
#line 2308
    more = blk_update_request(img_request->__annonCompField105.rq, result, xferred);
#line 2309
    if (! more) {
#line 2310
      __blk_mq_end_request(img_request->__annonCompField105.rq, result);
    } else {

    }
  }
#line 2313
  return (more);
}
}
#line 2316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_img_obj_callback(struct rbd_obj_request *obj_request ) 
{ 
  struct rbd_img_request *img_request ;
  u32 which ;
  bool more ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  struct _ddebug descriptor ;
  char const   *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  bool tmp___10 ;
  int tmp___11 ;
  struct list_head  const  *__mptr ;
  long tmp___12 ;

  {
#line 2319
  which = obj_request->which;
#line 2320
  more = 1;
#line 2322
  tmp = obj_request_img_data_test(obj_request);
#line 2322
  if (tmp) {
#line 2322
    tmp___0 = 0;
  } else {
#line 2322
    tmp___0 = 1;
  }
#line 2322
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 2322
  if (tmp___1 != 0L) {
#line 2322
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_callback",
           2322, (char *)"obj_request_img_data_test(obj_request)");
#line 2322
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2322), "i" (12UL));
    ldv_38160: ;
#line 2322
    goto ldv_38160;
  } else {

  }
#line 2323
  img_request = obj_request->__annonCompField101.__annonCompField100.img_request;
#line 2325
  descriptor.modname = "rbd";
#line 2325
  descriptor.function = "rbd_img_obj_callback";
#line 2325
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 2325
  descriptor.format = "%.*s %12.12s:%-4d : %s: img %p obj %p\n";
#line 2325
  descriptor.lineno = 2325U;
#line 2325
  descriptor.flags = 0U;
#line 2325
  tmp___3 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2325
  if (tmp___3 != 0L) {
#line 2325
    tmp___2 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 2325
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: img %p obj %p\n",
                       4, (char *)"    ", tmp___2, 2325, "rbd_img_obj_callback", img_request,
                       obj_request);
  } else {

  }
#line 2326
  tmp___4 = ldv__builtin_expect((unsigned long )img_request == (unsigned long )((struct rbd_img_request *)0),
                             0L);
#line 2326
  if (tmp___4 != 0L) {
#line 2326
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_callback",
           2326, (char *)"img_request != NULL");
#line 2326
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2326), "i" (12UL));
    ldv_38162: ;
#line 2326
    goto ldv_38162;
  } else {

  }
#line 2327
  tmp___5 = ldv__builtin_expect(img_request->obj_request_count == 0U, 0L);
#line 2327
  if (tmp___5 != 0L) {
#line 2327
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_callback",
           2327, (char *)"img_request->obj_request_count > 0");
#line 2327
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2327), "i" (12UL));
    ldv_38163: ;
#line 2327
    goto ldv_38163;
  } else {

  }
#line 2328
  tmp___6 = ldv__builtin_expect(which == 4294967295U, 0L);
#line 2328
  if (tmp___6 != 0L) {
#line 2328
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_callback",
           2328, (char *)"which != BAD_WHICH");
#line 2328
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2328), "i" (12UL));
    ldv_38164: ;
#line 2328
    goto ldv_38164;
  } else {

  }
#line 2329
  tmp___7 = ldv__builtin_expect(img_request->obj_request_count <= which, 0L);
#line 2329
  if (tmp___7 != 0L) {
#line 2329
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_callback",
           2329, (char *)"which < img_request->obj_request_count");
#line 2329
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2329), "i" (12UL));
    ldv_38165: ;
#line 2329
    goto ldv_38165;
  } else {

  }
#line 2331
  spin_lock_irq(& img_request->completion_lock);
#line 2332
  if (img_request->next_completion != which) {
#line 2333
    goto out;
  } else {

  }
#line 2335
  goto ldv_38173;
  ldv_38172: 
#line 2336
  tmp___8 = ldv__builtin_expect((long )(! more), 0L);
#line 2336
  if (tmp___8 != 0L) {
#line 2336
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_callback",
           2336, (char *)"more");
#line 2336
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2336), "i" (12UL));
    ldv_38169: ;
#line 2336
    goto ldv_38169;
  } else {

  }
#line 2337
  tmp___9 = ldv__builtin_expect(img_request->obj_request_count <= which, 0L);
#line 2337
  if (tmp___9 != 0L) {
#line 2337
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_callback",
           2337, (char *)"which < img_request->obj_request_count");
#line 2337
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2337), "i" (12UL));
    ldv_38170: ;
#line 2337
    goto ldv_38170;
  } else {

  }
#line 2339
  tmp___10 = obj_request_done_test(obj_request);
#line 2339
  if (tmp___10) {
#line 2339
    tmp___11 = 0;
  } else {
#line 2339
    tmp___11 = 1;
  }
#line 2339
  if (tmp___11) {
#line 2340
    goto ldv_38171;
  } else {

  }
#line 2341
  more = rbd_img_obj_end_request(obj_request);
#line 2342
  which = which + 1U;
#line 2335
  __mptr = (struct list_head  const  *)obj_request->__annonCompField101.__annonCompField100.links.next;
#line 2335
  obj_request = (struct rbd_obj_request *)__mptr + 0xffffffffffffffd0UL;
  ldv_38173: ;
#line 2335
  if ((unsigned long )(& obj_request->__annonCompField101.__annonCompField100.links) != (unsigned long )(& img_request->obj_requests)) {
#line 2337
    goto ldv_38172;
  } else {

  }
  ldv_38171: 
#line 2345
  tmp___12 = ldv__builtin_expect((int )more == (img_request->obj_request_count == which),
                              0L);
#line 2345
  if (tmp___12 != 0L) {
#line 2345
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_callback",
           2345, (char *)"more ^ (which == img_request->obj_request_count)");
#line 2345
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2345), "i" (12UL));
    ldv_38174: ;
#line 2345
    goto ldv_38174;
  } else {

  }
#line 2346
  img_request->next_completion = which;
  out: 
#line 2348
  spin_unlock_irq(& img_request->completion_lock);
#line 2349
  rbd_img_request_put(img_request);
#line 2351
  if (! more) {
#line 2352
    rbd_img_request_complete(img_request);
  } else {

  }
#line 2353
  return;
}
}
#line 2360 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_img_obj_request_fill(struct rbd_obj_request *obj_request , struct ceph_osd_request *osd_request ,
                                     enum obj_operation_type op_type , unsigned int num_ops ) 
{ 
  struct rbd_img_request *img_request ;
  struct rbd_device *rbd_dev ;
  u64 object_size ;
  u64 tmp ;
  u64 offset ;
  u64 length ;
  u64 img_end ;
  u16 opcode ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 2365
  img_request = obj_request->__annonCompField101.__annonCompField100.img_request;
#line 2366
  rbd_dev = img_request->rbd_dev;
#line 2367
  tmp = rbd_obj_bytes(& rbd_dev->header);
#line 2367
  object_size = tmp;
#line 2368
  offset = obj_request->offset;
#line 2369
  length = obj_request->length;
#line 2373
  if ((unsigned int )op_type == 2U) {
#line 2374
    if (offset == 0ULL && length == object_size) {
#line 2374
      tmp___0 = img_request_layered_test(img_request);
#line 2374
      if (tmp___0) {
#line 2374
        tmp___1 = 0;
      } else {
#line 2374
        tmp___1 = 1;
      }
#line 2374
      if (tmp___1) {
#line 2377
        opcode = 8709U;
      } else {
#line 2374
        tmp___2 = obj_request_overlaps_parent(obj_request);
#line 2374
        if (tmp___2) {
#line 2374
          tmp___3 = 0;
        } else {
#line 2374
          tmp___3 = 1;
        }
#line 2374
        if (tmp___3) {
#line 2377
          opcode = 8709U;
        } else {
#line 2374
          goto _L;
        }
      }
    } else
    _L: /* CIL Label */ 
#line 2378
    if (offset + length == object_size) {
#line 2379
      opcode = 8707U;
    } else {
#line 2381
      down_read(& rbd_dev->header_rwsem);
#line 2382
      img_end = rbd_dev->header.image_size;
#line 2383
      up_read(& rbd_dev->header_rwsem);
#line 2385
      if (obj_request->__annonCompField101.__annonCompField100.img_offset + length == img_end) {
#line 2386
        opcode = 8707U;
      } else {
#line 2388
        opcode = 8708U;
      }
    }
  } else
#line 2390
  if ((unsigned int )op_type == 0U) {
#line 2391
    opcode = 8705U;
#line 2392
    osd_req_op_alloc_hint_init(osd_request, num_ops, object_size, object_size);
#line 2394
    num_ops = num_ops + 1U;
  } else {
#line 2396
    opcode = 4609U;
  }
#line 2399
  if ((unsigned int )opcode == 8709U) {
#line 2400
    osd_req_op_init(osd_request, num_ops, (int )opcode, 0U);
  } else {
#line 2402
    osd_req_op_extent_init(osd_request, num_ops, (int )opcode, offset, length, 0ULL,
                           0U);
  }
#line 2405
  if ((unsigned int )obj_request->type == 1U) {
#line 2406
    osd_req_op_extent_osd_data_bio(osd_request, num_ops, obj_request->__annonCompField103.bio_list,
                                   (size_t )length);
  } else
#line 2408
  if ((unsigned int )obj_request->type == 2U) {
#line 2409
    osd_req_op_extent_osd_data_pages(osd_request, num_ops, obj_request->__annonCompField103.__annonCompField102.pages,
                                     length, (u32 )offset & 4095U, 0, 0);
  } else {

  }
#line 2414
  if ((unsigned int )op_type == 0U || (unsigned int )op_type == 2U) {
#line 2415
    rbd_osd_req_format_write(obj_request);
  } else {
#line 2417
    rbd_osd_req_format_read(obj_request);
  }
#line 2418
  return;
}
}
#line 2428 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_img_request_fill(struct rbd_img_request *img_request , enum obj_request_type type ,
                                void *data_desc ) 
{ 
  struct rbd_device *rbd_dev ;
  struct rbd_obj_request *obj_request ;
  struct rbd_obj_request *next_obj_request ;
  struct bio *bio_list ;
  unsigned int bio_offset ;
  struct page **pages ;
  enum obj_operation_type op_type ;
  u64 img_offset ;
  u64 resid ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  struct ceph_osd_request *osd_req ;
  char const   *object_name ;
  u64 offset ;
  u64 length ;
  unsigned int clone_size ;
  long tmp___3 ;
  unsigned int page_count___0 ;
  int tmp___4 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 2432
  rbd_dev = img_request->rbd_dev;
#line 2433
  obj_request = (struct rbd_obj_request *)0;
#line 2435
  bio_list = (struct bio *)0;
#line 2436
  bio_offset = 0U;
#line 2437
  pages = (struct page **)0;
#line 2442
  descriptor.modname = "rbd";
#line 2442
  descriptor.function = "rbd_img_request_fill";
#line 2442
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 2442
  descriptor.format = "%.*s %12.12s:%-4d : %s: img %p type %d data_desc %p\n";
#line 2442
  descriptor.lineno = 2443U;
#line 2442
  descriptor.flags = 0U;
#line 2442
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2442
  if (tmp___0 != 0L) {
#line 2442
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 2442
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: img %p type %d data_desc %p\n",
                       4, (char *)"    ", tmp, 2443, "rbd_img_request_fill", img_request,
                       (int )type, data_desc);
  } else {

  }
#line 2445
  img_offset = img_request->offset;
#line 2446
  resid = img_request->length;
#line 2447
  tmp___1 = ldv__builtin_expect(resid == 0ULL, 0L);
#line 2447
  if (tmp___1 != 0L) {
#line 2447
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_request_fill",
           2447, (char *)"resid > 0");
#line 2447
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2447), "i" (12UL));
    ldv_38204: ;
#line 2447
    goto ldv_38204;
  } else {

  }
#line 2448
  op_type = rbd_img_request_op_type(img_request);
#line 2450
  if ((unsigned int )type == 1U) {
#line 2451
    bio_list = (struct bio *)data_desc;
#line 2452
    tmp___2 = ldv__builtin_expect((unsigned long long )(bio_list->bi_iter.bi_sector << 9) != img_offset,
                               0L);
#line 2452
    if (tmp___2 != 0L) {
#line 2452
      printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n",
             "rbd_img_request_fill", 2453, (char *)"img_offset == bio_list->bi_iter.bi_sector << SECTOR_SHIFT");
#line 2452
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                           "i" (2453), "i" (12UL));
      ldv_38205: ;
#line 2452
      goto ldv_38205;
    } else {

    }
  } else
#line 2454
  if ((unsigned int )type == 2U) {
#line 2455
    pages = (struct page **)data_desc;
  } else {

  }
#line 2458
  goto ldv_38215;
  ldv_38214: 
#line 2464
  object_name = rbd_segment_name(rbd_dev, img_offset);
#line 2465
  if ((unsigned long )object_name == (unsigned long )((char const   *)0)) {
#line 2466
    goto out_unwind;
  } else {

  }
#line 2467
  offset = rbd_segment_offset(rbd_dev, img_offset);
#line 2468
  length = rbd_segment_length(rbd_dev, img_offset, resid);
#line 2469
  obj_request = rbd_obj_request_create(object_name, offset, length, type);
#line 2472
  rbd_segment_name_free(object_name);
#line 2473
  if ((unsigned long )obj_request == (unsigned long )((struct rbd_obj_request *)0)) {
#line 2474
    goto out_unwind;
  } else {

  }
#line 2480
  rbd_img_obj_request_add(img_request, obj_request);
#line 2482
  if ((unsigned int )type == 1U) {
#line 2485
    tmp___3 = ldv__builtin_expect(length > 4294967295ULL, 0L);
#line 2485
    if (tmp___3 != 0L) {
#line 2485
      printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n",
             "rbd_img_request_fill", 2485, (char *)"length <= (u64)UINT_MAX");
#line 2485
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                           "i" (2485), "i" (12UL));
      ldv_38212: ;
#line 2485
      goto ldv_38212;
    } else {

    }
#line 2486
    clone_size = (unsigned int )length;
#line 2487
    obj_request->__annonCompField103.bio_list = bio_chain_clone_range(& bio_list,
                                                                      & bio_offset,
                                                                      clone_size,
                                                                      32U);
#line 2492
    if ((unsigned long )obj_request->__annonCompField103.bio_list == (unsigned long )((struct bio *)0)) {
#line 2493
      goto out_unwind;
    } else {

    }
  } else
#line 2494
  if ((unsigned int )type == 2U) {
#line 2497
    obj_request->__annonCompField103.__annonCompField102.pages = pages;
#line 2498
    tmp___4 = calc_pages_for(offset, length);
#line 2498
    page_count___0 = (unsigned int )tmp___4;
#line 2499
    obj_request->__annonCompField103.__annonCompField102.page_count = page_count___0;
#line 2500
    if (((offset + length) & 4095ULL) != 0ULL) {
#line 2501
      page_count___0 = page_count___0 - 1U;
    } else {

    }
#line 2502
    pages = pages + (unsigned long )page_count___0;
  } else {

  }
#line 2505
  osd_req = rbd_osd_req_create(rbd_dev, op_type, (unsigned int )op_type == 0U ? 2U : 1U,
                               obj_request);
#line 2508
  if ((unsigned long )osd_req == (unsigned long )((struct ceph_osd_request *)0)) {
#line 2509
    goto out_unwind;
  } else {

  }
#line 2511
  obj_request->osd_req = osd_req;
#line 2512
  obj_request->callback = & rbd_img_obj_callback;
#line 2513
  obj_request->__annonCompField101.__annonCompField100.img_offset = img_offset;
#line 2515
  rbd_img_obj_request_fill(obj_request, osd_req, op_type, 0U);
#line 2517
  rbd_img_request_get(img_request);
#line 2519
  img_offset = img_offset + length;
#line 2520
  resid = resid - length;
  ldv_38215: ;
#line 2458
  if (resid != 0ULL) {
#line 2460
    goto ldv_38214;
  } else {

  }

#line 2523
  return (0);
  out_unwind: 
#line 2526
  __mptr = (struct list_head  const  *)img_request->obj_requests.prev;
#line 2526
  obj_request = (struct rbd_obj_request *)__mptr + 0xffffffffffffffd0UL;
#line 2526
  __mptr___0 = (struct list_head  const  *)obj_request->__annonCompField101.__annonCompField100.links.prev;
#line 2526
  next_obj_request = (struct rbd_obj_request *)__mptr___0 + 0xffffffffffffffd0UL;
#line 2526
  goto ldv_38224;
  ldv_38223: 
#line 2527
  rbd_img_obj_request_del(img_request, obj_request);
#line 2526
  obj_request = next_obj_request;
#line 2526
  __mptr___1 = (struct list_head  const  *)next_obj_request->__annonCompField101.__annonCompField100.links.prev;
#line 2526
  next_obj_request = (struct rbd_obj_request *)__mptr___1 + 0xffffffffffffffd0UL;
  ldv_38224: ;
#line 2526
  if ((unsigned long )(& obj_request->__annonCompField101.__annonCompField100.links) != (unsigned long )(& img_request->obj_requests)) {
#line 2528
    goto ldv_38223;
  } else {

  }

#line 2529
  return (-12);
}
}
#line 2533 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_img_obj_copyup_callback(struct rbd_obj_request *obj_request ) 
{ 
  struct rbd_img_request *img_request ;
  struct rbd_device *rbd_dev ;
  struct page **pages ;
  u32 page_count___0 ;
  long tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 2540
  tmp = ldv__builtin_expect((long )((unsigned int )obj_request->type != 1U && (unsigned int )obj_request->type != 0U),
                         0L);
#line 2540
  if (tmp != 0L) {
#line 2540
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_copyup_callback",
           2541, (char *)"obj_request->type == OBJ_REQUEST_BIO || obj_request->type == OBJ_REQUEST_NODATA");
#line 2540
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2541), "i" (12UL));
    ldv_38234: ;
#line 2540
    goto ldv_38234;
  } else {

  }
#line 2542
  tmp___0 = obj_request_img_data_test(obj_request);
#line 2542
  if (tmp___0) {
#line 2542
    tmp___1 = 0;
  } else {
#line 2542
    tmp___1 = 1;
  }
#line 2542
  tmp___2 = ldv__builtin_expect((long )tmp___1, 0L);
#line 2542
  if (tmp___2 != 0L) {
#line 2542
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_copyup_callback",
           2542, (char *)"obj_request_img_data_test(obj_request)");
#line 2542
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2542), "i" (12UL));
    ldv_38235: ;
#line 2542
    goto ldv_38235;
  } else {

  }
#line 2543
  img_request = obj_request->__annonCompField101.__annonCompField100.img_request;
#line 2544
  tmp___3 = ldv__builtin_expect((unsigned long )img_request == (unsigned long )((struct rbd_img_request *)0),
                             0L);
#line 2544
  if (tmp___3 != 0L) {
#line 2544
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_copyup_callback",
           2544, (char *)"img_request");
#line 2544
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2544), "i" (12UL));
    ldv_38236: ;
#line 2544
    goto ldv_38236;
  } else {

  }
#line 2546
  rbd_dev = img_request->rbd_dev;
#line 2547
  tmp___4 = ldv__builtin_expect((unsigned long )rbd_dev == (unsigned long )((struct rbd_device *)0),
                             0L);
#line 2547
  if (tmp___4 != 0L) {
#line 2547
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_copyup_callback",
           2547, (char *)"rbd_dev");
#line 2547
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2547), "i" (12UL));
    ldv_38237: ;
#line 2547
    goto ldv_38237;
  } else {

  }
#line 2549
  pages = obj_request->copyup_pages;
#line 2550
  tmp___5 = ldv__builtin_expect((unsigned long )pages == (unsigned long )((struct page **)0),
                             0L);
#line 2550
  if (tmp___5 != 0L) {
#line 2550
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_copyup_callback",
           2550, (char *)"pages != NULL");
#line 2550
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2550), "i" (12UL));
    ldv_38238: ;
#line 2550
    goto ldv_38238;
  } else {

  }
#line 2551
  obj_request->copyup_pages = (struct page **)0;
#line 2552
  page_count___0 = obj_request->copyup_page_count;
#line 2553
  tmp___6 = ldv__builtin_expect(page_count___0 == 0U, 0L);
#line 2553
  if (tmp___6 != 0L) {
#line 2553
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_copyup_callback",
           2553, (char *)"page_count");
#line 2553
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2553), "i" (12UL));
    ldv_38239: ;
#line 2553
    goto ldv_38239;
  } else {

  }
#line 2554
  obj_request->copyup_page_count = 0U;
#line 2555
  ceph_release_page_vector(pages, (int )page_count___0);
#line 2563
  if (obj_request->result == 0) {
#line 2564
    obj_request->xferred = obj_request->length;
  } else {

  }
#line 2568
  rbd_img_obj_callback(obj_request);
#line 2569
  return;
}
}
#line 2572 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_img_obj_parent_read_full_callback(struct rbd_img_request *img_request ) 
{ 
  struct rbd_obj_request *orig_request ;
  struct ceph_osd_request *osd_req ;
  struct ceph_osd_client *osdc ;
  struct rbd_device *rbd_dev ;
  struct page **pages ;
  enum obj_operation_type op_type ;
  u32 page_count___0 ;
  int img_result ;
  u64 parent_length ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  struct ceph_osd_client *osdc___0 ;

  {
#line 2584
  tmp = img_request_child_test(img_request);
#line 2584
  if (tmp) {
#line 2584
    tmp___0 = 0;
  } else {
#line 2584
    tmp___0 = 1;
  }
#line 2584
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 2584
  if (tmp___1 != 0L) {
#line 2584
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_parent_read_full_callback",
           2584, (char *)"img_request_child_test(img_request)");
#line 2584
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2584), "i" (12UL));
    ldv_38253: ;
#line 2584
    goto ldv_38253;
  } else {

  }
#line 2588
  pages = img_request->copyup_pages;
#line 2589
  tmp___2 = ldv__builtin_expect((unsigned long )pages == (unsigned long )((struct page **)0),
                             0L);
#line 2589
  if (tmp___2 != 0L) {
#line 2589
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_parent_read_full_callback",
           2589, (char *)"pages != NULL");
#line 2589
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2589), "i" (12UL));
    ldv_38254: ;
#line 2589
    goto ldv_38254;
  } else {

  }
#line 2590
  img_request->copyup_pages = (struct page **)0;
#line 2591
  page_count___0 = img_request->copyup_page_count;
#line 2592
  tmp___3 = ldv__builtin_expect(page_count___0 == 0U, 0L);
#line 2592
  if (tmp___3 != 0L) {
#line 2592
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_parent_read_full_callback",
           2592, (char *)"page_count");
#line 2592
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2592), "i" (12UL));
    ldv_38255: ;
#line 2592
    goto ldv_38255;
  } else {

  }
#line 2593
  img_request->copyup_page_count = 0U;
#line 2595
  orig_request = img_request->__annonCompField105.obj_request;
#line 2596
  tmp___4 = ldv__builtin_expect((unsigned long )orig_request == (unsigned long )((struct rbd_obj_request *)0),
                             0L);
#line 2596
  if (tmp___4 != 0L) {
#line 2596
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_parent_read_full_callback",
           2596, (char *)"orig_request != NULL");
#line 2596
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2596), "i" (12UL));
    ldv_38256: ;
#line 2596
    goto ldv_38256;
  } else {

  }
#line 2597
  tmp___5 = obj_request_type_valid(orig_request->type);
#line 2597
  if (tmp___5) {
#line 2597
    tmp___6 = 0;
  } else {
#line 2597
    tmp___6 = 1;
  }
#line 2597
  tmp___7 = ldv__builtin_expect((long )tmp___6, 0L);
#line 2597
  if (tmp___7 != 0L) {
#line 2597
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_parent_read_full_callback",
           2597, (char *)"obj_request_type_valid(orig_request->type)");
#line 2597
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2597), "i" (12UL));
    ldv_38257: ;
#line 2597
    goto ldv_38257;
  } else {

  }
#line 2598
  img_result = img_request->result;
#line 2599
  parent_length = img_request->length;
#line 2600
  tmp___8 = ldv__builtin_expect(img_request->xferred != parent_length, 0L);
#line 2600
  if (tmp___8 != 0L) {
#line 2600
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_parent_read_full_callback",
           2600, (char *)"parent_length == img_request->xferred");
#line 2600
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2600), "i" (12UL));
    ldv_38258: ;
#line 2600
    goto ldv_38258;
  } else {

  }
#line 2601
  rbd_img_request_put(img_request);
#line 2603
  tmp___9 = ldv__builtin_expect((unsigned long )orig_request->__annonCompField101.__annonCompField100.img_request == (unsigned long )((struct rbd_img_request *)0),
                             0L);
#line 2603
  if (tmp___9 != 0L) {
#line 2603
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_parent_read_full_callback",
           2603, (char *)"orig_request->img_request");
#line 2603
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2603), "i" (12UL));
    ldv_38259: ;
#line 2603
    goto ldv_38259;
  } else {

  }
#line 2604
  rbd_dev = (orig_request->__annonCompField101.__annonCompField100.img_request)->rbd_dev;
#line 2605
  tmp___10 = ldv__builtin_expect((unsigned long )rbd_dev == (unsigned long )((struct rbd_device *)0),
                              0L);
#line 2605
  if (tmp___10 != 0L) {
#line 2605
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_parent_read_full_callback",
           2605, (char *)"rbd_dev");
#line 2605
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2605), "i" (12UL));
    ldv_38260: ;
#line 2605
    goto ldv_38260;
  } else {

  }
#line 2612
  if (rbd_dev->parent_overlap == 0ULL) {
#line 2615
    ceph_release_page_vector(pages, (int )page_count___0);
#line 2616
    osdc___0 = & ((rbd_dev->rbd_client)->client)->osdc;
#line 2617
    img_result = rbd_obj_request_submit(osdc___0, orig_request);
#line 2618
    if (img_result == 0) {
#line 2619
      return;
    } else {

    }
  } else {

  }
#line 2622
  if (img_result != 0) {
#line 2623
    goto out_err;
  } else {

  }
#line 2631
  img_result = -12;
#line 2632
  osd_req = rbd_osd_req_create_copyup(orig_request);
#line 2633
  if ((unsigned long )osd_req == (unsigned long )((struct ceph_osd_request *)0)) {
#line 2634
    goto out_err;
  } else {

  }
#line 2635
  rbd_osd_req_destroy(orig_request->osd_req);
#line 2636
  orig_request->osd_req = osd_req;
#line 2637
  orig_request->copyup_pages = pages;
#line 2638
  orig_request->copyup_page_count = page_count___0;
#line 2642
  osd_req_op_cls_init(osd_req, 0U, 5121, "rbd", "copyup");
#line 2643
  osd_req_op_cls_request_data_pages(osd_req, 0U, pages, parent_length, 0U, 0, 0);
#line 2648
  op_type = rbd_img_request_op_type(orig_request->__annonCompField101.__annonCompField100.img_request);
#line 2649
  rbd_img_obj_request_fill(orig_request, osd_req, op_type, 1U);
#line 2653
  orig_request->callback = & rbd_img_obj_copyup_callback;
#line 2654
  osdc = & ((rbd_dev->rbd_client)->client)->osdc;
#line 2655
  img_result = rbd_obj_request_submit(osdc, orig_request);
#line 2656
  if (img_result == 0) {
#line 2657
    return;
  } else {

  }
  out_err: 
#line 2661
  orig_request->result = img_result;
#line 2662
  orig_request->xferred = 0ULL;
#line 2663
  obj_request_done_set(orig_request);
#line 2664
  rbd_obj_request_complete(orig_request);
#line 2665
  return;
}
}
#line 2681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_img_obj_parent_read_full(struct rbd_obj_request *obj_request ) 
{ 
  struct rbd_img_request *img_request ;
  struct rbd_img_request *parent_request ;
  struct rbd_device *rbd_dev ;
  u64 img_offset ;
  u64 length ;
  struct page **pages ;
  u32 page_count___0 ;
  int result ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  bool tmp___10 ;

  {
#line 2683
  img_request = (struct rbd_img_request *)0;
#line 2684
  parent_request = (struct rbd_img_request *)0;
#line 2688
  pages = (struct page **)0;
#line 2692
  tmp = obj_request_img_data_test(obj_request);
#line 2692
  if (tmp) {
#line 2692
    tmp___0 = 0;
  } else {
#line 2692
    tmp___0 = 1;
  }
#line 2692
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 2692
  if (tmp___1 != 0L) {
#line 2692
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_parent_read_full",
           2692, (char *)"obj_request_img_data_test(obj_request)");
#line 2692
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2692), "i" (12UL));
    ldv_38275: ;
#line 2692
    goto ldv_38275;
  } else {

  }
#line 2693
  tmp___2 = obj_request_type_valid(obj_request->type);
#line 2693
  if (tmp___2) {
#line 2693
    tmp___3 = 0;
  } else {
#line 2693
    tmp___3 = 1;
  }
#line 2693
  tmp___4 = ldv__builtin_expect((long )tmp___3, 0L);
#line 2693
  if (tmp___4 != 0L) {
#line 2693
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_parent_read_full",
           2693, (char *)"obj_request_type_valid(obj_request->type)");
#line 2693
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2693), "i" (12UL));
    ldv_38276: ;
#line 2693
    goto ldv_38276;
  } else {

  }
#line 2695
  img_request = obj_request->__annonCompField101.__annonCompField100.img_request;
#line 2696
  tmp___5 = ldv__builtin_expect((unsigned long )img_request == (unsigned long )((struct rbd_img_request *)0),
                             0L);
#line 2696
  if (tmp___5 != 0L) {
#line 2696
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_parent_read_full",
           2696, (char *)"img_request != NULL");
#line 2696
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2696), "i" (12UL));
    ldv_38277: ;
#line 2696
    goto ldv_38277;
  } else {

  }
#line 2697
  rbd_dev = img_request->rbd_dev;
#line 2698
  tmp___6 = ldv__builtin_expect((unsigned long )rbd_dev->parent == (unsigned long )((struct rbd_device *)0),
                             0L);
#line 2698
  if (tmp___6 != 0L) {
#line 2698
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_parent_read_full",
           2698, (char *)"rbd_dev->parent != NULL");
#line 2698
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2698), "i" (12UL));
    ldv_38278: ;
#line 2698
    goto ldv_38278;
  } else {

  }
#line 2704
  img_offset = obj_request->__annonCompField101.__annonCompField100.img_offset - obj_request->offset;
#line 2705
  length = 1ULL << (int )rbd_dev->header.obj_order;
#line 2712
  if (img_offset + length > rbd_dev->parent_overlap) {
#line 2713
    tmp___7 = ldv__builtin_expect(rbd_dev->parent_overlap <= img_offset, 0L);
#line 2713
    if (tmp___7 != 0L) {
#line 2713
      printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n",
             "rbd_img_obj_parent_read_full", 2713, (char *)"img_offset < rbd_dev->parent_overlap");
#line 2713
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                           "i" (2713), "i" (12UL));
      ldv_38279: ;
#line 2713
      goto ldv_38279;
    } else {

    }
#line 2714
    length = rbd_dev->parent_overlap - img_offset;
  } else {

  }
#line 2721
  tmp___8 = calc_pages_for(0ULL, length);
#line 2721
  page_count___0 = (unsigned int )tmp___8;
#line 2722
  pages = ceph_alloc_page_vector((int )page_count___0, 208U);
#line 2723
  tmp___10 = IS_ERR((void const   *)pages);
#line 2723
  if ((int )tmp___10) {
#line 2724
    tmp___9 = PTR_ERR((void const   *)pages);
#line 2724
    result = (int )tmp___9;
#line 2725
    pages = (struct page **)0;
#line 2726
    goto out_err;
  } else {

  }
#line 2729
  result = -12;
#line 2730
  parent_request = rbd_parent_request_create(obj_request, img_offset, length);
#line 2732
  if ((unsigned long )parent_request == (unsigned long )((struct rbd_img_request *)0)) {
#line 2733
    goto out_err;
  } else {

  }
#line 2735
  result = rbd_img_request_fill(parent_request, 2, (void *)pages);
#line 2736
  if (result != 0) {
#line 2737
    goto out_err;
  } else {

  }
#line 2738
  parent_request->copyup_pages = pages;
#line 2739
  parent_request->copyup_page_count = page_count___0;
#line 2741
  parent_request->callback = & rbd_img_obj_parent_read_full_callback;
#line 2742
  result = rbd_img_request_submit(parent_request);
#line 2743
  if (result == 0) {
#line 2744
    return (0);
  } else {

  }
#line 2746
  parent_request->copyup_pages = (struct page **)0;
#line 2747
  parent_request->copyup_page_count = 0U;
#line 2748
  parent_request->__annonCompField105.obj_request = (struct rbd_obj_request *)0;
#line 2749
  rbd_obj_request_put(obj_request);
  out_err: ;
#line 2751
  if ((unsigned long )pages != (unsigned long )((struct page **)0)) {
#line 2752
    ceph_release_page_vector(pages, (int )page_count___0);
  } else {

  }
#line 2753
  if ((unsigned long )parent_request != (unsigned long )((struct rbd_img_request *)0)) {
#line 2754
    rbd_img_request_put(parent_request);
  } else {

  }
#line 2755
  obj_request->result = result;
#line 2756
  obj_request->xferred = 0ULL;
#line 2757
  obj_request_done_set(obj_request);
#line 2759
  return (result);
}
}
#line 2762 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_img_obj_exists_callback(struct rbd_obj_request *obj_request ) 
{ 
  struct rbd_obj_request *orig_request ;
  struct rbd_device *rbd_dev ;
  int result ;
  bool tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor ;
  char const   *tmp___3 ;
  long tmp___4 ;
  struct ceph_osd_client *osdc ;

  {
#line 2768
  tmp = obj_request_img_data_test(obj_request);
#line 2768
  tmp___0 = ldv__builtin_expect((long )tmp, 0L);
#line 2768
  if (tmp___0 != 0L) {
#line 2768
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_exists_callback",
           2768, (char *)"!obj_request_img_data_test(obj_request)");
#line 2768
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2768), "i" (12UL));
    ldv_38288: ;
#line 2768
    goto ldv_38288;
  } else {

  }
#line 2775
  orig_request = obj_request->__annonCompField101.obj_request;
#line 2776
  obj_request->__annonCompField101.obj_request = (struct rbd_obj_request *)0;
#line 2777
  rbd_obj_request_put(orig_request);
#line 2778
  tmp___1 = ldv__builtin_expect((unsigned long )orig_request == (unsigned long )((struct rbd_obj_request *)0),
                             0L);
#line 2778
  if (tmp___1 != 0L) {
#line 2778
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_exists_callback",
           2778, (char *)"orig_request");
#line 2778
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2778), "i" (12UL));
    ldv_38289: ;
#line 2778
    goto ldv_38289;
  } else {

  }
#line 2779
  tmp___2 = ldv__builtin_expect((unsigned long )orig_request->__annonCompField101.__annonCompField100.img_request == (unsigned long )((struct rbd_img_request *)0),
                             0L);
#line 2779
  if (tmp___2 != 0L) {
#line 2779
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_exists_callback",
           2779, (char *)"orig_request->img_request");
#line 2779
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2779), "i" (12UL));
    ldv_38290: ;
#line 2779
    goto ldv_38290;
  } else {

  }
#line 2781
  result = obj_request->result;
#line 2782
  obj_request->result = 0;
#line 2784
  descriptor.modname = "rbd";
#line 2784
  descriptor.function = "rbd_img_obj_exists_callback";
#line 2784
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 2784
  descriptor.format = "%.*s %12.12s:%-4d : %s: obj %p for obj %p result %d %llu/%llu\n";
#line 2784
  descriptor.lineno = 2786U;
#line 2784
  descriptor.flags = 0U;
#line 2784
  tmp___4 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2784
  if (tmp___4 != 0L) {
#line 2784
    tmp___3 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 2784
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: obj %p for obj %p result %d %llu/%llu\n",
                       4, (char *)"    ", tmp___3, 2786, "rbd_img_obj_exists_callback",
                       obj_request, orig_request, result, obj_request->xferred, obj_request->length);
  } else {

  }
#line 2787
  rbd_obj_request_put(obj_request);
#line 2794
  rbd_dev = (orig_request->__annonCompField101.__annonCompField100.img_request)->rbd_dev;
#line 2795
  if (rbd_dev->parent_overlap == 0ULL) {
#line 2798
    osdc = & ((rbd_dev->rbd_client)->client)->osdc;
#line 2799
    result = rbd_obj_request_submit(osdc, orig_request);
#line 2800
    if (result == 0) {
#line 2801
      return;
    } else {

    }
  } else {

  }
#line 2810
  if (result == 0) {
#line 2811
    obj_request_existence_set(orig_request, 1);
  } else
#line 2812
  if (result == -2) {
#line 2813
    obj_request_existence_set(orig_request, 0);
  } else
#line 2814
  if (result != 0) {
#line 2815
    orig_request->result = result;
#line 2816
    goto out;
  } else {

  }
#line 2823
  orig_request->result = rbd_img_obj_request_submit(orig_request);
  out: ;
#line 2825
  if (orig_request->result != 0) {
#line 2826
    rbd_obj_request_complete(orig_request);
  } else {

  }
#line 2827
  return;
}
}
#line 2829 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_img_obj_exists_submit(struct rbd_obj_request *obj_request ) 
{ 
  struct rbd_obj_request *stat_request ;
  struct rbd_device *rbd_dev ;
  struct ceph_osd_client *osdc ;
  struct page **pages ;
  u32 page_count___0 ;
  size_t size ;
  int ret ;
  int tmp ;
  long tmp___0 ;
  bool tmp___1 ;
  long tmp___2 ;

  {
#line 2834
  pages = (struct page **)0;
#line 2847
  size = 16UL;
#line 2848
  tmp = calc_pages_for(0ULL, (u64 )size);
#line 2848
  page_count___0 = (unsigned int )tmp;
#line 2849
  pages = ceph_alloc_page_vector((int )page_count___0, 208U);
#line 2850
  tmp___1 = IS_ERR((void const   *)pages);
#line 2850
  if ((int )tmp___1) {
#line 2851
    tmp___0 = PTR_ERR((void const   *)pages);
#line 2851
    return ((int )tmp___0);
  } else {

  }
#line 2853
  ret = -12;
#line 2854
  stat_request = rbd_obj_request_create(obj_request->object_name, 0ULL, 0ULL, 2);
#line 2856
  if ((unsigned long )stat_request == (unsigned long )((struct rbd_obj_request *)0)) {
#line 2857
    goto out;
  } else {

  }
#line 2859
  rbd_obj_request_get(obj_request);
#line 2860
  stat_request->__annonCompField101.obj_request = obj_request;
#line 2861
  stat_request->__annonCompField103.__annonCompField102.pages = pages;
#line 2862
  stat_request->__annonCompField103.__annonCompField102.page_count = page_count___0;
#line 2864
  tmp___2 = ldv__builtin_expect((unsigned long )obj_request->__annonCompField101.__annonCompField100.img_request == (unsigned long )((struct rbd_img_request *)0),
                             0L);
#line 2864
  if (tmp___2 != 0L) {
#line 2864
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_obj_exists_submit",
           2864, (char *)"obj_request->img_request");
#line 2864
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2864), "i" (12UL));
    ldv_38306: ;
#line 2864
    goto ldv_38306;
  } else {

  }
#line 2865
  rbd_dev = (obj_request->__annonCompField101.__annonCompField100.img_request)->rbd_dev;
#line 2866
  stat_request->osd_req = rbd_osd_req_create(rbd_dev, 1, 1U, stat_request);
#line 2868
  if ((unsigned long )stat_request->osd_req == (unsigned long )((struct ceph_osd_request *)0)) {
#line 2869
    goto out;
  } else {

  }
#line 2870
  stat_request->callback = & rbd_img_obj_exists_callback;
#line 2872
  osd_req_op_init(stat_request->osd_req, 0U, 4610, 0U);
#line 2873
  osd_req_op_raw_data_in_pages(stat_request->osd_req, 0U, pages, (u64 )size, 0U, 0,
                               0);
#line 2875
  rbd_osd_req_format_read(stat_request);
#line 2877
  osdc = & ((rbd_dev->rbd_client)->client)->osdc;
#line 2878
  ret = rbd_obj_request_submit(osdc, stat_request);
  out: ;
#line 2880
  if (ret != 0) {
#line 2881
    rbd_obj_request_put(obj_request);
  } else {

  }
#line 2883
  return (ret);
}
}
#line 2886 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static bool img_obj_request_simple(struct rbd_obj_request *obj_request ) 
{ 
  struct rbd_img_request *img_request ;
  struct rbd_device *rbd_dev ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  u64 tmp___11 ;
  bool tmp___12 ;
  bool tmp___13 ;

  {
#line 2891
  tmp = obj_request_img_data_test(obj_request);
#line 2891
  if (tmp) {
#line 2891
    tmp___0 = 0;
  } else {
#line 2891
    tmp___0 = 1;
  }
#line 2891
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 2891
  if (tmp___1 != 0L) {
#line 2891
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "img_obj_request_simple",
           2891, (char *)"obj_request_img_data_test(obj_request)");
#line 2891
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2891), "i" (12UL));
    ldv_38313: ;
#line 2891
    goto ldv_38313;
  } else {

  }
#line 2893
  img_request = obj_request->__annonCompField101.__annonCompField100.img_request;
#line 2894
  tmp___2 = ldv__builtin_expect((unsigned long )img_request == (unsigned long )((struct rbd_img_request *)0),
                             0L);
#line 2894
  if (tmp___2 != 0L) {
#line 2894
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "img_obj_request_simple",
           2894, (char *)"img_request");
#line 2894
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2894), "i" (12UL));
    ldv_38314: ;
#line 2894
    goto ldv_38314;
  } else {

  }
#line 2895
  rbd_dev = img_request->rbd_dev;
#line 2898
  tmp___3 = img_request_write_test(img_request);
#line 2898
  if (tmp___3) {
#line 2898
    tmp___4 = 0;
  } else {
#line 2898
    tmp___4 = 1;
  }
#line 2898
  if (tmp___4) {
#line 2898
    tmp___5 = img_request_discard_test(img_request);
#line 2898
    if (tmp___5) {
#line 2898
      tmp___6 = 0;
    } else {
#line 2898
      tmp___6 = 1;
    }
#line 2898
    if (tmp___6) {
#line 2900
      return (1);
    } else {

    }
  } else {

  }
#line 2903
  tmp___7 = img_request_layered_test(img_request);
#line 2903
  if (tmp___7) {
#line 2903
    tmp___8 = 0;
  } else {
#line 2903
    tmp___8 = 1;
  }
#line 2903
  if (tmp___8) {
#line 2904
    return (1);
  } else {

  }
#line 2910
  tmp___9 = obj_request_overlaps_parent(obj_request);
#line 2910
  if (tmp___9) {
#line 2910
    tmp___10 = 0;
  } else {
#line 2910
    tmp___10 = 1;
  }
#line 2910
  if (tmp___10) {
#line 2911
    return (1);
  } else {

  }
#line 2917
  if (obj_request->offset == 0ULL) {
#line 2917
    tmp___11 = rbd_obj_bytes(& rbd_dev->header);
#line 2917
    if (obj_request->length == tmp___11) {
#line 2919
      return (1);
    } else {

    }
  } else {

  }
#line 2925
  tmp___12 = obj_request_known_test(obj_request);
#line 2925
  if ((int )tmp___12) {
#line 2925
    tmp___13 = obj_request_exists_test(obj_request);
#line 2925
    if ((int )tmp___13) {
#line 2927
      return (1);
    } else {

    }
  } else {

  }
#line 2929
  return (0);
}
}
#line 2932 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_img_obj_request_submit(struct rbd_obj_request *obj_request ) 
{ 
  struct rbd_device *rbd_dev ;
  struct ceph_osd_client *osdc ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 2934
  tmp___0 = img_obj_request_simple(obj_request);
#line 2934
  if ((int )tmp___0) {
#line 2938
    rbd_dev = (obj_request->__annonCompField101.__annonCompField100.img_request)->rbd_dev;
#line 2939
    osdc = & ((rbd_dev->rbd_client)->client)->osdc;
#line 2941
    tmp = rbd_obj_request_submit(osdc, obj_request);
#line 2941
    return (tmp);
  } else {

  }
#line 2950
  tmp___2 = obj_request_known_test(obj_request);
#line 2950
  if ((int )tmp___2) {
#line 2951
    tmp___1 = rbd_img_obj_parent_read_full(obj_request);
#line 2951
    return (tmp___1);
  } else {

  }
#line 2955
  tmp___3 = rbd_img_obj_exists_submit(obj_request);
#line 2955
  return (tmp___3);
}
}
#line 2958 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_img_request_submit(struct rbd_img_request *img_request ) 
{ 
  struct rbd_obj_request *obj_request ;
  struct rbd_obj_request *next_obj_request ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int ret ;
  struct list_head  const  *__mptr___1 ;

  {
#line 2963
  descriptor.modname = "rbd";
#line 2963
  descriptor.function = "rbd_img_request_submit";
#line 2963
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 2963
  descriptor.format = "%.*s %12.12s:%-4d : %s: img %p\n";
#line 2963
  descriptor.lineno = 2963U;
#line 2963
  descriptor.flags = 0U;
#line 2963
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 2963
  if (tmp___0 != 0L) {
#line 2963
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 2963
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: img %p\n", 4, (char *)"    ",
                       tmp, 2963, "rbd_img_request_submit", img_request);
  } else {

  }
#line 2964
  __mptr = (struct list_head  const  *)img_request->obj_requests.prev;
#line 2964
  obj_request = (struct rbd_obj_request *)__mptr + 0xffffffffffffffd0UL;
#line 2964
  __mptr___0 = (struct list_head  const  *)obj_request->__annonCompField101.__annonCompField100.links.prev;
#line 2964
  next_obj_request = (struct rbd_obj_request *)__mptr___0 + 0xffffffffffffffd0UL;
#line 2964
  goto ldv_38335;
  ldv_38334: 
#line 2967
  ret = rbd_img_obj_request_submit(obj_request);
#line 2968
  if (ret != 0) {
#line 2969
    return (ret);
  } else {

  }
#line 2964
  obj_request = next_obj_request;
#line 2964
  __mptr___1 = (struct list_head  const  *)next_obj_request->__annonCompField101.__annonCompField100.links.prev;
#line 2964
  next_obj_request = (struct rbd_obj_request *)__mptr___1 + 0xffffffffffffffd0UL;
  ldv_38335: ;
#line 2964
  if ((unsigned long )(& obj_request->__annonCompField101.__annonCompField100.links) != (unsigned long )(& img_request->obj_requests)) {
#line 2966
    goto ldv_38334;
  } else {

  }

#line 2972
  return (0);
}
}
#line 2975 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_img_parent_read_callback(struct rbd_img_request *img_request ) 
{ 
  struct rbd_obj_request *obj_request ;
  struct rbd_device *rbd_dev ;
  u64 obj_end ;
  u64 img_xferred ;
  int img_result ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  struct ceph_osd_client *osdc ;
  long tmp___4 ;
  u64 xferred ;
  u64 _min1 ;
  u64 _min2 ;

  {
#line 2983
  tmp = img_request_child_test(img_request);
#line 2983
  if (tmp) {
#line 2983
    tmp___0 = 0;
  } else {
#line 2983
    tmp___0 = 1;
  }
#line 2983
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 2983
  if (tmp___1 != 0L) {
#line 2983
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_parent_read_callback",
           2983, (char *)"img_request_child_test(img_request)");
#line 2983
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2983), "i" (12UL));
    ldv_38346: ;
#line 2983
    goto ldv_38346;
  } else {

  }
#line 2987
  obj_request = img_request->__annonCompField105.obj_request;
#line 2988
  img_xferred = img_request->xferred;
#line 2989
  img_result = img_request->result;
#line 2990
  rbd_img_request_put(img_request);
#line 2997
  tmp___2 = ldv__builtin_expect((unsigned long )obj_request == (unsigned long )((struct rbd_obj_request *)0),
                             0L);
#line 2997
  if (tmp___2 != 0L) {
#line 2997
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_parent_read_callback",
           2997, (char *)"obj_request");
#line 2997
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2997), "i" (12UL));
    ldv_38347: ;
#line 2997
    goto ldv_38347;
  } else {

  }
#line 2998
  tmp___3 = ldv__builtin_expect((unsigned long )obj_request->__annonCompField101.__annonCompField100.img_request == (unsigned long )((struct rbd_img_request *)0),
                             0L);
#line 2998
  if (tmp___3 != 0L) {
#line 2998
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_parent_read_callback",
           2998, (char *)"obj_request->img_request");
#line 2998
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (2998), "i" (12UL));
    ldv_38348: ;
#line 2998
    goto ldv_38348;
  } else {

  }
#line 2999
  rbd_dev = (obj_request->__annonCompField101.__annonCompField100.img_request)->rbd_dev;
#line 3000
  if (rbd_dev->parent_overlap == 0ULL) {
#line 3003
    osdc = & ((rbd_dev->rbd_client)->client)->osdc;
#line 3004
    img_result = rbd_obj_request_submit(osdc, obj_request);
#line 3005
    if (img_result == 0) {
#line 3006
      return;
    } else {

    }
  } else {

  }
#line 3009
  obj_request->result = img_result;
#line 3010
  if (obj_request->result != 0) {
#line 3011
    goto out;
  } else {

  }
#line 3020
  tmp___4 = ldv__builtin_expect(obj_request->__annonCompField101.__annonCompField100.img_offset >= ~ obj_request->length,
                             0L);
#line 3020
  if (tmp___4 != 0L) {
#line 3020
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_parent_read_callback",
           3020, (char *)"obj_request->img_offset < U64_MAX - obj_request->length");
#line 3020
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (3020), "i" (12UL));
    ldv_38351: ;
#line 3020
    goto ldv_38351;
  } else {

  }
#line 3021
  obj_end = obj_request->__annonCompField101.__annonCompField100.img_offset + obj_request->length;
#line 3022
  if (rbd_dev->parent_overlap < obj_end) {
#line 3023
    xferred = 0ULL;
#line 3025
    if (obj_request->__annonCompField101.__annonCompField100.img_offset < rbd_dev->parent_overlap) {
#line 3026
      xferred = rbd_dev->parent_overlap - obj_request->__annonCompField101.__annonCompField100.img_offset;
    } else {

    }
#line 3029
    _min1 = img_xferred;
#line 3029
    _min2 = xferred;
#line 3029
    obj_request->xferred = _min1 < _min2 ? _min1 : _min2;
  } else {
#line 3031
    obj_request->xferred = img_xferred;
  }
  out: 
#line 3034
  rbd_img_obj_request_read_callback(obj_request);
#line 3035
  rbd_obj_request_complete(obj_request);
#line 3036
  return;
}
}
#line 3038 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_img_parent_read(struct rbd_obj_request *obj_request ) 
{ 
  struct rbd_img_request *img_request ;
  int result ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;

  {
#line 3043
  tmp = obj_request_img_data_test(obj_request);
#line 3043
  if (tmp) {
#line 3043
    tmp___0 = 0;
  } else {
#line 3043
    tmp___0 = 1;
  }
#line 3043
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 3043
  if (tmp___1 != 0L) {
#line 3043
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_parent_read",
           3043, (char *)"obj_request_img_data_test(obj_request)");
#line 3043
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (3043), "i" (12UL));
    ldv_38362: ;
#line 3043
    goto ldv_38362;
  } else {

  }
#line 3044
  tmp___2 = ldv__builtin_expect((unsigned long )obj_request->__annonCompField101.__annonCompField100.img_request == (unsigned long )((struct rbd_img_request *)0),
                             0L);
#line 3044
  if (tmp___2 != 0L) {
#line 3044
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_parent_read",
           3044, (char *)"obj_request->img_request != NULL");
#line 3044
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (3044), "i" (12UL));
    ldv_38363: ;
#line 3044
    goto ldv_38363;
  } else {

  }
#line 3045
  tmp___3 = ldv__builtin_expect(obj_request->result != -2, 0L);
#line 3045
  if (tmp___3 != 0L) {
#line 3045
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_parent_read",
           3045, (char *)"obj_request->result == (s32) -ENOENT");
#line 3045
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (3045), "i" (12UL));
    ldv_38364: ;
#line 3045
    goto ldv_38364;
  } else {

  }
#line 3046
  tmp___4 = obj_request_type_valid(obj_request->type);
#line 3046
  if (tmp___4) {
#line 3046
    tmp___5 = 0;
  } else {
#line 3046
    tmp___5 = 1;
  }
#line 3046
  tmp___6 = ldv__builtin_expect((long )tmp___5, 0L);
#line 3046
  if (tmp___6 != 0L) {
#line 3046
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_img_parent_read",
           3046, (char *)"obj_request_type_valid(obj_request->type)");
#line 3046
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (3046), "i" (12UL));
    ldv_38365: ;
#line 3046
    goto ldv_38365;
  } else {

  }
#line 3049
  img_request = rbd_parent_request_create(obj_request, obj_request->__annonCompField101.__annonCompField100.img_offset,
                                          obj_request->length);
#line 3052
  result = -12;
#line 3053
  if ((unsigned long )img_request == (unsigned long )((struct rbd_img_request *)0)) {
#line 3054
    goto out_err;
  } else {

  }
#line 3056
  if ((unsigned int )obj_request->type == 1U) {
#line 3057
    result = rbd_img_request_fill(img_request, 1, (void *)obj_request->__annonCompField103.bio_list);
  } else {
#line 3060
    result = rbd_img_request_fill(img_request, 2, (void *)obj_request->__annonCompField103.__annonCompField102.pages);
  }
#line 3062
  if (result != 0) {
#line 3063
    goto out_err;
  } else {

  }
#line 3065
  img_request->callback = & rbd_img_parent_read_callback;
#line 3066
  result = rbd_img_request_submit(img_request);
#line 3067
  if (result != 0) {
#line 3068
    goto out_err;
  } else {

  }
#line 3070
  return;
  out_err: ;
#line 3072
  if ((unsigned long )img_request != (unsigned long )((struct rbd_img_request *)0)) {
#line 3073
    rbd_img_request_put(img_request);
  } else {

  }
#line 3074
  obj_request->result = result;
#line 3075
  obj_request->xferred = 0ULL;
#line 3076
  obj_request_done_set(obj_request);
#line 3077
  return;
}
}
#line 3079 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_obj_notify_ack_sync(struct rbd_device *rbd_dev , u64 notify_id ) 
{ 
  struct rbd_obj_request *obj_request ;
  struct ceph_osd_client *osdc ;
  int ret ;

  {
#line 3082
  osdc = & ((rbd_dev->rbd_client)->client)->osdc;
#line 3085
  obj_request = rbd_obj_request_create((char const   *)rbd_dev->header_name, 0ULL,
                                       0ULL, 0);
#line 3087
  if ((unsigned long )obj_request == (unsigned long )((struct rbd_obj_request *)0)) {
#line 3088
    return (-12);
  } else {

  }
#line 3090
  ret = -12;
#line 3091
  obj_request->osd_req = rbd_osd_req_create(rbd_dev, 1, 1U, obj_request);
#line 3093
  if ((unsigned long )obj_request->osd_req == (unsigned long )((struct ceph_osd_request *)0)) {
#line 3094
    goto out;
  } else {

  }
#line 3096
  osd_req_op_watch_init(obj_request->osd_req, 0U, 4615, notify_id, 0ULL, 0);
#line 3098
  rbd_osd_req_format_read(obj_request);
#line 3100
  ret = rbd_obj_request_submit(osdc, obj_request);
#line 3101
  if (ret != 0) {
#line 3102
    goto out;
  } else {

  }
#line 3103
  ret = rbd_obj_request_wait(obj_request);
  out: 
#line 3105
  rbd_obj_request_put(obj_request);
#line 3107
  return (ret);
}
}
#line 3110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_watch_cb(u64 ver , u64 notify_id , u8 opcode , void *data ) 
{ 
  struct rbd_device *rbd_dev ;
  int ret ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;

  {
#line 3112
  rbd_dev = (struct rbd_device *)data;
#line 3115
  if ((unsigned long )rbd_dev == (unsigned long )((struct rbd_device *)0)) {
#line 3116
    return;
  } else {

  }
#line 3118
  descriptor.modname = "rbd";
#line 3118
  descriptor.function = "rbd_watch_cb";
#line 3118
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 3118
  descriptor.format = "%.*s %12.12s:%-4d : %s: \"%s\" notify_id %llu opcode %u\n";
#line 3118
  descriptor.lineno = 3120U;
#line 3118
  descriptor.flags = 0U;
#line 3118
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 3118
  if (tmp___0 != 0L) {
#line 3118
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 3118
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: \"%s\" notify_id %llu opcode %u\n",
                       4, (char *)"    ", tmp, 3120, "rbd_watch_cb", rbd_dev->header_name,
                       notify_id, (unsigned int )opcode);
  } else {

  }
#line 3128
  ret = rbd_dev_refresh(rbd_dev);
#line 3129
  if (ret != 0) {
#line 3130
    rbd_warn(rbd_dev, "refresh failed: %d", ret);
  } else {

  }
#line 3132
  ret = rbd_obj_notify_ack_sync(rbd_dev, notify_id);
#line 3133
  if (ret != 0) {
#line 3134
    rbd_warn(rbd_dev, "notify_ack ret %d", ret);
  } else {

  }
#line 3135
  return;
}
}
#line 3141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct rbd_obj_request *rbd_obj_watch_request_helper(struct rbd_device *rbd_dev ,
                                                            bool watch ) 
{ 
  struct ceph_osd_client *osdc ;
  struct ceph_options *opts ;
  struct rbd_obj_request *obj_request ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 3145
  osdc = & ((rbd_dev->rbd_client)->client)->osdc;
#line 3146
  opts = (osdc->client)->options;
#line 3150
  obj_request = rbd_obj_request_create((char const   *)rbd_dev->header_name, 0ULL,
                                       0ULL, 0);
#line 3152
  if ((unsigned long )obj_request == (unsigned long )((struct rbd_obj_request *)0)) {
#line 3153
    tmp = ERR_PTR(-12L);
#line 3153
    return ((struct rbd_obj_request *)tmp);
  } else {

  }
#line 3155
  obj_request->osd_req = rbd_osd_req_create(rbd_dev, 0, 1U, obj_request);
#line 3157
  if ((unsigned long )obj_request->osd_req == (unsigned long )((struct ceph_osd_request *)0)) {
#line 3158
    ret = -12;
#line 3159
    goto out;
  } else {

  }
#line 3162
  osd_req_op_watch_init(obj_request->osd_req, 0U, 8719, (rbd_dev->watch_event)->cookie,
                        0ULL, (int )watch);
#line 3164
  rbd_osd_req_format_write(obj_request);
#line 3166
  if ((int )watch) {
#line 3167
    ceph_osdc_set_request_linger(osdc, obj_request->osd_req);
  } else {

  }
#line 3169
  ret = rbd_obj_request_submit(osdc, obj_request);
#line 3170
  if (ret != 0) {
#line 3171
    goto out;
  } else {

  }
#line 3173
  ret = rbd_obj_request_wait_timeout(obj_request, opts->mount_timeout);
#line 3174
  if (ret != 0) {
#line 3175
    goto out;
  } else {

  }
#line 3177
  ret = obj_request->result;
#line 3178
  if (ret != 0) {
#line 3179
    if ((int )watch) {
#line 3180
      rbd_obj_request_end(obj_request);
    } else {

    }
#line 3181
    goto out;
  } else {

  }
#line 3184
  return (obj_request);
  out: 
#line 3187
  rbd_obj_request_put(obj_request);
#line 3188
  tmp___0 = ERR_PTR((long )ret);
#line 3188
  return ((struct rbd_obj_request *)tmp___0);
}
}
#line 3194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_header_watch_sync(struct rbd_device *rbd_dev ) 
{ 
  struct ceph_osd_client *osdc ;
  struct rbd_obj_request *obj_request ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;

  {
#line 3196
  osdc = & ((rbd_dev->rbd_client)->client)->osdc;
#line 3200
  tmp = ldv__builtin_expect((unsigned long )rbd_dev->watch_event != (unsigned long )((struct ceph_osd_event *)0),
                         0L);
#line 3200
  if (tmp != 0L) {
#line 3200
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_dev_header_watch_sync",
           3200, (char *)"!rbd_dev->watch_event");
#line 3200
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (3200), "i" (12UL));
    ldv_38401: ;
#line 3200
    goto ldv_38401;
  } else {

  }
#line 3201
  tmp___0 = ldv__builtin_expect((unsigned long )rbd_dev->watch_request != (unsigned long )((struct rbd_obj_request *)0),
                             0L);
#line 3201
  if (tmp___0 != 0L) {
#line 3201
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_dev_header_watch_sync",
           3201, (char *)"!rbd_dev->watch_request");
#line 3201
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (3201), "i" (12UL));
    ldv_38402: ;
#line 3201
    goto ldv_38402;
  } else {

  }
#line 3203
  ret = ceph_osdc_create_event(osdc, & rbd_watch_cb, (void *)rbd_dev, & rbd_dev->watch_event);
#line 3205
  if (ret < 0) {
#line 3206
    return (ret);
  } else {

  }
#line 3208
  obj_request = rbd_obj_watch_request_helper(rbd_dev, 1);
#line 3209
  tmp___2 = IS_ERR((void const   *)obj_request);
#line 3209
  if ((int )tmp___2) {
#line 3210
    ceph_osdc_cancel_event(rbd_dev->watch_event);
#line 3211
    rbd_dev->watch_event = (struct ceph_osd_event *)0;
#line 3212
    tmp___1 = PTR_ERR((void const   *)obj_request);
#line 3212
    return ((int )tmp___1);
  } else {

  }
#line 3223
  rbd_dev->watch_request = obj_request;
#line 3225
  return (0);
}
}
#line 3231 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_dev_header_unwatch_sync(struct rbd_device *rbd_dev ) 
{ 
  struct rbd_obj_request *obj_request ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 3235
  tmp = ldv__builtin_expect((unsigned long )rbd_dev->watch_event == (unsigned long )((struct ceph_osd_event *)0),
                         0L);
#line 3235
  if (tmp != 0L) {
#line 3235
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_dev_header_unwatch_sync",
           3235, (char *)"rbd_dev->watch_event");
#line 3235
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (3235), "i" (12UL));
    ldv_38408: ;
#line 3235
    goto ldv_38408;
  } else {

  }
#line 3236
  tmp___0 = ldv__builtin_expect((unsigned long )rbd_dev->watch_request == (unsigned long )((struct rbd_obj_request *)0),
                             0L);
#line 3236
  if (tmp___0 != 0L) {
#line 3236
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_dev_header_unwatch_sync",
           3236, (char *)"rbd_dev->watch_request");
#line 3236
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (3236), "i" (12UL));
    ldv_38409: ;
#line 3236
    goto ldv_38409;
  } else {

  }
#line 3238
  rbd_obj_request_end(rbd_dev->watch_request);
#line 3239
  rbd_obj_request_put(rbd_dev->watch_request);
#line 3240
  rbd_dev->watch_request = (struct rbd_obj_request *)0;
#line 3242
  obj_request = rbd_obj_watch_request_helper(rbd_dev, 0);
#line 3243
  tmp___2 = IS_ERR((void const   *)obj_request);
#line 3243
  if (tmp___2) {
#line 3243
    tmp___3 = 0;
  } else {
#line 3243
    tmp___3 = 1;
  }
#line 3243
  if (tmp___3) {
#line 3244
    rbd_obj_request_put(obj_request);
  } else {
#line 3246
    tmp___1 = PTR_ERR((void const   *)obj_request);
#line 3246
    rbd_warn(rbd_dev, "unable to tear down watch request (%ld)", tmp___1);
  }
#line 3249
  ceph_osdc_cancel_event(rbd_dev->watch_event);
#line 3250
  rbd_dev->watch_event = (struct ceph_osd_event *)0;
#line 3251
  return;
}
}
#line 3257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_obj_method_sync(struct rbd_device *rbd_dev , char const   *object_name ,
                               char const   *class_name , char const   *method_name ,
                               void const   *outbound , size_t outbound_size , void *inbound ,
                               size_t inbound_size ) 
{ 
  struct ceph_osd_client *osdc ;
  struct rbd_obj_request *obj_request ;
  struct page **pages ;
  u32 page_count___0 ;
  int ret ;
  int tmp ;
  long tmp___0 ;
  bool tmp___1 ;
  struct ceph_pagelist *pagelist ;
  void *tmp___2 ;
  long tmp___3 ;

  {
#line 3266
  osdc = & ((rbd_dev->rbd_client)->client)->osdc;
#line 3279
  tmp = calc_pages_for(0ULL, (u64 )inbound_size);
#line 3279
  page_count___0 = (unsigned int )tmp;
#line 3280
  pages = ceph_alloc_page_vector((int )page_count___0, 208U);
#line 3281
  tmp___1 = IS_ERR((void const   *)pages);
#line 3281
  if ((int )tmp___1) {
#line 3282
    tmp___0 = PTR_ERR((void const   *)pages);
#line 3282
    return ((int )tmp___0);
  } else {

  }
#line 3284
  ret = -12;
#line 3285
  obj_request = rbd_obj_request_create(object_name, 0ULL, (u64 )inbound_size, 2);
#line 3287
  if ((unsigned long )obj_request == (unsigned long )((struct rbd_obj_request *)0)) {
#line 3288
    goto out;
  } else {

  }
#line 3290
  obj_request->__annonCompField103.__annonCompField102.pages = pages;
#line 3291
  obj_request->__annonCompField103.__annonCompField102.page_count = page_count___0;
#line 3293
  obj_request->osd_req = rbd_osd_req_create(rbd_dev, 1, 1U, obj_request);
#line 3295
  if ((unsigned long )obj_request->osd_req == (unsigned long )((struct ceph_osd_request *)0)) {
#line 3296
    goto out;
  } else {

  }
#line 3298
  osd_req_op_cls_init(obj_request->osd_req, 0U, 5121, class_name, method_name);
#line 3300
  if (outbound_size != 0UL) {
#line 3303
    tmp___2 = kmalloc(72UL, 80U);
#line 3303
    pagelist = (struct ceph_pagelist *)tmp___2;
#line 3304
    if ((unsigned long )pagelist == (unsigned long )((struct ceph_pagelist *)0)) {
#line 3305
      goto out;
    } else {

    }
#line 3307
    ceph_pagelist_init(pagelist);
#line 3308
    ceph_pagelist_append(pagelist, outbound, outbound_size);
#line 3309
    osd_req_op_cls_request_data_pagelist(obj_request->osd_req, 0U, pagelist);
  } else {

  }
#line 3312
  osd_req_op_cls_response_data_pages(obj_request->osd_req, 0U, obj_request->__annonCompField103.__annonCompField102.pages,
                                     (u64 )inbound_size, 0U, 0, 0);
#line 3315
  rbd_osd_req_format_read(obj_request);
#line 3317
  ret = rbd_obj_request_submit(osdc, obj_request);
#line 3318
  if (ret != 0) {
#line 3319
    goto out;
  } else {

  }
#line 3320
  ret = rbd_obj_request_wait(obj_request);
#line 3321
  if (ret != 0) {
#line 3322
    goto out;
  } else {

  }
#line 3324
  ret = obj_request->result;
#line 3325
  if (ret < 0) {
#line 3326
    goto out;
  } else {

  }
#line 3328
  tmp___3 = ldv__builtin_expect(obj_request->xferred > 2147483646ULL, 0L);
#line 3328
  if (tmp___3 != 0L) {
#line 3328
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_obj_method_sync",
           3328, (char *)"obj_request->xferred < (u64)INT_MAX");
#line 3328
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (3328), "i" (12UL));
    ldv_38428: ;
#line 3328
    goto ldv_38428;
  } else {

  }
#line 3329
  ret = (int )obj_request->xferred;
#line 3330
  ceph_copy_from_page_vector(pages, inbound, 0LL, (size_t )obj_request->xferred);
  out: ;
#line 3332
  if ((unsigned long )obj_request != (unsigned long )((struct rbd_obj_request *)0)) {
#line 3333
    rbd_obj_request_put(obj_request);
  } else {
#line 3335
    ceph_release_page_vector(pages, (int )page_count___0);
  }
#line 3337
  return (ret);
}
}
#line 3340 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_queue_workfn(struct work_struct *work ) 
{ 
  struct request *rq ;
  struct request *tmp ;
  struct rbd_device *rbd_dev ;
  struct rbd_img_request *img_request ;
  struct ceph_snap_context *snapc ;
  u64 offset ;
  sector_t tmp___0 ;
  u64 length ;
  unsigned int tmp___1 ;
  enum obj_operation_type op_type ;
  u64 mapping_size ;
  int result ;
  struct _ddebug descriptor ;
  char const   *tmp___2 ;
  long tmp___3 ;
  struct _ddebug descriptor___0 ;
  char const   *tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  struct _ddebug descriptor___1 ;
  char const   *tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;

  {
#line 3342
  tmp = blk_mq_rq_from_pdu((void *)work);
#line 3342
  rq = tmp;
#line 3343
  rbd_dev = (struct rbd_device *)(rq->q)->queuedata;
#line 3345
  snapc = (struct ceph_snap_context *)0;
#line 3346
  tmp___0 = blk_rq_pos((struct request  const  *)rq);
#line 3346
  offset = (unsigned long long )tmp___0 << 9;
#line 3347
  tmp___1 = blk_rq_bytes((struct request  const  *)rq);
#line 3347
  length = (u64 )tmp___1;
#line 3352
  if (rq->cmd_type != 1U) {
#line 3353
    descriptor.modname = "rbd";
#line 3353
    descriptor.function = "rbd_queue_workfn";
#line 3353
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 3353
    descriptor.format = "%.*s %12.12s:%-4d : %s: non-fs request type %d\n";
#line 3353
    descriptor.lineno = 3354U;
#line 3353
    descriptor.flags = 0U;
#line 3353
    tmp___3 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 3353
    if (tmp___3 != 0L) {
#line 3353
      tmp___2 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                               199);
#line 3353
      __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: non-fs request type %d\n",
                         4, (char *)"    ", tmp___2, 3354, "rbd_queue_workfn", (int )rq->cmd_type);
    } else {

    }
#line 3355
    result = -5;
#line 3356
    goto err;
  } else {

  }
#line 3359
  if ((rq->cmd_flags & 128ULL) != 0ULL) {
#line 3360
    op_type = 2;
  } else
#line 3361
  if ((int )rq->cmd_flags & 1) {
#line 3362
    op_type = 0;
  } else {
#line 3364
    op_type = 1;
  }
#line 3368
  if (length == 0ULL) {
#line 3369
    descriptor___0.modname = "rbd";
#line 3369
    descriptor___0.function = "rbd_queue_workfn";
#line 3369
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 3369
    descriptor___0.format = "%.*s %12.12s:%-4d : %s: zero-length request\n";
#line 3369
    descriptor___0.lineno = 3369U;
#line 3369
    descriptor___0.flags = 0U;
#line 3369
    tmp___5 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 3369
    if (tmp___5 != 0L) {
#line 3369
      tmp___4 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                               199);
#line 3369
      __dynamic_pr_debug(& descriptor___0, "rbd: %.*s %12.12s:%-4d : %s: zero-length request\n",
                         4, (char *)"    ", tmp___4, 3369, "rbd_queue_workfn");
    } else {

    }
#line 3370
    result = 0;
#line 3371
    goto err_rq;
  } else {

  }
#line 3376
  if ((unsigned int )op_type != 1U) {
#line 3377
    if ((int )rbd_dev->mapping.read_only) {
#line 3378
      result = -30;
#line 3379
      goto err_rq;
    } else {

    }
#line 3381
    tmp___6 = ldv__builtin_expect((rbd_dev->spec)->snap_id != 0xfffffffffffffffeULL,
                               0L);
#line 3381
    if (tmp___6 != 0L) {
#line 3381
      printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n",
             "rbd_queue_workfn", 3381, (char *)"rbd_dev->spec->snap_id == CEPH_NOSNAP");
#line 3381
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                           "i" (3381), "i" (12UL));
      ldv_38446: ;
#line 3381
      goto ldv_38446;
    } else {

    }
  } else {

  }
#line 3390
  tmp___10 = constant_test_bit(0L, (unsigned long const volatile   *)(& rbd_dev->flags));
#line 3390
  if (tmp___10 == 0) {
#line 3391
    descriptor___1.modname = "rbd";
#line 3391
    descriptor___1.function = "rbd_queue_workfn";
#line 3391
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 3391
    descriptor___1.format = "%.*s %12.12s:%-4d : request for non-existent snapshot";
#line 3391
    descriptor___1.lineno = 3391U;
#line 3391
    descriptor___1.flags = 0U;
#line 3391
    tmp___8 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 3391
    if (tmp___8 != 0L) {
#line 3391
      tmp___7 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                               199);
#line 3391
      __dynamic_pr_debug(& descriptor___1, "rbd: %.*s %12.12s:%-4d : request for non-existent snapshot",
                         4, (char *)"    ", tmp___7, 3391);
    } else {

    }
#line 3392
    tmp___9 = ldv__builtin_expect((rbd_dev->spec)->snap_id == 0xfffffffffffffffeULL,
                               0L);
#line 3392
    if (tmp___9 != 0L) {
#line 3392
      printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n",
             "rbd_queue_workfn", 3392, (char *)"rbd_dev->spec->snap_id != CEPH_NOSNAP");
#line 3392
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                           "i" (3392), "i" (12UL));
      ldv_38448: ;
#line 3392
      goto ldv_38448;
    } else {

    }
#line 3393
    result = -6;
#line 3394
    goto err_rq;
  } else {

  }
#line 3397
  if (offset != 0ULL && - offset < length) {
#line 3398
    rbd_warn(rbd_dev, "bad request range (%llu~%llu)", offset, length);
#line 3400
    result = -22;
#line 3401
    goto err_rq;
  } else {

  }
#line 3404
  blk_mq_start_request(rq);
#line 3406
  down_read(& rbd_dev->header_rwsem);
#line 3407
  mapping_size = rbd_dev->mapping.size;
#line 3408
  if ((unsigned int )op_type != 1U) {
#line 3409
    snapc = rbd_dev->header.snapc;
#line 3410
    ceph_get_snap_context(snapc);
  } else {

  }
#line 3412
  up_read(& rbd_dev->header_rwsem);
#line 3414
  if (offset + length > mapping_size) {
#line 3415
    rbd_warn(rbd_dev, "beyond EOD (%llu~%llu > %llu)", offset, length, mapping_size);
#line 3417
    result = -5;
#line 3418
    goto err_rq;
  } else {

  }
#line 3421
  img_request = rbd_img_request_create(rbd_dev, offset, length, op_type, snapc);
#line 3423
  if ((unsigned long )img_request == (unsigned long )((struct rbd_img_request *)0)) {
#line 3424
    result = -12;
#line 3425
    goto err_rq;
  } else {

  }
#line 3427
  img_request->__annonCompField105.rq = rq;
#line 3429
  if ((unsigned int )op_type == 2U) {
#line 3430
    result = rbd_img_request_fill(img_request, 0, (void *)0);
  } else {
#line 3433
    result = rbd_img_request_fill(img_request, 1, (void *)rq->bio);
  }
#line 3435
  if (result != 0) {
#line 3436
    goto err_img_request;
  } else {

  }
#line 3438
  result = rbd_img_request_submit(img_request);
#line 3439
  if (result != 0) {
#line 3440
    goto err_img_request;
  } else {

  }
#line 3442
  return;
  err_img_request: 
#line 3445
  rbd_img_request_put(img_request);
  err_rq: ;
#line 3447
  if (result != 0) {
#line 3448
    tmp___11 = obj_op_name(op_type);
#line 3448
    rbd_warn(rbd_dev, "%s %llx at %llx result %d", tmp___11, length, offset, result);
  } else {

  }
#line 3450
  ceph_put_snap_context(snapc);
  err: 
#line 3452
  blk_mq_end_request(rq, result);
#line 3453
  return;
}
}
#line 3455 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_queue_rq(struct blk_mq_hw_ctx *hctx , struct blk_mq_queue_data  const  *bd ) 
{ 
  struct request *rq ;
  struct work_struct *work ;
  void *tmp ;

  {
#line 3458
  rq = bd->rq;
#line 3459
  tmp = blk_mq_rq_to_pdu(rq);
#line 3459
  work = (struct work_struct *)tmp;
#line 3461
  queue_work(rbd_wq, work);
#line 3462
  return (0);
}
}
#line 3470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_merge_bvec(struct request_queue *q , struct bvec_merge_data *bmd ,
                          struct bio_vec *bvec ) 
{ 
  struct rbd_device *rbd_dev ;
  sector_t sector_offset ;
  sector_t sectors_per_obj ;
  sector_t obj_sector_offset ;
  int ret ;
  sector_t tmp ;
  long tmp___0 ;

  {
#line 3473
  rbd_dev = (struct rbd_device *)q->queuedata;
#line 3484
  tmp = get_start_sect(bmd->bi_bdev);
#line 3484
  sector_offset = tmp + bmd->bi_sector;
#line 3485
  sectors_per_obj = (sector_t )(1 << ((int )rbd_dev->header.obj_order + -9));
#line 3486
  obj_sector_offset = (sectors_per_obj - 1UL) & sector_offset;
#line 3492
  ret = (int )((unsigned int )sectors_per_obj - (unsigned int )obj_sector_offset) << 9;
#line 3493
  if ((unsigned int )ret > bmd->bi_size) {
#line 3494
    ret = (int )((unsigned int )ret - bmd->bi_size);
  } else {
#line 3496
    ret = 0;
  }
#line 3504
  tmp___0 = ldv__builtin_expect(bvec->bv_len > 4096U, 0L);
#line 3504
  if (tmp___0 != 0L) {
#line 3504
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_merge_bvec",
           3504, (char *)"bvec->bv_len <= PAGE_SIZE");
#line 3504
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (3504), "i" (12UL));
    ldv_38467: ;
#line 3504
    goto ldv_38467;
  } else {

  }
#line 3505
  if ((int )bvec->bv_len < ret || bmd->bi_size == 0U) {
#line 3506
    ret = (int )bvec->bv_len;
  } else {

  }
#line 3508
  return (ret);
}
}
#line 3511 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_free_disk(struct rbd_device *rbd_dev ) 
{ 
  struct gendisk *disk ;

  {
#line 3513
  disk = rbd_dev->disk;
#line 3515
  if ((unsigned long )disk == (unsigned long )((struct gendisk *)0)) {
#line 3516
    return;
  } else {

  }
#line 3518
  rbd_dev->disk = (struct gendisk *)0;
#line 3519
  if ((disk->flags & 16) != 0) {
#line 3520
    del_gendisk(disk);
#line 3521
    if ((unsigned long )disk->queue != (unsigned long )((struct request_queue *)0)) {
#line 3522
      blk_cleanup_queue(disk->queue);
    } else {

    }
#line 3523
    blk_mq_free_tag_set(& rbd_dev->tag_set);
  } else {

  }
#line 3525
  put_disk(disk);
#line 3526
  return;
}
}
#line 3528 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_obj_read_sync(struct rbd_device *rbd_dev , char const   *object_name ,
                             u64 offset , u64 length , void *buf ) 
{ 
  struct ceph_osd_client *osdc ;
  struct rbd_obj_request *obj_request ;
  struct page **pages ;
  u32 page_count___0 ;
  size_t size ;
  int ret ;
  int tmp ;
  long tmp___0 ;
  bool tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 3533
  osdc = & ((rbd_dev->rbd_client)->client)->osdc;
#line 3535
  pages = (struct page **)0;
#line 3540
  tmp = calc_pages_for(offset, length);
#line 3540
  page_count___0 = (unsigned int )tmp;
#line 3541
  pages = ceph_alloc_page_vector((int )page_count___0, 208U);
#line 3542
  tmp___1 = IS_ERR((void const   *)pages);
#line 3542
  if ((int )tmp___1) {
#line 3543
    tmp___0 = PTR_ERR((void const   *)pages);
#line 3543
    return ((int )tmp___0);
  } else {

  }
#line 3545
  ret = -12;
#line 3546
  obj_request = rbd_obj_request_create(object_name, offset, length, 2);
#line 3548
  if ((unsigned long )obj_request == (unsigned long )((struct rbd_obj_request *)0)) {
#line 3549
    goto out;
  } else {

  }
#line 3551
  obj_request->__annonCompField103.__annonCompField102.pages = pages;
#line 3552
  obj_request->__annonCompField103.__annonCompField102.page_count = page_count___0;
#line 3554
  obj_request->osd_req = rbd_osd_req_create(rbd_dev, 1, 1U, obj_request);
#line 3556
  if ((unsigned long )obj_request->osd_req == (unsigned long )((struct ceph_osd_request *)0)) {
#line 3557
    goto out;
  } else {

  }
#line 3559
  osd_req_op_extent_init(obj_request->osd_req, 0U, 4609, offset, length, 0ULL, 0U);
#line 3561
  osd_req_op_extent_osd_data_pages(obj_request->osd_req, 0U, obj_request->__annonCompField103.__annonCompField102.pages,
                                   obj_request->length, (u32 )obj_request->offset & 4095U,
                                   0, 0);
#line 3566
  rbd_osd_req_format_read(obj_request);
#line 3568
  ret = rbd_obj_request_submit(osdc, obj_request);
#line 3569
  if (ret != 0) {
#line 3570
    goto out;
  } else {

  }
#line 3571
  ret = rbd_obj_request_wait(obj_request);
#line 3572
  if (ret != 0) {
#line 3573
    goto out;
  } else {

  }
#line 3575
  ret = obj_request->result;
#line 3576
  if (ret < 0) {
#line 3577
    goto out;
  } else {

  }
#line 3579
  tmp___2 = ldv__builtin_expect(0L, 0L);
#line 3579
  if (tmp___2 != 0L) {
#line 3579
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_obj_read_sync",
           3579, (char *)"obj_request->xferred <= (u64) SIZE_MAX");
#line 3579
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (3579), "i" (12UL));
    ldv_38487: ;
#line 3579
    goto ldv_38487;
  } else {

  }
#line 3580
  size = (unsigned long )obj_request->xferred;
#line 3581
  ceph_copy_from_page_vector(pages, buf, 0LL, size);
#line 3582
  tmp___3 = ldv__builtin_expect(size > 2147483647UL, 0L);
#line 3582
  if (tmp___3 != 0L) {
#line 3582
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_obj_read_sync",
           3582, (char *)"size <= (size_t)INT_MAX");
#line 3582
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (3582), "i" (12UL));
    ldv_38488: ;
#line 3582
    goto ldv_38488;
  } else {

  }
#line 3583
  ret = (int )size;
  out: ;
#line 3585
  if ((unsigned long )obj_request != (unsigned long )((struct rbd_obj_request *)0)) {
#line 3586
    rbd_obj_request_put(obj_request);
  } else {
#line 3588
    ceph_release_page_vector(pages, (int )page_count___0);
  }
#line 3590
  return (ret);
}
}
#line 3598 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_v1_header_info(struct rbd_device *rbd_dev ) 
{ 
  struct rbd_image_header_ondisk *ondisk ;
  u32 snap_count ;
  u64 names_size ;
  u32 want_count ;
  int ret ;
  size_t size ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 3600
  ondisk = (struct rbd_image_header_ondisk *)0;
#line 3601
  snap_count = 0U;
#line 3602
  names_size = 0ULL;
  ldv_38499: 
#line 3616
  kfree((void const   *)ondisk);
#line 3618
  size = 112UL;
#line 3619
  size = (unsigned long )snap_count * 16UL + size;
#line 3620
  size = (size_t )((unsigned long long )size + names_size);
#line 3621
  tmp = kmalloc(size, 208U);
#line 3621
  ondisk = (struct rbd_image_header_ondisk *)tmp;
#line 3622
  if ((unsigned long )ondisk == (unsigned long )((struct rbd_image_header_ondisk *)0)) {
#line 3623
    return (-12);
  } else {

  }
#line 3625
  ret = rbd_obj_read_sync(rbd_dev, (char const   *)rbd_dev->header_name, 0ULL, (u64 )size,
                          (void *)ondisk);
#line 3627
  if (ret < 0) {
#line 3628
    goto out;
  } else {

  }
#line 3629
  if ((unsigned long )ret < size) {
#line 3630
    ret = -6;
#line 3631
    rbd_warn(rbd_dev, "short header read (want %zd got %d)", size, ret);
#line 3633
    goto out;
  } else {

  }
#line 3635
  tmp___0 = rbd_dev_ondisk_valid(ondisk);
#line 3635
  if (tmp___0) {
#line 3635
    tmp___1 = 0;
  } else {
#line 3635
    tmp___1 = 1;
  }
#line 3635
  if (tmp___1) {
#line 3636
    ret = -6;
#line 3637
    rbd_warn(rbd_dev, "invalid header");
#line 3638
    goto out;
  } else {

  }
#line 3641
  names_size = ondisk->snap_names_len;
#line 3642
  want_count = snap_count;
#line 3643
  snap_count = ondisk->snap_count;
#line 3644
  if (snap_count != want_count) {
#line 3646
    goto ldv_38499;
  } else {

  }
#line 3646
  ret = rbd_header_from_disk(rbd_dev, ondisk);
  out: 
#line 3648
  kfree((void const   *)ondisk);
#line 3650
  return (ret);
}
}
#line 3657 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_exists_validate(struct rbd_device *rbd_dev ) 
{ 
  u64 snap_id ;
  int tmp ;
  u32 tmp___0 ;

  {
#line 3661
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& rbd_dev->flags));
#line 3661
  if (tmp == 0) {
#line 3662
    return;
  } else {

  }
#line 3664
  snap_id = (rbd_dev->spec)->snap_id;
#line 3665
  if (snap_id == 0xfffffffffffffffeULL) {
#line 3666
    return;
  } else {

  }
#line 3668
  tmp___0 = rbd_dev_snap_index(rbd_dev, snap_id);
#line 3668
  if (tmp___0 == 4294967295U) {
#line 3669
    clear_bit(0L, (unsigned long volatile   *)(& rbd_dev->flags));
  } else {

  }
#line 3670
  return;
}
}
#line 3672 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_dev_update_size(struct rbd_device *rbd_dev ) 
{ 
  sector_t size ;
  bool removing ;
  int tmp ;
  struct _ddebug descriptor ;
  char const   *tmp___0 ;
  long tmp___1 ;

  {
#line 3682
  spin_lock_irq(& rbd_dev->lock);
#line 3683
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& rbd_dev->flags));
#line 3683
  removing = tmp != 0;
#line 3684
  spin_unlock_irq(& rbd_dev->lock);
#line 3689
  if (! removing) {
#line 3690
    size = (sector_t )(rbd_dev->mapping.size / 512ULL);
#line 3691
    descriptor.modname = "rbd";
#line 3691
    descriptor.function = "rbd_dev_update_size";
#line 3691
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 3691
    descriptor.format = "%.*s %12.12s:%-4d : setting size to %llu sectors";
#line 3691
    descriptor.lineno = 3691U;
#line 3691
    descriptor.flags = 0U;
#line 3691
    tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 3691
    if (tmp___1 != 0L) {
#line 3691
      tmp___0 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                               199);
#line 3691
      __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : setting size to %llu sectors",
                         4, (char *)"    ", tmp___0, 3691, (unsigned long long )size);
    } else {

    }
#line 3692
    set_capacity(rbd_dev->disk, size);
#line 3693
    revalidate_disk(rbd_dev->disk);
  } else {

  }
#line 3695
  return;
}
}
#line 3697 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_refresh(struct rbd_device *rbd_dev ) 
{ 
  u64 mapping_size ;
  int ret ;

  {
#line 3702
  down_write(& rbd_dev->header_rwsem);
#line 3703
  mapping_size = rbd_dev->mapping.size;
#line 3705
  ret = rbd_dev_header_info(rbd_dev);
#line 3706
  if (ret != 0) {
#line 3707
    goto out;
  } else {

  }
#line 3713
  if ((unsigned long )rbd_dev->parent != (unsigned long )((struct rbd_device *)0)) {
#line 3714
    ret = rbd_dev_v2_parent_info(rbd_dev);
#line 3715
    if (ret != 0) {
#line 3716
      goto out;
    } else {

    }
  } else {

  }
#line 3719
  if ((rbd_dev->spec)->snap_id == 0xfffffffffffffffeULL) {
#line 3720
    rbd_dev->mapping.size = rbd_dev->header.image_size;
  } else {
#line 3723
    rbd_exists_validate(rbd_dev);
  }
  out: 
#line 3727
  up_write(& rbd_dev->header_rwsem);
#line 3728
  if (ret == 0 && rbd_dev->mapping.size != mapping_size) {
#line 3729
    rbd_dev_update_size(rbd_dev);
  } else {

  }
#line 3731
  return (ret);
}
}
#line 3734 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_init_request(void *data , struct request *rq , unsigned int hctx_idx ,
                            unsigned int request_idx , unsigned int numa_node___0 ) 
{ 
  struct work_struct *work ;
  void *tmp ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
#line 3738
  tmp = blk_mq_rq_to_pdu(rq);
#line 3738
  work = (struct work_struct *)tmp;
#line 3740
  __init_work(work, 0);
#line 3740
  __constr_expr_0.counter = 137438953408L;
#line 3740
  work->data = __constr_expr_0;
#line 3740
  lockdep_init_map(& work->lockdep_map, "(work)", & __key, 0);
#line 3740
  INIT_LIST_HEAD(& work->entry);
#line 3740
  work->func = & rbd_queue_workfn;
#line 3741
  return (0);
}
}
#line 3744 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct blk_mq_ops rbd_mq_ops  = 
#line 3744
     {& rbd_queue_rq, & blk_mq_map_queue, 0, 0, 0, 0, & rbd_init_request, 0};
#line 3750 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_init_disk(struct rbd_device *rbd_dev ) 
{ 
  struct gendisk *disk ;
  struct request_queue *q ;
  u64 segment_size ;
  int err ;
  long tmp ;
  bool tmp___0 ;

  {
#line 3758
  disk = alloc_disk((int )single_major ? 16 : 256);
#line 3761
  if ((unsigned long )disk == (unsigned long )((struct gendisk *)0)) {
#line 3762
    return (-12);
  } else {

  }
#line 3764
  snprintf((char *)(& disk->disk_name), 32UL, "rbd%d", rbd_dev->dev_id);
#line 3766
  disk->major = rbd_dev->major;
#line 3767
  disk->first_minor = rbd_dev->minor;
#line 3768
  if ((int )single_major) {
#line 3769
    disk->flags = disk->flags | 64;
  } else {

  }
#line 3770
  disk->fops = & rbd_bd_ops;
#line 3771
  disk->private_data = (void *)rbd_dev;
#line 3773
  memset((void *)(& rbd_dev->tag_set), 0, 232UL);
#line 3774
  rbd_dev->tag_set.ops = & rbd_mq_ops;
#line 3775
  rbd_dev->tag_set.queue_depth = (unsigned int )(rbd_dev->opts)->queue_depth;
#line 3776
  rbd_dev->tag_set.numa_node = -1;
#line 3777
  rbd_dev->tag_set.flags = 5U;
#line 3778
  rbd_dev->tag_set.nr_hw_queues = 1U;
#line 3779
  rbd_dev->tag_set.cmd_size = 80U;
#line 3781
  err = blk_mq_alloc_tag_set(& rbd_dev->tag_set);
#line 3782
  if (err != 0) {
#line 3783
    goto out_disk;
  } else {

  }
#line 3785
  q = blk_mq_init_queue(& rbd_dev->tag_set);
#line 3786
  tmp___0 = IS_ERR((void const   *)q);
#line 3786
  if ((int )tmp___0) {
#line 3787
    tmp = PTR_ERR((void const   *)q);
#line 3787
    err = (int )tmp;
#line 3788
    goto out_tag_set;
  } else {

  }
#line 3791
  queue_flag_set_unlocked(12U, q);
#line 3795
  segment_size = rbd_obj_bytes(& rbd_dev->header);
#line 3796
  blk_queue_max_hw_sectors(q, (unsigned int )(segment_size / 512ULL));
#line 3797
  blk_queue_max_segments(q, (int )((unsigned short )(segment_size / 512ULL)));
#line 3798
  blk_queue_max_segment_size(q, (unsigned int )segment_size);
#line 3799
  blk_queue_io_min(q, (unsigned int )segment_size);
#line 3800
  blk_queue_io_opt(q, (unsigned int )segment_size);
#line 3803
  queue_flag_set_unlocked(14U, q);
#line 3804
  q->limits.discard_granularity = (unsigned int )segment_size;
#line 3805
  q->limits.discard_alignment = (unsigned int )segment_size;
#line 3806
  q->limits.max_discard_sectors = (unsigned int )(segment_size / 512ULL);
#line 3807
  q->limits.discard_zeroes_data = 1U;
#line 3809
  blk_queue_merge_bvec(q, & rbd_merge_bvec);
#line 3810
  disk->queue = q;
#line 3812
  q->queuedata = (void *)rbd_dev;
#line 3814
  rbd_dev->disk = disk;
#line 3816
  return (0);
  out_tag_set: 
#line 3818
  blk_mq_free_tag_set(& rbd_dev->tag_set);
  out_disk: 
#line 3820
  put_disk(disk);
#line 3821
  return (err);
}
}
#line 3828 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct rbd_device *dev_to_rbd_dev(struct device *dev ) 
{ 
  struct device  const  *__mptr ;

  {
#line 3830
  __mptr = (struct device  const  *)dev;
#line 3830
  return ((struct rbd_device *)__mptr + 0xfffffffffffffd08UL);
}
}
#line 3833 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static ssize_t rbd_size_show(struct device *dev , struct device_attribute *attr ,
                             char *buf ) 
{ 
  struct rbd_device *rbd_dev ;
  struct rbd_device *tmp ;
  int tmp___0 ;

  {
#line 3836
  tmp = dev_to_rbd_dev(dev);
#line 3836
  rbd_dev = tmp;
#line 3838
  tmp___0 = sprintf(buf, "%llu\n", rbd_dev->mapping.size);
#line 3838
  return ((ssize_t )tmp___0);
}
}
#line 3846 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static ssize_t rbd_features_show(struct device *dev , struct device_attribute *attr ,
                                 char *buf ) 
{ 
  struct rbd_device *rbd_dev ;
  struct rbd_device *tmp ;
  int tmp___0 ;

  {
#line 3849
  tmp = dev_to_rbd_dev(dev);
#line 3849
  rbd_dev = tmp;
#line 3851
  tmp___0 = sprintf(buf, "0x%016llx\n", rbd_dev->mapping.features);
#line 3851
  return ((ssize_t )tmp___0);
}
}
#line 3855 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static ssize_t rbd_major_show(struct device *dev , struct device_attribute *attr ,
                              char *buf ) 
{ 
  struct rbd_device *rbd_dev ;
  struct rbd_device *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 3858
  tmp = dev_to_rbd_dev(dev);
#line 3858
  rbd_dev = tmp;
#line 3860
  if (rbd_dev->major != 0) {
#line 3861
    tmp___0 = sprintf(buf, "%d\n", rbd_dev->major);
#line 3861
    return ((ssize_t )tmp___0);
  } else {

  }
#line 3863
  tmp___1 = sprintf(buf, "(none)\n");
#line 3863
  return ((ssize_t )tmp___1);
}
}
#line 3866 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static ssize_t rbd_minor_show(struct device *dev , struct device_attribute *attr ,
                              char *buf ) 
{ 
  struct rbd_device *rbd_dev ;
  struct rbd_device *tmp ;
  int tmp___0 ;

  {
#line 3869
  tmp = dev_to_rbd_dev(dev);
#line 3869
  rbd_dev = tmp;
#line 3871
  tmp___0 = sprintf(buf, "%d\n", rbd_dev->minor);
#line 3871
  return ((ssize_t )tmp___0);
}
}
#line 3874 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static ssize_t rbd_client_id_show(struct device *dev , struct device_attribute *attr ,
                                  char *buf ) 
{ 
  struct rbd_device *rbd_dev ;
  struct rbd_device *tmp ;
  u64 tmp___0 ;
  int tmp___1 ;

  {
#line 3877
  tmp = dev_to_rbd_dev(dev);
#line 3877
  rbd_dev = tmp;
#line 3879
  tmp___0 = ceph_client_id((rbd_dev->rbd_client)->client);
#line 3879
  tmp___1 = sprintf(buf, "client%lld\n", tmp___0);
#line 3879
  return ((ssize_t )tmp___1);
}
}
#line 3883 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static ssize_t rbd_pool_show(struct device *dev , struct device_attribute *attr ,
                             char *buf ) 
{ 
  struct rbd_device *rbd_dev ;
  struct rbd_device *tmp ;
  int tmp___0 ;

  {
#line 3886
  tmp = dev_to_rbd_dev(dev);
#line 3886
  rbd_dev = tmp;
#line 3888
  tmp___0 = sprintf(buf, "%s\n", (rbd_dev->spec)->pool_name);
#line 3888
  return ((ssize_t )tmp___0);
}
}
#line 3891 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static ssize_t rbd_pool_id_show(struct device *dev , struct device_attribute *attr ,
                                char *buf ) 
{ 
  struct rbd_device *rbd_dev ;
  struct rbd_device *tmp ;
  int tmp___0 ;

  {
#line 3894
  tmp = dev_to_rbd_dev(dev);
#line 3894
  rbd_dev = tmp;
#line 3896
  tmp___0 = sprintf(buf, "%llu\n", (rbd_dev->spec)->pool_id);
#line 3896
  return ((ssize_t )tmp___0);
}
}
#line 3900 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static ssize_t rbd_name_show(struct device *dev , struct device_attribute *attr ,
                             char *buf ) 
{ 
  struct rbd_device *rbd_dev ;
  struct rbd_device *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 3903
  tmp = dev_to_rbd_dev(dev);
#line 3903
  rbd_dev = tmp;
#line 3905
  if ((unsigned long )(rbd_dev->spec)->image_name != (unsigned long )((char const   *)0)) {
#line 3906
    tmp___0 = sprintf(buf, "%s\n", (rbd_dev->spec)->image_name);
#line 3906
    return ((ssize_t )tmp___0);
  } else {

  }
#line 3908
  tmp___1 = sprintf(buf, "(unknown)\n");
#line 3908
  return ((ssize_t )tmp___1);
}
}
#line 3911 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static ssize_t rbd_image_id_show(struct device *dev , struct device_attribute *attr ,
                                 char *buf ) 
{ 
  struct rbd_device *rbd_dev ;
  struct rbd_device *tmp ;
  int tmp___0 ;

  {
#line 3914
  tmp = dev_to_rbd_dev(dev);
#line 3914
  rbd_dev = tmp;
#line 3916
  tmp___0 = sprintf(buf, "%s\n", (rbd_dev->spec)->image_id);
#line 3916
  return ((ssize_t )tmp___0);
}
}
#line 3923 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static ssize_t rbd_snap_show(struct device *dev , struct device_attribute *attr ,
                             char *buf ) 
{ 
  struct rbd_device *rbd_dev ;
  struct rbd_device *tmp ;
  int tmp___0 ;

  {
#line 3927
  tmp = dev_to_rbd_dev(dev);
#line 3927
  rbd_dev = tmp;
#line 3929
  tmp___0 = sprintf(buf, "%s\n", (rbd_dev->spec)->snap_name);
#line 3929
  return ((ssize_t )tmp___0);
}
}
#line 3937 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static ssize_t rbd_parent_show(struct device *dev , struct device_attribute *attr ,
                               char *buf ) 
{ 
  struct rbd_device *rbd_dev ;
  struct rbd_device *tmp ;
  ssize_t count ;
  int tmp___0 ;
  struct rbd_spec *spec ;
  int tmp___1 ;

  {
#line 3941
  tmp = dev_to_rbd_dev(dev);
#line 3941
  rbd_dev = tmp;
#line 3942
  count = 0L;
#line 3944
  if ((unsigned long )rbd_dev->parent == (unsigned long )((struct rbd_device *)0)) {
#line 3945
    tmp___0 = sprintf(buf, "(no parent image)\n");
#line 3945
    return ((ssize_t )tmp___0);
  } else {

  }
#line 3947
  goto ldv_38612;
  ldv_38611: 
#line 3948
  spec = rbd_dev->parent_spec;
#line 3950
  tmp___1 = sprintf(buf + (unsigned long )count, "%spool_id %llu\npool_name %s\nimage_id %s\nimage_name %s\nsnap_id %llu\nsnap_name %s\noverlap %llu\n",
                    count == 0L ? (char *)"" : (char *)"\n", spec->pool_id, spec->pool_name,
                    spec->image_id, (unsigned long )spec->image_name != (unsigned long )((char const   *)0) ? (unsigned long )spec->image_name != (unsigned long )((char const   *)0) : "(unknown)",
                    spec->snap_id, spec->snap_name, rbd_dev->parent_overlap);
#line 3950
  count = (ssize_t )tmp___1 + count;
#line 3947
  rbd_dev = rbd_dev->parent;
  ldv_38612: ;
#line 3947
  if ((unsigned long )rbd_dev->parent != (unsigned long )((struct rbd_device *)0)) {
#line 3949
    goto ldv_38611;
  } else {

  }

#line 3962
  return (count);
}
}
#line 3965 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static ssize_t rbd_image_refresh(struct device *dev , struct device_attribute *attr ,
                                 char const   *buf , size_t size ) 
{ 
  struct rbd_device *rbd_dev ;
  struct rbd_device *tmp ;
  int ret ;

  {
#line 3970
  tmp = dev_to_rbd_dev(dev);
#line 3970
  rbd_dev = tmp;
#line 3973
  ret = rbd_dev_refresh(rbd_dev);
#line 3974
  if (ret != 0) {
#line 3975
    return ((ssize_t )ret);
  } else {

  }
#line 3977
  return ((ssize_t )size);
}
}
#line 3980 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct device_attribute dev_attr_size  =    {{"size", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                  {(char)0}, {(char)0}, {(char)0}}}}, & rbd_size_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 3981 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct device_attribute dev_attr_features  =    {{"features", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                      {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & rbd_features_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                      char const   * , size_t  ))0};
#line 3982 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct device_attribute dev_attr_major  =    {{"major", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                   {(char)0}, {(char)0}, {(char)0}}}}, & rbd_major_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 3983 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct device_attribute dev_attr_minor  =    {{"minor", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                   {(char)0}, {(char)0}, {(char)0}}}}, & rbd_minor_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 3984 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct device_attribute dev_attr_client_id  =    {{"client_id", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                       {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & rbd_client_id_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                       char const   * , size_t  ))0};
#line 3985 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct device_attribute dev_attr_pool  =    {{"pool", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                  {(char)0}, {(char)0}, {(char)0}}}}, & rbd_pool_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 3986 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct device_attribute dev_attr_pool_id  =    {{"pool_id", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                     {(char)0}, {(char)0}, {(char)0}}}}, & rbd_pool_id_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 3987 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct device_attribute dev_attr_name  =    {{"name", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                  {(char)0}, {(char)0}, {(char)0}}}}, & rbd_name_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 3988 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct device_attribute dev_attr_image_id  =    {{"image_id", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                      {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & rbd_image_id_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                      char const   * , size_t  ))0};
#line 3989 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct device_attribute dev_attr_refresh  =    {{"refresh", 128U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                     {(char)0}, {(char)0}, {(char)0}}}}, (ssize_t (*)(struct device * ,
                                                                                      struct device_attribute * ,
                                                                                      char * ))0,
    & rbd_image_refresh};
#line 3990 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct device_attribute dev_attr_current_snap  =    {{"current_snap", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                          {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & rbd_snap_show, (ssize_t (*)(struct device * , struct device_attribute * , char const   * ,
                                  size_t  ))0};
#line 3991 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct device_attribute dev_attr_parent  =    {{"parent", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, & rbd_parent_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 3993 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct attribute *rbd_attrs[13U]  = 
#line 3993
  {      & dev_attr_size.attr,      & dev_attr_features.attr,      & dev_attr_major.attr,      & dev_attr_minor.attr, 
        & dev_attr_client_id.attr,      & dev_attr_pool.attr,      & dev_attr_pool_id.attr,      & dev_attr_name.attr, 
        & dev_attr_image_id.attr,      & dev_attr_current_snap.attr,      & dev_attr_parent.attr,      & dev_attr_refresh.attr, 
        (struct attribute *)0};
#line 4009 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct attribute_group rbd_attr_group  =    {0, 0, (struct attribute **)(& rbd_attrs), 0};
#line 4013 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct attribute_group  const  *rbd_attr_groups[2U]  = {      (struct attribute_group  const  *)(& rbd_attr_group),      (struct attribute_group  const  *)0};
#line 4018 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_sysfs_dev_release(struct device *dev ) 
{ 


  {
#line 4020
  return;
}
}
#line 4022 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct device_type rbd_device_type  =    {"rbd", (struct attribute_group  const  **)(& rbd_attr_groups), 0, 0, & rbd_sysfs_dev_release,
    0};
#line 4028 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct rbd_spec *rbd_spec_get(struct rbd_spec *spec ) 
{ 


  {
#line 4030
  kref_get(& spec->kref);
#line 4032
  return (spec);
}
}
#line 4035
static void rbd_spec_free(struct kref *kref ) ;
#line 4036 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_spec_put(struct rbd_spec *spec ) 
{ 


  {
#line 4038
  if ((unsigned long )spec != (unsigned long )((struct rbd_spec *)0)) {
#line 4039
    kref_put(& spec->kref, & rbd_spec_free);
  } else {

  }
#line 4040
  return;
}
}
#line 4042 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct rbd_spec *rbd_spec_alloc(void) 
{ 
  struct rbd_spec *spec ;
  void *tmp ;

  {
#line 4046
  tmp = kzalloc(56UL, 208U);
#line 4046
  spec = (struct rbd_spec *)tmp;
#line 4047
  if ((unsigned long )spec == (unsigned long )((struct rbd_spec *)0)) {
#line 4048
    return ((struct rbd_spec *)0);
  } else {

  }
#line 4050
  spec->pool_id = 0xffffffffffffffffULL;
#line 4051
  spec->snap_id = 0xfffffffffffffffeULL;
#line 4052
  kref_init(& spec->kref);
#line 4054
  return (spec);
}
}
#line 4057 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_spec_free(struct kref *kref ) 
{ 
  struct rbd_spec *spec ;
  struct kref  const  *__mptr ;

  {
#line 4059
  __mptr = (struct kref  const  *)kref;
#line 4059
  spec = (struct rbd_spec *)__mptr + 0xffffffffffffffd0UL;
#line 4061
  kfree((void const   *)spec->pool_name);
#line 4062
  kfree((void const   *)spec->image_id);
#line 4063
  kfree((void const   *)spec->image_name);
#line 4064
  kfree((void const   *)spec->snap_name);
#line 4065
  kfree((void const   *)spec);
#line 4066
  return;
}
}
#line 4068 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static struct rbd_device *rbd_dev_create(struct rbd_client *rbdc , struct rbd_spec *spec ,
                                         struct rbd_options *opts ) 
{ 
  struct rbd_device *rbd_dev ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 4074
  tmp = kzalloc(2184UL, 208U);
#line 4074
  rbd_dev = (struct rbd_device *)tmp;
#line 4075
  if ((unsigned long )rbd_dev == (unsigned long )((struct rbd_device *)0)) {
#line 4076
    return ((struct rbd_device *)0);
  } else {

  }
#line 4078
  spinlock_check(& rbd_dev->lock);
#line 4078
  __raw_spin_lock_init(& rbd_dev->lock.__annonCompField17.rlock, "&(&rbd_dev->lock)->rlock",
                       & __key);
#line 4079
  rbd_dev->flags = 0UL;
#line 4080
  atomic_set(& rbd_dev->parent_ref, 0);
#line 4081
  INIT_LIST_HEAD(& rbd_dev->node);
#line 4082
  __init_rwsem(& rbd_dev->header_rwsem, "&rbd_dev->header_rwsem", & __key___0);
#line 4084
  rbd_dev->rbd_client = rbdc;
#line 4085
  rbd_dev->spec = spec;
#line 4086
  rbd_dev->opts = opts;
#line 4090
  rbd_dev->layout.fl_stripe_unit = 1073741824U;
#line 4091
  rbd_dev->layout.fl_stripe_count = 1U;
#line 4092
  rbd_dev->layout.fl_object_size = 1073741824U;
#line 4093
  rbd_dev->layout.fl_pg_pool = (unsigned int )spec->pool_id;
#line 4095
  return (rbd_dev);
}
}
#line 4098 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_dev_destroy(struct rbd_device *rbd_dev ) 
{ 


  {
#line 4100
  rbd_put_client(rbd_dev->rbd_client);
#line 4101
  rbd_spec_put(rbd_dev->spec);
#line 4102
  kfree((void const   *)rbd_dev->opts);
#line 4103
  kfree((void const   *)rbd_dev);
#line 4104
  return;
}
}
#line 4111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int _rbd_dev_v2_snap_size(struct rbd_device *rbd_dev , u64 snap_id , u8 *order ,
                                 u64 *snap_size ) 
{ 
  __le64 snapid ;
  int ret ;
  struct __anonstruct_size_buf_317 size_buf ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  char const   *tmp___3 ;
  long tmp___4 ;

  {
#line 4114
  snapid = snap_id;
#line 4119
  size_buf.order = 0U;
#line 4119
  size_buf.size = 0ULL;
#line 4121
  ret = rbd_obj_method_sync(rbd_dev, (char const   *)rbd_dev->header_name, "rbd",
                            "get_size", (void const   *)(& snapid), 8UL, (void *)(& size_buf),
                            9UL);
#line 4125
  descriptor.modname = "rbd";
#line 4125
  descriptor.function = "_rbd_dev_v2_snap_size";
#line 4125
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 4125
  descriptor.format = "%.*s %12.12s:%-4d : %s: rbd_obj_method_sync returned %d\n";
#line 4125
  descriptor.lineno = 4125U;
#line 4125
  descriptor.flags = 0U;
#line 4125
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4125
  if (tmp___0 != 0L) {
#line 4125
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 4125
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: rbd_obj_method_sync returned %d\n",
                       4, (char *)"    ", tmp, 4125, "_rbd_dev_v2_snap_size", ret);
  } else {

  }
#line 4126
  if (ret < 0) {
#line 4127
    return (ret);
  } else {

  }
#line 4128
  if ((unsigned int )ret <= 8U) {
#line 4129
    return (-34);
  } else {

  }
#line 4131
  if ((unsigned long )order != (unsigned long )((u8 *)0U)) {
#line 4132
    *order = size_buf.order;
#line 4133
    descriptor___0.modname = "rbd";
#line 4133
    descriptor___0.function = "_rbd_dev_v2_snap_size";
#line 4133
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 4133
    descriptor___0.format = "%.*s %12.12s:%-4d :   order %u";
#line 4133
    descriptor___0.lineno = 4133U;
#line 4133
    descriptor___0.flags = 0U;
#line 4133
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 4133
    if (tmp___2 != 0L) {
#line 4133
      tmp___1 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                               199);
#line 4133
      __dynamic_pr_debug(& descriptor___0, "rbd: %.*s %12.12s:%-4d :   order %u",
                         4, (char *)"    ", tmp___1, 4133, (unsigned int )*order);
    } else {

    }
  } else {

  }
#line 4135
  *snap_size = size_buf.size;
#line 4137
  descriptor___1.modname = "rbd";
#line 4137
  descriptor___1.function = "_rbd_dev_v2_snap_size";
#line 4137
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 4137
  descriptor___1.format = "%.*s %12.12s:%-4d :   snap_id 0x%016llx snap_size = %llu\n";
#line 4137
  descriptor___1.lineno = 4139U;
#line 4137
  descriptor___1.flags = 0U;
#line 4137
  tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 4137
  if (tmp___4 != 0L) {
#line 4137
    tmp___3 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 4137
    __dynamic_pr_debug(& descriptor___1, "rbd: %.*s %12.12s:%-4d :   snap_id 0x%016llx snap_size = %llu\n",
                       4, (char *)"    ", tmp___3, 4139, snap_id, *snap_size);
  } else {

  }
#line 4141
  return (0);
}
}
#line 4144 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_v2_image_size(struct rbd_device *rbd_dev ) 
{ 
  int tmp ;

  {
#line 4146
  tmp = _rbd_dev_v2_snap_size(rbd_dev, 0xfffffffffffffffeULL, & rbd_dev->header.obj_order,
                              & rbd_dev->header.image_size);
#line 4146
  return (tmp);
}
}
#line 4151 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_v2_object_prefix(struct rbd_device *rbd_dev ) 
{ 
  void *reply_buf ;
  int ret ;
  void *p ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___0 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  bool tmp___4 ;

  {
#line 4157
  reply_buf = kzalloc(64UL, 208U);
#line 4158
  if ((unsigned long )reply_buf == (unsigned long )((void *)0)) {
#line 4159
    return (-12);
  } else {

  }
#line 4161
  ret = rbd_obj_method_sync(rbd_dev, (char const   *)rbd_dev->header_name, "rbd",
                            "get_object_prefix", (void const   *)0, 0UL, reply_buf,
                            64UL);
#line 4164
  descriptor.modname = "rbd";
#line 4164
  descriptor.function = "rbd_dev_v2_object_prefix";
#line 4164
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 4164
  descriptor.format = "%.*s %12.12s:%-4d : %s: rbd_obj_method_sync returned %d\n";
#line 4164
  descriptor.lineno = 4164U;
#line 4164
  descriptor.flags = 0U;
#line 4164
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4164
  if (tmp___0 != 0L) {
#line 4164
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 4164
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: rbd_obj_method_sync returned %d\n",
                       4, (char *)"    ", tmp, 4164, "rbd_dev_v2_object_prefix", ret);
  } else {

  }
#line 4165
  if (ret < 0) {
#line 4166
    goto out;
  } else {

  }
#line 4168
  p = reply_buf;
#line 4169
  rbd_dev->header.object_prefix = ceph_extract_encoded_string(& p, p + (unsigned long )ret,
                                                              (size_t *)0UL, 16U);
#line 4171
  ret = 0;
#line 4173
  tmp___4 = IS_ERR((void const   *)rbd_dev->header.object_prefix);
#line 4173
  if ((int )tmp___4) {
#line 4174
    tmp___1 = PTR_ERR((void const   *)rbd_dev->header.object_prefix);
#line 4174
    ret = (int )tmp___1;
#line 4175
    rbd_dev->header.object_prefix = (char *)0;
  } else {
#line 4177
    descriptor___0.modname = "rbd";
#line 4177
    descriptor___0.function = "rbd_dev_v2_object_prefix";
#line 4177
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 4177
    descriptor___0.format = "%.*s %12.12s:%-4d :   object_prefix = %s\n";
#line 4177
    descriptor___0.lineno = 4177U;
#line 4177
    descriptor___0.flags = 0U;
#line 4177
    tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 4177
    if (tmp___3 != 0L) {
#line 4177
      tmp___2 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                               199);
#line 4177
      __dynamic_pr_debug(& descriptor___0, "rbd: %.*s %12.12s:%-4d :   object_prefix = %s\n",
                         4, (char *)"    ", tmp___2, 4177, rbd_dev->header.object_prefix);
    } else {

    }
  }
  out: 
#line 4180
  kfree((void const   *)reply_buf);
#line 4182
  return (ret);
}
}
#line 4185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int _rbd_dev_v2_snap_features(struct rbd_device *rbd_dev , u64 snap_id , u64 *snap_features ) 
{ 
  __le64 snapid ;
  struct __anonstruct_features_buf_319 features_buf ;
  u64 incompat ;
  int ret ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;

  {
#line 4188
  snapid = snap_id;
#line 4192
  features_buf.features = 0ULL;
#line 4192
  features_buf.incompat = 0ULL;
#line 4196
  ret = rbd_obj_method_sync(rbd_dev, (char const   *)rbd_dev->header_name, "rbd",
                            "get_features", (void const   *)(& snapid), 8UL, (void *)(& features_buf),
                            16UL);
#line 4200
  descriptor.modname = "rbd";
#line 4200
  descriptor.function = "_rbd_dev_v2_snap_features";
#line 4200
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 4200
  descriptor.format = "%.*s %12.12s:%-4d : %s: rbd_obj_method_sync returned %d\n";
#line 4200
  descriptor.lineno = 4200U;
#line 4200
  descriptor.flags = 0U;
#line 4200
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4200
  if (tmp___0 != 0L) {
#line 4200
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 4200
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: rbd_obj_method_sync returned %d\n",
                       4, (char *)"    ", tmp, 4200, "_rbd_dev_v2_snap_features",
                       ret);
  } else {

  }
#line 4201
  if (ret < 0) {
#line 4202
    return (ret);
  } else {

  }
#line 4203
  if ((unsigned int )ret <= 15U) {
#line 4204
    return (-34);
  } else {

  }
#line 4206
  incompat = features_buf.incompat;
#line 4207
  if ((incompat & 0xfffffffffffffffcULL) != 0ULL) {
#line 4208
    return (-6);
  } else {

  }
#line 4210
  *snap_features = features_buf.features;
#line 4212
  descriptor___0.modname = "rbd";
#line 4212
  descriptor___0.function = "_rbd_dev_v2_snap_features";
#line 4212
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 4212
  descriptor___0.format = "%.*s %12.12s:%-4d :   snap_id 0x%016llx features = 0x%016llx incompat = 0x%016llx\n";
#line 4212
  descriptor___0.lineno = 4215U;
#line 4212
  descriptor___0.flags = 0U;
#line 4212
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 4212
  if (tmp___2 != 0L) {
#line 4212
    tmp___1 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 4212
    __dynamic_pr_debug(& descriptor___0, "rbd: %.*s %12.12s:%-4d :   snap_id 0x%016llx features = 0x%016llx incompat = 0x%016llx\n",
                       4, (char *)"    ", tmp___1, 4215, snap_id, *snap_features,
                       features_buf.incompat);
  } else {

  }
#line 4217
  return (0);
}
}
#line 4220 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_v2_features(struct rbd_device *rbd_dev ) 
{ 
  int tmp ;

  {
#line 4222
  tmp = _rbd_dev_v2_snap_features(rbd_dev, 0xfffffffffffffffeULL, & rbd_dev->header.features);
#line 4222
  return (tmp);
}
}
#line 4226 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_v2_parent_info(struct rbd_device *rbd_dev ) 
{ 
  struct rbd_spec *parent_spec ;
  size_t size ;
  void *reply_buf ;
  __le64 snapid ;
  void *p ;
  void *end ;
  u64 pool_id ;
  char *image_id ;
  u64 snap_id ;
  u64 overlap ;
  int ret ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;

  {
#line 4230
  reply_buf = (void *)0;
#line 4240
  parent_spec = rbd_spec_alloc();
#line 4241
  if ((unsigned long )parent_spec == (unsigned long )((struct rbd_spec *)0)) {
#line 4242
    return (-12);
  } else {

  }
#line 4244
  size = 92UL;
#line 4248
  reply_buf = kmalloc(size, 208U);
#line 4249
  if ((unsigned long )reply_buf == (unsigned long )((void *)0)) {
#line 4250
    ret = -12;
#line 4251
    goto out_err;
  } else {

  }
#line 4254
  snapid = (rbd_dev->spec)->snap_id;
#line 4255
  ret = rbd_obj_method_sync(rbd_dev, (char const   *)rbd_dev->header_name, "rbd",
                            "get_parent", (void const   *)(& snapid), 8UL, reply_buf,
                            size);
#line 4259
  descriptor.modname = "rbd";
#line 4259
  descriptor.function = "rbd_dev_v2_parent_info";
#line 4259
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 4259
  descriptor.format = "%.*s %12.12s:%-4d : %s: rbd_obj_method_sync returned %d\n";
#line 4259
  descriptor.lineno = 4259U;
#line 4259
  descriptor.flags = 0U;
#line 4259
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4259
  if (tmp___0 != 0L) {
#line 4259
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 4259
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: rbd_obj_method_sync returned %d\n",
                       4, (char *)"    ", tmp, 4259, "rbd_dev_v2_parent_info", ret);
  } else {

  }
#line 4260
  if (ret < 0) {
#line 4261
    goto out_err;
  } else {

  }
#line 4263
  p = reply_buf;
#line 4264
  end = reply_buf + (unsigned long )ret;
#line 4265
  ret = -34;
#line 4266
  tmp___1 = ceph_has_room(& p, end, 8UL);
#line 4266
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 1L);
#line 4266
  if (tmp___2 == 0L) {
#line 4266
    goto out_err;
  } else {

  }
#line 4266
  pool_id = ceph_decode_64(& p);
#line 4267
  if (pool_id == 0xffffffffffffffffULL) {
#line 4277
    if (rbd_dev->parent_overlap != 0ULL) {
#line 4278
      rbd_dev->parent_overlap = 0ULL;
#line 4279
      rbd_dev_parent_put(rbd_dev);
#line 4280
      printk("\016rbd: %s: clone image has been flattened\n", (char *)(& (rbd_dev->disk)->disk_name));
    } else {

    }
#line 4284
    goto out;
  } else {

  }
#line 4289
  ret = -5;
#line 4290
  if (pool_id > 4294967295ULL) {
#line 4291
    rbd_warn((struct rbd_device *)0, "parent pool id too large (%llu > %u)", pool_id,
             4294967295U);
#line 4293
    goto out_err;
  } else {

  }
#line 4296
  image_id = ceph_extract_encoded_string(& p, end, (size_t *)0UL, 208U);
#line 4297
  tmp___4 = IS_ERR((void const   *)image_id);
#line 4297
  if ((int )tmp___4) {
#line 4298
    tmp___3 = PTR_ERR((void const   *)image_id);
#line 4298
    ret = (int )tmp___3;
#line 4299
    goto out_err;
  } else {

  }
#line 4301
  tmp___5 = ceph_has_room(& p, end, 8UL);
#line 4301
  tmp___6 = ldv__builtin_expect(tmp___5 != 0, 1L);
#line 4301
  if (tmp___6 == 0L) {
#line 4301
    goto out_err;
  } else {

  }
#line 4301
  snap_id = ceph_decode_64(& p);
#line 4302
  tmp___7 = ceph_has_room(& p, end, 8UL);
#line 4302
  tmp___8 = ldv__builtin_expect(tmp___7 != 0, 1L);
#line 4302
  if (tmp___8 == 0L) {
#line 4302
    goto out_err;
  } else {

  }
#line 4302
  overlap = ceph_decode_64(& p);
#line 4309
  if ((unsigned long )rbd_dev->parent_spec == (unsigned long )((struct rbd_spec *)0)) {
#line 4310
    parent_spec->pool_id = pool_id;
#line 4311
    parent_spec->image_id = (char const   *)image_id;
#line 4312
    parent_spec->snap_id = snap_id;
#line 4313
    rbd_dev->parent_spec = parent_spec;
#line 4314
    parent_spec = (struct rbd_spec *)0;
  } else {
#line 4316
    kfree((void const   *)image_id);
  }
#line 4323
  if (overlap == 0ULL) {
#line 4324
    if ((unsigned long )parent_spec != (unsigned long )((struct rbd_spec *)0)) {
#line 4326
      if (rbd_dev->parent_overlap != 0ULL) {
#line 4327
        rbd_warn(rbd_dev, "clone now standalone (overlap became 0)");
      } else {

      }
    } else {
#line 4331
      rbd_warn(rbd_dev, "clone is standalone (overlap 0)");
    }
  } else {

  }
#line 4334
  rbd_dev->parent_overlap = overlap;
  out: 
#line 4337
  ret = 0;
  out_err: 
#line 4339
  kfree((void const   *)reply_buf);
#line 4340
  rbd_spec_put(parent_spec);
#line 4342
  return (ret);
}
}
#line 4345 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_v2_striping_info(struct rbd_device *rbd_dev ) 
{ 
  struct __anonstruct_striping_info_buf_321 striping_info_buf ;
  size_t size ;
  void *p ;
  u64 obj_size ;
  u64 stripe_unit ;
  u64 stripe_count ;
  int ret ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;

  {
#line 4350
  striping_info_buf.stripe_unit = 0ULL;
#line 4350
  striping_info_buf.stripe_count = 0ULL;
#line 4351
  size = 16UL;
#line 4358
  ret = rbd_obj_method_sync(rbd_dev, (char const   *)rbd_dev->header_name, "rbd",
                            "get_stripe_unit_count", (void const   *)0, 0UL, (void *)(& striping_info_buf),
                            size);
#line 4361
  descriptor.modname = "rbd";
#line 4361
  descriptor.function = "rbd_dev_v2_striping_info";
#line 4361
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 4361
  descriptor.format = "%.*s %12.12s:%-4d : %s: rbd_obj_method_sync returned %d\n";
#line 4361
  descriptor.lineno = 4361U;
#line 4361
  descriptor.flags = 0U;
#line 4361
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4361
  if (tmp___0 != 0L) {
#line 4361
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 4361
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: rbd_obj_method_sync returned %d\n",
                       4, (char *)"    ", tmp, 4361, "rbd_dev_v2_striping_info", ret);
  } else {

  }
#line 4362
  if (ret < 0) {
#line 4363
    return (ret);
  } else {

  }
#line 4364
  if ((size_t )ret < size) {
#line 4365
    return (-34);
  } else {

  }
#line 4373
  ret = -22;
#line 4374
  obj_size = 1ULL << (int )rbd_dev->header.obj_order;
#line 4375
  p = (void *)(& striping_info_buf);
#line 4376
  stripe_unit = ceph_decode_64(& p);
#line 4377
  if (stripe_unit != obj_size) {
#line 4378
    rbd_warn(rbd_dev, "unsupported stripe unit (got %llu want %llu)", stripe_unit,
             obj_size);
#line 4381
    return (-22);
  } else {

  }
#line 4383
  stripe_count = ceph_decode_64(& p);
#line 4384
  if (stripe_count != 1ULL) {
#line 4385
    rbd_warn(rbd_dev, "unsupported stripe count (got %llu want 1)", stripe_count);
#line 4387
    return (-22);
  } else {

  }
#line 4389
  rbd_dev->header.stripe_unit = stripe_unit;
#line 4390
  rbd_dev->header.stripe_count = stripe_count;
#line 4392
  return (0);
}
}
#line 4395 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static char *rbd_dev_image_name(struct rbd_device *rbd_dev ) 
{ 
  size_t image_id_size ;
  char *image_id ;
  void *p ;
  void *end ;
  size_t size ;
  void *reply_buf ;
  size_t len ;
  char *image_name ;
  int ret ;
  long tmp ;
  void *tmp___0 ;
  struct _ddebug descriptor ;
  char const   *tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;

  {
#line 4402
  reply_buf = (void *)0;
#line 4403
  len = 0UL;
#line 4404
  image_name = (char *)0;
#line 4407
  tmp = ldv__builtin_expect((unsigned long )(rbd_dev->spec)->image_name != (unsigned long )((char const   *)0),
                         0L);
#line 4407
  if (tmp != 0L) {
#line 4407
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_dev_image_name",
           4407, (char *)"!rbd_dev->spec->image_name");
#line 4407
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (4407), "i" (12UL));
    ldv_38907: ;
#line 4407
    goto ldv_38907;
  } else {

  }
#line 4409
  len = strlen((rbd_dev->spec)->image_id);
#line 4410
  image_id_size = len + 4UL;
#line 4411
  tmp___0 = kmalloc(image_id_size, 208U);
#line 4411
  image_id = (char *)tmp___0;
#line 4412
  if ((unsigned long )image_id == (unsigned long )((char *)0)) {
#line 4413
    return ((char *)0);
  } else {

  }
#line 4415
  p = (void *)image_id;
#line 4416
  end = (void *)(image_id + image_id_size);
#line 4417
  ceph_encode_string(& p, end, (rbd_dev->spec)->image_id, (unsigned int )len);
#line 4419
  size = 4095UL;
#line 4420
  reply_buf = kmalloc(size, 208U);
#line 4421
  if ((unsigned long )reply_buf == (unsigned long )((void *)0)) {
#line 4422
    goto out;
  } else {

  }
#line 4424
  ret = rbd_obj_method_sync(rbd_dev, "rbd_directory", "rbd", "dir_get_name", (void const   *)image_id,
                            image_id_size, reply_buf, size);
#line 4428
  if (ret < 0) {
#line 4429
    goto out;
  } else {

  }
#line 4430
  p = reply_buf;
#line 4431
  end = reply_buf + (unsigned long )ret;
#line 4433
  image_name = ceph_extract_encoded_string(& p, end, & len, 208U);
#line 4434
  tmp___3 = IS_ERR((void const   *)image_name);
#line 4434
  if ((int )tmp___3) {
#line 4435
    image_name = (char *)0;
  } else {
#line 4437
    descriptor.modname = "rbd";
#line 4437
    descriptor.function = "rbd_dev_image_name";
#line 4437
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 4437
    descriptor.format = "%.*s %12.12s:%-4d : %s: name is %s len is %zd\n";
#line 4437
    descriptor.lineno = 4437U;
#line 4437
    descriptor.flags = 0U;
#line 4437
    tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4437
    if (tmp___2 != 0L) {
#line 4437
      tmp___1 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                               199);
#line 4437
      __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: name is %s len is %zd\n",
                         4, (char *)"    ", tmp___1, 4437, "rbd_dev_image_name", image_name,
                         len);
    } else {

    }
  }
  out: 
#line 4439
  kfree((void const   *)reply_buf);
#line 4440
  kfree((void const   *)image_id);
#line 4442
  return (image_name);
}
}
#line 4445 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static u64 rbd_v1_snap_id_by_name(struct rbd_device *rbd_dev , char const   *name ) 
{ 
  struct ceph_snap_context *snapc ;
  char const   *snap_name ;
  u32 which ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 4447
  snapc = rbd_dev->header.snapc;
#line 4449
  which = 0U;
#line 4453
  snap_name = (char const   *)rbd_dev->header.snap_names;
#line 4454
  goto ldv_38918;
  ldv_38917: 
#line 4455
  tmp = strcmp(name, snap_name);
#line 4455
  if (tmp == 0) {
#line 4456
    return (snapc->snaps[which]);
  } else {

  }
#line 4457
  tmp___0 = strlen(snap_name);
#line 4457
  snap_name = snap_name + (tmp___0 + 1UL);
#line 4458
  which = which + 1U;
  ldv_38918: ;
#line 4454
  if (snapc->num_snaps > which) {
#line 4456
    goto ldv_38917;
  } else {

  }

#line 4460
  return (0xfffffffffffffffeULL);
}
}
#line 4463 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static u64 rbd_v2_snap_id_by_name(struct rbd_device *rbd_dev , char const   *name ) 
{ 
  struct ceph_snap_context *snapc ;
  u32 which ;
  bool found ;
  u64 snap_id ;
  char const   *snap_name ;
  long tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 4465
  snapc = rbd_dev->header.snapc;
#line 4467
  found = 0;
#line 4470
  which = 0U;
#line 4470
  goto ldv_38932;
  ldv_38931: 
#line 4473
  snap_id = snapc->snaps[which];
#line 4474
  snap_name = rbd_dev_v2_snap_name(rbd_dev, snap_id);
#line 4475
  tmp___0 = IS_ERR((void const   *)snap_name);
#line 4475
  if ((int )tmp___0) {
#line 4477
    tmp = PTR_ERR((void const   *)snap_name);
#line 4477
    if (tmp == -2L) {
#line 4478
      goto ldv_38929;
    } else {
#line 4480
      goto ldv_38930;
    }
  } else {

  }
#line 4482
  tmp___1 = strcmp(name, snap_name);
#line 4482
  found = tmp___1 == 0;
#line 4483
  kfree((void const   *)snap_name);
  ldv_38929: 
#line 4470
  which = which + 1U;
  ldv_38932: ;
#line 4470
  if (! found && snapc->num_snaps > which) {
#line 4472
    goto ldv_38931;
  } else {

  }
  ldv_38930: ;
#line 4485
  return ((int )found ? snap_id : 0xfffffffffffffffeULL);
}
}
#line 4492 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static u64 rbd_snap_id_by_name(struct rbd_device *rbd_dev , char const   *name ) 
{ 
  u64 tmp ;
  u64 tmp___0 ;

  {
#line 4494
  if (rbd_dev->image_format == 1U) {
#line 4495
    tmp = rbd_v1_snap_id_by_name(rbd_dev, name);
#line 4495
    return (tmp);
  } else {

  }
#line 4497
  tmp___0 = rbd_v2_snap_id_by_name(rbd_dev, name);
#line 4497
  return (tmp___0);
}
}
#line 4503 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_spec_fill_snap_id(struct rbd_device *rbd_dev ) 
{ 
  struct rbd_spec *spec ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  u64 snap_id ;
  int tmp___2 ;

  {
#line 4505
  spec = rbd_dev->spec;
#line 4507
  tmp = ldv__builtin_expect((long )(spec->pool_id == 0xffffffffffffffffULL || (unsigned long )spec->pool_name == (unsigned long )((char const   *)0)),
                         0L);
#line 4507
  if (tmp != 0L) {
#line 4507
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_spec_fill_snap_id",
           4507, (char *)"spec->pool_id != CEPH_NOPOOL && spec->pool_name");
#line 4507
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (4507), "i" (12UL));
    ldv_38942: ;
#line 4507
    goto ldv_38942;
  } else {

  }
#line 4508
  tmp___0 = ldv__builtin_expect((long )((unsigned long )spec->image_id == (unsigned long )((char const   *)0) || (unsigned long )spec->image_name == (unsigned long )((char const   *)0)),
                             0L);
#line 4508
  if (tmp___0 != 0L) {
#line 4508
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_spec_fill_snap_id",
           4508, (char *)"spec->image_id && spec->image_name");
#line 4508
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (4508), "i" (12UL));
    ldv_38943: ;
#line 4508
    goto ldv_38943;
  } else {

  }
#line 4509
  tmp___1 = ldv__builtin_expect((unsigned long )spec->snap_name == (unsigned long )((char const   *)0),
                             0L);
#line 4509
  if (tmp___1 != 0L) {
#line 4509
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_spec_fill_snap_id",
           4509, (char *)"spec->snap_name");
#line 4509
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (4509), "i" (12UL));
    ldv_38944: ;
#line 4509
    goto ldv_38944;
  } else {

  }
#line 4511
  tmp___2 = strcmp(spec->snap_name, "-");
#line 4511
  if (tmp___2 != 0) {
#line 4514
    snap_id = rbd_snap_id_by_name(rbd_dev, spec->snap_name);
#line 4515
    if (snap_id == 0xfffffffffffffffeULL) {
#line 4516
      return (-2);
    } else {

    }
#line 4518
    spec->snap_id = snap_id;
  } else {
#line 4520
    spec->snap_id = 0xfffffffffffffffeULL;
  }
#line 4523
  return (0);
}
}
#line 4532 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_spec_fill_names(struct rbd_device *rbd_dev ) 
{ 
  struct ceph_osd_client *osdc ;
  struct rbd_spec *spec ;
  char const   *pool_name ;
  char const   *image_name ;
  char const   *snap_name ;
  int ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  long tmp___4 ;
  bool tmp___5 ;

  {
#line 4534
  osdc = & ((rbd_dev->rbd_client)->client)->osdc;
#line 4535
  spec = rbd_dev->spec;
#line 4541
  tmp = ldv__builtin_expect(spec->pool_id == 0xffffffffffffffffULL, 0L);
#line 4541
  if (tmp != 0L) {
#line 4541
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_spec_fill_names",
           4541, (char *)"spec->pool_id != CEPH_NOPOOL");
#line 4541
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (4541), "i" (12UL));
    ldv_38956: ;
#line 4541
    goto ldv_38956;
  } else {

  }
#line 4542
  tmp___0 = ldv__builtin_expect((unsigned long )spec->image_id == (unsigned long )((char const   *)0),
                             0L);
#line 4542
  if (tmp___0 != 0L) {
#line 4542
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_spec_fill_names",
           4542, (char *)"spec->image_id");
#line 4542
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (4542), "i" (12UL));
    ldv_38957: ;
#line 4542
    goto ldv_38957;
  } else {

  }
#line 4543
  tmp___1 = ldv__builtin_expect(spec->snap_id == 0xfffffffffffffffeULL, 0L);
#line 4543
  if (tmp___1 != 0L) {
#line 4543
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_spec_fill_names",
           4543, (char *)"spec->snap_id != CEPH_NOSNAP");
#line 4543
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (4543), "i" (12UL));
    ldv_38958: ;
#line 4543
    goto ldv_38958;
  } else {

  }
#line 4547
  pool_name = ceph_pg_pool_name_by_id(osdc->osdmap, spec->pool_id);
#line 4548
  if ((unsigned long )pool_name == (unsigned long )((char const   *)0)) {
#line 4549
    rbd_warn(rbd_dev, "no pool with id %llu", spec->pool_id);
#line 4550
    return (-5);
  } else {

  }
#line 4552
  tmp___2 = kstrdup(pool_name, 208U);
#line 4552
  pool_name = (char const   *)tmp___2;
#line 4553
  if ((unsigned long )pool_name == (unsigned long )((char const   *)0)) {
#line 4554
    return (-12);
  } else {

  }
#line 4558
  tmp___3 = rbd_dev_image_name(rbd_dev);
#line 4558
  image_name = (char const   *)tmp___3;
#line 4559
  if ((unsigned long )image_name == (unsigned long )((char const   *)0)) {
#line 4560
    rbd_warn(rbd_dev, "unable to get image name");
  } else {

  }
#line 4564
  snap_name = rbd_snap_name(rbd_dev, spec->snap_id);
#line 4565
  tmp___5 = IS_ERR((void const   *)snap_name);
#line 4565
  if ((int )tmp___5) {
#line 4566
    tmp___4 = PTR_ERR((void const   *)snap_name);
#line 4566
    ret = (int )tmp___4;
#line 4567
    goto out_err;
  } else {

  }
#line 4570
  spec->pool_name = pool_name;
#line 4571
  spec->image_name = image_name;
#line 4572
  spec->snap_name = snap_name;
#line 4574
  return (0);
  out_err: 
#line 4577
  kfree((void const   *)image_name);
#line 4578
  kfree((void const   *)pool_name);
#line 4579
  return (ret);
}
}
#line 4582 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_v2_snap_context(struct rbd_device *rbd_dev ) 
{ 
  size_t size ;
  int ret ;
  void *reply_buf ;
  void *p ;
  void *end ;
  u64 seq ;
  u32 snap_count ;
  struct ceph_snap_context *snapc ;
  u32 i ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  struct _ddebug descriptor___0 ;
  char const   *tmp___6 ;
  long tmp___7 ;

  {
#line 4600
  size = 4092UL;
#line 4602
  reply_buf = kzalloc(size, 208U);
#line 4603
  if ((unsigned long )reply_buf == (unsigned long )((void *)0)) {
#line 4604
    return (-12);
  } else {

  }
#line 4606
  ret = rbd_obj_method_sync(rbd_dev, (char const   *)rbd_dev->header_name, "rbd",
                            "get_snapcontext", (void const   *)0, 0UL, reply_buf,
                            size);
#line 4609
  descriptor.modname = "rbd";
#line 4609
  descriptor.function = "rbd_dev_v2_snap_context";
#line 4609
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 4609
  descriptor.format = "%.*s %12.12s:%-4d : %s: rbd_obj_method_sync returned %d\n";
#line 4609
  descriptor.lineno = 4609U;
#line 4609
  descriptor.flags = 0U;
#line 4609
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4609
  if (tmp___0 != 0L) {
#line 4609
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 4609
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: rbd_obj_method_sync returned %d\n",
                       4, (char *)"    ", tmp, 4609, "rbd_dev_v2_snap_context", ret);
  } else {

  }
#line 4610
  if (ret < 0) {
#line 4611
    goto out;
  } else {

  }
#line 4613
  p = reply_buf;
#line 4614
  end = reply_buf + (unsigned long )ret;
#line 4615
  ret = -34;
#line 4616
  tmp___1 = ceph_has_room(& p, end, 8UL);
#line 4616
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 1L);
#line 4616
  if (tmp___2 == 0L) {
#line 4616
    goto out;
  } else {

  }
#line 4616
  seq = ceph_decode_64(& p);
#line 4617
  tmp___3 = ceph_has_room(& p, end, 4UL);
#line 4617
  tmp___4 = ldv__builtin_expect(tmp___3 != 0, 1L);
#line 4617
  if (tmp___4 == 0L) {
#line 4617
    goto out;
  } else {

  }
#line 4617
  snap_count = ceph_decode_32(& p);
#line 4630
  tmp___5 = ceph_has_room(& p, end, (unsigned long )snap_count * 8UL);
#line 4630
  if (tmp___5 == 0) {
#line 4631
    goto out;
  } else {

  }
#line 4632
  ret = 0;
#line 4634
  snapc = ceph_create_snap_context(snap_count, 208U);
#line 4635
  if ((unsigned long )snapc == (unsigned long )((struct ceph_snap_context *)0)) {
#line 4636
    ret = -12;
#line 4637
    goto out;
  } else {

  }
#line 4639
  snapc->seq = seq;
#line 4640
  i = 0U;
#line 4640
  goto ldv_38976;
  ldv_38975: 
#line 4641
  snapc->snaps[i] = ceph_decode_64(& p);
#line 4640
  i = i + 1U;
  ldv_38976: ;
#line 4640
  if (i < snap_count) {
#line 4642
    goto ldv_38975;
  } else {

  }
#line 4643
  ceph_put_snap_context(rbd_dev->header.snapc);
#line 4644
  rbd_dev->header.snapc = snapc;
#line 4646
  descriptor___0.modname = "rbd";
#line 4646
  descriptor___0.function = "rbd_dev_v2_snap_context";
#line 4646
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 4646
  descriptor___0.format = "%.*s %12.12s:%-4d :   snap context seq = %llu, snap_count = %u\n";
#line 4646
  descriptor___0.lineno = 4647U;
#line 4646
  descriptor___0.flags = 0U;
#line 4646
  tmp___7 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 4646
  if (tmp___7 != 0L) {
#line 4646
    tmp___6 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 4646
    __dynamic_pr_debug(& descriptor___0, "rbd: %.*s %12.12s:%-4d :   snap context seq = %llu, snap_count = %u\n",
                       4, (char *)"    ", tmp___6, 4647, seq, snap_count);
  } else {

  }
  out: 
#line 4649
  kfree((void const   *)reply_buf);
#line 4651
  return (ret);
}
}
#line 4654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static char const   *rbd_dev_v2_snap_name(struct rbd_device *rbd_dev , u64 snap_id ) 
{ 
  size_t size ;
  void *reply_buf ;
  __le64 snapid ;
  int ret ;
  void *p ;
  void *end ;
  char *snap_name ;
  void *tmp ;
  struct _ddebug descriptor ;
  char const   *tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  bool tmp___3 ;
  struct _ddebug descriptor___0 ;
  char const   *tmp___4 ;
  long tmp___5 ;

  {
#line 4665
  size = 254UL;
#line 4666
  reply_buf = kmalloc(size, 208U);
#line 4667
  if ((unsigned long )reply_buf == (unsigned long )((void *)0)) {
#line 4668
    tmp = ERR_PTR(-12L);
#line 4668
    return ((char const   *)tmp);
  } else {

  }
#line 4670
  snapid = snap_id;
#line 4671
  ret = rbd_obj_method_sync(rbd_dev, (char const   *)rbd_dev->header_name, "rbd",
                            "get_snapshot_name", (void const   *)(& snapid), 8UL,
                            reply_buf, size);
#line 4675
  descriptor.modname = "rbd";
#line 4675
  descriptor.function = "rbd_dev_v2_snap_name";
#line 4675
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 4675
  descriptor.format = "%.*s %12.12s:%-4d : %s: rbd_obj_method_sync returned %d\n";
#line 4675
  descriptor.lineno = 4675U;
#line 4675
  descriptor.flags = 0U;
#line 4675
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4675
  if (tmp___1 != 0L) {
#line 4675
    tmp___0 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 4675
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: rbd_obj_method_sync returned %d\n",
                       4, (char *)"    ", tmp___0, 4675, "rbd_dev_v2_snap_name", ret);
  } else {

  }
#line 4676
  if (ret < 0) {
#line 4677
    tmp___2 = ERR_PTR((long )ret);
#line 4677
    snap_name = (char *)tmp___2;
#line 4678
    goto out;
  } else {

  }
#line 4681
  p = reply_buf;
#line 4682
  end = reply_buf + (unsigned long )ret;
#line 4683
  snap_name = ceph_extract_encoded_string(& p, end, (size_t *)0UL, 208U);
#line 4684
  tmp___3 = IS_ERR((void const   *)snap_name);
#line 4684
  if ((int )tmp___3) {
#line 4685
    goto out;
  } else {

  }
#line 4687
  descriptor___0.modname = "rbd";
#line 4687
  descriptor___0.function = "rbd_dev_v2_snap_name";
#line 4687
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 4687
  descriptor___0.format = "%.*s %12.12s:%-4d :   snap_id 0x%016llx snap_name = %s\n";
#line 4687
  descriptor___0.lineno = 4688U;
#line 4687
  descriptor___0.flags = 0U;
#line 4687
  tmp___5 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 4687
  if (tmp___5 != 0L) {
#line 4687
    tmp___4 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 4687
    __dynamic_pr_debug(& descriptor___0, "rbd: %.*s %12.12s:%-4d :   snap_id 0x%016llx snap_name = %s\n",
                       4, (char *)"    ", tmp___4, 4688, snap_id, snap_name);
  } else {

  }
  out: 
#line 4690
  kfree((void const   *)reply_buf);
#line 4692
  return ((char const   *)snap_name);
}
}
#line 4695 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_v2_header_info(struct rbd_device *rbd_dev ) 
{ 
  bool first_time ;
  int ret ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;

  {
#line 4697
  first_time = (unsigned long )rbd_dev->header.object_prefix == (unsigned long )((char *)0);
#line 4700
  ret = rbd_dev_v2_image_size(rbd_dev);
#line 4701
  if (ret != 0) {
#line 4702
    return (ret);
  } else {

  }
#line 4704
  if ((int )first_time) {
#line 4705
    ret = rbd_dev_v2_header_onetime(rbd_dev);
#line 4706
    if (ret != 0) {
#line 4707
      return (ret);
    } else {

    }
  } else {

  }
#line 4710
  ret = rbd_dev_v2_snap_context(rbd_dev);
#line 4711
  descriptor.modname = "rbd";
#line 4711
  descriptor.function = "rbd_dev_v2_header_info";
#line 4711
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 4711
  descriptor.format = "%.*s %12.12s:%-4d : rbd_dev_v2_snap_context returned %d\n";
#line 4711
  descriptor.lineno = 4711U;
#line 4711
  descriptor.flags = 0U;
#line 4711
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4711
  if (tmp___0 != 0L) {
#line 4711
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 4711
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : rbd_dev_v2_snap_context returned %d\n",
                       4, (char *)"    ", tmp, 4711, ret);
  } else {

  }
#line 4713
  return (ret);
}
}
#line 4716 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_header_info(struct rbd_device *rbd_dev ) 
{ 
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 4718
  tmp = rbd_image_format_valid(rbd_dev->image_format);
#line 4718
  if (tmp) {
#line 4718
    tmp___0 = 0;
  } else {
#line 4718
    tmp___0 = 1;
  }
#line 4718
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 4718
  if (tmp___1 != 0L) {
#line 4718
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_dev_header_info",
           4718, (char *)"rbd_image_format_valid(rbd_dev->image_format)");
#line 4718
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (4718), "i" (12UL));
    ldv_39005: ;
#line 4718
    goto ldv_39005;
  } else {

  }
#line 4720
  if (rbd_dev->image_format == 1U) {
#line 4721
    tmp___2 = rbd_dev_v1_header_info(rbd_dev);
#line 4721
    return (tmp___2);
  } else {

  }
#line 4723
  tmp___3 = rbd_dev_v2_header_info(rbd_dev);
#line 4723
  return (tmp___3);
}
}
#line 4726 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_bus_add_dev(struct rbd_device *rbd_dev ) 
{ 
  struct device *dev ;
  int ret ;

  {
#line 4731
  dev = & rbd_dev->dev;
#line 4732
  dev->bus = & rbd_bus_type;
#line 4733
  dev->type = (struct device_type  const  *)(& rbd_device_type);
#line 4734
  dev->parent = & rbd_root_dev;
#line 4735
  dev->release = & rbd_dev_device_release;
#line 4736
  dev_set_name(dev, "%d", rbd_dev->dev_id);
#line 4737
  ret = device_register(dev);
#line 4739
  return (ret);
}
}
#line 4742 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_bus_del_dev(struct rbd_device *rbd_dev ) 
{ 


  {
#line 4744
  device_unregister(& rbd_dev->dev);
#line 4745
  return;
}
}
#line 4751 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_id_get(struct rbd_device *rbd_dev ) 
{ 
  int new_dev_id ;
  int tmp ;
  struct _ddebug descriptor ;
  char const   *tmp___0 ;
  long tmp___1 ;

  {
#line 4755
  tmp = minor_to_rbd_dev_id(1048576);
#line 4755
  new_dev_id = ida_simple_get(& rbd_dev_id_ida, 0U, (unsigned int )tmp, 208U);
#line 4758
  if (new_dev_id < 0) {
#line 4759
    return (new_dev_id);
  } else {

  }
#line 4761
  rbd_dev->dev_id = new_dev_id;
#line 4763
  spin_lock(& rbd_dev_list_lock);
#line 4764
  list_add_tail(& rbd_dev->node, & rbd_dev_list);
#line 4765
  spin_unlock(& rbd_dev_list_lock);
#line 4767
  descriptor.modname = "rbd";
#line 4767
  descriptor.function = "rbd_dev_id_get";
#line 4767
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 4767
  descriptor.format = "%.*s %12.12s:%-4d : rbd_dev %p given dev id %d\n";
#line 4767
  descriptor.lineno = 4767U;
#line 4767
  descriptor.flags = 0U;
#line 4767
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4767
  if (tmp___1 != 0L) {
#line 4767
    tmp___0 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 4767
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : rbd_dev %p given dev id %d\n",
                       4, (char *)"    ", tmp___0, 4767, rbd_dev, rbd_dev->dev_id);
  } else {

  }
#line 4769
  return (0);
}
}
#line 4776 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_dev_id_put(struct rbd_device *rbd_dev ) 
{ 
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;

  {
#line 4778
  spin_lock(& rbd_dev_list_lock);
#line 4779
  list_del_init(& rbd_dev->node);
#line 4780
  spin_unlock(& rbd_dev_list_lock);
#line 4782
  ida_simple_remove(& rbd_dev_id_ida, (unsigned int )rbd_dev->dev_id);
#line 4784
  descriptor.modname = "rbd";
#line 4784
  descriptor.function = "rbd_dev_id_put";
#line 4784
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 4784
  descriptor.format = "%.*s %12.12s:%-4d : rbd_dev %p released dev id %d\n";
#line 4784
  descriptor.lineno = 4784U;
#line 4784
  descriptor.flags = 0U;
#line 4784
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 4784
  if (tmp___0 != 0L) {
#line 4784
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 4784
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : rbd_dev %p released dev id %d\n",
                       4, (char *)"    ", tmp, 4784, rbd_dev, rbd_dev->dev_id);
  } else {

  }
#line 4786
  return;
}
}
#line 4793 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
__inline static size_t next_token(char const   **buf ) 
{ 
  char const   *spaces ;
  __kernel_size_t tmp ;
  __kernel_size_t tmp___0 ;

  {
#line 4799
  spaces = " \f\n\r\t\v";
#line 4801
  tmp = strspn(*buf, spaces);
#line 4801
  *buf = *buf + tmp;
#line 4803
  tmp___0 = strcspn(*buf, spaces);
#line 4803
  return (tmp___0);
}
}
#line 4822 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
__inline static char *dup_token(char const   **buf , size_t *lenp ) 
{ 
  char *dup ;
  size_t len ;
  void *tmp ;

  {
#line 4827
  len = next_token(buf);
#line 4828
  tmp = kmemdup((void const   *)*buf, len + 1UL, 208U);
#line 4828
  dup = (char *)tmp;
#line 4829
  if ((unsigned long )dup == (unsigned long )((char *)0)) {
#line 4830
    return ((char *)0);
  } else {

  }
#line 4831
  *(dup + len) = 0;
#line 4832
  *buf = *buf + len;
#line 4834
  if ((unsigned long )lenp != (unsigned long )((size_t *)0UL)) {
#line 4835
    *lenp = len;
  } else {

  }
#line 4837
  return (dup);
}
}
#line 4881 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_add_parse_args(char const   *buf , struct ceph_options **ceph_opts ,
                              struct rbd_options **opts , struct rbd_spec **rbd_spec ) 
{ 
  size_t len ;
  char *options ;
  char const   *mon_addrs ;
  char *snap_name ;
  size_t mon_addrs_size ;
  struct rbd_spec *spec ;
  struct rbd_options *rbd_opts ;
  struct ceph_options *copts ;
  int ret ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  bool tmp___4 ;

  {
#line 4891
  spec = (struct rbd_spec *)0;
#line 4892
  rbd_opts = (struct rbd_options *)0;
#line 4898
  len = next_token(& buf);
#line 4899
  if (len == 0UL) {
#line 4900
    rbd_warn((struct rbd_device *)0, "no monitor address(es) provided");
#line 4901
    return (-22);
  } else {

  }
#line 4903
  mon_addrs = buf;
#line 4904
  mon_addrs_size = len + 1UL;
#line 4905
  buf = buf + len;
#line 4907
  ret = -22;
#line 4908
  options = dup_token(& buf, (size_t *)0UL);
#line 4909
  if ((unsigned long )options == (unsigned long )((char *)0)) {
#line 4910
    return (-12);
  } else {

  }
#line 4911
  if ((int )((signed char )*options) == 0) {
#line 4912
    rbd_warn((struct rbd_device *)0, "no options provided");
#line 4913
    goto out_err;
  } else {

  }
#line 4916
  spec = rbd_spec_alloc();
#line 4917
  if ((unsigned long )spec == (unsigned long )((struct rbd_spec *)0)) {
#line 4918
    goto out_mem;
  } else {

  }
#line 4920
  tmp = dup_token(& buf, (size_t *)0UL);
#line 4920
  spec->pool_name = (char const   *)tmp;
#line 4921
  if ((unsigned long )spec->pool_name == (unsigned long )((char const   *)0)) {
#line 4922
    goto out_mem;
  } else {

  }
#line 4923
  if ((int )((signed char )*(spec->pool_name)) == 0) {
#line 4924
    rbd_warn((struct rbd_device *)0, "no pool name provided");
#line 4925
    goto out_err;
  } else {

  }
#line 4928
  tmp___0 = dup_token(& buf, (size_t *)0UL);
#line 4928
  spec->image_name = (char const   *)tmp___0;
#line 4929
  if ((unsigned long )spec->image_name == (unsigned long )((char const   *)0)) {
#line 4930
    goto out_mem;
  } else {

  }
#line 4931
  if ((int )((signed char )*(spec->image_name)) == 0) {
#line 4932
    rbd_warn((struct rbd_device *)0, "no image name provided");
#line 4933
    goto out_err;
  } else {

  }
#line 4940
  len = next_token(& buf);
#line 4941
  if (len == 0UL) {
#line 4942
    buf = "-";
#line 4943
    len = 1UL;
  } else
#line 4944
  if (len > 250UL) {
#line 4945
    ret = -36;
#line 4946
    goto out_err;
  } else {

  }
#line 4948
  tmp___1 = kmemdup((void const   *)buf, len + 1UL, 208U);
#line 4948
  snap_name = (char *)tmp___1;
#line 4949
  if ((unsigned long )snap_name == (unsigned long )((char *)0)) {
#line 4950
    goto out_mem;
  } else {

  }
#line 4951
  *(snap_name + len) = 0;
#line 4952
  spec->snap_name = (char const   *)snap_name;
#line 4956
  tmp___2 = kzalloc(8UL, 208U);
#line 4956
  rbd_opts = (struct rbd_options *)tmp___2;
#line 4957
  if ((unsigned long )rbd_opts == (unsigned long )((struct rbd_options *)0)) {
#line 4958
    goto out_mem;
  } else {

  }
#line 4960
  rbd_opts->read_only = 0;
#line 4961
  rbd_opts->queue_depth = 128;
#line 4963
  copts = ceph_parse_options(options, mon_addrs, mon_addrs + (mon_addrs_size + 0xffffffffffffffffUL),
                             & parse_rbd_opts_token, (void *)rbd_opts);
#line 4966
  tmp___4 = IS_ERR((void const   *)copts);
#line 4966
  if ((int )tmp___4) {
#line 4967
    tmp___3 = PTR_ERR((void const   *)copts);
#line 4967
    ret = (int )tmp___3;
#line 4968
    goto out_err;
  } else {

  }
#line 4970
  kfree((void const   *)options);
#line 4972
  *ceph_opts = copts;
#line 4973
  *opts = rbd_opts;
#line 4974
  *rbd_spec = spec;
#line 4976
  return (0);
  out_mem: 
#line 4978
  ret = -12;
  out_err: 
#line 4980
  kfree((void const   *)rbd_opts);
#line 4981
  rbd_spec_put(spec);
#line 4982
  kfree((void const   *)options);
#line 4984
  return (ret);
}
}
#line 4990 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_add_get_pool_id(struct rbd_client *rbdc , char const   *pool_name ) 
{ 
  struct ceph_options *opts ;
  u64 newest_epoch ;
  int tries ;
  int ret ;
  int tmp ;

  {
#line 4992
  opts = (rbdc->client)->options;
#line 4994
  tries = 0;
  again: 
#line 4998
  ret = ceph_pg_poolid_by_name((rbdc->client)->osdc.osdmap, pool_name);
#line 4999
  if (ret == -2) {
#line 4999
    tmp = tries;
#line 4999
    tries = tries + 1;
#line 4999
    if (tmp <= 0) {
#line 5000
      ret = ceph_monc_do_get_version(& (rbdc->client)->monc, "osdmap", & newest_epoch);
#line 5002
      if (ret < 0) {
#line 5003
        return (ret);
      } else {

      }
#line 5005
      if ((u64 )((rbdc->client)->osdc.osdmap)->epoch < newest_epoch) {
#line 5006
        ceph_monc_request_next_osdmap(& (rbdc->client)->monc);
#line 5007
        ceph_monc_wait_osdmap(& (rbdc->client)->monc, (u32 )newest_epoch, opts->mount_timeout);
#line 5010
        goto again;
      } else {
#line 5013
        return (-2);
      }
    } else {

    }
  } else {

  }
#line 5017
  return (ret);
}
}
#line 5034 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_image_id(struct rbd_device *rbd_dev ) 
{ 
  int ret ;
  size_t size ;
  char *object_name ;
  void *response ;
  char *image_id ;
  size_t tmp ;
  void *tmp___0 ;
  struct _ddebug descriptor ;
  char const   *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___0 ;
  char const   *tmp___3 ;
  long tmp___4 ;
  void *p ;
  struct _ddebug descriptor___1 ;
  char const   *tmp___5 ;
  long tmp___6 ;

  {
#line 5048
  if ((unsigned long )(rbd_dev->spec)->image_id != (unsigned long )((char const   *)0)) {
#line 5049
    rbd_dev->image_format = (int )((signed char )*((rbd_dev->spec)->image_id)) != 0 ? 2U : 1U;
#line 5051
    return (0);
  } else {

  }
#line 5058
  tmp = strlen((rbd_dev->spec)->image_name);
#line 5058
  size = tmp + 8UL;
#line 5059
  tmp___0 = kmalloc(size, 16U);
#line 5059
  object_name = (char *)tmp___0;
#line 5060
  if ((unsigned long )object_name == (unsigned long )((char *)0)) {
#line 5061
    return (-12);
  } else {

  }
#line 5062
  sprintf(object_name, "%s%s", (char *)"rbd_id.", (rbd_dev->spec)->image_name);
#line 5063
  descriptor.modname = "rbd";
#line 5063
  descriptor.function = "rbd_dev_image_id";
#line 5063
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 5063
  descriptor.format = "%.*s %12.12s:%-4d : rbd id object name is %s\n";
#line 5063
  descriptor.lineno = 5063U;
#line 5063
  descriptor.flags = 0U;
#line 5063
  tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 5063
  if (tmp___2 != 0L) {
#line 5063
    tmp___1 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 5063
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : rbd id object name is %s\n",
                       4, (char *)"    ", tmp___1, 5063, object_name);
  } else {

  }
#line 5067
  size = 68UL;
#line 5068
  response = kzalloc(size, 16U);
#line 5069
  if ((unsigned long )response == (unsigned long )((void *)0)) {
#line 5070
    ret = -12;
#line 5071
    goto out;
  } else {

  }
#line 5076
  ret = rbd_obj_method_sync(rbd_dev, (char const   *)object_name, "rbd", "get_id",
                            (void const   *)0, 0UL, response, 64UL);
#line 5079
  descriptor___0.modname = "rbd";
#line 5079
  descriptor___0.function = "rbd_dev_image_id";
#line 5079
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 5079
  descriptor___0.format = "%.*s %12.12s:%-4d : %s: rbd_obj_method_sync returned %d\n";
#line 5079
  descriptor___0.lineno = 5079U;
#line 5079
  descriptor___0.flags = 0U;
#line 5079
  tmp___4 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
#line 5079
  if (tmp___4 != 0L) {
#line 5079
    tmp___3 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 5079
    __dynamic_pr_debug(& descriptor___0, "rbd: %.*s %12.12s:%-4d : %s: rbd_obj_method_sync returned %d\n",
                       4, (char *)"    ", tmp___3, 5079, "rbd_dev_image_id", ret);
  } else {

  }
#line 5080
  if (ret == -2) {
#line 5081
    image_id = kstrdup("", 208U);
#line 5082
    ret = (unsigned long )image_id != (unsigned long )((char *)0) ? 0 : -12;
#line 5083
    if (ret == 0) {
#line 5084
      rbd_dev->image_format = 1U;
    } else {

    }
  } else
#line 5085
  if (ret >= 0) {
#line 5086
    p = response;
#line 5088
    image_id = ceph_extract_encoded_string(& p, p + (unsigned long )ret, (size_t *)0UL,
                                           16U);
#line 5090
    ret = PTR_ERR_OR_ZERO((void const   *)image_id);
#line 5091
    if (ret == 0) {
#line 5092
      rbd_dev->image_format = 2U;
    } else {

    }
  } else {

  }
#line 5095
  if (ret == 0) {
#line 5096
    (rbd_dev->spec)->image_id = (char const   *)image_id;
#line 5097
    descriptor___1.modname = "rbd";
#line 5097
    descriptor___1.function = "rbd_dev_image_id";
#line 5097
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 5097
    descriptor___1.format = "%.*s %12.12s:%-4d : image_id is %s\n";
#line 5097
    descriptor___1.lineno = 5097U;
#line 5097
    descriptor___1.flags = 0U;
#line 5097
    tmp___6 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
#line 5097
    if (tmp___6 != 0L) {
#line 5097
      tmp___5 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                               199);
#line 5097
      __dynamic_pr_debug(& descriptor___1, "rbd: %.*s %12.12s:%-4d : image_id is %s\n",
                         4, (char *)"    ", tmp___5, 5097, image_id);
    } else {

    }
  } else {

  }
  out: 
#line 5100
  kfree((void const   *)response);
#line 5101
  kfree((void const   *)object_name);
#line 5103
  return (ret);
}
}
#line 5110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_dev_unprobe(struct rbd_device *rbd_dev ) 
{ 
  struct rbd_image_header *header ;

  {
#line 5114
  rbd_dev_parent_put(rbd_dev);
#line 5118
  header = & rbd_dev->header;
#line 5119
  ceph_put_snap_context(header->snapc);
#line 5120
  kfree((void const   *)header->snap_sizes);
#line 5121
  kfree((void const   *)header->snap_names);
#line 5122
  kfree((void const   *)header->object_prefix);
#line 5123
  memset((void *)header, 0, 72UL);
#line 5124
  return;
}
}
#line 5126 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_v2_header_onetime(struct rbd_device *rbd_dev ) 
{ 
  int ret ;

  {
#line 5130
  ret = rbd_dev_v2_object_prefix(rbd_dev);
#line 5131
  if (ret != 0) {
#line 5132
    goto out_err;
  } else {

  }
#line 5138
  ret = rbd_dev_v2_features(rbd_dev);
#line 5139
  if (ret != 0) {
#line 5140
    goto out_err;
  } else {

  }
#line 5144
  if ((rbd_dev->header.features & 2ULL) != 0ULL) {
#line 5145
    ret = rbd_dev_v2_striping_info(rbd_dev);
#line 5146
    if (ret < 0) {
#line 5147
      goto out_err;
    } else {

    }
  } else {

  }
#line 5151
  return (0);
  out_err: 
#line 5153
  rbd_dev->header.features = 0ULL;
#line 5154
  kfree((void const   *)rbd_dev->header.object_prefix);
#line 5155
  rbd_dev->header.object_prefix = (char *)0;
#line 5157
  return (ret);
}
}
#line 5160 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_probe_parent(struct rbd_device *rbd_dev ) 
{ 
  struct rbd_device *parent ;
  struct rbd_spec *parent_spec ;
  struct rbd_client *rbdc ;
  int ret ;

  {
#line 5162
  parent = (struct rbd_device *)0;
#line 5167
  if ((unsigned long )rbd_dev->parent_spec == (unsigned long )((struct rbd_spec *)0)) {
#line 5168
    return (0);
  } else {

  }
#line 5174
  parent_spec = rbd_spec_get(rbd_dev->parent_spec);
#line 5175
  rbdc = __rbd_get_client(rbd_dev->rbd_client);
#line 5177
  ret = -12;
#line 5178
  parent = rbd_dev_create(rbdc, parent_spec, (struct rbd_options *)0);
#line 5179
  if ((unsigned long )parent == (unsigned long )((struct rbd_device *)0)) {
#line 5180
    goto out_err;
  } else {

  }
#line 5182
  ret = rbd_dev_image_probe(parent, 0);
#line 5183
  if (ret < 0) {
#line 5184
    goto out_err;
  } else {

  }
#line 5185
  rbd_dev->parent = parent;
#line 5186
  atomic_set(& rbd_dev->parent_ref, 1);
#line 5188
  return (0);
  out_err: ;
#line 5190
  if ((unsigned long )parent != (unsigned long )((struct rbd_device *)0)) {
#line 5191
    rbd_dev_unparent(rbd_dev);
#line 5192
    kfree((void const   *)rbd_dev->header_name);
#line 5193
    rbd_dev_destroy(parent);
  } else {
#line 5195
    rbd_put_client(rbdc);
#line 5196
    rbd_spec_put(parent_spec);
  }
#line 5199
  return (ret);
}
}
#line 5202 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_device_setup(struct rbd_device *rbd_dev ) 
{ 
  int ret ;

  {
#line 5208
  ret = rbd_dev_id_get(rbd_dev);
#line 5209
  if (ret != 0) {
#line 5210
    return (ret);
  } else {

  }
#line 5214
  sprintf((char *)(& rbd_dev->name), "%s%d", (char *)"rbd", rbd_dev->dev_id);
#line 5218
  if (! single_major) {
#line 5219
    ret = register_blkdev(0U, (char const   *)(& rbd_dev->name));
#line 5220
    if (ret < 0) {
#line 5221
      goto err_out_id;
    } else {

    }
#line 5223
    rbd_dev->major = ret;
#line 5224
    rbd_dev->minor = 0;
  } else {
#line 5226
    rbd_dev->major = rbd_major;
#line 5227
    rbd_dev->minor = rbd_dev_id_to_minor(rbd_dev->dev_id);
  }
#line 5232
  ret = rbd_init_disk(rbd_dev);
#line 5233
  if (ret != 0) {
#line 5234
    goto err_out_blkdev;
  } else {

  }
#line 5236
  ret = rbd_dev_mapping_set(rbd_dev);
#line 5237
  if (ret != 0) {
#line 5238
    goto err_out_disk;
  } else {

  }
#line 5240
  set_capacity(rbd_dev->disk, (sector_t )(rbd_dev->mapping.size / 512ULL));
#line 5241
  set_disk_ro(rbd_dev->disk, (int )rbd_dev->mapping.read_only);
#line 5243
  ret = rbd_bus_add_dev(rbd_dev);
#line 5244
  if (ret != 0) {
#line 5245
    goto err_out_mapping;
  } else {

  }
#line 5249
  set_bit(0L, (unsigned long volatile   *)(& rbd_dev->flags));
#line 5250
  add_disk(rbd_dev->disk);
#line 5252
  printk("\016rbd: %s: added with size 0x%llx\n", (char *)(& (rbd_dev->disk)->disk_name),
         rbd_dev->mapping.size);
#line 5255
  return (ret);
  err_out_mapping: 
#line 5258
  rbd_dev_mapping_clear(rbd_dev);
  err_out_disk: 
#line 5260
  rbd_free_disk(rbd_dev);
  err_out_blkdev: ;
#line 5262
  if (! single_major) {
#line 5263
    unregister_blkdev((unsigned int )rbd_dev->major, (char const   *)(& rbd_dev->name));
  } else {

  }
  err_out_id: 
#line 5265
  rbd_dev_id_put(rbd_dev);
#line 5266
  rbd_dev_mapping_clear(rbd_dev);
#line 5268
  return (ret);
}
}
#line 5271 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_header_name(struct rbd_device *rbd_dev ) 
{ 
  struct rbd_spec *spec ;
  size_t size ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
#line 5273
  spec = rbd_dev->spec;
#line 5278
  tmp = rbd_image_format_valid(rbd_dev->image_format);
#line 5278
  if (tmp) {
#line 5278
    tmp___0 = 0;
  } else {
#line 5278
    tmp___0 = 1;
  }
#line 5278
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
#line 5278
  if (tmp___1 != 0L) {
#line 5278
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_dev_header_name",
           5278, (char *)"rbd_image_format_valid(rbd_dev->image_format)");
#line 5278
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (5278), "i" (12UL));
    ldv_39106: ;
#line 5278
    goto ldv_39106;
  } else {

  }
#line 5280
  if (rbd_dev->image_format == 1U) {
#line 5281
    tmp___2 = strlen(spec->image_name);
#line 5281
    size = tmp___2 + 5UL;
  } else {
#line 5283
    tmp___3 = strlen(spec->image_id);
#line 5283
    size = tmp___3 + 12UL;
  }
#line 5285
  tmp___4 = kmalloc(size, 208U);
#line 5285
  rbd_dev->header_name = (char *)tmp___4;
#line 5286
  if ((unsigned long )rbd_dev->header_name == (unsigned long )((char *)0)) {
#line 5287
    return (-12);
  } else {

  }
#line 5289
  if (rbd_dev->image_format == 1U) {
#line 5290
    sprintf(rbd_dev->header_name, "%s%s", spec->image_name, (char *)".rbd");
  } else {
#line 5293
    sprintf(rbd_dev->header_name, "%s%s", (char *)"rbd_header.", spec->image_id);
  }
#line 5295
  return (0);
}
}
#line 5298 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_dev_image_release(struct rbd_device *rbd_dev ) 
{ 


  {
#line 5300
  rbd_dev_unprobe(rbd_dev);
#line 5301
  kfree((void const   *)rbd_dev->header_name);
#line 5302
  rbd_dev->header_name = (char *)0;
#line 5303
  rbd_dev->image_format = 0U;
#line 5304
  kfree((void const   *)(rbd_dev->spec)->image_id);
#line 5305
  (rbd_dev->spec)->image_id = (char const   *)0;
#line 5307
  rbd_dev_destroy(rbd_dev);
#line 5308
  return;
}
}
#line 5316 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_dev_image_probe(struct rbd_device *rbd_dev , bool mapping ) 
{ 
  int ret ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;

  {
#line 5326
  ret = rbd_dev_image_id(rbd_dev);
#line 5327
  if (ret != 0) {
#line 5328
    return (ret);
  } else {

  }
#line 5330
  ret = rbd_dev_header_name(rbd_dev);
#line 5331
  if (ret != 0) {
#line 5332
    goto err_out_format;
  } else {

  }
#line 5334
  if ((int )mapping) {
#line 5335
    ret = rbd_dev_header_watch_sync(rbd_dev);
#line 5336
    if (ret != 0) {
#line 5337
      if (ret == -2) {
#line 5338
        printk("\016rbd: image %s/%s does not exist\n", (rbd_dev->spec)->pool_name,
               (rbd_dev->spec)->image_name);
      } else {

      }
#line 5341
      goto out_header_name;
    } else {

    }
  } else {

  }
#line 5345
  ret = rbd_dev_header_info(rbd_dev);
#line 5346
  if (ret != 0) {
#line 5347
    goto err_out_watch;
  } else {

  }
#line 5355
  if ((int )mapping) {
#line 5356
    ret = rbd_spec_fill_snap_id(rbd_dev);
  } else {
#line 5358
    ret = rbd_spec_fill_names(rbd_dev);
  }
#line 5359
  if (ret != 0) {
#line 5360
    if (ret == -2) {
#line 5361
      printk("\016rbd: snap %s/%s@%s does not exist\n", (rbd_dev->spec)->pool_name,
             (rbd_dev->spec)->image_name, (rbd_dev->spec)->snap_name);
    } else {

    }
#line 5365
    goto err_out_probe;
  } else {

  }
#line 5368
  if ((int )rbd_dev->header.features & 1) {
#line 5369
    ret = rbd_dev_v2_parent_info(rbd_dev);
#line 5370
    if (ret != 0) {
#line 5371
      goto err_out_probe;
    } else {

    }
#line 5377
    if ((int )mapping && (unsigned long )rbd_dev->parent_spec != (unsigned long )((struct rbd_spec *)0)) {
#line 5378
      rbd_warn(rbd_dev, "WARNING: kernel layering is EXPERIMENTAL!");
    } else {

    }
  } else {

  }
#line 5382
  ret = rbd_dev_probe_parent(rbd_dev);
#line 5383
  if (ret != 0) {
#line 5384
    goto err_out_probe;
  } else {

  }
#line 5386
  descriptor.modname = "rbd";
#line 5386
  descriptor.function = "rbd_dev_image_probe";
#line 5386
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 5386
  descriptor.format = "%.*s %12.12s:%-4d : discovered format %u image, header name is %s\n";
#line 5386
  descriptor.lineno = 5387U;
#line 5386
  descriptor.flags = 0U;
#line 5386
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 5386
  if (tmp___0 != 0L) {
#line 5386
    tmp = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                         199);
#line 5386
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : discovered format %u image, header name is %s\n",
                       4, (char *)"    ", tmp, 5387, rbd_dev->image_format, rbd_dev->header_name);
  } else {

  }
#line 5388
  return (0);
  err_out_probe: 
#line 5391
  rbd_dev_unprobe(rbd_dev);
  err_out_watch: ;
#line 5393
  if ((int )mapping) {
#line 5394
    rbd_dev_header_unwatch_sync(rbd_dev);
  } else {

  }
  out_header_name: 
#line 5396
  kfree((void const   *)rbd_dev->header_name);
#line 5397
  rbd_dev->header_name = (char *)0;
  err_out_format: 
#line 5399
  rbd_dev->image_format = 0U;
#line 5400
  kfree((void const   *)(rbd_dev->spec)->image_id);
#line 5401
  (rbd_dev->spec)->image_id = (char const   *)0;
#line 5402
  return (ret);
}
}
#line 5405 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static ssize_t do_rbd_add(struct bus_type *bus , char const   *buf , size_t count ) 
{ 
  struct rbd_device *rbd_dev ;
  struct ceph_options *ceph_opts ;
  struct rbd_options *rbd_opts ;
  struct rbd_spec *spec ;
  struct rbd_client *rbdc ;
  bool read_only ;
  int rc ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  struct _ddebug descriptor ;
  char const   *tmp___3 ;
  long tmp___4 ;

  {
#line 5409
  rbd_dev = (struct rbd_device *)0;
#line 5410
  ceph_opts = (struct ceph_options *)0;
#line 5411
  rbd_opts = (struct rbd_options *)0;
#line 5412
  spec = (struct rbd_spec *)0;
#line 5415
  rc = -12;
#line 5417
  tmp = try_module_get(& __this_module);
#line 5417
  if (tmp) {
#line 5417
    tmp___0 = 0;
  } else {
#line 5417
    tmp___0 = 1;
  }
#line 5417
  if (tmp___0) {
#line 5418
    return (-19L);
  } else {

  }
#line 5421
  rc = rbd_add_parse_args(buf, & ceph_opts, & rbd_opts, & spec);
#line 5422
  if (rc < 0) {
#line 5423
    goto err_out_module;
  } else {

  }
#line 5425
  rbdc = rbd_get_client(ceph_opts);
#line 5426
  tmp___2 = IS_ERR((void const   *)rbdc);
#line 5426
  if ((int )tmp___2) {
#line 5427
    tmp___1 = PTR_ERR((void const   *)rbdc);
#line 5427
    rc = (int )tmp___1;
#line 5428
    goto err_out_args;
  } else {

  }
#line 5432
  rc = rbd_add_get_pool_id(rbdc, spec->pool_name);
#line 5433
  if (rc < 0) {
#line 5434
    if (rc == -2) {
#line 5435
      printk("\016rbd: pool %s does not exist\n", spec->pool_name);
    } else {

    }
#line 5436
    goto err_out_client;
  } else {

  }
#line 5438
  spec->pool_id = (unsigned long long )rc;
#line 5442
  if (spec->pool_id > 4294967295ULL) {
#line 5443
    rbd_warn((struct rbd_device *)0, "pool id too large (%llu > %u)", spec->pool_id,
             4294967295U);
#line 5445
    rc = -5;
#line 5446
    goto err_out_client;
  } else {

  }
#line 5449
  rbd_dev = rbd_dev_create(rbdc, spec, rbd_opts);
#line 5450
  if ((unsigned long )rbd_dev == (unsigned long )((struct rbd_device *)0)) {
#line 5451
    goto err_out_client;
  } else {

  }
#line 5452
  rbdc = (struct rbd_client *)0;
#line 5453
  spec = (struct rbd_spec *)0;
#line 5454
  rbd_opts = (struct rbd_options *)0;
#line 5456
  rc = rbd_dev_image_probe(rbd_dev, 1);
#line 5457
  if (rc < 0) {
#line 5458
    goto err_out_rbd_dev;
  } else {

  }
#line 5462
  read_only = (rbd_dev->opts)->read_only;
#line 5463
  if ((rbd_dev->spec)->snap_id != 0xfffffffffffffffeULL) {
#line 5464
    read_only = 1;
  } else {

  }
#line 5465
  rbd_dev->mapping.read_only = read_only;
#line 5467
  rc = rbd_dev_device_setup(rbd_dev);
#line 5468
  if (rc != 0) {
#line 5474
    rbd_dev_header_unwatch_sync(rbd_dev);
#line 5475
    rbd_dev_image_release(rbd_dev);
#line 5476
    goto err_out_module;
  } else {

  }
#line 5479
  return ((ssize_t )count);
  err_out_rbd_dev: 
#line 5482
  rbd_dev_destroy(rbd_dev);
  err_out_client: 
#line 5484
  rbd_put_client(rbdc);
  err_out_args: 
#line 5486
  rbd_spec_put(spec);
#line 5487
  kfree((void const   *)rbd_opts);
  err_out_module: 
#line 5489
  module_put(& __this_module);
#line 5491
  descriptor.modname = "rbd";
#line 5491
  descriptor.function = "do_rbd_add";
#line 5491
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 5491
  descriptor.format = "%.*s %12.12s:%-4d : Error adding device %s\n";
#line 5491
  descriptor.lineno = 5491U;
#line 5491
  descriptor.flags = 0U;
#line 5491
  tmp___4 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 5491
  if (tmp___4 != 0L) {
#line 5491
    tmp___3 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 5491
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : Error adding device %s\n",
                       4, (char *)"    ", tmp___3, 5491, buf);
  } else {

  }
#line 5493
  return ((ssize_t )rc);
}
}
#line 5496 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static ssize_t rbd_add(struct bus_type *bus , char const   *buf , size_t count ) 
{ 
  ssize_t tmp ;

  {
#line 5500
  if ((int )single_major) {
#line 5501
    return (-22L);
  } else {

  }
#line 5503
  tmp = do_rbd_add(bus, buf, count);
#line 5503
  return (tmp);
}
}
#line 5506 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static ssize_t rbd_add_single_major(struct bus_type *bus , char const   *buf , size_t count ) 
{ 
  ssize_t tmp ;

  {
#line 5510
  tmp = do_rbd_add(bus, buf, count);
#line 5510
  return (tmp);
}
}
#line 5513 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_dev_device_release(struct device *dev ) 
{ 
  struct rbd_device *rbd_dev ;
  struct rbd_device *tmp ;

  {
#line 5515
  tmp = dev_to_rbd_dev(dev);
#line 5515
  rbd_dev = tmp;
#line 5517
  rbd_free_disk(rbd_dev);
#line 5518
  clear_bit(0L, (unsigned long volatile   *)(& rbd_dev->flags));
#line 5519
  rbd_dev_mapping_clear(rbd_dev);
#line 5520
  if (! single_major) {
#line 5521
    unregister_blkdev((unsigned int )rbd_dev->major, (char const   *)(& rbd_dev->name));
  } else {

  }
#line 5522
  rbd_dev_id_put(rbd_dev);
#line 5523
  rbd_dev_mapping_clear(rbd_dev);
#line 5524
  return;
}
}
#line 5526 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_dev_remove_parent(struct rbd_device *rbd_dev ) 
{ 
  struct rbd_device *first ;
  struct rbd_device *second ;
  struct rbd_device *third ;
  long tmp ;
  long tmp___0 ;

  {
#line 5528
  goto ldv_39166;
  ldv_39165: 
#line 5529
  first = rbd_dev;
#line 5530
  second = first->parent;
#line 5537
  goto ldv_39160;
  ldv_39159: 
#line 5538
  first = second;
#line 5539
  second = third;
  ldv_39160: ;
#line 5537
  if ((unsigned long )second != (unsigned long )((struct rbd_device *)0)) {
#line 5537
    third = second->parent;
#line 5537
    if ((unsigned long )third != (unsigned long )((struct rbd_device *)0)) {
#line 5539
      goto ldv_39159;
    } else {
#line 5542
      goto ldv_39161;
    }
  } else {

  }
  ldv_39161: 
#line 5541
  tmp = ldv__builtin_expect((unsigned long )second == (unsigned long )((struct rbd_device *)0),
                         0L);
#line 5541
  if (tmp != 0L) {
#line 5541
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_dev_remove_parent",
           5541, (char *)"second");
#line 5541
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (5541), "i" (12UL));
    ldv_39163: ;
#line 5541
    goto ldv_39163;
  } else {

  }
#line 5542
  rbd_dev_image_release(second);
#line 5543
  first->parent = (struct rbd_device *)0;
#line 5544
  first->parent_overlap = 0ULL;
#line 5546
  tmp___0 = ldv__builtin_expect((unsigned long )first->parent_spec == (unsigned long )((struct rbd_spec *)0),
                             0L);
#line 5546
  if (tmp___0 != 0L) {
#line 5546
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_dev_remove_parent",
           5546, (char *)"first->parent_spec");
#line 5546
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (5546), "i" (12UL));
    ldv_39164: ;
#line 5546
    goto ldv_39164;
  } else {

  }
#line 5547
  rbd_spec_put(first->parent_spec);
#line 5548
  first->parent_spec = (struct rbd_spec *)0;
  ldv_39166: ;
#line 5528
  if ((unsigned long )rbd_dev->parent != (unsigned long )((struct rbd_device *)0)) {
#line 5530
    goto ldv_39165;
  } else {

  }

#line 5535
  return;
}
}
#line 5552 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static ssize_t do_rbd_remove(struct bus_type *bus , char const   *buf , size_t count ) 
{ 
  struct rbd_device *rbd_dev ;
  struct list_head *tmp ;
  int dev_id ;
  unsigned long ul ;
  bool already ;
  int ret ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  struct _ddebug descriptor ;
  char const   *tmp___1 ;
  long tmp___2 ;

  {
#line 5556
  rbd_dev = (struct rbd_device *)0;
#line 5560
  already = 0;
#line 5563
  ret = kstrtoul(buf, 10U, & ul);
#line 5564
  if (ret != 0) {
#line 5565
    return ((ssize_t )ret);
  } else {

  }
#line 5568
  dev_id = (int )ul;
#line 5569
  if ((unsigned long )dev_id != ul) {
#line 5570
    return (-22L);
  } else {

  }
#line 5572
  ret = -2;
#line 5573
  spin_lock(& rbd_dev_list_lock);
#line 5574
  tmp = rbd_dev_list.next;
#line 5574
  goto ldv_39183;
  ldv_39182: 
#line 5575
  __mptr = (struct list_head  const  *)tmp;
#line 5575
  rbd_dev = (struct rbd_device *)__mptr + 0xfffffffffffffd18UL;
#line 5576
  if (rbd_dev->dev_id == dev_id) {
#line 5577
    ret = 0;
#line 5578
    goto ldv_39181;
  } else {

  }
#line 5574
  tmp = tmp->next;
  ldv_39183: ;
#line 5574
  if ((unsigned long )tmp != (unsigned long )(& rbd_dev_list)) {
#line 5576
    goto ldv_39182;
  } else {

  }
  ldv_39181: ;
#line 5581
  if (ret == 0) {
#line 5582
    spin_lock_irq(& rbd_dev->lock);
#line 5583
    if (rbd_dev->open_count != 0UL) {
#line 5584
      ret = -16;
    } else {
#line 5586
      tmp___0 = test_and_set_bit(1L, (unsigned long volatile   *)(& rbd_dev->flags));
#line 5586
      already = tmp___0 != 0;
    }
#line 5588
    spin_unlock_irq(& rbd_dev->lock);
  } else {

  }
#line 5590
  spin_unlock(& rbd_dev_list_lock);
#line 5591
  if (ret < 0 || (int )already) {
#line 5592
    return ((ssize_t )ret);
  } else {

  }
#line 5594
  rbd_dev_header_unwatch_sync(rbd_dev);
#line 5599
  descriptor.modname = "rbd";
#line 5599
  descriptor.function = "do_rbd_remove";
#line 5599
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c";
#line 5599
  descriptor.format = "%.*s %12.12s:%-4d : %s: flushing notifies";
#line 5599
  descriptor.lineno = 5599U;
#line 5599
  descriptor.flags = 0U;
#line 5599
  tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
#line 5599
  if (tmp___2 != 0L) {
#line 5599
    tmp___1 = ceph_file_part("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c",
                             199);
#line 5599
    __dynamic_pr_debug(& descriptor, "rbd: %.*s %12.12s:%-4d : %s: flushing notifies",
                       4, (char *)"    ", tmp___1, 5599, "do_rbd_remove");
  } else {

  }
#line 5600
  ceph_osdc_flush_notifies(& ((rbd_dev->rbd_client)->client)->osdc);
#line 5608
  rbd_bus_del_dev(rbd_dev);
#line 5609
  rbd_dev_image_release(rbd_dev);
#line 5610
  module_put(& __this_module);
#line 5612
  return ((ssize_t )count);
}
}
#line 5615 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static ssize_t rbd_remove(struct bus_type *bus , char const   *buf , size_t count ) 
{ 
  ssize_t tmp ;

  {
#line 5619
  if ((int )single_major) {
#line 5620
    return (-22L);
  } else {

  }
#line 5622
  tmp = do_rbd_remove(bus, buf, count);
#line 5622
  return (tmp);
}
}
#line 5625 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static ssize_t rbd_remove_single_major(struct bus_type *bus , char const   *buf ,
                                       size_t count ) 
{ 
  ssize_t tmp ;

  {
#line 5629
  tmp = do_rbd_remove(bus, buf, count);
#line 5629
  return (tmp);
}
}
#line 5636 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_sysfs_init(void) 
{ 
  int ret ;

  {
#line 5640
  ret = device_register(& rbd_root_dev);
#line 5641
  if (ret < 0) {
#line 5642
    return (ret);
  } else {

  }
#line 5644
  ret = bus_register(& rbd_bus_type);
#line 5645
  if (ret < 0) {
#line 5646
    device_unregister(& rbd_root_dev);
  } else {

  }
#line 5648
  return (ret);
}
}
#line 5651 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_sysfs_cleanup(void) 
{ 


  {
#line 5653
  bus_unregister(& rbd_bus_type);
#line 5654
  device_unregister(& rbd_root_dev);
#line 5655
  return;
}
}
#line 5657 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_slab_init(void) 
{ 
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 5659
  tmp = ldv__builtin_expect((unsigned long )rbd_img_request_cache != (unsigned long )((struct kmem_cache *)0),
                         0L);
#line 5659
  if (tmp != 0L) {
#line 5659
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_slab_init",
           5659, (char *)"!rbd_img_request_cache");
#line 5659
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (5659), "i" (12UL));
    ldv_39207: ;
#line 5659
    goto ldv_39207;
  } else {

  }
#line 5660
  rbd_img_request_cache = kmem_cache_create("rbd_img_request", 192UL, 8UL, 0UL, (void (*)(void * ))0);
#line 5664
  if ((unsigned long )rbd_img_request_cache == (unsigned long )((struct kmem_cache *)0)) {
#line 5665
    return (-12);
  } else {

  }
#line 5667
  tmp___0 = ldv__builtin_expect((unsigned long )rbd_obj_request_cache != (unsigned long )((struct kmem_cache *)0),
                             0L);
#line 5667
  if (tmp___0 != 0L) {
#line 5667
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_slab_init",
           5667, (char *)"!rbd_obj_request_cache");
#line 5667
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (5667), "i" (12UL));
    ldv_39208: ;
#line 5667
    goto ldv_39208;
  } else {

  }
#line 5668
  rbd_obj_request_cache = kmem_cache_create("rbd_obj_request", 240UL, 8UL, 0UL, (void (*)(void * ))0);
#line 5672
  if ((unsigned long )rbd_obj_request_cache == (unsigned long )((struct kmem_cache *)0)) {
#line 5673
    goto out_err;
  } else {

  }
#line 5675
  tmp___1 = ldv__builtin_expect((unsigned long )rbd_segment_name_cache != (unsigned long )((struct kmem_cache *)0),
                             0L);
#line 5675
  if (tmp___1 != 0L) {
#line 5675
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_slab_init",
           5675, (char *)"!rbd_segment_name_cache");
#line 5675
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (5675), "i" (12UL));
    ldv_39210: ;
#line 5675
    goto ldv_39210;
  } else {

  }
#line 5676
  rbd_segment_name_cache = kmem_cache_create("rbd_segment_name", 101UL, 1UL, 0UL,
                                             (void (*)(void * ))0);
#line 5678
  if ((unsigned long )rbd_segment_name_cache != (unsigned long )((struct kmem_cache *)0)) {
#line 5679
    return (0);
  } else {

  }
  out_err: ;
#line 5681
  if ((unsigned long )rbd_obj_request_cache != (unsigned long )((struct kmem_cache *)0)) {
#line 5682
    kmem_cache_destroy(rbd_obj_request_cache);
#line 5683
    rbd_obj_request_cache = (struct kmem_cache *)0;
  } else {

  }
#line 5686
  kmem_cache_destroy(rbd_img_request_cache);
#line 5687
  rbd_img_request_cache = (struct kmem_cache *)0;
#line 5689
  return (-12);
}
}
#line 5692 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_slab_exit(void) 
{ 
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 5694
  tmp = ldv__builtin_expect((unsigned long )rbd_segment_name_cache == (unsigned long )((struct kmem_cache *)0),
                         0L);
#line 5694
  if (tmp != 0L) {
#line 5694
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_slab_exit",
           5694, (char *)"rbd_segment_name_cache");
#line 5694
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (5694), "i" (12UL));
    ldv_39215: ;
#line 5694
    goto ldv_39215;
  } else {

  }
#line 5695
  kmem_cache_destroy(rbd_segment_name_cache);
#line 5696
  rbd_segment_name_cache = (struct kmem_cache *)0;
#line 5698
  tmp___0 = ldv__builtin_expect((unsigned long )rbd_obj_request_cache == (unsigned long )((struct kmem_cache *)0),
                             0L);
#line 5698
  if (tmp___0 != 0L) {
#line 5698
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_slab_exit",
           5698, (char *)"rbd_obj_request_cache");
#line 5698
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (5698), "i" (12UL));
    ldv_39216: ;
#line 5698
    goto ldv_39216;
  } else {

  }
#line 5699
  kmem_cache_destroy(rbd_obj_request_cache);
#line 5700
  rbd_obj_request_cache = (struct kmem_cache *)0;
#line 5702
  tmp___1 = ldv__builtin_expect((unsigned long )rbd_img_request_cache == (unsigned long )((struct kmem_cache *)0),
                             0L);
#line 5702
  if (tmp___1 != 0L) {
#line 5702
    printk("\v\nAssertion failure in %s() at line %d:\n\n\trbd_assert(%s);\n\n", "rbd_slab_exit",
           5702, (char *)"rbd_img_request_cache");
#line 5702
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"),
                         "i" (5702), "i" (12UL));
    ldv_39217: ;
#line 5702
    goto ldv_39217;
  } else {

  }
#line 5703
  kmem_cache_destroy(rbd_img_request_cache);
#line 5704
  rbd_img_request_cache = (struct kmem_cache *)0;
#line 5705
  return;
}
}
#line 5707 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static int rbd_init(void) 
{ 
  int rc ;
  bool tmp ;
  int tmp___0 ;
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp___1 ;

  {
#line 5711
  tmp = libceph_compatible((void *)0);
#line 5711
  if (tmp) {
#line 5711
    tmp___0 = 0;
  } else {
#line 5711
    tmp___0 = 1;
  }
#line 5711
  if (tmp___0) {
#line 5712
    rbd_warn((struct rbd_device *)0, "libceph incompatibility (quitting)");
#line 5713
    return (-22);
  } else {

  }
#line 5716
  rc = rbd_slab_init();
#line 5717
  if (rc != 0) {
#line 5718
    return (rc);
  } else {

  }
#line 5724
  __lock_name = "RBD_DRV_NAME";
#line 5724
  tmp___1 = __alloc_workqueue_key("rbd", 8U, 0, & __key, __lock_name);
#line 5724
  rbd_wq = tmp___1;
#line 5725
  if ((unsigned long )rbd_wq == (unsigned long )((struct workqueue_struct *)0)) {
#line 5726
    rc = -12;
#line 5727
    goto err_out_slab;
  } else {

  }
#line 5730
  if ((int )single_major) {
#line 5731
    rbd_major = register_blkdev(0U, "rbd");
#line 5732
    if (rbd_major < 0) {
#line 5733
      rc = rbd_major;
#line 5734
      goto err_out_wq;
    } else {

    }
  } else {

  }
#line 5738
  rc = rbd_sysfs_init();
#line 5739
  if (rc != 0) {
#line 5740
    goto err_out_blkdev;
  } else {

  }
#line 5742
  if ((int )single_major) {
#line 5743
    printk("\016rbd: loaded (major %d)\n", rbd_major);
  } else {
#line 5745
    printk("\016rbd: loaded\n");
  }
#line 5747
  return (0);
  err_out_blkdev: ;
#line 5750
  if ((int )single_major) {
#line 5751
    unregister_blkdev((unsigned int )rbd_major, "rbd");
  } else {

  }
  err_out_wq: 
#line 5753
  ldv_destroy_workqueue_19(rbd_wq);
  err_out_slab: 
#line 5755
  rbd_slab_exit();
#line 5756
  return (rc);
}
}
#line 5759 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.c"
static void rbd_exit(void) 
{ 


  {
#line 5761
  ida_destroy(& rbd_dev_id_ida);
#line 5762
  rbd_sysfs_cleanup();
#line 5763
  if ((int )single_major) {
#line 5764
    unregister_blkdev((unsigned int )rbd_major, "rbd");
  } else {

  }
#line 5765
  ldv_destroy_workqueue_20(rbd_wq);
#line 5766
  rbd_slab_exit();
#line 5767
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_retval_0  ;
#line 121 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_retval_1  ;
#line 122
extern void ldv_initialize(void) ;
#line 123
extern int ldv_probe_17(void) ;
#line 124
void ldv_check_final_state(void) ;
#line 125
extern int ldv_probe_2(void) ;
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void ldv_initialize_block_device_operations_16(void) 
{ 
  void *tmp ;

  {
#line 129
  tmp = ldv_init_zalloc(480UL);
#line 129
  rbd_bd_ops_group0 = (struct block_device *)tmp;
#line 130
  return;
}
}
#line 132 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void call_and_disable_work_1(struct work_struct *work ) 
{ 


  {
#line 135
  if ((ldv_work_1_0 == 2 || ldv_work_1_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_0) {
#line 137
    rbd_queue_workfn(work);
#line 138
    ldv_work_1_0 = 1;
#line 139
    return;
  } else {

  }
#line 141
  if ((ldv_work_1_1 == 2 || ldv_work_1_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_1) {
#line 143
    rbd_queue_workfn(work);
#line 144
    ldv_work_1_1 = 1;
#line 145
    return;
  } else {

  }
#line 147
  if ((ldv_work_1_2 == 2 || ldv_work_1_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_2) {
#line 149
    rbd_queue_workfn(work);
#line 150
    ldv_work_1_2 = 1;
#line 151
    return;
  } else {

  }
#line 153
  if ((ldv_work_1_3 == 2 || ldv_work_1_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_3) {
#line 155
    rbd_queue_workfn(work);
#line 156
    ldv_work_1_3 = 1;
#line 157
    return;
  } else {

  }
#line 159
  return;
}
}
#line 162 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void disable_work_1(struct work_struct *work ) 
{ 


  {
#line 164
  if ((ldv_work_1_0 == 3 || ldv_work_1_0 == 2) && (unsigned long )ldv_work_struct_1_0 == (unsigned long )work) {
#line 166
    ldv_work_1_0 = 1;
  } else {

  }
#line 168
  if ((ldv_work_1_1 == 3 || ldv_work_1_1 == 2) && (unsigned long )ldv_work_struct_1_1 == (unsigned long )work) {
#line 170
    ldv_work_1_1 = 1;
  } else {

  }
#line 172
  if ((ldv_work_1_2 == 3 || ldv_work_1_2 == 2) && (unsigned long )ldv_work_struct_1_2 == (unsigned long )work) {
#line 174
    ldv_work_1_2 = 1;
  } else {

  }
#line 176
  if ((ldv_work_1_3 == 3 || ldv_work_1_3 == 2) && (unsigned long )ldv_work_struct_1_3 == (unsigned long )work) {
#line 178
    ldv_work_1_3 = 1;
  } else {

  }
#line 179
  return;
}
}
#line 183 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void work_init_1(void) 
{ 


  {
#line 184
  ldv_work_1_0 = 0;
#line 185
  ldv_work_1_1 = 0;
#line 186
  ldv_work_1_2 = 0;
#line 187
  ldv_work_1_3 = 0;
#line 188
  return;
}
}
#line 191 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void call_and_disable_all_1(int state ) 
{ 


  {
#line 193
  if (ldv_work_1_0 == state) {
#line 194
    call_and_disable_work_1(ldv_work_struct_1_0);
  } else {

  }
#line 195
  if (ldv_work_1_1 == state) {
#line 196
    call_and_disable_work_1(ldv_work_struct_1_1);
  } else {

  }
#line 197
  if (ldv_work_1_2 == state) {
#line 198
    call_and_disable_work_1(ldv_work_struct_1_2);
  } else {

  }
#line 199
  if (ldv_work_1_3 == state) {
#line 200
    call_and_disable_work_1(ldv_work_struct_1_3);
  } else {

  }
#line 201
  return;
}
}
#line 204 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void invoke_work_1(void) 
{ 
  int tmp ;

  {
#line 206
  tmp = __VERIFIER_nondet_int();
#line 206
  switch (tmp) {
  case 0: ;
#line 208
  if (ldv_work_1_0 == 2 || ldv_work_1_0 == 3) {
#line 209
    ldv_work_1_0 = 4;
#line 210
    rbd_queue_workfn(ldv_work_struct_1_0);
#line 211
    ldv_work_1_0 = 1;
  } else {

  }
#line 214
  goto ldv_39280;
  case 1: ;
#line 216
  if (ldv_work_1_1 == 2 || ldv_work_1_1 == 3) {
#line 217
    ldv_work_1_1 = 4;
#line 218
    rbd_queue_workfn(ldv_work_struct_1_0);
#line 219
    ldv_work_1_1 = 1;
  } else {

  }
#line 222
  goto ldv_39280;
  case 2: ;
#line 224
  if (ldv_work_1_2 == 2 || ldv_work_1_2 == 3) {
#line 225
    ldv_work_1_2 = 4;
#line 226
    rbd_queue_workfn(ldv_work_struct_1_0);
#line 227
    ldv_work_1_2 = 1;
  } else {

  }
#line 230
  goto ldv_39280;
  case 3: ;
#line 232
  if (ldv_work_1_3 == 2 || ldv_work_1_3 == 3) {
#line 233
    ldv_work_1_3 = 4;
#line 234
    rbd_queue_workfn(ldv_work_struct_1_0);
#line 235
    ldv_work_1_3 = 1;
  } else {

  }
#line 238
  goto ldv_39280;
  default: 
#line 239
  ldv_stop();
  }
  ldv_39280: ;
#line 241
  return;
}
}
#line 246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void activate_work_1(struct work_struct *work , int state ) 
{ 


  {
#line 247
  if (ldv_work_1_0 == 0) {
#line 248
    ldv_work_struct_1_0 = work;
#line 249
    ldv_work_1_0 = state;
#line 250
    return;
  } else {

  }
#line 253
  if (ldv_work_1_1 == 0) {
#line 254
    ldv_work_struct_1_1 = work;
#line 255
    ldv_work_1_1 = state;
#line 256
    return;
  } else {

  }
#line 259
  if (ldv_work_1_2 == 0) {
#line 260
    ldv_work_struct_1_2 = work;
#line 261
    ldv_work_1_2 = state;
#line 262
    return;
  } else {

  }
#line 265
  if (ldv_work_1_3 == 0) {
#line 266
    ldv_work_struct_1_3 = work;
#line 267
    ldv_work_1_3 = state;
#line 268
    return;
  } else {

  }
#line 270
  return;
}
}
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void main(void) 
{ 
  char *ldvarg1 ;
  void *tmp ;
  struct device *ldvarg0 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg2 ;
  void *tmp___1 ;
  size_t ldvarg4 ;
  struct bus_type *ldvarg3 ;
  void *tmp___2 ;
  char *ldvarg5 ;
  void *tmp___3 ;
  struct device_attribute *ldvarg8 ;
  void *tmp___4 ;
  char *ldvarg7 ;
  void *tmp___5 ;
  struct device *ldvarg6 ;
  void *tmp___6 ;
  struct device *ldvarg9 ;
  void *tmp___7 ;
  struct device *ldvarg10 ;
  void *tmp___8 ;
  struct bus_type *ldvarg11 ;
  void *tmp___9 ;
  char *ldvarg13 ;
  void *tmp___10 ;
  size_t ldvarg12 ;
  struct kobject *ldvarg14 ;
  void *tmp___11 ;
  struct attribute *ldvarg16 ;
  void *tmp___12 ;
  int ldvarg15 ;
  struct gendisk *ldvarg24 ;
  void *tmp___13 ;
  unsigned long ldvarg18 ;
  fmode_t ldvarg20 ;
  fmode_t ldvarg23 ;
  unsigned long ldvarg21 ;
  fmode_t ldvarg25 ;
  fmode_t ldvarg17 ;
  unsigned int ldvarg22 ;
  unsigned int ldvarg19 ;
  char *ldvarg27 ;
  void *tmp___14 ;
  struct device *ldvarg26 ;
  void *tmp___15 ;
  struct device_attribute *ldvarg28 ;
  void *tmp___16 ;
  struct device_attribute *ldvarg31 ;
  void *tmp___17 ;
  struct device *ldvarg29 ;
  void *tmp___18 ;
  char *ldvarg30 ;
  void *tmp___19 ;
  struct device *ldvarg32 ;
  void *tmp___20 ;
  struct device_attribute *ldvarg34 ;
  void *tmp___21 ;
  char *ldvarg33 ;
  void *tmp___22 ;
  struct device_attribute *ldvarg37 ;
  void *tmp___23 ;
  struct device *ldvarg35 ;
  void *tmp___24 ;
  char *ldvarg36 ;
  void *tmp___25 ;
  char *ldvarg39 ;
  void *tmp___26 ;
  struct device_attribute *ldvarg40 ;
  void *tmp___27 ;
  struct device *ldvarg38 ;
  void *tmp___28 ;
  struct bus_type *ldvarg41 ;
  void *tmp___29 ;
  char *ldvarg43 ;
  void *tmp___30 ;
  size_t ldvarg42 ;
  char *ldvarg45 ;
  void *tmp___31 ;
  struct device *ldvarg44 ;
  void *tmp___32 ;
  struct device_attribute *ldvarg46 ;
  void *tmp___33 ;
  unsigned int ldvarg51 ;
  struct request_queue *ldvarg49 ;
  void *tmp___34 ;
  int ldvarg50 ;
  struct blk_mq_queue_data *ldvarg48 ;
  void *tmp___35 ;
  struct request *ldvarg54 ;
  void *tmp___36 ;
  unsigned int ldvarg53 ;
  unsigned int ldvarg55 ;
  void *ldvarg52 ;
  void *tmp___37 ;
  struct blk_mq_hw_ctx *ldvarg47 ;
  void *tmp___38 ;
  char *ldvarg57 ;
  void *tmp___39 ;
  struct device_attribute *ldvarg58 ;
  void *tmp___40 ;
  struct device *ldvarg56 ;
  void *tmp___41 ;
  struct device_attribute *ldvarg61 ;
  void *tmp___42 ;
  char *ldvarg60 ;
  void *tmp___43 ;
  struct device *ldvarg59 ;
  void *tmp___44 ;
  size_t ldvarg63 ;
  char *ldvarg64 ;
  void *tmp___45 ;
  struct bus_type *ldvarg62 ;
  void *tmp___46 ;
  struct device *ldvarg65 ;
  void *tmp___47 ;
  struct device_attribute *ldvarg67 ;
  void *tmp___48 ;
  char *ldvarg66 ;
  void *tmp___49 ;
  char *ldvarg70 ;
  void *tmp___50 ;
  struct device_attribute *ldvarg71 ;
  void *tmp___51 ;
  size_t ldvarg68 ;
  struct device *ldvarg69 ;
  void *tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;

  {
#line 302
  tmp = ldv_init_zalloc(1UL);
#line 302
  ldvarg1 = (char *)tmp;
#line 303
  tmp___0 = ldv_init_zalloc(1416UL);
#line 303
  ldvarg0 = (struct device *)tmp___0;
#line 304
  tmp___1 = ldv_init_zalloc(48UL);
#line 304
  ldvarg2 = (struct device_attribute *)tmp___1;
#line 306
  tmp___2 = ldv_init_zalloc(160UL);
#line 306
  ldvarg3 = (struct bus_type *)tmp___2;
#line 307
  tmp___3 = ldv_init_zalloc(1UL);
#line 307
  ldvarg5 = (char *)tmp___3;
#line 308
  tmp___4 = ldv_init_zalloc(48UL);
#line 308
  ldvarg8 = (struct device_attribute *)tmp___4;
#line 309
  tmp___5 = ldv_init_zalloc(1UL);
#line 309
  ldvarg7 = (char *)tmp___5;
#line 310
  tmp___6 = ldv_init_zalloc(1416UL);
#line 310
  ldvarg6 = (struct device *)tmp___6;
#line 311
  tmp___7 = ldv_init_zalloc(1416UL);
#line 311
  ldvarg9 = (struct device *)tmp___7;
#line 312
  tmp___8 = ldv_init_zalloc(1416UL);
#line 312
  ldvarg10 = (struct device *)tmp___8;
#line 313
  tmp___9 = ldv_init_zalloc(160UL);
#line 313
  ldvarg11 = (struct bus_type *)tmp___9;
#line 314
  tmp___10 = ldv_init_zalloc(1UL);
#line 314
  ldvarg13 = (char *)tmp___10;
#line 316
  tmp___11 = ldv_init_zalloc(296UL);
#line 316
  ldvarg14 = (struct kobject *)tmp___11;
#line 317
  tmp___12 = ldv_init_zalloc(32UL);
#line 317
  ldvarg16 = (struct attribute *)tmp___12;
#line 319
  tmp___13 = ldv_init_zalloc(1744UL);
#line 319
  ldvarg24 = (struct gendisk *)tmp___13;
#line 328
  tmp___14 = ldv_init_zalloc(1UL);
#line 328
  ldvarg27 = (char *)tmp___14;
#line 329
  tmp___15 = ldv_init_zalloc(1416UL);
#line 329
  ldvarg26 = (struct device *)tmp___15;
#line 330
  tmp___16 = ldv_init_zalloc(48UL);
#line 330
  ldvarg28 = (struct device_attribute *)tmp___16;
#line 331
  tmp___17 = ldv_init_zalloc(48UL);
#line 331
  ldvarg31 = (struct device_attribute *)tmp___17;
#line 332
  tmp___18 = ldv_init_zalloc(1416UL);
#line 332
  ldvarg29 = (struct device *)tmp___18;
#line 333
  tmp___19 = ldv_init_zalloc(1UL);
#line 333
  ldvarg30 = (char *)tmp___19;
#line 334
  tmp___20 = ldv_init_zalloc(1416UL);
#line 334
  ldvarg32 = (struct device *)tmp___20;
#line 335
  tmp___21 = ldv_init_zalloc(48UL);
#line 335
  ldvarg34 = (struct device_attribute *)tmp___21;
#line 336
  tmp___22 = ldv_init_zalloc(1UL);
#line 336
  ldvarg33 = (char *)tmp___22;
#line 337
  tmp___23 = ldv_init_zalloc(48UL);
#line 337
  ldvarg37 = (struct device_attribute *)tmp___23;
#line 338
  tmp___24 = ldv_init_zalloc(1416UL);
#line 338
  ldvarg35 = (struct device *)tmp___24;
#line 339
  tmp___25 = ldv_init_zalloc(1UL);
#line 339
  ldvarg36 = (char *)tmp___25;
#line 340
  tmp___26 = ldv_init_zalloc(1UL);
#line 340
  ldvarg39 = (char *)tmp___26;
#line 341
  tmp___27 = ldv_init_zalloc(48UL);
#line 341
  ldvarg40 = (struct device_attribute *)tmp___27;
#line 342
  tmp___28 = ldv_init_zalloc(1416UL);
#line 342
  ldvarg38 = (struct device *)tmp___28;
#line 343
  tmp___29 = ldv_init_zalloc(160UL);
#line 343
  ldvarg41 = (struct bus_type *)tmp___29;
#line 344
  tmp___30 = ldv_init_zalloc(1UL);
#line 344
  ldvarg43 = (char *)tmp___30;
#line 346
  tmp___31 = ldv_init_zalloc(1UL);
#line 346
  ldvarg45 = (char *)tmp___31;
#line 347
  tmp___32 = ldv_init_zalloc(1416UL);
#line 347
  ldvarg44 = (struct device *)tmp___32;
#line 348
  tmp___33 = ldv_init_zalloc(48UL);
#line 348
  ldvarg46 = (struct device_attribute *)tmp___33;
#line 350
  tmp___34 = ldv_init_zalloc(4208UL);
#line 350
  ldvarg49 = (struct request_queue *)tmp___34;
#line 352
  tmp___35 = ldv_init_zalloc(24UL);
#line 352
  ldvarg48 = (struct blk_mq_queue_data *)tmp___35;
#line 353
  tmp___36 = ldv_init_zalloc(368UL);
#line 353
  ldvarg54 = (struct request *)tmp___36;
#line 356
  tmp___37 = ldv_init_zalloc(1UL);
#line 356
  ldvarg52 = tmp___37;
#line 357
  tmp___38 = ldv_init_zalloc(1152UL);
#line 357
  ldvarg47 = (struct blk_mq_hw_ctx *)tmp___38;
#line 358
  tmp___39 = ldv_init_zalloc(1UL);
#line 358
  ldvarg57 = (char *)tmp___39;
#line 359
  tmp___40 = ldv_init_zalloc(48UL);
#line 359
  ldvarg58 = (struct device_attribute *)tmp___40;
#line 360
  tmp___41 = ldv_init_zalloc(1416UL);
#line 360
  ldvarg56 = (struct device *)tmp___41;
#line 361
  tmp___42 = ldv_init_zalloc(48UL);
#line 361
  ldvarg61 = (struct device_attribute *)tmp___42;
#line 362
  tmp___43 = ldv_init_zalloc(1UL);
#line 362
  ldvarg60 = (char *)tmp___43;
#line 363
  tmp___44 = ldv_init_zalloc(1416UL);
#line 363
  ldvarg59 = (struct device *)tmp___44;
#line 365
  tmp___45 = ldv_init_zalloc(1UL);
#line 365
  ldvarg64 = (char *)tmp___45;
#line 366
  tmp___46 = ldv_init_zalloc(160UL);
#line 366
  ldvarg62 = (struct bus_type *)tmp___46;
#line 367
  tmp___47 = ldv_init_zalloc(1416UL);
#line 367
  ldvarg65 = (struct device *)tmp___47;
#line 368
  tmp___48 = ldv_init_zalloc(48UL);
#line 368
  ldvarg67 = (struct device_attribute *)tmp___48;
#line 369
  tmp___49 = ldv_init_zalloc(1UL);
#line 369
  ldvarg66 = (char *)tmp___49;
#line 370
  tmp___50 = ldv_init_zalloc(1UL);
#line 370
  ldvarg70 = (char *)tmp___50;
#line 371
  tmp___51 = ldv_init_zalloc(48UL);
#line 371
  ldvarg71 = (struct device_attribute *)tmp___51;
#line 373
  tmp___52 = ldv_init_zalloc(1416UL);
#line 373
  ldvarg69 = (struct device *)tmp___52;
#line 300
  ldv_initialize();
#line 305
  ldv_memset((void *)(& ldvarg4), 0, 8UL);
#line 315
  ldv_memset((void *)(& ldvarg12), 0, 8UL);
#line 318
  ldv_memset((void *)(& ldvarg15), 0, 4UL);
#line 320
  ldv_memset((void *)(& ldvarg18), 0, 8UL);
#line 321
  ldv_memset((void *)(& ldvarg20), 0, 4UL);
#line 322
  ldv_memset((void *)(& ldvarg23), 0, 4UL);
#line 323
  ldv_memset((void *)(& ldvarg21), 0, 8UL);
#line 324
  ldv_memset((void *)(& ldvarg25), 0, 4UL);
#line 325
  ldv_memset((void *)(& ldvarg17), 0, 4UL);
#line 326
  ldv_memset((void *)(& ldvarg22), 0, 4UL);
#line 327
  ldv_memset((void *)(& ldvarg19), 0, 4UL);
#line 345
  ldv_memset((void *)(& ldvarg42), 0, 8UL);
#line 349
  ldv_memset((void *)(& ldvarg51), 0, 4UL);
#line 351
  ldv_memset((void *)(& ldvarg50), 0, 4UL);
#line 354
  ldv_memset((void *)(& ldvarg53), 0, 4UL);
#line 355
  ldv_memset((void *)(& ldvarg55), 0, 4UL);
#line 364
  ldv_memset((void *)(& ldvarg63), 0, 8UL);
#line 372
  ldv_memset((void *)(& ldvarg68), 0, 8UL);
#line 375
  ldv_state_variable_11 = 0;
#line 376
  ldv_state_variable_21 = 0;
#line 377
  ldv_state_variable_7 = 0;
#line 378
  ldv_state_variable_17 = 0;
#line 379
  ldv_state_variable_2 = 0;
#line 380
  ldv_state_variable_22 = 0;
#line 382
  work_init_1();
#line 384
  ldv_state_variable_1 = 1;
#line 385
  ldv_state_variable_18 = 0;
#line 386
  ref_cnt = 0;
#line 387
  ldv_state_variable_0 = 1;
#line 388
  ldv_state_variable_16 = 0;
#line 389
  ldv_state_variable_13 = 0;
#line 390
  ldv_state_variable_6 = 0;
#line 391
  ldv_state_variable_3 = 0;
#line 392
  ldv_state_variable_9 = 0;
#line 393
  ldv_state_variable_12 = 0;
#line 394
  ldv_state_variable_20 = 0;
#line 395
  ldv_state_variable_14 = 0;
#line 396
  ldv_state_variable_15 = 0;
#line 397
  ldv_state_variable_8 = 0;
#line 398
  ldv_state_variable_4 = 0;
#line 399
  ldv_state_variable_19 = 0;
#line 400
  ldv_state_variable_10 = 0;
#line 401
  ldv_state_variable_5 = 0;
  ldv_39510: 
#line 403
  tmp___53 = __VERIFIER_nondet_int();
#line 403
  switch (tmp___53) {
  case 0: ;
#line 407
  if (ldv_state_variable_11 != 0) {
#line 408
    tmp___54 = __VERIFIER_nondet_int();
#line 408
    switch (tmp___54) {
    case 0: ;
#line 411
    if (ldv_state_variable_11 == 1) {
#line 413
      rbd_minor_show(ldvarg0, ldvarg2, ldvarg1);
#line 415
      ldv_state_variable_11 = 1;
    } else {

    }
#line 418
    goto ldv_39412;
    default: 
#line 419
    ldv_stop();
    }
    ldv_39412: ;
  } else {

  }
#line 423
  goto ldv_39414;
  case 1: ;
#line 427
  if (ldv_state_variable_21 != 0) {
#line 428
    tmp___55 = __VERIFIER_nondet_int();
#line 428
    switch (tmp___55) {
    case 0: ;
#line 431
    if (ldv_state_variable_21 == 1) {
#line 433
      rbd_remove(ldvarg3, (char const   *)ldvarg5, ldvarg4);
#line 435
      ldv_state_variable_21 = 1;
    } else {

    }
#line 438
    goto ldv_39417;
    default: 
#line 439
    ldv_stop();
    }
    ldv_39417: ;
  } else {

  }
#line 443
  goto ldv_39414;
  case 2: ;
#line 447
  if (ldv_state_variable_7 != 0) {
#line 448
    tmp___56 = __VERIFIER_nondet_int();
#line 448
    switch (tmp___56) {
    case 0: ;
#line 451
    if (ldv_state_variable_7 == 1) {
#line 453
      rbd_name_show(ldvarg6, ldvarg8, ldvarg7);
#line 455
      ldv_state_variable_7 = 1;
    } else {

    }
#line 458
    goto ldv_39421;
    default: 
#line 459
    ldv_stop();
    }
    ldv_39421: ;
  } else {

  }
#line 463
  goto ldv_39414;
  case 3: ;
#line 467
  if (ldv_state_variable_17 != 0) {
#line 468
    tmp___57 = __VERIFIER_nondet_int();
#line 468
    switch (tmp___57) {
    case 0: ;
#line 471
    if (ldv_state_variable_17 == 2) {
#line 473
      rbd_root_dev_release(ldvarg9);
#line 475
      ldv_state_variable_17 = 1;
#line 476
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 479
    goto ldv_39425;
    case 1: ;
#line 482
    if (ldv_state_variable_17 == 1) {
#line 484
      ldv_probe_17();
#line 486
      ldv_state_variable_17 = 2;
#line 487
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 490
    goto ldv_39425;
    default: 
#line 491
    ldv_stop();
    }
    ldv_39425: ;
  } else {

  }
#line 495
  goto ldv_39414;
  case 4: ;
#line 499
  if (ldv_state_variable_2 != 0) {
#line 500
    tmp___58 = __VERIFIER_nondet_int();
#line 500
    switch (tmp___58) {
    case 0: ;
#line 503
    if (ldv_state_variable_2 == 2) {
#line 505
      rbd_sysfs_dev_release(ldvarg10);
#line 507
      ldv_state_variable_2 = 1;
#line 508
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 511
    goto ldv_39430;
    case 1: ;
#line 514
    if (ldv_state_variable_2 == 1) {
#line 516
      ldv_probe_2();
#line 518
      ldv_state_variable_2 = 2;
#line 519
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 522
    goto ldv_39430;
    default: 
#line 523
    ldv_stop();
    }
    ldv_39430: ;
  } else {

  }
#line 527
  goto ldv_39414;
  case 5: ;
#line 531
  if (ldv_state_variable_22 != 0) {
#line 532
    tmp___59 = __VERIFIER_nondet_int();
#line 532
    switch (tmp___59) {
    case 0: ;
#line 535
    if (ldv_state_variable_22 == 1) {
#line 537
      rbd_add(ldvarg11, (char const   *)ldvarg13, ldvarg12);
#line 539
      ldv_state_variable_22 = 1;
    } else {

    }
#line 542
    goto ldv_39435;
    default: 
#line 543
    ldv_stop();
    }
    ldv_39435: ;
  } else {

  }
#line 547
  goto ldv_39414;
  case 6: ;
#line 551
  if (ldv_state_variable_1 != 0) {
#line 552
    invoke_work_1();
  } else {

  }
#line 555
  goto ldv_39414;
  case 7: ;
#line 559
  if (ldv_state_variable_18 != 0) {
#line 560
    tmp___60 = __VERIFIER_nondet_int();
#line 560
    switch (tmp___60) {
    case 0: ;
#line 563
    if (ldv_state_variable_18 == 1) {
#line 565
      rbd_bus_is_visible(ldvarg14, ldvarg16, ldvarg15);
#line 567
      ldv_state_variable_18 = 1;
    } else {

    }
#line 570
    goto ldv_39440;
    default: 
#line 571
    ldv_stop();
    }
    ldv_39440: ;
  } else {

  }
#line 575
  goto ldv_39414;
  case 8: ;
#line 579
  if (ldv_state_variable_0 != 0) {
#line 580
    tmp___61 = __VERIFIER_nondet_int();
#line 580
    switch (tmp___61) {
    case 0: ;
#line 583
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 585
      rbd_exit();
#line 586
      ldv_state_variable_0 = 2;
#line 587
      goto ldv_final;
    } else {

    }
#line 590
    goto ldv_39445;
    case 1: ;
#line 593
    if (ldv_state_variable_0 == 1) {
#line 595
      ldv_retval_0 = rbd_init();
#line 597
      if (ldv_retval_0 == 0) {
#line 598
        ldv_state_variable_0 = 3;
#line 599
        ldv_state_variable_5 = 1;
#line 600
        ldv_state_variable_10 = 1;
#line 601
        ldv_state_variable_19 = 1;
#line 602
        ldv_state_variable_4 = 1;
#line 603
        ldv_state_variable_8 = 1;
#line 604
        ldv_state_variable_15 = 1;
#line 605
        ldv_state_variable_14 = 1;
#line 606
        ldv_state_variable_20 = 1;
#line 607
        ldv_state_variable_12 = 1;
#line 608
        ldv_state_variable_9 = 1;
#line 609
        ldv_state_variable_3 = 1;
#line 610
        ldv_state_variable_6 = 1;
#line 611
        ldv_state_variable_13 = 1;
#line 612
        ldv_state_variable_16 = 1;
#line 613
        ldv_initialize_block_device_operations_16();
#line 614
        ldv_state_variable_18 = 1;
#line 615
        ldv_state_variable_22 = 1;
#line 616
        ldv_state_variable_2 = 1;
#line 617
        ldv_state_variable_17 = 1;
#line 618
        ldv_state_variable_7 = 1;
#line 619
        ldv_state_variable_21 = 1;
#line 620
        ldv_state_variable_11 = 1;
      } else {

      }
#line 622
      if (ldv_retval_0 != 0) {
#line 623
        ldv_state_variable_0 = 2;
#line 624
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 628
    goto ldv_39445;
    default: 
#line 629
    ldv_stop();
    }
    ldv_39445: ;
  } else {

  }
#line 633
  goto ldv_39414;
  case 9: ;
#line 637
  if (ldv_state_variable_16 != 0) {
#line 638
    tmp___62 = __VERIFIER_nondet_int();
#line 638
    switch (tmp___62) {
    case 0: ;
#line 641
    if (ldv_state_variable_16 == 2) {
#line 643
      rbd_release(ldvarg24, ldvarg25);
#line 645
      ldv_state_variable_16 = 1;
#line 646
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 649
    goto ldv_39450;
    case 1: ;
#line 652
    if (ldv_state_variable_16 == 1) {
#line 654
      rbd_ioctl(rbd_bd_ops_group0, ldvarg23, ldvarg22, ldvarg21);
#line 656
      ldv_state_variable_16 = 1;
    } else {

    }
#line 659
    if (ldv_state_variable_16 == 2) {
#line 661
      rbd_ioctl(rbd_bd_ops_group0, ldvarg23, ldvarg22, ldvarg21);
#line 663
      ldv_state_variable_16 = 2;
    } else {

    }
#line 666
    goto ldv_39450;
    case 2: ;
#line 669
    if (ldv_state_variable_16 == 1) {
#line 671
      rbd_compat_ioctl(rbd_bd_ops_group0, ldvarg20, ldvarg19, ldvarg18);
#line 673
      ldv_state_variable_16 = 1;
    } else {

    }
#line 676
    if (ldv_state_variable_16 == 2) {
#line 678
      rbd_compat_ioctl(rbd_bd_ops_group0, ldvarg20, ldvarg19, ldvarg18);
#line 680
      ldv_state_variable_16 = 2;
    } else {

    }
#line 683
    goto ldv_39450;
    case 3: ;
#line 686
    if (ldv_state_variable_16 == 1) {
#line 688
      ldv_retval_1 = rbd_open(rbd_bd_ops_group0, ldvarg17);
#line 690
      if (ldv_retval_1 == 0) {
#line 691
        ldv_state_variable_16 = 2;
#line 692
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 696
    goto ldv_39450;
    default: 
#line 697
    ldv_stop();
    }
    ldv_39450: ;
  } else {

  }
#line 701
  goto ldv_39414;
  case 10: ;
#line 705
  if (ldv_state_variable_13 != 0) {
#line 706
    tmp___63 = __VERIFIER_nondet_int();
#line 706
    switch (tmp___63) {
    case 0: ;
#line 709
    if (ldv_state_variable_13 == 1) {
#line 711
      rbd_features_show(ldvarg26, ldvarg28, ldvarg27);
#line 713
      ldv_state_variable_13 = 1;
    } else {

    }
#line 716
    goto ldv_39457;
    default: 
#line 717
    ldv_stop();
    }
    ldv_39457: ;
  } else {

  }
#line 721
  goto ldv_39414;
  case 11: ;
#line 725
  if (ldv_state_variable_6 != 0) {
#line 726
    tmp___64 = __VERIFIER_nondet_int();
#line 726
    switch (tmp___64) {
    case 0: ;
#line 729
    if (ldv_state_variable_6 == 1) {
#line 731
      rbd_image_id_show(ldvarg29, ldvarg31, ldvarg30);
#line 733
      ldv_state_variable_6 = 1;
    } else {

    }
#line 736
    goto ldv_39461;
    default: 
#line 737
    ldv_stop();
    }
    ldv_39461: ;
  } else {

  }
#line 741
  goto ldv_39414;
  case 12: ;
#line 745
  if (ldv_state_variable_3 != 0) {
#line 746
    tmp___65 = __VERIFIER_nondet_int();
#line 746
    switch (tmp___65) {
    case 0: ;
#line 749
    if (ldv_state_variable_3 == 1) {
#line 751
      rbd_parent_show(ldvarg32, ldvarg34, ldvarg33);
#line 753
      ldv_state_variable_3 = 1;
    } else {

    }
#line 756
    goto ldv_39465;
    default: 
#line 757
    ldv_stop();
    }
    ldv_39465: ;
  } else {

  }
#line 761
  goto ldv_39414;
  case 13: ;
#line 765
  if (ldv_state_variable_9 != 0) {
#line 766
    tmp___66 = __VERIFIER_nondet_int();
#line 766
    switch (tmp___66) {
    case 0: ;
#line 769
    if (ldv_state_variable_9 == 1) {
#line 771
      rbd_pool_show(ldvarg35, ldvarg37, ldvarg36);
#line 773
      ldv_state_variable_9 = 1;
    } else {

    }
#line 776
    goto ldv_39469;
    default: 
#line 777
    ldv_stop();
    }
    ldv_39469: ;
  } else {

  }
#line 781
  goto ldv_39414;
  case 14: ;
#line 785
  if (ldv_state_variable_12 != 0) {
#line 786
    tmp___67 = __VERIFIER_nondet_int();
#line 786
    switch (tmp___67) {
    case 0: ;
#line 789
    if (ldv_state_variable_12 == 1) {
#line 791
      rbd_major_show(ldvarg38, ldvarg40, ldvarg39);
#line 793
      ldv_state_variable_12 = 1;
    } else {

    }
#line 796
    goto ldv_39473;
    default: 
#line 797
    ldv_stop();
    }
    ldv_39473: ;
  } else {

  }
#line 801
  goto ldv_39414;
  case 15: ;
#line 805
  if (ldv_state_variable_20 != 0) {
#line 806
    tmp___68 = __VERIFIER_nondet_int();
#line 806
    switch (tmp___68) {
    case 0: ;
#line 809
    if (ldv_state_variable_20 == 1) {
#line 811
      rbd_add_single_major(ldvarg41, (char const   *)ldvarg43, ldvarg42);
#line 813
      ldv_state_variable_20 = 1;
    } else {

    }
#line 816
    goto ldv_39477;
    default: 
#line 817
    ldv_stop();
    }
    ldv_39477: ;
  } else {

  }
#line 821
  goto ldv_39414;
  case 16: ;
#line 825
  if (ldv_state_variable_14 != 0) {
#line 826
    tmp___69 = __VERIFIER_nondet_int();
#line 826
    switch (tmp___69) {
    case 0: ;
#line 829
    if (ldv_state_variable_14 == 1) {
#line 831
      rbd_size_show(ldvarg44, ldvarg46, ldvarg45);
#line 833
      ldv_state_variable_14 = 1;
    } else {

    }
#line 836
    goto ldv_39481;
    default: 
#line 837
    ldv_stop();
    }
    ldv_39481: ;
  } else {

  }
#line 841
  goto ldv_39414;
  case 17: ;
#line 845
  if (ldv_state_variable_15 != 0) {
#line 846
    tmp___70 = __VERIFIER_nondet_int();
#line 846
    switch (tmp___70) {
    case 0: ;
#line 849
    if (ldv_state_variable_15 == 1) {
#line 851
      rbd_init_request(ldvarg52, ldvarg54, ldvarg53, ldvarg51, ldvarg55);
#line 853
      ldv_state_variable_15 = 1;
    } else {

    }
#line 856
    goto ldv_39485;
    case 1: ;
#line 859
    if (ldv_state_variable_15 == 1) {
#line 861
      blk_mq_map_queue(ldvarg49, ldvarg50);
#line 863
      ldv_state_variable_15 = 1;
    } else {

    }
#line 866
    goto ldv_39485;
    case 2: ;
#line 869
    if (ldv_state_variable_15 == 1) {
#line 871
      rbd_queue_rq(ldvarg47, (struct blk_mq_queue_data  const  *)ldvarg48);
#line 873
      ldv_state_variable_15 = 1;
    } else {

    }
#line 876
    goto ldv_39485;
    default: 
#line 877
    ldv_stop();
    }
    ldv_39485: ;
  } else {

  }
#line 881
  goto ldv_39414;
  case 18: ;
#line 885
  if (ldv_state_variable_8 != 0) {
#line 886
    tmp___71 = __VERIFIER_nondet_int();
#line 886
    switch (tmp___71) {
    case 0: ;
#line 889
    if (ldv_state_variable_8 == 1) {
#line 891
      rbd_pool_id_show(ldvarg56, ldvarg58, ldvarg57);
#line 893
      ldv_state_variable_8 = 1;
    } else {

    }
#line 896
    goto ldv_39491;
    default: 
#line 897
    ldv_stop();
    }
    ldv_39491: ;
  } else {

  }
#line 901
  goto ldv_39414;
  case 19: ;
#line 905
  if (ldv_state_variable_4 != 0) {
#line 906
    tmp___72 = __VERIFIER_nondet_int();
#line 906
    switch (tmp___72) {
    case 0: ;
#line 909
    if (ldv_state_variable_4 == 1) {
#line 911
      rbd_snap_show(ldvarg59, ldvarg61, ldvarg60);
#line 913
      ldv_state_variable_4 = 1;
    } else {

    }
#line 916
    goto ldv_39495;
    default: 
#line 917
    ldv_stop();
    }
    ldv_39495: ;
  } else {

  }
#line 921
  goto ldv_39414;
  case 20: ;
#line 925
  if (ldv_state_variable_19 != 0) {
#line 926
    tmp___73 = __VERIFIER_nondet_int();
#line 926
    switch (tmp___73) {
    case 0: ;
#line 929
    if (ldv_state_variable_19 == 1) {
#line 931
      rbd_remove_single_major(ldvarg62, (char const   *)ldvarg64, ldvarg63);
#line 933
      ldv_state_variable_19 = 1;
    } else {

    }
#line 936
    goto ldv_39499;
    default: 
#line 937
    ldv_stop();
    }
    ldv_39499: ;
  } else {

  }
#line 941
  goto ldv_39414;
  case 21: ;
#line 945
  if (ldv_state_variable_10 != 0) {
#line 946
    tmp___74 = __VERIFIER_nondet_int();
#line 946
    switch (tmp___74) {
    case 0: ;
#line 949
    if (ldv_state_variable_10 == 1) {
#line 951
      rbd_client_id_show(ldvarg65, ldvarg67, ldvarg66);
#line 953
      ldv_state_variable_10 = 1;
    } else {

    }
#line 956
    goto ldv_39503;
    default: 
#line 957
    ldv_stop();
    }
    ldv_39503: ;
  } else {

  }
#line 961
  goto ldv_39414;
  case 22: ;
#line 965
  if (ldv_state_variable_5 != 0) {
#line 966
    tmp___75 = __VERIFIER_nondet_int();
#line 966
    switch (tmp___75) {
    case 0: ;
#line 969
    if (ldv_state_variable_5 == 1) {
#line 971
      rbd_image_refresh(ldvarg69, ldvarg71, (char const   *)ldvarg70, ldvarg68);
#line 973
      ldv_state_variable_5 = 1;
    } else {

    }
#line 976
    goto ldv_39507;
    default: 
#line 977
    ldv_stop();
    }
    ldv_39507: ;
  } else {

  }
#line 981
  goto ldv_39414;
  default: 
#line 982
  ldv_stop();
  }
  ldv_39414: ;
#line 984
  goto ldv_39510;
  ldv_final: 
#line 986
  ldv_check_final_state();
#line 987
  return;
}
}
#line 990 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
__inline static void *ERR_PTR(long error ) 
{ 
  void *tmp ;

  {
#line 993
  tmp = ldv_err_ptr(error);
#line 993
  return (tmp);
}
}
#line 996 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
#line 999
  tmp = ldv_ptr_err(ptr);
#line 999
  return (tmp);
}
}
#line 1002 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  bool tmp ;

  {
#line 1005
  tmp = ldv_is_err(ptr);
#line 1005
  return (tmp);
}
}
#line 1014 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
#line 1018
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1018
  ldv_func_res = tmp;
#line 1020
  activate_work_1(ldv_func_arg3, 2);
#line 1022
  return (ldv_func_res);
}
}
#line 1025 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
#line 1029
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1029
  ldv_func_res = tmp;
#line 1031
  activate_work_1(& ldv_func_arg3->work, 2);
#line 1033
  return (ldv_func_res);
}
}
#line 1036 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
#line 1040
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 1040
  ldv_func_res = tmp;
#line 1042
  activate_work_1(ldv_func_arg3, 2);
#line 1044
  return (ldv_func_res);
}
}
#line 1047 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1050
  flush_workqueue(ldv_func_arg1);
#line 1052
  call_and_disable_all_1(2);
#line 1053
  return;
}
}
#line 1055 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
#line 1059
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
#line 1059
  ldv_func_res = tmp;
#line 1061
  activate_work_1(& ldv_func_arg3->work, 2);
#line 1063
  return (ldv_func_res);
}
}
#line 1066 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void ldv_mutex_unlock_10(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1069
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 1071
  mutex_unlock(ldv_func_arg1);
#line 1072
  return;
}
}
#line 1074 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1077
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 1079
  mutex_lock(ldv_func_arg1);
#line 1080
  return;
}
}
#line 1082 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void ldv_mutex_lock_12(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1085
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 1087
  mutex_lock(ldv_func_arg1);
#line 1088
  return;
}
}
#line 1090 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void ldv_mutex_unlock_13(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1093
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 1095
  mutex_unlock(ldv_func_arg1);
#line 1096
  return;
}
}
#line 1098 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void ldv_mutex_lock_14(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1101
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 1103
  mutex_lock(ldv_func_arg1);
#line 1104
  return;
}
}
#line 1106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
int ldv_mutex_trylock_15(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 1110
  tmp = mutex_trylock(ldv_func_arg1);
#line 1110
  ldv_func_res = tmp;
#line 1112
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 1112
  return (tmp___0);
#line 1114
  return (ldv_func_res);
}
}
#line 1117 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1120
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 1122
  mutex_unlock(ldv_func_arg1);
#line 1123
  return;
}
}
#line 1125 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void ldv_mutex_lock_nested_17(struct mutex *ldv_func_arg1 , unsigned int ldv_func_arg2 ) 
{ 


  {
#line 1128
  ldv_mutex_lock_client_mutex(ldv_func_arg1);
#line 1130
  mutex_lock_nested(ldv_func_arg1, ldv_func_arg2);
#line 1131
  return;
}
}
#line 1133 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void ldv_mutex_unlock_18(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 1136
  ldv_mutex_unlock_client_mutex(ldv_func_arg1);
#line 1138
  mutex_unlock(ldv_func_arg1);
#line 1139
  return;
}
}
#line 1141 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void ldv_destroy_workqueue_19(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1144
  destroy_workqueue(ldv_func_arg1);
#line 1146
  call_and_disable_all_1(2);
#line 1147
  return;
}
}
#line 1149 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/dscv/ri/32_7a/drivers/block/rbd.o.c.prepared"
void ldv_destroy_workqueue_20(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
#line 1152
  destroy_workqueue(ldv_func_arg1);
#line 1154
  call_and_disable_all_1(2);
#line 1155
  return;
}
}
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
#line 34
  tmp = ldv_undef_int();
#line 34
  ret = tmp;
#line 36
  if (ret >= 0) {
#line 36
    ldv_stop();
  } else {

  }
#line 38
  return (ret);
}
}
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 8 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_client_mutex  =    1;
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_client_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 16
  if (ldv_mutex_client_mutex != 1) {
#line 16
    ldv_error();
  } else {

  }
#line 19
  nondetermined = ldv_undef_int();
#line 22
  if (nondetermined != 0) {
#line 25
    ldv_mutex_client_mutex = 2;
#line 27
    return (0);
  } else {
#line 32
    return (-4);
  }
}
}
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_client_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 42
  if (ldv_mutex_client_mutex != 1) {
#line 42
    ldv_error();
  } else {

  }
#line 45
  nondetermined = ldv_undef_int();
#line 48
  if (nondetermined != 0) {
#line 51
    ldv_mutex_client_mutex = 2;
#line 53
    return (0);
  } else {
#line 58
    return (-4);
  }
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_client_mutex(struct mutex *lock ) 
{ 


  {
#line 66
  if (ldv_mutex_client_mutex != 1) {
#line 66
    ldv_error();
  } else {

  }
#line 68
  ldv_mutex_client_mutex = 2;
#line 69
  return;
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_client_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 77
  if (ldv_mutex_client_mutex != 1) {
#line 77
    ldv_error();
  } else {

  }
#line 80
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 83
  if (is_mutex_held_by_another_thread != 0) {
#line 86
    return (0);
  } else {
#line 91
    ldv_mutex_client_mutex = 2;
#line 93
    return (1);
  }
}
}
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_client_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 103
  if (ldv_mutex_client_mutex != 1) {
#line 103
    ldv_error();
  } else {

  }
#line 106
  atomic_value_after_dec = ldv_undef_int();
#line 109
  if (atomic_value_after_dec == 0) {
#line 112
    ldv_mutex_client_mutex = 2;
#line 114
    return (1);
  } else {

  }
#line 118
  return (0);
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_client_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 127
  if (ldv_mutex_client_mutex == 1) {
#line 130
    nondetermined = ldv_undef_int();
#line 133
    if (nondetermined != 0) {
#line 136
      return (0);
    } else {
#line 141
      return (1);
    }
  } else {
#line 147
    return (1);
  }
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_client_mutex(struct mutex *lock ) 
{ 


  {
#line 155
  if (ldv_mutex_client_mutex != 2) {
#line 155
    ldv_error();
  } else {

  }
#line 157
  ldv_mutex_client_mutex = 1;
#line 158
  return;
}
}
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_client_mutex(void) 
{ 


  {
#line 166
  ldv_mutex_lock_client_mutex((struct mutex *)0);
#line 167
  return;
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_client_mutex(void) 
{ 
  int tmp ;

  {
#line 172
  tmp = ldv_mutex_trylock_client_mutex((struct mutex *)0);
#line 172
  return (tmp);
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_client_mutex(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 178
  tmp___0 = ldv_undef_int();
#line 178
  if (tmp___0 != 0) {
#line 180
    ldv_mutex_lock_client_mutex((struct mutex *)0);
#line 182
    return (0);
  } else {
#line 185
    tmp = ldv_undef_int_negative();
#line 185
    return (tmp);
  }
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_client_mutex(void) 
{ 


  {
#line 191
  ldv_mutex_unlock_client_mutex((struct mutex *)0);
#line 192
  return;
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_i_mutex_of_inode  =    1;
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 202
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 202
    ldv_error();
  } else {

  }
#line 205
  nondetermined = ldv_undef_int();
#line 208
  if (nondetermined != 0) {
#line 211
    ldv_mutex_i_mutex_of_inode = 2;
#line 213
    return (0);
  } else {
#line 218
    return (-4);
  }
}
}
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 228
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 228
    ldv_error();
  } else {

  }
#line 231
  nondetermined = ldv_undef_int();
#line 234
  if (nondetermined != 0) {
#line 237
    ldv_mutex_i_mutex_of_inode = 2;
#line 239
    return (0);
  } else {
#line 244
    return (-4);
  }
}
}
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
#line 252
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 252
    ldv_error();
  } else {

  }
#line 254
  ldv_mutex_i_mutex_of_inode = 2;
#line 255
  return;
}
}
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 263
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 263
    ldv_error();
  } else {

  }
#line 266
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 269
  if (is_mutex_held_by_another_thread != 0) {
#line 272
    return (0);
  } else {
#line 277
    ldv_mutex_i_mutex_of_inode = 2;
#line 279
    return (1);
  }
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_i_mutex_of_inode(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 289
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 289
    ldv_error();
  } else {

  }
#line 292
  atomic_value_after_dec = ldv_undef_int();
#line 295
  if (atomic_value_after_dec == 0) {
#line 298
    ldv_mutex_i_mutex_of_inode = 2;
#line 300
    return (1);
  } else {

  }
#line 304
  return (0);
}
}
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 313
  if (ldv_mutex_i_mutex_of_inode == 1) {
#line 316
    nondetermined = ldv_undef_int();
#line 319
    if (nondetermined != 0) {
#line 322
      return (0);
    } else {
#line 327
      return (1);
    }
  } else {
#line 333
    return (1);
  }
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
#line 341
  if (ldv_mutex_i_mutex_of_inode != 2) {
#line 341
    ldv_error();
  } else {

  }
#line 343
  ldv_mutex_i_mutex_of_inode = 1;
#line 344
  return;
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_i_mutex_of_inode(void) 
{ 


  {
#line 352
  ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
#line 353
  return;
}
}
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_i_mutex_of_inode(void) 
{ 
  int tmp ;

  {
#line 358
  tmp = ldv_mutex_trylock_i_mutex_of_inode((struct mutex *)0);
#line 358
  return (tmp);
}
}
#line 362 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_i_mutex_of_inode(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 364
  tmp___0 = ldv_undef_int();
#line 364
  if (tmp___0 != 0) {
#line 366
    ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
#line 368
    return (0);
  } else {
#line 371
    tmp = ldv_undef_int_negative();
#line 371
    return (tmp);
  }
}
}
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_i_mutex_of_inode(void) 
{ 


  {
#line 377
  ldv_mutex_unlock_i_mutex_of_inode((struct mutex *)0);
#line 378
  return;
}
}
#line 380 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock  =    1;
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 388
  if (ldv_mutex_lock != 1) {
#line 388
    ldv_error();
  } else {

  }
#line 391
  nondetermined = ldv_undef_int();
#line 394
  if (nondetermined != 0) {
#line 397
    ldv_mutex_lock = 2;
#line 399
    return (0);
  } else {
#line 404
    return (-4);
  }
}
}
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 414
  if (ldv_mutex_lock != 1) {
#line 414
    ldv_error();
  } else {

  }
#line 417
  nondetermined = ldv_undef_int();
#line 420
  if (nondetermined != 0) {
#line 423
    ldv_mutex_lock = 2;
#line 425
    return (0);
  } else {
#line 430
    return (-4);
  }
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
#line 438
  if (ldv_mutex_lock != 1) {
#line 438
    ldv_error();
  } else {

  }
#line 440
  ldv_mutex_lock = 2;
#line 441
  return;
}
}
#line 444 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 449
  if (ldv_mutex_lock != 1) {
#line 449
    ldv_error();
  } else {

  }
#line 452
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 455
  if (is_mutex_held_by_another_thread != 0) {
#line 458
    return (0);
  } else {
#line 463
    ldv_mutex_lock = 2;
#line 465
    return (1);
  }
}
}
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 475
  if (ldv_mutex_lock != 1) {
#line 475
    ldv_error();
  } else {

  }
#line 478
  atomic_value_after_dec = ldv_undef_int();
#line 481
  if (atomic_value_after_dec == 0) {
#line 484
    ldv_mutex_lock = 2;
#line 486
    return (1);
  } else {

  }
#line 490
  return (0);
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 499
  if (ldv_mutex_lock == 1) {
#line 502
    nondetermined = ldv_undef_int();
#line 505
    if (nondetermined != 0) {
#line 508
      return (0);
    } else {
#line 513
      return (1);
    }
  } else {
#line 519
    return (1);
  }
}
}
#line 524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
#line 527
  if (ldv_mutex_lock != 2) {
#line 527
    ldv_error();
  } else {

  }
#line 529
  ldv_mutex_lock = 1;
#line 530
  return;
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_lock(void) 
{ 


  {
#line 538
  ldv_mutex_lock_lock((struct mutex *)0);
#line 539
  return;
}
}
#line 542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_lock(void) 
{ 
  int tmp ;

  {
#line 544
  tmp = ldv_mutex_trylock_lock((struct mutex *)0);
#line 544
  return (tmp);
}
}
#line 548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_lock(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 550
  tmp___0 = ldv_undef_int();
#line 550
  if (tmp___0 != 0) {
#line 552
    ldv_mutex_lock_lock((struct mutex *)0);
#line 554
    return (0);
  } else {
#line 557
    tmp = ldv_undef_int_negative();
#line 557
    return (tmp);
  }
}
}
#line 561 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_lock(void) 
{ 


  {
#line 563
  ldv_mutex_unlock_lock((struct mutex *)0);
#line 564
  return;
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_device  =    1;
#line 569 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 574
  if (ldv_mutex_mutex_of_device != 1) {
#line 574
    ldv_error();
  } else {

  }
#line 577
  nondetermined = ldv_undef_int();
#line 580
  if (nondetermined != 0) {
#line 583
    ldv_mutex_mutex_of_device = 2;
#line 585
    return (0);
  } else {
#line 590
    return (-4);
  }
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 600
  if (ldv_mutex_mutex_of_device != 1) {
#line 600
    ldv_error();
  } else {

  }
#line 603
  nondetermined = ldv_undef_int();
#line 606
  if (nondetermined != 0) {
#line 609
    ldv_mutex_mutex_of_device = 2;
#line 611
    return (0);
  } else {
#line 616
    return (-4);
  }
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 624
  if (ldv_mutex_mutex_of_device != 1) {
#line 624
    ldv_error();
  } else {

  }
#line 626
  ldv_mutex_mutex_of_device = 2;
#line 627
  return;
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 635
  if (ldv_mutex_mutex_of_device != 1) {
#line 635
    ldv_error();
  } else {

  }
#line 638
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 641
  if (is_mutex_held_by_another_thread != 0) {
#line 644
    return (0);
  } else {
#line 649
    ldv_mutex_mutex_of_device = 2;
#line 651
    return (1);
  }
}
}
#line 656 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 661
  if (ldv_mutex_mutex_of_device != 1) {
#line 661
    ldv_error();
  } else {

  }
#line 664
  atomic_value_after_dec = ldv_undef_int();
#line 667
  if (atomic_value_after_dec == 0) {
#line 670
    ldv_mutex_mutex_of_device = 2;
#line 672
    return (1);
  } else {

  }
#line 676
  return (0);
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 685
  if (ldv_mutex_mutex_of_device == 1) {
#line 688
    nondetermined = ldv_undef_int();
#line 691
    if (nondetermined != 0) {
#line 694
      return (0);
    } else {
#line 699
      return (1);
    }
  } else {
#line 705
    return (1);
  }
}
}
#line 710 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 713
  if (ldv_mutex_mutex_of_device != 2) {
#line 713
    ldv_error();
  } else {

  }
#line 715
  ldv_mutex_mutex_of_device = 1;
#line 716
  return;
}
}
#line 721 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_mutex_of_device(void) 
{ 


  {
#line 724
  ldv_mutex_lock_mutex_of_device((struct mutex *)0);
#line 725
  return;
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_mutex_of_device(void) 
{ 
  int tmp ;

  {
#line 730
  tmp = ldv_mutex_trylock_mutex_of_device((struct mutex *)0);
#line 730
  return (tmp);
}
}
#line 734 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_mutex_of_device(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 736
  tmp___0 = ldv_undef_int();
#line 736
  if (tmp___0 != 0) {
#line 738
    ldv_mutex_lock_mutex_of_device((struct mutex *)0);
#line 740
    return (0);
  } else {
#line 743
    tmp = ldv_undef_int_negative();
#line 743
    return (tmp);
  }
}
}
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_mutex_of_device(void) 
{ 


  {
#line 749
  ldv_mutex_unlock_mutex_of_device((struct mutex *)0);
#line 750
  return;
}
}
#line 754 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/10785/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 757
  if (ldv_mutex_client_mutex != 1) {
#line 757
    ldv_error();
  } else {

  }
#line 759
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 759
    ldv_error();
  } else {

  }
#line 761
  if (ldv_mutex_lock != 1) {
#line 761
    ldv_error();
  } else {

  }
#line 763
  if (ldv_mutex_mutex_of_device != 1) {
#line 763
    ldv_error();
  } else {

  }
#line 767
  return;
}
}
