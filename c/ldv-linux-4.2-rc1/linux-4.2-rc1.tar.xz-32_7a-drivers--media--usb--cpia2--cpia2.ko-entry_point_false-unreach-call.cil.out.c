extern void __VERIFIER_error() __attribute__ ((__noreturn__));
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 20 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "./include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 40 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 48 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "./include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "./include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "./include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "./include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 32 "include/uapi/linux/types.h"
typedef __u16 __le16;
#line 34 "include/uapi/linux/types.h"
typedef __u32 __le32;
#line 229 "include/linux/compiler.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "include/linux/export.h"
struct module;
#line 12 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "include/linux/types.h"
typedef _Bool bool;
#line 31 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "include/linux/types.h"
typedef __s32 int32_t;
#line 108 "include/linux/types.h"
typedef __u32 uint32_t;
#line 133 "include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 152 "include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 177 "include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 67 "./arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 66 "./arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 12 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "./arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
#line 18 "./arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_11 pte_t;
#line 20 "./arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "./arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "./arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 220 "./arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 361
struct page;
#line 361 "./arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 372
struct file;
#line 385
struct seq_file;
#line 423
struct thread_struct;
#line 425
struct mm_struct;
#line 426
struct task_struct;
#line 427
struct cpumask;
#line 20 "./arch/x86/include/asm/spinlock_types.h"
struct qspinlock {
   atomic_t val ;
};
#line 33 "include/asm-generic/qspinlock_types.h"
typedef struct qspinlock arch_spinlock_t;
#line 34 "include/asm-generic/qspinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 131 "include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 48 "include/linux/dynamic_debug.h"
struct device;
#line 420 "include/linux/printk.h"
struct file_operations;
#line 432
struct completion;
#line 687 "include/linux/list.h"
struct lockdep_map;
#line 127 "./arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_15 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "./arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 328 "include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "include/linux/bug.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 15 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 652 "include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 260 "./arch/x86/include/asm/special_insns.h"
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_25 {
   u64 rip ;
   u64 rdp ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct __anonstruct____missing_field_name_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_24 {
   struct __anonstruct____missing_field_name_25 __annonCompField11 ;
   struct __anonstruct____missing_field_name_26 __annonCompField12 ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
union __anonunion____missing_field_name_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 26 "./arch/x86/include/asm/fpu/types.h"
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_24 __annonCompField13 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_27 __annonCompField14 ;
};
#line 66 "./arch/x86/include/asm/fpu/types.h"
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 155 "./arch/x86/include/asm/fpu/types.h"
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 161 "./arch/x86/include/asm/fpu/types.h"
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
#line 179 "./arch/x86/include/asm/fpu/types.h"
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
#line 193 "./arch/x86/include/asm/fpu/types.h"
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
   unsigned char fpstate_active ;
   unsigned char fpregs_active ;
   unsigned char counter ;
};
#line 170 "./arch/x86/include/asm/processor.h"
struct seq_operations;
#line 369
struct perf_event;
#line 370 "./arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
};
#line 489 "./arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_29 {
   unsigned long seg ;
};
#line 489 "./arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_29 mm_segment_t;
#line 23 "include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 28 "include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
};
#line 546 "include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "include/linux/spinlock_types.h"
union __anonunion____missing_field_name_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_31 __annonCompField16 ;
};
#line 33 "include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_30 __annonCompField17 ;
};
#line 76 "include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
#line 13 "include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 39 "include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
struct usb_device;
#line 128 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
struct vm_area_struct;
#line 15 "include/linux/mmdebug.h"
struct timespec;
#line 16
struct compat_timespec;
#line 17 "include/linux/mmdebug.h"
struct __anonstruct_futex_34 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 17 "include/linux/mmdebug.h"
struct __anonstruct_nanosleep_35 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 17
struct pollfd;
#line 17 "include/linux/mmdebug.h"
struct __anonstruct_poll_36 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 17 "include/linux/mmdebug.h"
union __anonunion____missing_field_name_33 {
   struct __anonstruct_futex_34 futex ;
   struct __anonstruct_nanosleep_35 nanosleep ;
   struct __anonstruct_poll_36 poll ;
};
#line 17 "include/linux/mmdebug.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_33 __annonCompField18 ;
};
#line 52 "include/linux/thread_info.h"
struct thread_info {
   struct task_struct *task ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int saved_preempt_count ;
   mm_segment_t addr_limit ;
   void *sysenter_return ;
   unsigned char sig_on_uaccess_error : 1 ;
   unsigned char uaccess_err : 1 ;
};
#line 12 "include/linux/wait.h"
struct __wait_queue;
#line 12 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 38 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 1170 "include/linux/wait.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 52 "include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 404 "include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 404 "include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 95 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_46 {
   unsigned long bits[16U] ;
};
#line 95 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_46 nodemask_t;
#line 796 "include/linux/mmzone.h"
struct rw_semaphore;
#line 797 "include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 172 "include/linux/rwsem.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 105 "include/linux/debugobjects.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 13 "include/uapi/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 437 "include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "include/linux/ktime.h"
typedef union ktime ktime_t;
#line 1121 "include/linux/rcupdate.h"
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   u32 flags ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 238 "include/linux/timer.h"
struct hrtimer;
#line 239
enum hrtimer_restart;
#line 240 "include/linux/timer.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 41 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 838 "include/uapi/linux/sysctl.h"
struct nsproxy;
#line 259 "include/linux/timer.h"
struct workqueue_struct;
#line 260
struct work_struct;
#line 54 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 58 "include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 336
struct wake_irq;
#line 338 "include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 553
struct dev_pm_qos;
#line 553 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 615 "include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_113 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "./arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_113 mm_context_t;
#line 1281 "include/linux/mmzone.h"
struct llist_node;
#line 64 "include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 60 "include/linux/kmemleak.h"
struct kmem_cache;
#line 22 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 33
struct inode;
#line 34
struct dentry;
#line 35
struct user_namespace;
#line 84 "include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 58 "./arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_146 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_147 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "./arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_145 {
   struct __anonstruct____missing_field_name_146 __annonCompField33 ;
   struct __anonstruct____missing_field_name_147 __annonCompField34 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "./arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_145 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "include/linux/uprobes.h"
struct xol_area;
#line 95 "include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_148 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_150 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_154 __annonCompField38 ;
   int units ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_152 {
   union __anonunion____missing_field_name_153 __annonCompField39 ;
   atomic_t _count ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_151 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_152 __annonCompField40 ;
   unsigned int active ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_149 {
   union __anonunion____missing_field_name_150 __annonCompField37 ;
   union __anonunion____missing_field_name_151 __annonCompField41 ;
};
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_156 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_157 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_156 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_157 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
#line 32 "include/linux/mm_types.h"
union __anonunion____missing_field_name_158 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_148 __annonCompField36 ;
   struct __anonstruct____missing_field_name_149 __annonCompField42 ;
   union __anonunion____missing_field_name_155 __annonCompField45 ;
   union __anonunion____missing_field_name_158 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 266 "include/linux/mm_types.h"
struct __anonstruct_shared_159 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 266
struct anon_vma;
#line 266
struct vm_operations_struct;
#line 266
struct mempolicy;
#line 266 "include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_159 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 334 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 340 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 353 "include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 361 "include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 366
struct kioctx_table;
#line 367
struct linux_binfmt;
#line 367
struct mmu_notifier_mm;
#line 367 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 4 "include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 22 "include/linux/uidgid.h"
struct __anonstruct_kuid_t_161 {
   uid_t val ;
};
#line 22 "include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_161 kuid_t;
#line 27 "include/linux/uidgid.h"
struct __anonstruct_kgid_t_162 {
   gid_t val ;
};
#line 27 "include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_162 kgid_t;
#line 25 "include/linux/sem.h"
struct sem_undo_list;
#line 25 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "include/uapi/linux/shm.h"
struct user_struct;
#line 26 "include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "./arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_163 {
   unsigned long sig[1U] ;
};
#line 24 "./arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_163 sigset_t;
#line 25
struct siginfo;
#line 17 "./include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "./include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "./include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "./include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "./arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_165 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_166 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_167 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_168 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_170 {
   void *_lower ;
   void *_upper ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_169 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_170 _addr_bnd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_171 {
   long _band ;
   int _fd ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_172 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_164 {
   int _pad[28U] ;
   struct __anonstruct__kill_165 _kill ;
   struct __anonstruct__timer_166 _timer ;
   struct __anonstruct__rt_167 _rt ;
   struct __anonstruct__sigchld_168 _sigchld ;
   struct __anonstruct__sigfault_169 _sigfault ;
   struct __anonstruct__sigpoll_171 _sigpoll ;
   struct __anonstruct__sigsys_172 _sigsys ;
};
#line 11 "include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_164 _sifields ;
};
#line 113 "include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 123 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
#line 156 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set_seq ;
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
   unsigned int nr_retries ;
   unsigned int nr_hangs ;
   unsigned int max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 466 "include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct cred;
#line 38
struct key_type;
#line 42 "include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_179 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_180 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "include/linux/key.h"
struct __anonstruct____missing_field_name_182 {
   struct key_type *type ;
   char *description ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_181 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_182 __annonCompField49 ;
};
#line 123 "include/linux/key.h"
union __anonunion_type_data_183 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "include/linux/key.h"
union __anonunion_payload_185 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "include/linux/key.h"
union __anonunion____missing_field_name_184 {
   union __anonunion_payload_185 payload ;
   struct assoc_array keys ;
};
#line 123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_179 __annonCompField47 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_180 __annonCompField48 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_181 __annonCompField50 ;
   union __anonunion_type_data_183 type_data ;
   union __anonunion____missing_field_name_184 __annonCompField51 ;
};
#line 358
struct audit_context;
#line 27 "include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 90 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 369 "include/linux/cred.h"
union __anonunion____missing_field_name_186 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 369 "include/linux/cred.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_186 __annonCompField52 ;
};
#line 41 "include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct percpu_ref;
#line 55 "include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 27 "include/linux/percpu-rwsem.h"
struct cgroup;
#line 28
struct cgroup_root;
#line 29
struct cgroup_subsys;
#line 30
struct cgroup_taskset;
#line 31
struct kernfs_node;
#line 32
struct kernfs_ops;
#line 33
struct kernfs_open_file;
#line 75 "include/linux/percpu-rwsem.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 124 "include/linux/cgroup-defs.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 197 "include/linux/cgroup-defs.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 270
struct kernfs_root;
#line 270 "include/linux/cgroup-defs.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 306 "include/linux/cgroup-defs.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 388 "include/linux/cgroup-defs.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 128 "include/linux/sched.h"
struct futex_pi_state;
#line 129
struct robust_list_head;
#line 130
struct bio_list;
#line 131
struct fs_struct;
#line 132
struct perf_event_context;
#line 133
struct blk_plug;
#line 135
struct nameidata;
#line 188
struct cfs_rq;
#line 189
struct task_group;
#line 477 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 516 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 524 "include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 531 "include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 543 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 563 "include/linux/sched.h"
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
#line 584 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
};
#line 620
struct autogroup;
#line 621
struct tty_struct;
#line 621
struct taskstats;
#line 621
struct tty_audit_buf;
#line 621 "include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 790 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 833
struct backing_dev_info;
#line 834
struct reclaim_state;
#line 835 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 849 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 897 "include/linux/sched.h"
struct wake_q_node {
   struct wake_q_node *next ;
};
#line 1126
struct io_context;
#line 1160
struct pipe_inode_info;
#line 1162 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1169 "include/linux/sched.h"
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
   unsigned long utilization_avg_contrib ;
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
#line 1194 "include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1229 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1261
struct rt_rq;
#line 1261 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1277 "include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1343 "include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1769
struct sched_class;
#line 1769
struct files_struct;
#line 1769
struct compat_robust_list_head;
#line 1769
struct numa_group;
#line 1769 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned long jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
   int pagefault_disabled ;
};
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
struct v4l2_event_subscription;
#line 91
struct v4l2_streamparm;
#line 92
struct usb_interface;
#line 94
struct v4l2_format;
#line 103
struct v4l2_buffer;
#line 105
struct v4l2_fh;
#line 135 "./arch/x86/include/uapi/asm/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 15 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "include/linux/elf.h"
struct iattr;
#line 54
struct super_block;
#line 55
struct file_system_type;
#line 56
struct kernfs_open_node;
#line 57
struct kernfs_iattrs;
#line 80 "include/linux/elf.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 85 "include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 89 "include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 96 "include/linux/kernfs.h"
union __anonunion____missing_field_name_209 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 96 "include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_209 __annonCompField56 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 138 "include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 155 "include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 171 "include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 188 "include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 477
struct sock;
#line 478
struct kobject;
#line 479
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 485 "include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 59 "include/linux/kobject_ns.h"
struct bin_attribute;
#line 60 "include/linux/kobject_ns.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 82 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 155 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 509 "include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 52 "include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct kernel_param;
#line 227 "include/linux/kobject.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_210 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_210 __annonCompField57 ;
};
#line 83 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 89 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 469 "include/linux/moduleparam.h"
struct latch_tree_node {
   struct rb_node node[2U] ;
};
#line 211 "include/linux/rbtree_latch.h"
struct mod_arch_specific {

};
#line 37 "include/linux/module.h"
struct module_param_attrs;
#line 37 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 47 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 73
struct exception_table_entry;
#line 206
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 213 "include/linux/module.h"
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
#line 220
struct module_sect_attrs;
#line 220
struct module_notes_attrs;
#line 220
struct tracepoint;
#line 220
struct trace_event_call;
#line 220
struct trace_enum_map;
#line 220 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 712 "include/linux/module.h"
struct v4l2_edid {
   __u32 pad ;
   __u32 start_block ;
   __u32 blocks ;
   __u32 reserved[5U] ;
   __u8 *edid ;
};
#line 571 "./include/uapi/linux/v4l2-common.h"
enum v4l2_buf_type {
    V4L2_BUF_TYPE_VIDEO_CAPTURE = 1,
    V4L2_BUF_TYPE_VIDEO_OUTPUT = 2,
    V4L2_BUF_TYPE_VIDEO_OVERLAY = 3,
    V4L2_BUF_TYPE_VBI_CAPTURE = 4,
    V4L2_BUF_TYPE_VBI_OUTPUT = 5,
    V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6,
    V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
    V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE = 10,
    V4L2_BUF_TYPE_SDR_CAPTURE = 11,
    V4L2_BUF_TYPE_PRIVATE = 128
} ;
#line 643
enum v4l2_priority {
    V4L2_PRIORITY_UNSET = 0,
    V4L2_PRIORITY_BACKGROUND = 1,
    V4L2_PRIORITY_INTERACTIVE = 2,
    V4L2_PRIORITY_RECORD = 3,
    V4L2_PRIORITY_DEFAULT = 2
} ;
#line 651 "./include/uapi/linux/v4l2-common.h"
struct v4l2_rect {
   __s32 left ;
   __s32 top ;
   __u32 width ;
   __u32 height ;
};
#line 370 "include/uapi/linux/videodev2.h"
struct v4l2_fract {
   __u32 numerator ;
   __u32 denominator ;
};
#line 375 "include/uapi/linux/videodev2.h"
struct v4l2_capability {
   __u8 driver[16U] ;
   __u8 card[32U] ;
   __u8 bus_info[32U] ;
   __u32 version ;
   __u32 capabilities ;
   __u32 device_caps ;
   __u32 reserved[3U] ;
};
#line 396 "include/uapi/linux/videodev2.h"
struct v4l2_pix_format {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 bytesperline ;
   __u32 sizeimage ;
   __u32 colorspace ;
   __u32 priv ;
   __u32 flags ;
   __u32 ycbcr_enc ;
   __u32 quantization ;
   __u32 xfer_func ;
};
#line 450 "include/uapi/linux/videodev2.h"
struct v4l2_fmtdesc {
   __u32 index ;
   __u32 type ;
   __u32 flags ;
   __u8 description[32U] ;
   __u32 pixelformat ;
   __u32 reserved[4U] ;
};
#line 640 "include/uapi/linux/videodev2.h"
struct v4l2_frmsize_discrete {
   __u32 width ;
   __u32 height ;
};
#line 653 "include/uapi/linux/videodev2.h"
struct v4l2_frmsize_stepwise {
   __u32 min_width ;
   __u32 max_width ;
   __u32 step_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 step_height ;
};
#line 662 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_217 {
   struct v4l2_frmsize_discrete discrete ;
   struct v4l2_frmsize_stepwise stepwise ;
};
#line 662 "include/uapi/linux/videodev2.h"
struct v4l2_frmsizeenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 type ;
   union __anonunion____missing_field_name_217 __annonCompField58 ;
   __u32 reserved[2U] ;
};
#line 681 "include/uapi/linux/videodev2.h"
struct v4l2_frmival_stepwise {
   struct v4l2_fract min ;
   struct v4l2_fract max ;
   struct v4l2_fract step ;
};
#line 690 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_218 {
   struct v4l2_fract discrete ;
   struct v4l2_frmival_stepwise stepwise ;
};
#line 690 "include/uapi/linux/videodev2.h"
struct v4l2_frmivalenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 width ;
   __u32 height ;
   __u32 type ;
   union __anonunion____missing_field_name_218 __annonCompField59 ;
   __u32 reserved[2U] ;
};
#line 705 "include/uapi/linux/videodev2.h"
struct v4l2_timecode {
   __u32 type ;
   __u32 flags ;
   __u8 frames ;
   __u8 seconds ;
   __u8 minutes ;
   __u8 hours ;
   __u8 userbits[4U] ;
};
#line 719 "include/uapi/linux/videodev2.h"
struct v4l2_jpegcompression {
   int quality ;
   int APPn ;
   int APP_len ;
   char APP_data[60U] ;
   int COM_len ;
   char COM_data[60U] ;
   __u32 jpeg_markers ;
};
#line 748 "include/uapi/linux/videodev2.h"
struct v4l2_requestbuffers {
   __u32 count ;
   __u32 type ;
   __u32 memory ;
   __u32 reserved[2U] ;
};
#line 773 "include/uapi/linux/videodev2.h"
union __anonunion_m_219 {
   __u32 mem_offset ;
   unsigned long userptr ;
   __s32 fd ;
};
#line 773 "include/uapi/linux/videodev2.h"
struct v4l2_plane {
   __u32 bytesused ;
   __u32 length ;
   union __anonunion_m_219 m ;
   __u32 data_offset ;
   __u32 reserved[11U] ;
};
#line 805 "include/uapi/linux/videodev2.h"
union __anonunion_m_220 {
   __u32 offset ;
   unsigned long userptr ;
   struct v4l2_plane *planes ;
   __s32 fd ;
};
#line 805 "include/uapi/linux/videodev2.h"
struct v4l2_buffer {
   __u32 index ;
   __u32 type ;
   __u32 bytesused ;
   __u32 flags ;
   __u32 field ;
   struct timeval timestamp ;
   struct v4l2_timecode timecode ;
   __u32 sequence ;
   __u32 memory ;
   union __anonunion_m_220 m ;
   __u32 length ;
   __u32 reserved2 ;
   __u32 reserved ;
};
#line 858 "include/uapi/linux/videodev2.h"
struct v4l2_exportbuffer {
   __u32 type ;
   __u32 index ;
   __u32 plane ;
   __u32 flags ;
   __s32 fd ;
   __u32 reserved[11U] ;
};
#line 919 "include/uapi/linux/videodev2.h"
struct __anonstruct_fmt_221 {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 bytesperline ;
   __u32 sizeimage ;
   __u32 colorspace ;
   __u32 priv ;
};
#line 919 "include/uapi/linux/videodev2.h"
struct v4l2_framebuffer {
   __u32 capability ;
   __u32 flags ;
   void *base ;
   struct __anonstruct_fmt_221 fmt ;
};
#line 940 "include/uapi/linux/videodev2.h"
struct v4l2_clip {
   struct v4l2_rect c ;
   struct v4l2_clip *next ;
};
#line 962 "include/uapi/linux/videodev2.h"
struct v4l2_window {
   struct v4l2_rect w ;
   __u32 field ;
   __u32 chromakey ;
   struct v4l2_clip *clips ;
   __u32 clipcount ;
   void *bitmap ;
   __u8 global_alpha ;
};
#line 972 "include/uapi/linux/videodev2.h"
struct v4l2_captureparm {
   __u32 capability ;
   __u32 capturemode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 readbuffers ;
   __u32 reserved[4U] ;
};
#line 984 "include/uapi/linux/videodev2.h"
struct v4l2_outputparm {
   __u32 capability ;
   __u32 outputmode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 writebuffers ;
   __u32 reserved[4U] ;
};
#line 997 "include/uapi/linux/videodev2.h"
struct v4l2_cropcap {
   __u32 type ;
   struct v4l2_rect bounds ;
   struct v4l2_rect defrect ;
   struct v4l2_fract pixelaspect ;
};
#line 1007 "include/uapi/linux/videodev2.h"
struct v4l2_crop {
   __u32 type ;
   struct v4l2_rect c ;
};
#line 1012 "include/uapi/linux/videodev2.h"
struct v4l2_selection {
   __u32 type ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[9U] ;
};
#line 1039 "include/uapi/linux/videodev2.h"
typedef __u64 v4l2_std_id;
#line 1175 "include/uapi/linux/videodev2.h"
struct v4l2_bt_timings {
   __u32 width ;
   __u32 height ;
   __u32 interlaced ;
   __u32 polarities ;
   __u64 pixelclock ;
   __u32 hfrontporch ;
   __u32 hsync ;
   __u32 hbackporch ;
   __u32 vfrontporch ;
   __u32 vsync ;
   __u32 vbackporch ;
   __u32 il_vfrontporch ;
   __u32 il_vsync ;
   __u32 il_vbackporch ;
   __u32 standards ;
   __u32 flags ;
   __u32 reserved[14U] ;
};
#line 1231 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_222 {
   struct v4l2_bt_timings bt ;
   __u32 reserved[32U] ;
};
#line 1231 "include/uapi/linux/videodev2.h"
struct v4l2_dv_timings {
   __u32 type ;
   union __anonunion____missing_field_name_222 __annonCompField60 ;
};
#line 1299 "include/uapi/linux/videodev2.h"
struct v4l2_enum_dv_timings {
   __u32 index ;
   __u32 pad ;
   __u32 reserved[2U] ;
   struct v4l2_dv_timings timings ;
};
#line 1317 "include/uapi/linux/videodev2.h"
struct v4l2_bt_timings_cap {
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u64 min_pixelclock ;
   __u64 max_pixelclock ;
   __u32 standards ;
   __u32 capabilities ;
   __u32 reserved[16U] ;
};
#line 1340 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_223 {
   struct v4l2_bt_timings_cap bt ;
   __u32 raw_data[32U] ;
};
#line 1340 "include/uapi/linux/videodev2.h"
struct v4l2_dv_timings_cap {
   __u32 type ;
   __u32 pad ;
   __u32 reserved[2U] ;
   union __anonunion____missing_field_name_223 __annonCompField61 ;
};
#line 1365 "include/uapi/linux/videodev2.h"
struct v4l2_input {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 tuner ;
   v4l2_std_id std ;
   __u32 status ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1381 "include/uapi/linux/videodev2.h"
struct v4l2_output {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 modulator ;
   v4l2_std_id std ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1429 "include/uapi/linux/videodev2.h"
struct v4l2_control {
   __u32 id ;
   __s32 value ;
};
#line 1447 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_224 {
   __s32 value ;
   __s64 value64 ;
   char *string ;
   __u8 *p_u8 ;
   __u16 *p_u16 ;
   __u32 *p_u32 ;
   void *ptr ;
};
#line 1447 "include/uapi/linux/videodev2.h"
struct v4l2_ext_control {
   __u32 id ;
   __u32 size ;
   __u32 reserved2[1U] ;
   union __anonunion____missing_field_name_224 __annonCompField62 ;
};
#line 1462 "include/uapi/linux/videodev2.h"
struct v4l2_ext_controls {
   __u32 ctrl_class ;
   __u32 count ;
   __u32 error_idx ;
   __u32 reserved[2U] ;
   struct v4l2_ext_control *controls ;
};
#line 1470
enum v4l2_ctrl_type {
    V4L2_CTRL_TYPE_INTEGER = 1,
    V4L2_CTRL_TYPE_BOOLEAN = 2,
    V4L2_CTRL_TYPE_MENU = 3,
    V4L2_CTRL_TYPE_BUTTON = 4,
    V4L2_CTRL_TYPE_INTEGER64 = 5,
    V4L2_CTRL_TYPE_CTRL_CLASS = 6,
    V4L2_CTRL_TYPE_STRING = 7,
    V4L2_CTRL_TYPE_BITMASK = 8,
    V4L2_CTRL_TYPE_INTEGER_MENU = 9,
    V4L2_CTRL_COMPOUND_TYPES = 256,
    V4L2_CTRL_TYPE_U8 = 256,
    V4L2_CTRL_TYPE_U16 = 257,
    V4L2_CTRL_TYPE_U32 = 258
} ;
#line 1486 "include/uapi/linux/videodev2.h"
struct v4l2_queryctrl {
   __u32 id ;
   __u32 type ;
   __u8 name[32U] ;
   __s32 minimum ;
   __s32 maximum ;
   __s32 step ;
   __s32 default_value ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1506 "include/uapi/linux/videodev2.h"
struct v4l2_query_ext_ctrl {
   __u32 id ;
   __u32 type ;
   char name[32U] ;
   __s64 minimum ;
   __s64 maximum ;
   __u64 step ;
   __s64 default_value ;
   __u32 flags ;
   __u32 elem_size ;
   __u32 elems ;
   __u32 nr_of_dims ;
   __u32 dims[4U] ;
   __u32 reserved[32U] ;
};
#line 1523 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_225 {
   __u8 name[32U] ;
   __s64 value ;
};
#line 1523 "include/uapi/linux/videodev2.h"
struct v4l2_querymenu {
   __u32 id ;
   __u32 index ;
   union __anonunion____missing_field_name_225 __annonCompField63 ;
   __u32 reserved ;
};
#line 1534 "include/uapi/linux/videodev2.h"
struct v4l2_tuner {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 rxsubchans ;
   __u32 audmode ;
   __s32 signal ;
   __s32 afc ;
   __u32 reserved[4U] ;
};
#line 1573 "include/uapi/linux/videodev2.h"
struct v4l2_modulator {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 txsubchans ;
   __u32 reserved[4U] ;
};
#line 1583 "include/uapi/linux/videodev2.h"
struct v4l2_frequency {
   __u32 tuner ;
   __u32 type ;
   __u32 frequency ;
   __u32 reserved[8U] ;
};
#line 1622 "include/uapi/linux/videodev2.h"
struct v4l2_frequency_band {
   __u32 tuner ;
   __u32 type ;
   __u32 index ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 modulation ;
   __u32 reserved[9U] ;
};
#line 1637 "include/uapi/linux/videodev2.h"
struct v4l2_hw_freq_seek {
   __u32 tuner ;
   __u32 type ;
   __u32 seek_upward ;
   __u32 wrap_around ;
   __u32 spacing ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 reserved[5U] ;
};
#line 1658 "include/uapi/linux/videodev2.h"
struct v4l2_audio {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 1680 "include/uapi/linux/videodev2.h"
struct v4l2_audioout {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 1695 "include/uapi/linux/videodev2.h"
struct v4l2_enc_idx_entry {
   __u64 offset ;
   __u64 pts ;
   __u32 length ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1714 "include/uapi/linux/videodev2.h"
struct v4l2_enc_idx {
   __u32 entries ;
   __u32 entries_cap ;
   __u32 reserved[4U] ;
   struct v4l2_enc_idx_entry entry[64U] ;
};
#line 1722 "include/uapi/linux/videodev2.h"
struct __anonstruct_raw_227 {
   __u32 data[8U] ;
};
#line 1722 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_226 {
   struct __anonstruct_raw_227 raw ;
};
#line 1722 "include/uapi/linux/videodev2.h"
struct v4l2_encoder_cmd {
   __u32 cmd ;
   __u32 flags ;
   union __anonunion____missing_field_name_226 __annonCompField64 ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct __anonstruct_stop_229 {
   __u64 pts ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct __anonstruct_start_230 {
   __s32 speed ;
   __u32 format ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct __anonstruct_raw_231 {
   __u32 data[16U] ;
};
#line 1741 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_228 {
   struct __anonstruct_stop_229 stop ;
   struct __anonstruct_start_230 start ;
   struct __anonstruct_raw_231 raw ;
};
#line 1741 "include/uapi/linux/videodev2.h"
struct v4l2_decoder_cmd {
   __u32 cmd ;
   __u32 flags ;
   union __anonunion____missing_field_name_228 __annonCompField65 ;
};
#line 1790 "include/uapi/linux/videodev2.h"
struct v4l2_vbi_format {
   __u32 sampling_rate ;
   __u32 offset ;
   __u32 samples_per_line ;
   __u32 sample_format ;
   __s32 start[2U] ;
   __u32 count[2U] ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1810 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_format {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 io_size ;
   __u32 reserved[2U] ;
};
#line 1838 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_cap {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 type ;
   __u32 reserved[3U] ;
};
#line 1862 "include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_data {
   __u32 id ;
   __u32 field ;
   __u32 line ;
   __u32 reserved ;
   __u8 data[48U] ;
};
#line 1917 "include/uapi/linux/videodev2.h"
struct v4l2_plane_pix_format {
   __u32 sizeimage ;
   __u32 bytesperline ;
   __u16 reserved[6U] ;
};
#line 1934 "include/uapi/linux/videodev2.h"
struct v4l2_pix_format_mplane {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 colorspace ;
   struct v4l2_plane_pix_format plane_fmt[8U] ;
   __u8 num_planes ;
   __u8 flags ;
   __u8 ycbcr_enc ;
   __u8 quantization ;
   __u8 xfer_func ;
   __u8 reserved[7U] ;
};
#line 1964 "include/uapi/linux/videodev2.h"
struct v4l2_sdr_format {
   __u32 pixelformat ;
   __u32 buffersize ;
   __u8 reserved[24U] ;
};
#line 1975 "include/uapi/linux/videodev2.h"
union __anonunion_fmt_233 {
   struct v4l2_pix_format pix ;
   struct v4l2_pix_format_mplane pix_mp ;
   struct v4l2_window win ;
   struct v4l2_vbi_format vbi ;
   struct v4l2_sliced_vbi_format sliced ;
   struct v4l2_sdr_format sdr ;
   __u8 raw_data[200U] ;
};
#line 1975 "include/uapi/linux/videodev2.h"
struct v4l2_format {
   __u32 type ;
   union __anonunion_fmt_233 fmt ;
};
#line 1998 "include/uapi/linux/videodev2.h"
union __anonunion_parm_234 {
   struct v4l2_captureparm capture ;
   struct v4l2_outputparm output ;
   __u8 raw_data[200U] ;
};
#line 1998 "include/uapi/linux/videodev2.h"
struct v4l2_streamparm {
   __u32 type ;
   union __anonunion_parm_234 parm ;
};
#line 2089 "include/uapi/linux/videodev2.h"
struct v4l2_event_subscription {
   __u32 type ;
   __u32 id ;
   __u32 flags ;
   __u32 reserved[5U] ;
};
#line 2099 "include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_237 {
   __u32 addr ;
   char name[32U] ;
};
#line 2099 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_match {
   __u32 type ;
   union __anonunion____missing_field_name_237 __annonCompField68 ;
};
#line 2125 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_register {
   struct v4l2_dbg_match match ;
   __u32 size ;
   __u64 reg ;
   __u64 val ;
};
#line 2132 "include/uapi/linux/videodev2.h"
struct v4l2_dbg_chip_info {
   struct v4l2_dbg_match match ;
   char name[32U] ;
   __u32 flags ;
   __u32 reserved[32U] ;
};
#line 2143 "include/uapi/linux/videodev2.h"
struct v4l2_create_buffers {
   __u32 index ;
   __u32 count ;
   __u32 memory ;
   struct v4l2_format format ;
   __u32 reserved[8U] ;
};
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_node;
#line 93 "include/linux/bit_spinlock.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_241 {
   spinlock_t lock ;
   int count ;
};
#line 114 "include/linux/rculist_bl.h"
union __anonunion____missing_field_name_240 {
   struct __anonstruct____missing_field_name_241 __annonCompField69 ;
};
#line 114 "include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_240 __annonCompField70 ;
};
#line 50 "include/linux/lockref.h"
struct path;
#line 51
struct vfsmount;
#line 52 "include/linux/lockref.h"
struct __anonstruct____missing_field_name_243 {
   u32 hash ;
   u32 len ;
};
#line 52 "include/linux/lockref.h"
union __anonunion____missing_field_name_242 {
   struct __anonstruct____missing_field_name_243 __annonCompField71 ;
   u64 hash_len ;
};
#line 52 "include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_242 __annonCompField72 ;
   unsigned char const   *name ;
};
#line 90 "include/linux/dcache.h"
struct dentry_operations;
#line 90 "include/linux/dcache.h"
union __anonunion_d_u_244 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_244 d_u ;
};
#line 142 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
#line 585 "include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 19 "include/linux/path.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 80 "include/linux/shrinker.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_248 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "include/linux/radix-tree.h"
union __anonunion____missing_field_name_247 {
   struct __anonstruct____missing_field_name_248 __annonCompField73 ;
   struct callback_head callback_head ;
};
#line 58 "include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_247 __annonCompField74 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "./include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 47
struct block_device;
#line 60 "include/uapi/linux/fs.h"
struct bdi_writeback;
#line 61
struct export_operations;
#line 64
struct kiocb;
#line 65
struct poll_table_struct;
#line 66
struct kstatfs;
#line 67
struct swap_info_struct;
#line 68
struct iov_iter;
#line 69
struct vm_fault;
#line 74 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 212 "./include/uapi/linux/dqblk_xfs.h"
struct dquot;
#line 19 "include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "include/linux/projid.h"
struct __anonstruct_kprojid_t_252 {
   projid_t val ;
};
#line 23 "include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_252 kprojid_t;
#line 166 "include/uapi/linux/quota.h"
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 66 "include/linux/quota.h"
typedef long long qsize_t;
#line 67 "include/linux/quota.h"
union __anonunion____missing_field_name_253 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 67 "include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_253 __annonCompField76 ;
   enum quota_type type ;
};
#line 184 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 206
struct quota_format_type;
#line 207 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 272 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 299 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 310 "include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
#line 325 "include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 348 "include/linux/quota.h"
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
   unsigned int ino_timelimit ;
   unsigned int rt_spc_timelimit ;
   unsigned int spc_warnlimit ;
   unsigned int ino_warnlimit ;
   unsigned int rt_spc_warnlimit ;
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
#line 394 "include/linux/quota.h"
struct qc_state {
   unsigned int s_incoredqs ;
   struct qc_type_state s_state[3U] ;
};
#line 405 "include/linux/quota.h"
struct qc_info {
   int i_fieldmask ;
   unsigned int i_flags ;
   unsigned int i_spc_timelimit ;
   unsigned int i_ino_timelimit ;
   unsigned int i_rt_spc_timelimit ;
   unsigned int i_spc_warnlimit ;
   unsigned int i_ino_warnlimit ;
   unsigned int i_rt_spc_warnlimit ;
};
#line 418 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 432 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 496 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
#line 526
struct writeback_control;
#line 527 "include/linux/quota.h"
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
};
#line 365 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 422 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 442
struct request_queue;
#line 443
struct hd_struct;
#line 443
struct gendisk;
#line 443 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 559
struct posix_acl;
#line 560
struct inode_operations;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_256 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_257 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 560
struct file_lock_context;
#line 560
struct cdev;
#line 560 "include/linux/fs.h"
union __anonunion____missing_field_name_258 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
#line 560 "include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_256 __annonCompField77 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   unsigned long dirtied_time_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_257 __annonCompField78 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_258 __annonCompField79 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 806 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 814 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 837 "include/linux/fs.h"
union __anonunion_f_u_259 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 837 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_259 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 922 "include/linux/fs.h"
typedef void *fl_owner_t;
#line 923
struct file_lock;
#line 924 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 930 "include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 951
struct nlm_lockowner;
#line 952 "include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "include/linux/nfs_fs_i.h"
struct __anonstruct_afs_261 {
   struct list_head link ;
   int state ;
};
#line 19 "include/linux/nfs_fs_i.h"
union __anonunion_fl_u_260 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_261 afs ;
};
#line 19 "include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_260 fl_u ;
};
#line 1004 "include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1062 "include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1240 "include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1271
struct super_operations;
#line 1271
struct xattr_handler;
#line 1271
struct mtd_info;
#line 1271 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_iflags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1510 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1524
struct dir_context;
#line 1549 "include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1556 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1617 "include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1671 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1910 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 62 "./arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 744 "./arch/x86/include/asm/uaccess.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 32 "include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 40 "include/linux/poll.h"
typedef struct poll_table_struct poll_table;
#line 163 "include/linux/poll.h"
struct v4l2_ioctl_ops {
   int (*vidioc_querycap)(struct file * , void * , struct v4l2_capability * ) ;
   int (*vidioc_enum_fmt_vid_cap)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_overlay)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_out)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_sdr_cap)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_g_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_reqbufs)(struct file * , void * , struct v4l2_requestbuffers * ) ;
   int (*vidioc_querybuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_qbuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_expbuf)(struct file * , void * , struct v4l2_exportbuffer * ) ;
   int (*vidioc_dqbuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_create_bufs)(struct file * , void * , struct v4l2_create_buffers * ) ;
   int (*vidioc_prepare_buf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_overlay)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_g_fbuf)(struct file * , void * , struct v4l2_framebuffer * ) ;
   int (*vidioc_s_fbuf)(struct file * , void * , struct v4l2_framebuffer  const  * ) ;
   int (*vidioc_streamon)(struct file * , void * , enum v4l2_buf_type  ) ;
   int (*vidioc_streamoff)(struct file * , void * , enum v4l2_buf_type  ) ;
   int (*vidioc_g_std)(struct file * , void * , v4l2_std_id * ) ;
   int (*vidioc_s_std)(struct file * , void * , v4l2_std_id  ) ;
   int (*vidioc_querystd)(struct file * , void * , v4l2_std_id * ) ;
   int (*vidioc_enum_input)(struct file * , void * , struct v4l2_input * ) ;
   int (*vidioc_g_input)(struct file * , void * , unsigned int * ) ;
   int (*vidioc_s_input)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_enum_output)(struct file * , void * , struct v4l2_output * ) ;
   int (*vidioc_g_output)(struct file * , void * , unsigned int * ) ;
   int (*vidioc_s_output)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_queryctrl)(struct file * , void * , struct v4l2_queryctrl * ) ;
   int (*vidioc_query_ext_ctrl)(struct file * , void * , struct v4l2_query_ext_ctrl * ) ;
   int (*vidioc_g_ctrl)(struct file * , void * , struct v4l2_control * ) ;
   int (*vidioc_s_ctrl)(struct file * , void * , struct v4l2_control * ) ;
   int (*vidioc_g_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_s_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_try_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_querymenu)(struct file * , void * , struct v4l2_querymenu * ) ;
   int (*vidioc_enumaudio)(struct file * , void * , struct v4l2_audio * ) ;
   int (*vidioc_g_audio)(struct file * , void * , struct v4l2_audio * ) ;
   int (*vidioc_s_audio)(struct file * , void * , struct v4l2_audio  const  * ) ;
   int (*vidioc_enumaudout)(struct file * , void * , struct v4l2_audioout * ) ;
   int (*vidioc_g_audout)(struct file * , void * , struct v4l2_audioout * ) ;
   int (*vidioc_s_audout)(struct file * , void * , struct v4l2_audioout  const  * ) ;
   int (*vidioc_g_modulator)(struct file * , void * , struct v4l2_modulator * ) ;
   int (*vidioc_s_modulator)(struct file * , void * , struct v4l2_modulator  const  * ) ;
   int (*vidioc_cropcap)(struct file * , void * , struct v4l2_cropcap * ) ;
   int (*vidioc_g_crop)(struct file * , void * , struct v4l2_crop * ) ;
   int (*vidioc_s_crop)(struct file * , void * , struct v4l2_crop  const  * ) ;
   int (*vidioc_g_selection)(struct file * , void * , struct v4l2_selection * ) ;
   int (*vidioc_s_selection)(struct file * , void * , struct v4l2_selection * ) ;
   int (*vidioc_g_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression * ) ;
   int (*vidioc_s_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression  const  * ) ;
   int (*vidioc_g_enc_index)(struct file * , void * , struct v4l2_enc_idx * ) ;
   int (*vidioc_encoder_cmd)(struct file * , void * , struct v4l2_encoder_cmd * ) ;
   int (*vidioc_try_encoder_cmd)(struct file * , void * , struct v4l2_encoder_cmd * ) ;
   int (*vidioc_decoder_cmd)(struct file * , void * , struct v4l2_decoder_cmd * ) ;
   int (*vidioc_try_decoder_cmd)(struct file * , void * , struct v4l2_decoder_cmd * ) ;
   int (*vidioc_g_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
   int (*vidioc_s_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
   int (*vidioc_g_tuner)(struct file * , void * , struct v4l2_tuner * ) ;
   int (*vidioc_s_tuner)(struct file * , void * , struct v4l2_tuner  const  * ) ;
   int (*vidioc_g_frequency)(struct file * , void * , struct v4l2_frequency * ) ;
   int (*vidioc_s_frequency)(struct file * , void * , struct v4l2_frequency  const  * ) ;
   int (*vidioc_enum_freq_bands)(struct file * , void * , struct v4l2_frequency_band * ) ;
   int (*vidioc_g_sliced_vbi_cap)(struct file * , void * , struct v4l2_sliced_vbi_cap * ) ;
   int (*vidioc_log_status)(struct file * , void * ) ;
   int (*vidioc_s_hw_freq_seek)(struct file * , void * , struct v4l2_hw_freq_seek  const  * ) ;
   int (*vidioc_g_register)(struct file * , void * , struct v4l2_dbg_register * ) ;
   int (*vidioc_s_register)(struct file * , void * , struct v4l2_dbg_register  const  * ) ;
   int (*vidioc_g_chip_info)(struct file * , void * , struct v4l2_dbg_chip_info * ) ;
   int (*vidioc_enum_framesizes)(struct file * , void * , struct v4l2_frmsizeenum * ) ;
   int (*vidioc_enum_frameintervals)(struct file * , void * , struct v4l2_frmivalenum * ) ;
   int (*vidioc_s_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_g_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_query_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_enum_dv_timings)(struct file * , void * , struct v4l2_enum_dv_timings * ) ;
   int (*vidioc_dv_timings_cap)(struct file * , void * , struct v4l2_dv_timings_cap * ) ;
   int (*vidioc_g_edid)(struct file * , void * , struct v4l2_edid * ) ;
   int (*vidioc_s_edid)(struct file * , void * , struct v4l2_edid * ) ;
   int (*vidioc_subscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
   int (*vidioc_unsubscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
   long (*vidioc_default)(struct file * , void * , bool  , unsigned int  , void * ) ;
};
#line 309 "include/media/v4l2-ioctl.h"
struct video_device;
#line 334
struct v4l2_subdev;
#line 13 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 186 "include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 253 "include/uapi/linux/usb/ch9.h"
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
};
#line 275 "include/uapi/linux/usb/ch9.h"
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
};
#line 343 "include/uapi/linux/usb/ch9.h"
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
};
#line 363 "include/uapi/linux/usb/ch9.h"
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
};
#line 613 "include/uapi/linux/usb/ch9.h"
struct usb_ss_ep_comp_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bMaxBurst ;
   __u8 bmAttributes ;
   __le16 wBytesPerInterval ;
};
#line 692 "include/uapi/linux/usb/ch9.h"
struct usb_interface_assoc_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bFirstInterface ;
   __u8 bInterfaceCount ;
   __u8 bFunctionClass ;
   __u8 bFunctionSubClass ;
   __u8 bFunctionProtocol ;
   __u8 iFunction ;
};
#line 751 "include/uapi/linux/usb/ch9.h"
struct usb_bos_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumDeviceCaps ;
};
#line 801 "include/uapi/linux/usb/ch9.h"
struct usb_ext_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __le32 bmAttributes ;
};
#line 811 "include/uapi/linux/usb/ch9.h"
struct usb_ss_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bmAttributes ;
   __le16 wSpeedSupported ;
   __u8 bFunctionalitySupport ;
   __u8 bU1devExitLat ;
   __le16 bU2DevExitLat ;
};
#line 840 "include/uapi/linux/usb/ch9.h"
struct usb_ss_container_id_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bReserved ;
   __u8 ContainerID[16U] ;
};
#line 905
enum usb_device_speed {
    USB_SPEED_UNKNOWN = 0,
    USB_SPEED_LOW = 1,
    USB_SPEED_FULL = 2,
    USB_SPEED_HIGH = 3,
    USB_SPEED_WIRELESS = 4,
    USB_SPEED_SUPER = 5
} ;
#line 914
enum usb_device_state {
    USB_STATE_NOTATTACHED = 0,
    USB_STATE_ATTACHED = 1,
    USB_STATE_POWERED = 2,
    USB_STATE_RECONNECTING = 3,
    USB_STATE_UNAUTHENTICATED = 4,
    USB_STATE_DEFAULT = 5,
    USB_STATE_ADDRESS = 6,
    USB_STATE_CONFIGURED = 7,
    USB_STATE_SUSPENDED = 8
} ;
#line 672 "include/linux/interrupt.h"
struct klist_node;
#line 37 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67 "include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 187
struct pinctrl;
#line 188
struct pinctrl_state;
#line 194 "include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "./arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct device_node;
#line 21
struct fwnode_handle;
#line 22
struct iommu_ops;
#line 23
struct iommu_group;
#line 61 "include/linux/device.h"
struct device_attribute;
#line 61 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 139
struct device_type;
#line 197
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
#line 203 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 353
struct class_attribute;
#line 353 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 446 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 514 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 542 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 674 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 683
struct dma_coherent_mem;
#line 683
struct cma;
#line 683 "include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 829 "include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 283 "include/linux/pm_runtime.h"
struct wusb_dev;
#line 284
struct ep_device;
#line 285 "include/linux/pm_runtime.h"
struct usb_host_endpoint {
   struct usb_endpoint_descriptor desc ;
   struct usb_ss_ep_comp_descriptor ss_ep_comp ;
   struct list_head urb_list ;
   void *hcpriv ;
   struct ep_device *ep_dev ;
   unsigned char *extra ;
   int extralen ;
   int enabled ;
   int streams ;
};
#line 77 "include/linux/usb.h"
struct usb_host_interface {
   struct usb_interface_descriptor desc ;
   int extralen ;
   unsigned char *extra ;
   struct usb_host_endpoint *endpoint ;
   char *string ;
};
#line 92
enum usb_interface_condition {
    USB_INTERFACE_UNBOUND = 0,
    USB_INTERFACE_BINDING = 1,
    USB_INTERFACE_BOUND = 2,
    USB_INTERFACE_UNBINDING = 3
} ;
#line 99 "include/linux/usb.h"
struct usb_interface {
   struct usb_host_interface *altsetting ;
   struct usb_host_interface *cur_altsetting ;
   unsigned int num_altsetting ;
   struct usb_interface_assoc_descriptor *intf_assoc ;
   int minor ;
   enum usb_interface_condition condition ;
   unsigned char sysfs_files_created : 1 ;
   unsigned char ep_devs_created : 1 ;
   unsigned char unregistering : 1 ;
   unsigned char needs_remote_wakeup : 1 ;
   unsigned char needs_altsetting0 : 1 ;
   unsigned char needs_binding : 1 ;
   unsigned char resetting_device : 1 ;
   struct device dev ;
   struct device *usb_dev ;
   atomic_t pm_usage_cnt ;
   struct work_struct reset_ws ;
};
#line 201 "include/linux/usb.h"
struct usb_interface_cache {
   unsigned int num_altsetting ;
   struct kref ref ;
   struct usb_host_interface altsetting[0U] ;
};
#line 256 "include/linux/usb.h"
struct usb_host_config {
   struct usb_config_descriptor desc ;
   char *string ;
   struct usb_interface_assoc_descriptor *intf_assoc[16U] ;
   struct usb_interface *interface[32U] ;
   struct usb_interface_cache *intf_cache[32U] ;
   unsigned char *extra ;
   int extralen ;
};
#line 320 "include/linux/usb.h"
struct usb_host_bos {
   struct usb_bos_descriptor *desc ;
   struct usb_ext_cap_descriptor *ext_cap ;
   struct usb_ss_cap_descriptor *ss_cap ;
   struct usb_ss_container_id_descriptor *ss_id ;
};
#line 332 "include/linux/usb.h"
struct usb_devmap {
   unsigned long devicemap[2U] ;
};
#line 344
struct mon_bus;
#line 344 "include/linux/usb.h"
struct usb_bus {
   struct device *controller ;
   int busnum ;
   char const   *bus_name ;
   u8 uses_dma ;
   u8 uses_pio_for_control ;
   u8 otg_port ;
   unsigned char is_b_host : 1 ;
   unsigned char b_hnp_enable : 1 ;
   unsigned char no_stop_on_short : 1 ;
   unsigned char no_sg_constraint : 1 ;
   unsigned int sg_tablesize ;
   int devnum_next ;
   struct usb_devmap devmap ;
   struct usb_device *root_hub ;
   struct usb_bus *hs_companion ;
   struct list_head bus_list ;
   struct mutex usb_address0_mutex ;
   int bandwidth_allocated ;
   int bandwidth_int_reqs ;
   int bandwidth_isoc_reqs ;
   unsigned int resuming_ports ;
   struct mon_bus *mon_bus ;
   int monitored ;
};
#line 395
struct usb_tt;
#line 396
enum usb_device_removable {
    USB_DEVICE_REMOVABLE_UNKNOWN = 0,
    USB_DEVICE_REMOVABLE = 1,
    USB_DEVICE_FIXED = 2
} ;
#line 409 "include/linux/usb.h"
struct usb2_lpm_parameters {
   unsigned int besl ;
   int timeout ;
};
#line 430 "include/linux/usb.h"
struct usb3_lpm_parameters {
   unsigned int mel ;
   unsigned int pel ;
   unsigned int sel ;
   int timeout ;
};
#line 469 "include/linux/usb.h"
struct usb_device {
   int devnum ;
   char devpath[16U] ;
   u32 route ;
   enum usb_device_state state ;
   enum usb_device_speed speed ;
   struct usb_tt *tt ;
   int ttport ;
   unsigned int toggle[2U] ;
   struct usb_device *parent ;
   struct usb_bus *bus ;
   struct usb_host_endpoint ep0 ;
   struct device dev ;
   struct usb_device_descriptor descriptor ;
   struct usb_host_bos *bos ;
   struct usb_host_config *config ;
   struct usb_host_config *actconfig ;
   struct usb_host_endpoint *ep_in[16U] ;
   struct usb_host_endpoint *ep_out[16U] ;
   char **rawdescriptors ;
   unsigned short bus_mA ;
   u8 portnum ;
   u8 level ;
   unsigned char can_submit : 1 ;
   unsigned char persist_enabled : 1 ;
   unsigned char have_langid : 1 ;
   unsigned char authorized : 1 ;
   unsigned char authenticated : 1 ;
   unsigned char wusb : 1 ;
   unsigned char lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_besl_capable : 1 ;
   unsigned char usb2_hw_lpm_enabled : 1 ;
   unsigned char usb2_hw_lpm_allowed : 1 ;
   unsigned char usb3_lpm_enabled : 1 ;
   int string_langid ;
   char *product ;
   char *manufacturer ;
   char *serial ;
   struct list_head filelist ;
   int maxchild ;
   u32 quirks ;
   atomic_t urbnum ;
   unsigned long active_duration ;
   unsigned long connect_time ;
   unsigned char do_remote_wakeup : 1 ;
   unsigned char reset_resume : 1 ;
   unsigned char port_is_suspended : 1 ;
   struct wusb_dev *wusb_dev ;
   int slot_id ;
   enum usb_device_removable removable ;
   struct usb2_lpm_parameters l1_params ;
   struct usb3_lpm_parameters u1_params ;
   struct usb3_lpm_parameters u2_params ;
   unsigned int lpm_disable_count ;
};
#line 1200 "include/linux/usb.h"
struct usb_iso_packet_descriptor {
   unsigned int offset ;
   unsigned int length ;
   unsigned int actual_length ;
   int status ;
};
#line 1242
struct urb;
#line 1243 "include/linux/usb.h"
struct usb_anchor {
   struct list_head urb_list ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
   atomic_t suspend_wakeups ;
   unsigned char poisoned : 1 ;
};
#line 1262
struct scatterlist;
#line 1262 "include/linux/usb.h"
struct urb {
   struct kref kref ;
   void *hcpriv ;
   atomic_t use_count ;
   atomic_t reject ;
   int unlinked ;
   struct list_head urb_list ;
   struct list_head anchor_list ;
   struct usb_anchor *anchor ;
   struct usb_device *dev ;
   struct usb_host_endpoint *ep ;
   unsigned int pipe ;
   unsigned int stream_id ;
   int status ;
   unsigned int transfer_flags ;
   void *transfer_buffer ;
   dma_addr_t transfer_dma ;
   struct scatterlist *sg ;
   int num_mapped_sgs ;
   int num_sgs ;
   u32 transfer_buffer_length ;
   u32 actual_length ;
   unsigned char *setup_packet ;
   dma_addr_t setup_dma ;
   int start_frame ;
   int number_of_packets ;
   int interval ;
   int error_count ;
   void *context ;
   void (*complete)(struct urb * ) ;
   struct usb_iso_packet_descriptor iso_frame_desc[0U] ;
};
#line 1894 "include/linux/usb.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 169 "./include/uapi/linux/media.h"
struct media_pipeline {

};
#line 172
struct media_pad;
#line 172 "./include/uapi/linux/media.h"
struct media_link {
   struct media_pad *source ;
   struct media_pad *sink ;
   struct media_link *reverse ;
   unsigned long flags ;
};
#line 40 "include/media/media-entity.h"
struct media_entity;
#line 40 "include/media/media-entity.h"
struct media_pad {
   struct media_entity *entity ;
   u16 index ;
   unsigned long flags ;
};
#line 46 "include/media/media-entity.h"
struct media_entity_operations {
   int (*link_setup)(struct media_entity * , struct media_pad  const  * , struct media_pad  const  * ,
                     u32  ) ;
   int (*link_validate)(struct media_link * ) ;
};
#line 62
struct media_device;
#line 62 "include/media/media-entity.h"
struct __anonstruct_dev_280 {
   u32 major ;
   u32 minor ;
};
#line 62 "include/media/media-entity.h"
union __anonunion_info_279 {
   struct __anonstruct_dev_280 dev ;
};
#line 62 "include/media/media-entity.h"
struct media_entity {
   struct list_head list ;
   struct media_device *parent ;
   u32 id ;
   char const   *name ;
   u32 type ;
   u32 revision ;
   unsigned long flags ;
   u32 group_id ;
   u16 num_pads ;
   u16 num_links ;
   u16 num_backlinks ;
   u16 max_links ;
   struct media_pad *pads ;
   struct media_link *links ;
   struct media_entity_operations  const  *ops ;
   int stream_count ;
   int use_count ;
   struct media_pipeline *pipe ;
   union __anonunion_info_279 info ;
};
#line 155
struct v4l2_device;
#line 156
struct v4l2_ctrl_handler;
#line 157 "include/media/media-entity.h"
struct v4l2_prio_state {
   atomic_t prios[4U] ;
};
#line 61 "include/media/v4l2-dev.h"
struct v4l2_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl32)(struct file * , unsigned int  , unsigned long  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 78
struct vb2_queue;
#line 78 "include/media/v4l2-dev.h"
struct video_device {
   struct media_entity entity ;
   struct v4l2_file_operations  const  *fops ;
   struct device dev ;
   struct cdev *cdev ;
   struct v4l2_device *v4l2_dev ;
   struct device *dev_parent ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct vb2_queue *queue ;
   struct v4l2_prio_state *prio ;
   char name[32U] ;
   int vfl_type ;
   int vfl_dir ;
   int minor ;
   u16 num ;
   unsigned long flags ;
   int index ;
   spinlock_t fh_lock ;
   struct list_head fh_list ;
   int dev_debug ;
   v4l2_std_id tvnorms ;
   void (*release)(struct video_device * ) ;
   struct v4l2_ioctl_ops  const  *ioctl_ops ;
   unsigned long valid_ioctls[3U] ;
   unsigned long disable_locking[3U] ;
   struct mutex *lock ;
};
#line 89 "include/media/v4l2-common.h"
struct v4l2_subdev_ops;
#line 207 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 239 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 2242 "include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 147 "include/media/v4l2-common.h"
struct v4l2_priv_tun_config {
   int tuner ;
   void *priv ;
};
#line 191 "include/media/v4l2-common.h"
struct media_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 53 "include/media/media-devnode.h"
struct media_devnode {
   struct media_file_operations  const  *fops ;
   struct device dev ;
   struct cdev cdev ;
   struct device *parent ;
   int minor ;
   unsigned long flags ;
   void (*release)(struct media_devnode * ) ;
};
#line 98 "include/media/media-devnode.h"
struct media_device {
   struct device *dev ;
   struct media_devnode devnode ;
   char model[32U] ;
   char serial[40U] ;
   char bus_info[32U] ;
   u32 hw_revision ;
   u32 driver_version ;
   u32 entity_id ;
   struct list_head entities ;
   spinlock_t lock ;
   struct mutex graph_mutex ;
   int (*link_notify)(struct media_link * , u32  , unsigned int  ) ;
};
#line 98 "include/media/media-device.h"
struct v4l2_mbus_framefmt {
   __u32 width ;
   __u32 height ;
   __u32 code ;
   __u32 field ;
   __u32 colorspace ;
   __u16 ycbcr_enc ;
   __u16 quantization ;
   __u16 xfer_func ;
   __u16 reserved[11U] ;
};
#line 45 "./include/uapi/linux/v4l2-mediabus.h"
struct v4l2_subdev_format {
   __u32 which ;
   __u32 pad ;
   struct v4l2_mbus_framefmt format ;
   __u32 reserved[8U] ;
};
#line 66 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_mbus_code_enum {
   __u32 pad ;
   __u32 index ;
   __u32 code ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 81 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_size_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 100 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval {
   __u32 pad ;
   struct v4l2_fract interval ;
   __u32 reserved[9U] ;
};
#line 111 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 width ;
   __u32 height ;
   struct v4l2_fract interval ;
   __u32 which ;
   __u32 reserved[8U] ;
};
#line 132 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_selection {
   __u32 which ;
   __u32 pad ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[8U] ;
};
#line 156
struct v4l2_async_notifier;
#line 157
enum v4l2_async_match_type {
    V4L2_ASYNC_MATCH_CUSTOM = 0,
    V4L2_ASYNC_MATCH_DEVNAME = 1,
    V4L2_ASYNC_MATCH_I2C = 2,
    V4L2_ASYNC_MATCH_OF = 3
} ;
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_of_283 {
   struct device_node  const  *node ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_device_name_284 {
   char const   *name ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_i2c_285 {
   int adapter_id ;
   unsigned short address ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_custom_286 {
   bool (*match)(struct device * , struct v4l2_async_subdev * ) ;
   void *priv ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
union __anonunion_match_282 {
   struct __anonstruct_of_283 of ;
   struct __anonstruct_device_name_284 device_name ;
   struct __anonstruct_i2c_285 i2c ;
   struct __anonstruct_custom_286 custom ;
};
#line 164 "./include/uapi/linux/v4l2-subdev.h"
struct v4l2_async_subdev {
   enum v4l2_async_match_type match_type ;
   union __anonunion_match_282 match ;
   struct list_head list ;
};
#line 63 "include/media/v4l2-async.h"
struct v4l2_async_notifier {
   unsigned int num_subdevs ;
   struct v4l2_async_subdev **subdevs ;
   struct v4l2_device *v4l2_dev ;
   struct list_head waiting ;
   struct list_head done ;
   struct list_head list ;
   int (*bound)(struct v4l2_async_notifier * , struct v4l2_subdev * , struct v4l2_async_subdev * ) ;
   int (*complete)(struct v4l2_async_notifier * ) ;
   void (*unbind)(struct v4l2_async_notifier * , struct v4l2_subdev * , struct v4l2_async_subdev * ) ;
};
#line 97
struct v4l2_m2m_ctx;
#line 97 "include/media/v4l2-async.h"
struct v4l2_fh {
   struct list_head list ;
   struct video_device *vdev ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   enum v4l2_priority prio ;
   wait_queue_head_t wait ;
   struct list_head subscribed ;
   struct list_head available ;
   unsigned int navailable ;
   u32 sequence ;
   struct v4l2_m2m_ctx *m2m_ctx ;
};
#line 106 "include/media/v4l2-fh.h"
enum v4l2_mbus_type {
    V4L2_MBUS_PARALLEL = 0,
    V4L2_MBUS_BT656 = 1,
    V4L2_MBUS_CSI2 = 2
} ;
#line 112 "include/media/v4l2-fh.h"
struct v4l2_mbus_config {
   enum v4l2_mbus_type type ;
   unsigned int flags ;
};
#line 115 "include/media/v4l2-mediabus.h"
struct v4l2_subdev_fh;
#line 116
struct tuner_setup;
#line 117
struct v4l2_mbus_frame_desc;
#line 118 "include/media/v4l2-mediabus.h"
struct v4l2_decode_vbi_line {
   u32 is_second_field ;
   u8 *p ;
   u32 line ;
   u32 type ;
};
#line 63 "include/media/v4l2-subdev.h"
struct v4l2_subdev_io_pin_config {
   u32 flags ;
   u8 pin ;
   u8 function ;
   u8 value ;
   u8 strength ;
};
#line 119 "include/media/v4l2-subdev.h"
struct v4l2_subdev_core_ops {
   int (*log_status)(struct v4l2_subdev * ) ;
   int (*s_io_pin_config)(struct v4l2_subdev * , size_t  , struct v4l2_subdev_io_pin_config * ) ;
   int (*init)(struct v4l2_subdev * , u32  ) ;
   int (*load_fw)(struct v4l2_subdev * ) ;
   int (*reset)(struct v4l2_subdev * , u32  ) ;
   int (*s_gpio)(struct v4l2_subdev * , u32  ) ;
   int (*queryctrl)(struct v4l2_subdev * , struct v4l2_queryctrl * ) ;
   int (*g_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*s_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*g_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*s_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*try_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*querymenu)(struct v4l2_subdev * , struct v4l2_querymenu * ) ;
   long (*ioctl)(struct v4l2_subdev * , unsigned int  , void * ) ;
   long (*compat_ioctl32)(struct v4l2_subdev * , unsigned int  , unsigned long  ) ;
   int (*g_register)(struct v4l2_subdev * , struct v4l2_dbg_register * ) ;
   int (*s_register)(struct v4l2_subdev * , struct v4l2_dbg_register  const  * ) ;
   int (*s_power)(struct v4l2_subdev * , int  ) ;
   int (*interrupt_service_routine)(struct v4l2_subdev * , u32  , bool * ) ;
   int (*subscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
   int (*unsubscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
};
#line 180 "include/media/v4l2-subdev.h"
struct v4l2_subdev_tuner_ops {
   int (*s_radio)(struct v4l2_subdev * ) ;
   int (*s_frequency)(struct v4l2_subdev * , struct v4l2_frequency  const  * ) ;
   int (*g_frequency)(struct v4l2_subdev * , struct v4l2_frequency * ) ;
   int (*enum_freq_bands)(struct v4l2_subdev * , struct v4l2_frequency_band * ) ;
   int (*g_tuner)(struct v4l2_subdev * , struct v4l2_tuner * ) ;
   int (*s_tuner)(struct v4l2_subdev * , struct v4l2_tuner  const  * ) ;
   int (*g_modulator)(struct v4l2_subdev * , struct v4l2_modulator * ) ;
   int (*s_modulator)(struct v4l2_subdev * , struct v4l2_modulator  const  * ) ;
   int (*s_type_addr)(struct v4l2_subdev * , struct tuner_setup * ) ;
   int (*s_config)(struct v4l2_subdev * , struct v4l2_priv_tun_config  const  * ) ;
};
#line 207 "include/media/v4l2-subdev.h"
struct v4l2_subdev_audio_ops {
   int (*s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_i2s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
};
#line 234 "include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc_entry {
   u16 flags ;
   u32 pixelcode ;
   u32 length ;
};
#line 255 "include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc {
   struct v4l2_mbus_frame_desc_entry entry[4U] ;
   unsigned short num_entries ;
};
#line 267 "include/media/v4l2-subdev.h"
struct v4l2_subdev_video_ops {
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_crystal_freq)(struct v4l2_subdev * , u32  , u32  ) ;
   int (*g_std)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*s_std)(struct v4l2_subdev * , v4l2_std_id  ) ;
   int (*s_std_output)(struct v4l2_subdev * , v4l2_std_id  ) ;
   int (*g_std_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*querystd)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_tvnorms)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_tvnorms_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_input_status)(struct v4l2_subdev * , u32 * ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
   int (*cropcap)(struct v4l2_subdev * , struct v4l2_cropcap * ) ;
   int (*g_crop)(struct v4l2_subdev * , struct v4l2_crop * ) ;
   int (*s_crop)(struct v4l2_subdev * , struct v4l2_crop  const  * ) ;
   int (*g_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*s_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*g_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*s_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*s_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*g_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*query_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*g_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config * ) ;
   int (*s_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config  const  * ) ;
   int (*s_rx_buffer)(struct v4l2_subdev * , void * , unsigned int * ) ;
};
#line 341 "include/media/v4l2-subdev.h"
struct v4l2_subdev_vbi_ops {
   int (*decode_vbi_line)(struct v4l2_subdev * , struct v4l2_decode_vbi_line * ) ;
   int (*s_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data  const  * ) ;
   int (*g_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data * ) ;
   int (*g_sliced_vbi_cap)(struct v4l2_subdev * , struct v4l2_sliced_vbi_cap * ) ;
   int (*s_raw_fmt)(struct v4l2_subdev * , struct v4l2_vbi_format * ) ;
   int (*g_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
   int (*s_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
};
#line 381 "include/media/v4l2-subdev.h"
struct v4l2_subdev_sensor_ops {
   int (*g_skip_top_lines)(struct v4l2_subdev * , u32 * ) ;
   int (*g_skip_frames)(struct v4l2_subdev * , u32 * ) ;
};
#line 396
enum v4l2_subdev_ir_mode {
    V4L2_SUBDEV_IR_MODE_PULSE_WIDTH = 0
} ;
#line 400 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_parameters {
   unsigned int bytes_per_data_element ;
   enum v4l2_subdev_ir_mode mode ;
   bool enable ;
   bool interrupt_enable ;
   bool shutdown ;
   bool modulation ;
   u32 max_pulse_width ;
   unsigned int carrier_freq ;
   unsigned int duty_cycle ;
   bool invert_level ;
   bool invert_carrier_sense ;
   u32 noise_filter_min_width ;
   unsigned int carrier_range_lower ;
   unsigned int carrier_range_upper ;
   u32 resolution ;
};
#line 448 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_ops {
   int (*rx_read)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*rx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*rx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_write)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*tx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
};
#line 467 "include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_config {
   struct v4l2_mbus_framefmt try_fmt ;
   struct v4l2_rect try_crop ;
   struct v4l2_rect try_compose ;
};
#line 480 "include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_ops {
   int (*enum_mbus_code)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * ,
                         struct v4l2_subdev_mbus_code_enum * ) ;
   int (*enum_frame_size)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * ,
                          struct v4l2_subdev_frame_size_enum * ) ;
   int (*enum_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * ,
                              struct v4l2_subdev_frame_interval_enum * ) ;
   int (*get_fmt)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_format * ) ;
   int (*set_fmt)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_format * ) ;
   int (*get_selection)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_selection * ) ;
   int (*set_selection)(struct v4l2_subdev * , struct v4l2_subdev_pad_config * , struct v4l2_subdev_selection * ) ;
   int (*get_edid)(struct v4l2_subdev * , struct v4l2_edid * ) ;
   int (*set_edid)(struct v4l2_subdev * , struct v4l2_edid * ) ;
   int (*dv_timings_cap)(struct v4l2_subdev * , struct v4l2_dv_timings_cap * ) ;
   int (*enum_dv_timings)(struct v4l2_subdev * , struct v4l2_enum_dv_timings * ) ;
   int (*link_validate)(struct v4l2_subdev * , struct media_link * , struct v4l2_subdev_format * ,
                        struct v4l2_subdev_format * ) ;
   int (*get_frame_desc)(struct v4l2_subdev * , unsigned int  , struct v4l2_mbus_frame_desc * ) ;
   int (*set_frame_desc)(struct v4l2_subdev * , unsigned int  , struct v4l2_mbus_frame_desc * ) ;
};
#line 524 "include/media/v4l2-subdev.h"
struct v4l2_subdev_ops {
   struct v4l2_subdev_core_ops  const  *core ;
   struct v4l2_subdev_tuner_ops  const  *tuner ;
   struct v4l2_subdev_audio_ops  const  *audio ;
   struct v4l2_subdev_video_ops  const  *video ;
   struct v4l2_subdev_vbi_ops  const  *vbi ;
   struct v4l2_subdev_ir_ops  const  *ir ;
   struct v4l2_subdev_sensor_ops  const  *sensor ;
   struct v4l2_subdev_pad_ops  const  *pad ;
};
#line 536 "include/media/v4l2-subdev.h"
struct v4l2_subdev_internal_ops {
   int (*registered)(struct v4l2_subdev * ) ;
   void (*unregistered)(struct v4l2_subdev * ) ;
   int (*open)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
   int (*close)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
};
#line 557
struct regulator_bulk_data;
#line 558 "include/media/v4l2-subdev.h"
struct v4l2_subdev_platform_data {
   struct regulator_bulk_data *regulators ;
   int num_regulators ;
   void *host_priv ;
};
#line 579 "include/media/v4l2-subdev.h"
struct v4l2_subdev {
   struct media_entity entity ;
   struct list_head list ;
   struct module *owner ;
   bool owner_v4l2_dev ;
   u32 flags ;
   struct v4l2_device *v4l2_dev ;
   struct v4l2_subdev_ops  const  *ops ;
   struct v4l2_subdev_internal_ops  const  *internal_ops ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   char name[32U] ;
   u32 grp_id ;
   void *dev_priv ;
   void *host_priv ;
   struct video_device *devnode ;
   struct device *dev ;
   struct device_node *of_node ;
   struct list_head async_list ;
   struct v4l2_async_subdev *asd ;
   struct v4l2_async_notifier *notifier ;
   struct v4l2_subdev_platform_data *pdata ;
};
#line 619 "include/media/v4l2-subdev.h"
struct v4l2_subdev_fh {
   struct v4l2_fh vfh ;
   struct v4l2_subdev_pad_config *pad ;
};
#line 684 "include/media/v4l2-subdev.h"
struct v4l2_device {
   struct device *dev ;
   struct media_device *mdev ;
   struct list_head subdevs ;
   spinlock_t lock ;
   char name[36U] ;
   void (*notify)(struct v4l2_subdev * , unsigned int  , void * ) ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct v4l2_prio_state prio ;
   struct kref ref ;
   void (*release)(struct v4l2_device * ) ;
};
#line 128 "include/media/v4l2-device.h"
struct v4l2_ctrl_helper;
#line 129
struct v4l2_ctrl;
#line 130 "include/media/v4l2-device.h"
union v4l2_ctrl_ptr {
   s32 *p_s32 ;
   s64 *p_s64 ;
   u8 *p_u8 ;
   u16 *p_u16 ;
   u32 *p_u32 ;
   char *p_char ;
   void *p ;
};
#line 57 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_ops {
   int (*g_volatile_ctrl)(struct v4l2_ctrl * ) ;
   int (*try_ctrl)(struct v4l2_ctrl * ) ;
   int (*s_ctrl)(struct v4l2_ctrl * ) ;
};
#line 75 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_type_ops {
   bool (*equal)(struct v4l2_ctrl  const  * , u32  , union v4l2_ctrl_ptr  , union v4l2_ctrl_ptr  ) ;
   void (*init)(struct v4l2_ctrl  const  * , u32  , union v4l2_ctrl_ptr  ) ;
   void (*log)(struct v4l2_ctrl  const  * ) ;
   int (*validate)(struct v4l2_ctrl  const  * , u32  , union v4l2_ctrl_ptr  ) ;
};
#line 94 "include/media/v4l2-ctrls.h"
union __anonunion____missing_field_name_287 {
   u64 step ;
   u64 menu_skip_mask ;
};
#line 94 "include/media/v4l2-ctrls.h"
union __anonunion____missing_field_name_288 {
   char const   * const  *qmenu ;
   s64 const   *qmenu_int ;
};
#line 94 "include/media/v4l2-ctrls.h"
struct __anonstruct_cur_289 {
   s32 val ;
};
#line 94 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl {
   struct list_head node ;
   struct list_head ev_subs ;
   struct v4l2_ctrl_handler *handler ;
   struct v4l2_ctrl **cluster ;
   unsigned int ncontrols ;
   unsigned char done : 1 ;
   unsigned char is_new : 1 ;
   unsigned char has_changed : 1 ;
   unsigned char is_private : 1 ;
   unsigned char is_auto : 1 ;
   unsigned char is_int : 1 ;
   unsigned char is_string : 1 ;
   unsigned char is_ptr : 1 ;
   unsigned char is_array : 1 ;
   unsigned char has_volatiles : 1 ;
   unsigned char call_notify : 1 ;
   unsigned char manual_mode_value ;
   struct v4l2_ctrl_ops  const  *ops ;
   struct v4l2_ctrl_type_ops  const  *type_ops ;
   u32 id ;
   char const   *name ;
   enum v4l2_ctrl_type type ;
   s64 minimum ;
   s64 maximum ;
   s64 default_value ;
   u32 elems ;
   u32 elem_size ;
   u32 dims[4U] ;
   u32 nr_of_dims ;
   union __anonunion____missing_field_name_287 __annonCompField88 ;
   union __anonunion____missing_field_name_288 __annonCompField89 ;
   unsigned long flags ;
   void *priv ;
   s32 val ;
   struct __anonstruct_cur_289 cur ;
   union v4l2_ctrl_ptr p_new ;
   union v4l2_ctrl_ptr p_cur ;
};
#line 212 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_ref {
   struct list_head node ;
   struct v4l2_ctrl_ref *next ;
   struct v4l2_ctrl *ctrl ;
   struct v4l2_ctrl_helper *helper ;
};
#line 229 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_handler {
   struct mutex _lock ;
   struct mutex *lock ;
   struct list_head ctrls ;
   struct list_head ctrl_refs ;
   struct v4l2_ctrl_ref *cached ;
   struct v4l2_ctrl_ref **buckets ;
   void (*notify)(struct v4l2_ctrl * , void * ) ;
   void *notify_priv ;
   u16 nr_of_buckets ;
   int error ;
};
#line 261 "include/media/v4l2-ctrls.h"
struct v4l2_ctrl_config {
   struct v4l2_ctrl_ops  const  *ops ;
   struct v4l2_ctrl_type_ops  const  *type_ops ;
   u32 id ;
   char const   *name ;
   enum v4l2_ctrl_type type ;
   s64 min ;
   s64 max ;
   u64 step ;
   s64 def ;
   u32 dims[4U] ;
   u32 elem_size ;
   u32 flags ;
   u64 menu_skip_mask ;
   char const   * const  *qmenu ;
   s64 const   *qmenu_int ;
   unsigned char is_private : 1 ;
};
#line 848
enum sensors {
    CPIA2_SENSOR_410 = 0,
    CPIA2_SENSOR_500 = 1
} ;
#line 853
enum frame_status {
    FRAME_EMPTY = 0,
    FRAME_READING = 1,
    FRAME_READY = 2,
    FRAME_ERROR = 3
} ;
#line 259 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
struct __anonstruct_version_290 {
   u8 firmware_revision_hi ;
   u8 firmware_revision_lo ;
   u8 asic_id ;
   u8 asic_rev ;
   u8 vp_device_hi ;
   u8 vp_device_lo ;
   u8 sensor_flags ;
   u8 sensor_rev ;
};
#line 259 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
struct __anonstruct_pnp_id_291 {
   u32 device_type ;
   u16 vendor ;
   u16 product ;
   u16 device_revision ;
};
#line 259 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
struct __anonstruct_color_params_292 {
   u8 brightness ;
   u8 contrast ;
   u8 saturation ;
};
#line 259 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
struct __anonstruct_flicker_control_293 {
   u8 cam_register ;
   u8 flicker_mode_req ;
};
#line 259 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
struct __anonstruct_compression_294 {
   u8 jpeg_options ;
   u8 creep_period ;
   u8 user_squeeze ;
   u8 inhibit_htables ;
};
#line 259 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
struct __anonstruct_image_size_295 {
   u8 ohsize ;
   u8 ovsize ;
   u8 hcrop ;
   u8 vcrop ;
   u8 hphase ;
   u8 vphase ;
   u8 hispan ;
   u8 vispan ;
   u8 hicrop ;
   u8 vicrop ;
   u8 hifraction ;
   u8 vifraction ;
};
#line 259 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
struct __anonstruct_roi_296 {
   int width ;
   int height ;
};
#line 259 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
struct __anonstruct_vp_params_297 {
   u8 video_mode ;
   u8 frame_rate ;
   u8 video_size ;
   u8 gpio_direction ;
   u8 gpio_data ;
   u8 system_ctrl ;
   u8 system_state ;
   u8 lowlight_boost ;
   u8 device_config ;
   u8 exposure_modes ;
   u8 user_effects ;
};
#line 259 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
struct __anonstruct_vc_params_298 {
   u8 pw_control ;
   u8 wakeup ;
   u8 vc_control ;
   u8 vc_mp_direction ;
   u8 vc_mp_data ;
   u8 quality ;
};
#line 259 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
struct __anonstruct_camera_state_299 {
   u8 power_mode ;
   u8 system_ctrl ;
   u8 stream_mode ;
   u8 allow_corrupt ;
};
#line 259 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
struct camera_params {
   struct __anonstruct_version_290 version ;
   struct __anonstruct_pnp_id_291 pnp_id ;
   struct __anonstruct_color_params_292 color_params ;
   struct __anonstruct_flicker_control_293 flicker_control ;
   struct __anonstruct_compression_294 compression ;
   struct __anonstruct_image_size_295 image_size ;
   struct __anonstruct_roi_296 roi ;
   struct __anonstruct_vp_params_297 vp_params ;
   struct __anonstruct_vc_params_298 vc_params ;
   struct __anonstruct_camera_state_299 camera_state ;
};
#line 348 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
struct cpia2_sbuf {
   char *data ;
   struct urb *urb ;
};
#line 355 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
struct framebuf {
   struct timeval timestamp ;
   unsigned long seq ;
   int num ;
   int length ;
   int max_length ;
   enum frame_status  volatile  status ;
   u8 *data ;
   struct framebuf *next ;
};
#line 366 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
struct __anonstruct____missing_field_name_300 {
   struct v4l2_ctrl *top_light ;
   struct v4l2_ctrl *bottom_light ;
};
#line 366 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
struct camera_data {
   struct v4l2_device v4l2_dev ;
   struct mutex v4l2_lock ;
   struct v4l2_ctrl_handler hdl ;
   struct __anonstruct____missing_field_name_300 __annonCompField90 ;
   struct v4l2_ctrl *usb_alt ;
   int first_image_seen ;
   enum sensors sensor_type ;
   u8 flush ;
   struct v4l2_fh *stream_fh ;
   u8 mmapped ;
   int streaming ;
   int xfer_mode ;
   struct camera_params params ;
   int video_size ;
   struct video_device vdev ;
   u32 width ;
   u32 height ;
   __u32 pixelformat ;
   struct usb_device *dev ;
   unsigned char iface ;
   unsigned int cur_alt ;
   unsigned int old_alt ;
   struct cpia2_sbuf sbuf[2U] ;
   wait_queue_head_t wq_stream ;
   u32 frame_size ;
   int num_frames ;
   unsigned long frame_count ;
   u8 *frame_buffer ;
   struct framebuf *buffers ;
   struct framebuf * volatile  curbuff ;
   struct framebuf *workbuff ;
   int APPn ;
   int APP_len ;
   char APP_data[60U] ;
   int COM_len ;
   char COM_data[60U] ;
};
#line 506 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
struct framerate_info {
   int value ;
   struct v4l2_fract period ;
};
#line 575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
struct __anonstruct_cpia2_framesizes_303 {
   u32 width ;
   u32 height ;
};
#line 709 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
typedef int ldv_func_ret_type;
#line 744 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
typedef int ldv_func_ret_type___0;
#line 779 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
typedef int ldv_func_ret_type___1;
#line 846 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
typedef int ldv_func_ret_type___2;
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 39 "include/linux/mod_devicetable.h"
struct usb_device_id {
   __u16 match_flags ;
   __u16 idVendor ;
   __u16 idProduct ;
   __u16 bcdDevice_lo ;
   __u16 bcdDevice_hi ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 bInterfaceNumber ;
   kernel_ulong_t driver_info ;
};
#line 282 "include/linux/pm_runtime.h"
struct usb_driver;
#line 819 "include/linux/usb.h"
struct usb_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 1007 "include/linux/usb.h"
struct usbdrv_wrap {
   struct device_driver driver ;
   int for_devices ;
};
#line 1017 "include/linux/usb.h"
struct usb_driver {
   char const   *name ;
   int (*probe)(struct usb_interface * , struct usb_device_id  const  * ) ;
   void (*disconnect)(struct usb_interface * ) ;
   int (*unlocked_ioctl)(struct usb_interface * , unsigned int  , void * ) ;
   int (*suspend)(struct usb_interface * , pm_message_t  ) ;
   int (*resume)(struct usb_interface * ) ;
   int (*reset_resume)(struct usb_interface * ) ;
   int (*pre_reset)(struct usb_interface * ) ;
   int (*post_reset)(struct usb_interface * ) ;
   struct usb_device_id  const  *id_table ;
   struct usb_dynids dynids ;
   struct usbdrv_wrap drvwrap ;
   unsigned char no_dynamic_id : 1 ;
   unsigned char supports_autosuspend : 1 ;
   unsigned char disable_hub_initiated_lpm : 1 ;
   unsigned char soft_unbind : 1 ;
};
#line 932 "include/media/v4l2-ctrls.h"
struct cpia2_register {
   u8 index ;
   u8 value ;
};
#line 238 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
struct cpia2_reg_mask {
   u8 index ;
   u8 and_mask ;
   u8 or_mask ;
   u8 fill ;
};
#line 245 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
union reg_types {
   struct cpia2_register registers[32U] ;
   struct cpia2_reg_mask masks[16U] ;
   u8 block_data[64U] ;
   u8 *patch_data ;
};
#line 258 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
struct cpia2_command {
   u32 command ;
   u8 req_mode ;
   u8 reg_count ;
   u8 direction ;
   u8 start ;
   union reg_types buffer ;
};
#line 239 "include/linux/timer.h"
enum hrtimer_restart;
#line 193 "include/linux/vmalloc.h"
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
#line 1 "<compiler builtins>"
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 33 "include/linux/export.h"
extern struct module __this_module ;
#line 308 "./arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 314 "./arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 318
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 323
  return (oldbit);
}
}
#line 142 "include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 178 "include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 405
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 87 "./arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "./arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "./arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
#line 14
  switch (8UL) {
  case 1UL: 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  case 2UL: 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  case 4UL: 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  case 8UL: 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_2696;
  default: 
#line 14
  __bad_percpu_size();
  }
  ldv_2696: ;
#line 14
  return (pfo_ret__);
}
}
#line 25 "include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 30 "./arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 57
extern void *memset(void * , int  , size_t  ) ;
#line 65
extern char *strcpy(char * , char const   * ) ;
#line 66
extern char *strcat(char * , char const   * ) ;
#line 173 "include/linux/mutex.h"
extern int mutex_trylock(struct mutex * ) ;
#line 176
int ldv_mutex_trylock_10(struct mutex *ldv_func_arg1 ) ;
#line 178
extern void mutex_unlock(struct mutex * ) ;
#line 181
void ldv_mutex_unlock_6(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_7(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_11(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_13(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_15(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_17(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_19(struct mutex *ldv_func_arg1 ) ;
#line 209
void ldv_mutex_unlock_21(struct mutex *ldv_func_arg1 ) ;
#line 213
void ldv_mutex_unlock_22(struct mutex *ldv_func_arg1 ) ;
#line 217
void ldv_mutex_unlock_24(struct mutex *ldv_func_arg1 ) ;
#line 221
void ldv_mutex_unlock_27(struct mutex *ldv_func_arg1 ) ;
#line 6 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
extern void *malloc(size_t  ) ;
#line 7
extern void *calloc(size_t  , size_t  ) ;
#line 13
extern int __VERIFIER_nondet_int(void) ;
#line 28
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 29
extern void *__VERIFIER_nondet_pointer(void) ;
#line 30
extern void __VERIFIER_assume(int  ) ;
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 33
  tmp___0 = __VERIFIER_nondet_int();
#line 33
  if (tmp___0 != 0) {
#line 34
    return ((void *)0);
  } else {
#line 36
    tmp = malloc(size);
#line 36
    p = tmp;
#line 37
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 38
    return (p);
  }
}
}
#line 42 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
#line 43
  tmp___0 = __VERIFIER_nondet_int();
#line 43
  if (tmp___0 != 0) {
#line 44
    return ((void *)0);
  } else {
#line 46
    tmp = calloc(1UL, size);
#line 46
    p = tmp;
#line 47
    __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 48
    return (p);
  }
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 53
  tmp = calloc(1UL, size);
#line 53
  p = tmp;
#line 54
  __VERIFIER_assume((unsigned long )p != (unsigned long )((void *)0));
#line 55
  return (p);
}
}
#line 58 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
#line 59
  tmp = memset(s, c, n);
#line 59
  return (tmp);
}
}
#line 62 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
#line 63
  tmp = __VERIFIER_nondet_int();
#line 63
  return (tmp);
}
}
#line 66 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
#line 67
  tmp = __VERIFIER_nondet_pointer();
#line 67
  return (tmp);
}
}
#line 70 "/home/ldvuser/ldv/inst/kernel-rules/verifier/sv-comp.h"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
#line 71
  tmp = __VERIFIER_nondet_ulong();
#line 71
  return (tmp);
}
}
#line 22 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
#line 23
  goto LDV_STOP;
}
}
#line 52 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
#line 54
  return (exp);
}
}
#line 16 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
extern int mutex_lock_interruptible(struct mutex * ) ;
#line 19
int ldv_mutex_lock_interruptible_14(struct mutex *ldv_func_arg1 ) ;
#line 23
int ldv_mutex_lock_interruptible_18(struct mutex *ldv_func_arg1 ) ;
#line 27
int ldv_mutex_lock_interruptible_26(struct mutex *ldv_func_arg1 ) ;
#line 30
extern void mutex_lock(struct mutex * ) ;
#line 33
void ldv_mutex_lock_5(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_8(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_9(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_12(struct mutex *ldv_func_arg1 ) ;
#line 49
void ldv_mutex_lock_16(struct mutex *ldv_func_arg1 ) ;
#line 53
void ldv_mutex_lock_20(struct mutex *ldv_func_arg1 ) ;
#line 57
void ldv_mutex_lock_23(struct mutex *ldv_func_arg1 ) ;
#line 61
void ldv_mutex_lock_25(struct mutex *ldv_func_arg1 ) ;
#line 66
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) ;
#line 70
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) ;
#line 79
void ldv_mutex_lock_lock(struct mutex *lock ) ;
#line 83
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
#line 92
void ldv_mutex_lock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) ;
#line 96
void ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) ;
#line 105
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) ;
#line 106
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) ;
#line 109
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) ;
#line 115
int ldv_mutex_lock_interruptible_v4l2_lock_of_camera_data(struct mutex *lock ) ;
#line 118
void ldv_mutex_lock_v4l2_lock_of_camera_data(struct mutex *lock ) ;
#line 122
void ldv_mutex_unlock_v4l2_lock_of_camera_data(struct mutex *lock ) ;
#line 89 "include/linux/thread_info.h"
__inline static int test_ti_thread_flag(struct thread_info *ti , int flag ) 
{ 
  int tmp ;

  {
#line 91
  tmp = variable_test_bit((long )flag, (unsigned long const volatile   *)(& ti->flags));
#line 91
  return (tmp);
}
}
#line 926 "include/linux/wait.h"
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 927
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 421 "include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 425
extern void schedule(void) ;
#line 2821 "include/linux/sched.h"
__inline static int test_tsk_thread_flag(struct task_struct *tsk , int flag ) 
{ 
  int tmp ;

  {
#line 2823
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
#line 2823
  return (tmp);
}
}
#line 2847 "include/linux/sched.h"
__inline static int signal_pending(struct task_struct *p ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 2849
  tmp = test_tsk_thread_flag(p, 2);
#line 2849
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
#line 2849
  return ((int )tmp___0);
}
}
#line 143 "include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 88 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
int LDV_IN_INTERRUPT  =    1;
#line 90 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
struct v4l2_event_subscription  const  *cpia2_ioctl_ops_group2  ;
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
struct v4l2_streamparm *cpia2_ioctl_ops_group1  ;
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
struct usb_interface *cpia2_driver_group1  ;
#line 93 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
struct file *cpia2_ioctl_ops_group3  ;
#line 94 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
struct v4l2_format *cpia2_ioctl_ops_group0  ;
#line 95 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
int ldv_state_variable_0  ;
#line 96 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
int ldv_state_variable_5  ;
#line 97 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
int ldv_state_variable_3  ;
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
int ldv_state_variable_2  ;
#line 99 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
int ref_cnt  ;
#line 100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
int ldv_state_variable_1  ;
#line 101 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
int usb_counter  ;
#line 102 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
struct file *cpia2_fops_group0  ;
#line 103 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
struct v4l2_buffer *cpia2_ioctl_ops_group5  ;
#line 104 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
int ldv_state_variable_4  ;
#line 105 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
struct v4l2_fh *cpia2_ioctl_ops_group4  ;
#line 108
void ldv_initialize_v4l2_file_operations_4(void) ;
#line 109
void ldv_initialize_v4l2_ioctl_ops_5(void) ;
#line 333 "include/media/v4l2-ioctl.h"
extern long video_ioctl2(struct file * , unsigned int  , unsigned long  ) ;
#line 130 "include/media/v4l2-event.h"
extern int v4l2_event_unsubscribe(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
#line 863 "include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 865
  return ((void *)dev->driver_data);
}
}
#line 868 "include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 870
  dev->driver_data = data;
#line 871
  return;
}
}
#line 812 "include/linux/usb.h"
__inline static int usb_make_path(struct usb_device *dev , char *buf , size_t size ) 
{ 
  int actual ;

  {
#line 815
  actual = snprintf(buf, size, "usb-%s-%s", (dev->bus)->bus_name, (char *)(& dev->devpath));
#line 817
  return ((int )size > actual ? actual : -1);
}
}
#line 149 "include/media/v4l2-dev.h"
extern int __video_register_device(struct video_device * , int  , int  , int  , struct module * ) ;
#line 156 "include/media/v4l2-dev.h"
__inline static int video_register_device(struct video_device *vdev , int type , int nr ) 
{ 
  int tmp ;

  {
#line 159
  tmp = __video_register_device(vdev, type, nr, 1, (vdev->fops)->owner);
#line 159
  return (tmp);
}
}
#line 172
extern void video_unregister_device(struct video_device * ) ;
#line 184
extern void video_device_release_empty(struct video_device * ) ;
#line 207 "include/media/v4l2-dev.h"
__inline static void *video_get_drvdata(struct video_device *vdev ) 
{ 
  void *tmp ;

  {
#line 209
  tmp = dev_get_drvdata((struct device  const  *)(& vdev->dev));
#line 209
  return (tmp);
}
}
#line 212 "include/media/v4l2-dev.h"
__inline static void video_set_drvdata(struct video_device *vdev , void *data ) 
{ 


  {
#line 214
  dev_set_drvdata(& vdev->dev, data);
#line 215
  return;
}
}
#line 217
extern struct video_device *video_devdata(struct file * ) ;
#line 221 "include/media/v4l2-dev.h"
__inline static void *video_drvdata(struct file *file ) 
{ 
  struct video_device *tmp ;
  void *tmp___0 ;

  {
#line 223
  tmp = video_devdata(file);
#line 223
  tmp___0 = video_get_drvdata(tmp);
#line 223
  return (tmp___0);
}
}
#line 231 "include/media/v4l2-dev.h"
__inline static int video_is_registered(struct video_device *vdev ) 
{ 
  int tmp ;

  {
#line 233
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& vdev->flags));
#line 233
  return (tmp);
}
}
#line 71 "include/media/v4l2-fh.h"
extern int v4l2_fh_open(struct file * ) ;
#line 92
extern int v4l2_fh_release(struct file * ) ;
#line 97
extern int v4l2_fh_is_singular(struct v4l2_fh * ) ;
#line 102 "include/media/v4l2-fh.h"
__inline static int v4l2_fh_is_singular_file(struct file *filp ) 
{ 
  int tmp ;

  {
#line 104
  tmp = v4l2_fh_is_singular((struct v4l2_fh *)filp->private_data);
#line 104
  return (tmp);
}
}
#line 104 "include/media/v4l2-device.h"
extern void v4l2_device_unregister(struct v4l2_device * ) ;
#line 343 "include/media/v4l2-ctrls.h"
extern int v4l2_ctrl_handler_init_class(struct v4l2_ctrl_handler * , unsigned int  ,
                                        struct lock_class_key * , char const   * ) ;
#line 370
extern void v4l2_ctrl_handler_free(struct v4l2_ctrl_handler * ) ;
#line 423
extern struct v4l2_ctrl *v4l2_ctrl_new_custom(struct v4l2_ctrl_handler * , struct v4l2_ctrl_config  const  * ,
                                              void * ) ;
#line 443
extern struct v4l2_ctrl *v4l2_ctrl_new_std(struct v4l2_ctrl_handler * , struct v4l2_ctrl_ops  const  * ,
                                           u32  , s64  , s64  , u64  , s64  ) ;
#line 465
extern struct v4l2_ctrl *v4l2_ctrl_new_std_menu(struct v4l2_ctrl_handler * , struct v4l2_ctrl_ops  const  * ,
                                                u32  , u8  , u64  , u8  ) ;
#line 552
extern void v4l2_ctrl_cluster(unsigned int  , struct v4l2_ctrl ** ) ;
#line 623
extern void v4l2_ctrl_grab(struct v4l2_ctrl * , bool  ) ;
#line 802
extern int v4l2_ctrl_subscribe_event(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
#line 424 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
int cpia2_register_camera(struct camera_data *cam ) ;
#line 425
void cpia2_unregister_camera(struct camera_data *cam ) ;
#line 426
void cpia2_camera_release(struct v4l2_device *v4l2_dev ) ;
#line 429
int cpia2_reset_camera(struct camera_data *cam ) ;
#line 430
int cpia2_set_low_power(struct camera_data *cam ) ;
#line 431
void cpia2_dbg_dump_registers(struct camera_data *cam ) ;
#line 432
int cpia2_match_video_size(int width , int height ) ;
#line 434
void cpia2_save_camera_state(struct camera_data *cam ) ;
#line 436
void cpia2_set_brightness(struct camera_data *cam , unsigned char value ) ;
#line 437
void cpia2_set_contrast(struct camera_data *cam , unsigned char value ) ;
#line 438
void cpia2_set_saturation(struct camera_data *cam , unsigned char value ) ;
#line 439
int cpia2_set_flicker_mode(struct camera_data *cam , int mode ) ;
#line 440
void cpia2_set_format(struct camera_data *cam ) ;
#line 447
int cpia2_allocate_buffers(struct camera_data *cam ) ;
#line 448
void cpia2_free_buffers(struct camera_data *cam ) ;
#line 449
long cpia2_read(struct camera_data *cam , char *buf , unsigned long count , int noblock ) ;
#line 451
unsigned int cpia2_poll(struct camera_data *cam , struct file *filp , poll_table *wait ) ;
#line 453
int cpia2_remap_buffer(struct camera_data *cam , struct vm_area_struct *vma ) ;
#line 454
void cpia2_set_property_flip(struct camera_data *cam , int prop_val ) ;
#line 455
void cpia2_set_property_mirror(struct camera_data *cam , int prop_val ) ;
#line 456
int cpia2_set_gpio(struct camera_data *cam , unsigned char setting ) ;
#line 457
int cpia2_set_fps(struct camera_data *cam , int framerate ) ;
#line 460
int cpia2_usb_init(void) ;
#line 461
void cpia2_usb_cleanup(void) ;
#line 464
int cpia2_usb_stream_start(struct camera_data *cam , unsigned int alternate___0 ) ;
#line 465
int cpia2_usb_stream_stop(struct camera_data *cam ) ;
#line 46 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int video_nr  =    -1;
#line 50 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int buffer_size  =    69632;
#line 54 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int num_buffers  =    3;
#line 59 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int alternate  =    7;
#line 65 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int flicker_mode  ;
#line 84 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_open(struct file *file ) 
{ 
  struct camera_data *cam ;
  void *tmp ;
  int retval ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 86
  tmp = video_drvdata(file);
#line 86
  cam = (struct camera_data *)tmp;
#line 89
  tmp___0 = ldv_mutex_lock_interruptible_14(& cam->v4l2_lock);
#line 89
  if (tmp___0 != 0) {
#line 90
    return (-512);
  } else {

  }
#line 91
  retval = v4l2_fh_open(file);
#line 92
  if (retval != 0) {
#line 93
    goto open_unlock;
  } else {

  }
#line 95
  tmp___3 = v4l2_fh_is_singular_file(file);
#line 95
  if (tmp___3 != 0) {
#line 96
    tmp___1 = cpia2_allocate_buffers(cam);
#line 96
    if (tmp___1 != 0) {
#line 97
      v4l2_fh_release(file);
#line 98
      retval = -12;
#line 99
      goto open_unlock;
    } else {

    }
#line 103
    tmp___2 = cpia2_reset_camera(cam);
#line 103
    if (tmp___2 < 0) {
#line 104
      v4l2_fh_release(file);
#line 105
      retval = -5;
#line 106
      goto open_unlock;
    } else {

    }
#line 109
    cam->APP_len = 0;
#line 110
    cam->COM_len = 0;
  } else {

  }
#line 113
  cpia2_dbg_dump_registers(cam);
  open_unlock: 
#line 115
  ldv_mutex_unlock_15(& cam->v4l2_lock);
#line 116
  return (retval);
}
}
#line 124 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_close(struct file *file ) 
{ 
  struct video_device *dev ;
  struct video_device *tmp ;
  struct camera_data *cam ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 126
  tmp = video_devdata(file);
#line 126
  dev = tmp;
#line 127
  tmp___0 = video_get_drvdata(dev);
#line 127
  cam = (struct camera_data *)tmp___0;
#line 129
  ldv_mutex_lock_16(& cam->v4l2_lock);
#line 130
  tmp___1 = video_is_registered(& cam->vdev);
#line 130
  if (tmp___1 != 0) {
#line 130
    tmp___2 = v4l2_fh_is_singular_file(file);
#line 130
    if (tmp___2 != 0) {
#line 131
      cpia2_usb_stream_stop(cam);
#line 134
      cpia2_save_camera_state(cam);
#line 136
      cpia2_set_low_power(cam);
#line 137
      cpia2_free_buffers(cam);
    } else {

    }
  } else {

  }
#line 140
  if ((unsigned long )((void *)cam->stream_fh) == (unsigned long )file->private_data) {
#line 141
    cam->stream_fh = (struct v4l2_fh *)0;
#line 142
    cam->mmapped = 0U;
  } else {

  }
#line 144
  ldv_mutex_unlock_17(& cam->v4l2_lock);
#line 145
  tmp___3 = v4l2_fh_release(file);
#line 145
  return (tmp___3);
}
}
#line 153 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static ssize_t cpia2_v4l_read(struct file *file , char *buf , size_t count , loff_t *off ) 
{ 
  struct camera_data *cam ;
  void *tmp ;
  int noblock ;
  ssize_t ret ;
  int tmp___0 ;

  {
#line 156
  tmp = video_drvdata(file);
#line 156
  cam = (struct camera_data *)tmp;
#line 157
  noblock = (int )file->f_flags & 2048;
#line 160
  if ((unsigned long )cam == (unsigned long )((struct camera_data *)0)) {
#line 161
    return (-22L);
  } else {

  }
#line 163
  tmp___0 = ldv_mutex_lock_interruptible_18(& cam->v4l2_lock);
#line 163
  if (tmp___0 != 0) {
#line 164
    return (-512L);
  } else {

  }
#line 165
  ret = cpia2_read(cam, buf, count, noblock);
#line 166
  ldv_mutex_unlock_19(& cam->v4l2_lock);
#line 167
  return (ret);
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static unsigned int cpia2_v4l_poll(struct file *filp , struct poll_table_struct *wait ) 
{ 
  struct camera_data *cam ;
  void *tmp ;
  unsigned int res ;

  {
#line 178
  tmp = video_drvdata(filp);
#line 178
  cam = (struct camera_data *)tmp;
#line 181
  ldv_mutex_lock_20(& cam->v4l2_lock);
#line 182
  res = cpia2_poll(cam, filp, wait);
#line 183
  ldv_mutex_unlock_21(& cam->v4l2_lock);
#line 184
  return (res);
}
}
#line 188 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int sync(struct camera_data *cam , int frame_nr ) 
{ 
  struct framebuf *frame ;
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp ;
  struct task_struct *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 190
  frame = cam->buffers + (unsigned long )frame_nr;
  ldv_35147: ;
#line 193
  if ((unsigned int )frame->status == 2U) {
#line 194
    return (0);
  } else {

  }
#line 196
  if (cam->streaming == 0) {
#line 197
    frame->status = 2;
#line 198
    frame->length = 0;
#line 199
    return (0);
  } else {

  }
#line 202
  ldv_mutex_unlock_22(& cam->v4l2_lock);
#line 203
  __ret = 0;
#line 203
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c",
                205, 0);
#line 203
  if (cam->streaming != 0 && (unsigned int )frame->status != 2U) {
#line 203
    __ret___0 = 0L;
#line 203
    INIT_LIST_HEAD(& __wait.task_list);
#line 203
    __wait.flags = 0U;
    ldv_35144: 
#line 203
    tmp = prepare_to_wait_event(& cam->wq_stream, & __wait, 1);
#line 203
    __int = tmp;
#line 203
    if (cam->streaming == 0 || (unsigned int )frame->status == 2U) {
#line 203
      goto ldv_35143;
    } else {

    }
#line 203
    if (__int != 0L) {
#line 203
      __ret___0 = __int;
#line 203
      goto ldv_35143;
    } else {

    }
#line 203
    schedule();
#line 203
    goto ldv_35144;
    ldv_35143: 
#line 203
    finish_wait(& cam->wq_stream, & __wait);
#line 203
    __ret = (int )__ret___0;
  } else {

  }
#line 206
  ldv_mutex_lock_23(& cam->v4l2_lock);
#line 207
  tmp___0 = get_current();
#line 207
  tmp___1 = signal_pending(tmp___0);
#line 207
  if (tmp___1 != 0) {
#line 208
    return (-512);
  } else {

  }
#line 209
  tmp___2 = video_is_registered(& cam->vdev);
#line 209
  if (tmp___2 == 0) {
#line 210
    return (-25);
  } else {

  }
#line 211
  goto ldv_35147;
}
}
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_querycap(struct file *file , void *fh , struct v4l2_capability *vc ) 
{ 
  struct camera_data *cam ;
  void *tmp ;
  int tmp___0 ;

  {
#line 224
  tmp = video_drvdata(file);
#line 224
  cam = (struct camera_data *)tmp;
#line 226
  strcpy((char *)(& vc->driver), "cpia2");
#line 228
  if ((unsigned int )cam->params.pnp_id.product == 337U) {
#line 229
    strcpy((char *)(& vc->card), "QX5 Microscope");
  } else {
#line 231
    strcpy((char *)(& vc->card), "CPiA2 Camera");
  }
#line 232
  switch (cam->params.pnp_id.device_type) {
  case 1U: 
#line 234
  strcat((char *)(& vc->card), " (672/");
#line 235
  goto ldv_35155;
  case 2U: 
#line 237
  strcat((char *)(& vc->card), " (676/");
#line 238
  goto ldv_35155;
  default: 
#line 240
  strcat((char *)(& vc->card), " (XXX/");
#line 241
  goto ldv_35155;
  }
  ldv_35155: ;
#line 243
  switch ((int )cam->params.version.sensor_flags) {
  case 1: 
#line 245
  strcat((char *)(& vc->card), "404)");
#line 246
  goto ldv_35159;
  case 2: 
#line 248
  strcat((char *)(& vc->card), "407)");
#line 249
  goto ldv_35159;
  case 4: 
#line 251
  strcat((char *)(& vc->card), "409)");
#line 252
  goto ldv_35159;
  case 8: 
#line 254
  strcat((char *)(& vc->card), "410)");
#line 255
  goto ldv_35159;
  case 16: 
#line 257
  strcat((char *)(& vc->card), "500)");
#line 258
  goto ldv_35159;
  default: 
#line 260
  strcat((char *)(& vc->card), "XXX)");
#line 261
  goto ldv_35159;
  }
  ldv_35159: 
#line 264
  tmp___0 = usb_make_path(cam->dev, (char *)(& vc->bus_info), 32UL);
#line 264
  if (tmp___0 < 0) {
#line 265
    memset((void *)(& vc->bus_info), 0, 32UL);
  } else {

  }
#line 267
  vc->device_caps = 83886081U;
#line 270
  vc->capabilities = vc->device_caps | 2147483648U;
#line 273
  return (0);
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_enum_input(struct file *file , void *fh , struct v4l2_input *i ) 
{ 


  {
#line 286
  if (i->index != 0U) {
#line 287
    return (-22);
  } else {

  }
#line 288
  strcpy((char *)(& i->name), "Camera");
#line 289
  i->type = 2U;
#line 290
  return (0);
}
}
#line 293 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_g_input(struct file *file , void *fh , unsigned int *i ) 
{ 


  {
#line 295
  *i = 0U;
#line 296
  return (0);
}
}
#line 299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_s_input(struct file *file , void *fh , unsigned int i ) 
{ 


  {
#line 301
  return (i != 0U ? -22 : 0);
}
}
#line 312 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_enum_fmt_vid_cap(struct file *file , void *fh , struct v4l2_fmtdesc *f ) 
{ 
  int index ;

  {
#line 315
  index = (int )f->index;
#line 317
  if (index < 0 || index > 1) {
#line 318
    return (-22);
  } else {

  }
#line 320
  memset((void *)f, 0, 64UL);
#line 321
  f->index = (__u32 )index;
#line 322
  f->type = 1U;
#line 323
  f->flags = 1U;
#line 324
  switch (index) {
  case 0: 
#line 326
  strcpy((char *)(& f->description), "MJPEG");
#line 327
  f->pixelformat = 1196444237U;
#line 328
  goto ldv_35187;
  case 1: 
#line 330
  strcpy((char *)(& f->description), "JPEG");
#line 331
  f->pixelformat = 1195724874U;
#line 332
  goto ldv_35187;
  default: ;
#line 334
  return (-22);
  }
  ldv_35187: ;
#line 337
  return (0);
}
}
#line 348 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_try_fmt_vid_cap(struct file *file , void *fh , struct v4l2_format *f ) 
{ 
  struct camera_data *cam ;
  void *tmp ;
  int tmp___0 ;

  {
#line 351
  tmp = video_drvdata(file);
#line 351
  cam = (struct camera_data *)tmp;
#line 353
  if (f->fmt.pix.pixelformat != 1196444237U && f->fmt.pix.pixelformat != 1195724874U) {
#line 355
    return (-22);
  } else {

  }
#line 357
  f->fmt.pix.field = 1U;
#line 358
  f->fmt.pix.bytesperline = 0U;
#line 359
  f->fmt.pix.sizeimage = cam->frame_size;
#line 360
  f->fmt.pix.colorspace = 7U;
#line 361
  f->fmt.pix.priv = 0U;
#line 363
  tmp___0 = cpia2_match_video_size((int )f->fmt.pix.width, (int )f->fmt.pix.height);
#line 363
  switch (tmp___0) {
  case 0: 
#line 365
  f->fmt.pix.width = 640U;
#line 366
  f->fmt.pix.height = 480U;
#line 367
  goto ldv_35197;
  case 1: 
#line 369
  f->fmt.pix.width = 352U;
#line 370
  f->fmt.pix.height = 288U;
#line 371
  goto ldv_35197;
  case 2: 
#line 373
  f->fmt.pix.width = 320U;
#line 374
  f->fmt.pix.height = 240U;
#line 375
  goto ldv_35197;
  case 4: 
#line 377
  f->fmt.pix.width = 288U;
#line 378
  f->fmt.pix.height = 216U;
#line 379
  goto ldv_35197;
  case 5: 
#line 381
  f->fmt.pix.width = 256U;
#line 382
  f->fmt.pix.height = 192U;
#line 383
  goto ldv_35197;
  case 6: 
#line 385
  f->fmt.pix.width = 224U;
#line 386
  f->fmt.pix.height = 168U;
#line 387
  goto ldv_35197;
  case 7: 
#line 389
  f->fmt.pix.width = 192U;
#line 390
  f->fmt.pix.height = 144U;
#line 391
  goto ldv_35197;
  case 3: ;
  default: 
#line 394
  f->fmt.pix.width = 176U;
#line 395
  f->fmt.pix.height = 144U;
#line 396
  goto ldv_35197;
  }
  ldv_35197: ;
#line 399
  return (0);
}
}
#line 410 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_s_fmt_vid_cap(struct file *file , void *_fh , struct v4l2_format *f ) 
{ 
  struct camera_data *cam ;
  void *tmp ;
  int err ;
  int frame ;

  {
#line 413
  tmp = video_drvdata(file);
#line 413
  cam = (struct camera_data *)tmp;
#line 416
  err = cpia2_try_fmt_vid_cap(file, _fh, f);
#line 417
  if (err != 0) {
#line 418
    return (err);
  } else {

  }
#line 420
  cam->pixelformat = f->fmt.pix.pixelformat;
#line 424
  cam->params.compression.inhibit_htables = 0U;
#line 432
  if (f->fmt.pix.width != cam->width || f->fmt.pix.height != cam->height) {
#line 434
    cam->width = f->fmt.pix.width;
#line 435
    cam->height = f->fmt.pix.height;
#line 436
    cam->params.roi.width = (int )f->fmt.pix.width;
#line 437
    cam->params.roi.height = (int )f->fmt.pix.height;
#line 438
    cpia2_set_format(cam);
  } else {

  }
#line 441
  frame = 0;
#line 441
  goto ldv_35215;
  ldv_35214: ;
#line 442
  if ((unsigned int )(cam->buffers + (unsigned long )frame)->status == 1U) {
#line 443
    err = sync(cam, frame);
#line 443
    if (err < 0) {
#line 444
      return (err);
    } else {

    }
  } else {

  }
#line 446
  (cam->buffers + (unsigned long )frame)->status = 0;
#line 441
  frame = frame + 1;
  ldv_35215: ;
#line 441
  if (cam->num_frames > frame) {
#line 443
    goto ldv_35214;
  } else {

  }

#line 449
  return (0);
}
}
#line 460 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_g_fmt_vid_cap(struct file *file , void *fh , struct v4l2_format *f ) 
{ 
  struct camera_data *cam ;
  void *tmp ;

  {
#line 463
  tmp = video_drvdata(file);
#line 463
  cam = (struct camera_data *)tmp;
#line 465
  f->fmt.pix.width = cam->width;
#line 466
  f->fmt.pix.height = cam->height;
#line 467
  f->fmt.pix.pixelformat = cam->pixelformat;
#line 468
  f->fmt.pix.field = 1U;
#line 469
  f->fmt.pix.bytesperline = 0U;
#line 470
  f->fmt.pix.sizeimage = cam->frame_size;
#line 471
  f->fmt.pix.colorspace = 7U;
#line 472
  f->fmt.pix.priv = 0U;
#line 474
  return (0);
}
}
#line 486 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_cropcap(struct file *file , void *fh , struct v4l2_cropcap *c ) 
{ 
  struct camera_data *cam ;
  void *tmp ;

  {
#line 488
  tmp = video_drvdata(file);
#line 488
  cam = (struct camera_data *)tmp;
#line 490
  if (c->type != 1U) {
#line 491
    return (-22);
  } else {

  }
#line 493
  c->bounds.left = 0;
#line 494
  c->bounds.top = 0;
#line 495
  c->bounds.width = cam->width;
#line 496
  c->bounds.height = cam->height;
#line 497
  c->defrect.left = 0;
#line 498
  c->defrect.top = 0;
#line 499
  c->defrect.width = cam->width;
#line 500
  c->defrect.height = cam->height;
#line 501
  c->pixelaspect.numerator = 1U;
#line 502
  c->pixelaspect.denominator = 1U;
#line 504
  return (0);
}
}
#line 512 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static struct framerate_info  const  framerate_controls[6U]  = {      {1, {4U, 25U}}, 
        {2, {2U, 15U}}, 
        {4, {2U, 25U}}, 
        {8, {1U, 15U}}, 
        {16, {1U, 25U}}, 
        {32, {1U, 30U}}};
#line 521 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_g_parm(struct file *file , void *fh , struct v4l2_streamparm *p ) 
{ 
  struct camera_data *cam ;
  void *tmp ;
  struct v4l2_captureparm *cap ;
  int i ;

  {
#line 523
  tmp = video_drvdata(file);
#line 523
  cam = (struct camera_data *)tmp;
#line 524
  cap = & p->parm.capture;
#line 527
  if (p->type != 1U) {
#line 528
    return (-22);
  } else {

  }
#line 530
  cap->capability = 4096U;
#line 531
  cap->readbuffers = (__u32 )cam->num_frames;
#line 532
  i = 0;
#line 532
  goto ldv_35245;
  ldv_35244: ;
#line 533
  if ((int )cam->params.vp_params.frame_rate == (int )framerate_controls[i].value) {
#line 534
    cap->timeperframe = framerate_controls[i].period;
#line 535
    goto ldv_35243;
  } else {

  }
#line 532
  i = i + 1;
  ldv_35245: ;
#line 532
  if ((unsigned int )i <= 5U) {
#line 534
    goto ldv_35244;
  } else {

  }
  ldv_35243: ;
#line 537
  return (0);
}
}
#line 540 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_s_parm(struct file *file , void *fh , struct v4l2_streamparm *p ) 
{ 
  struct camera_data *cam ;
  void *tmp ;
  struct v4l2_captureparm *cap ;
  struct v4l2_fract tpf ;
  int max ;
  int ret ;
  int i ;
  struct v4l2_fract f1 ;
  struct v4l2_fract f2 ;
  int tmp___0 ;

  {
#line 542
  tmp = video_drvdata(file);
#line 542
  cam = (struct camera_data *)tmp;
#line 543
  cap = & p->parm.capture;
#line 544
  tpf = cap->timeperframe;
#line 545
  max = 5;
#line 549
  ret = cpia2_g_parm(file, fh, p);
#line 550
  if ((ret != 0 || tpf.denominator == 0U) || tpf.numerator == 0U) {
#line 551
    return (ret);
  } else {

  }
#line 554
  if (cam->params.pnp_id.device_type == 1U && (unsigned int )cam->params.version.sensor_flags == 16U) {
#line 556
    max = max + -2;
  } else {

  }
#line 557
  i = 0;
#line 557
  goto ldv_35263;
  ldv_35262: 
#line 558
  f1 = tpf;
#line 559
  f2 = framerate_controls[i].period;
#line 561
  f1.numerator = f1.numerator * f2.denominator;
#line 562
  f2.numerator = f2.numerator * f1.denominator;
#line 563
  if (f1.numerator >= f2.numerator) {
#line 564
    goto ldv_35261;
  } else {

  }
#line 557
  i = i + 1;
  ldv_35263: ;
#line 557
  if (i <= max) {
#line 559
    goto ldv_35262;
  } else {

  }
  ldv_35261: ;
#line 566
  if (i > max) {
#line 567
    i = max;
  } else {

  }
#line 568
  cap->timeperframe = framerate_controls[i].period;
#line 569
  tmp___0 = cpia2_set_fps(cam, framerate_controls[i].value);
#line 569
  return (tmp___0);
}
}
#line 575 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static struct __anonstruct_cpia2_framesizes_303  const  cpia2_framesizes[8U]  = 
#line 575
  {      {640U, 480U}, 
        {352U, 288U}, 
        {320U, 240U}, 
        {288U, 216U}, 
        {256U, 192U}, 
        {224U, 168U}, 
        {192U, 144U}, 
        {176U, 144U}};
#line 586 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_enum_framesizes(struct file *file , void *fh , struct v4l2_frmsizeenum *fsize ) 
{ 


  {
#line 590
  if (fsize->pixel_format != 1196444237U && fsize->pixel_format != 1195724874U) {
#line 592
    return (-22);
  } else {

  }
#line 593
  if (fsize->index > 7U) {
#line 594
    return (-22);
  } else {

  }
#line 595
  fsize->type = 1U;
#line 596
  fsize->__annonCompField58.discrete.width = cpia2_framesizes[fsize->index].width;
#line 597
  fsize->__annonCompField58.discrete.height = cpia2_framesizes[fsize->index].height;
#line 599
  return (0);
}
}
#line 602 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_enum_frameintervals(struct file *file , void *fh , struct v4l2_frmivalenum *fival ) 
{ 
  struct camera_data *cam ;
  void *tmp ;
  int max ;
  int i ;

  {
#line 605
  tmp = video_drvdata(file);
#line 605
  cam = (struct camera_data *)tmp;
#line 606
  max = 5;
#line 609
  if (fival->pixel_format != 1196444237U && fival->pixel_format != 1195724874U) {
#line 611
    return (-22);
  } else {

  }
#line 614
  if (cam->params.pnp_id.device_type == 1U && (unsigned int )cam->params.version.sensor_flags == 16U) {
#line 616
    max = max + -2;
  } else {

  }
#line 617
  if (fival->index > (__u32 )max) {
#line 618
    return (-22);
  } else {

  }
#line 619
  i = 0;
#line 619
  goto ldv_35289;
  ldv_35288: ;
#line 620
  if (fival->width == (__u32 )cpia2_framesizes[i].width && fival->height == (__u32 )cpia2_framesizes[i].height) {
#line 622
    goto ldv_35287;
  } else {

  }
#line 619
  i = i + 1;
  ldv_35289: ;
#line 619
  if ((unsigned int )i <= 7U) {
#line 621
    goto ldv_35288;
  } else {

  }
  ldv_35287: ;
#line 623
  if (i == 8) {
#line 624
    return (-22);
  } else {

  }
#line 625
  fival->type = 1U;
#line 626
  fival->__annonCompField59.discrete = framerate_controls[fival->index].period;
#line 627
  return (0);
}
}
#line 638 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_s_ctrl(struct v4l2_ctrl *ctrl ) 
{ 
  struct camera_data *cam ;
  struct v4l2_ctrl_handler  const  *__mptr ;
  int flicker_table[3U] ;
  int tmp ;
  int tmp___0 ;

  {
#line 641
  __mptr = (struct v4l2_ctrl_handler  const  *)ctrl->handler;
#line 641
  cam = (struct camera_data *)__mptr + 0xfffffffffffffea0UL;
#line 642
  flicker_table[0] = 0;
#line 642
  flicker_table[1] = 50;
#line 642
  flicker_table[2] = 60;
#line 650
  switch (ctrl->id) {
  case 9963776U: 
#line 652
  cpia2_set_brightness(cam, (int )((unsigned char )ctrl->val));
#line 653
  goto ldv_35300;
  case 9963777U: 
#line 655
  cpia2_set_contrast(cam, (int )((unsigned char )ctrl->val));
#line 656
  goto ldv_35300;
  case 9963778U: 
#line 658
  cpia2_set_saturation(cam, (int )((unsigned char )ctrl->val));
#line 659
  goto ldv_35300;
  case 9963796U: 
#line 661
  cpia2_set_property_mirror(cam, ctrl->val);
#line 662
  goto ldv_35300;
  case 9963797U: 
#line 664
  cpia2_set_property_flip(cam, ctrl->val);
#line 665
  goto ldv_35300;
  case 9963800U: 
#line 667
  tmp = cpia2_set_flicker_mode(cam, flicker_table[ctrl->val]);
#line 667
  return (tmp);
  case 9963813U: 
#line 669
  tmp___0 = cpia2_set_gpio(cam, (int )((unsigned char )((int )((signed char )((cam->__annonCompField90.top_light)->val << 6)) | (int )((signed char )((cam->__annonCompField90.bottom_light)->val << 7)))));
#line 669
  return (tmp___0);
  case 10291460U: 
#line 672
  cam->params.compression.inhibit_htables = (ctrl->val & 262144) == 0;
#line 674
  goto ldv_35300;
  case 10291459U: 
#line 676
  cam->params.vc_params.quality = (u8 )ctrl->val;
#line 677
  goto ldv_35300;
  case 10025216U: 
#line 679
  cam->params.camera_state.stream_mode = (u8 )ctrl->val;
#line 680
  goto ldv_35300;
  default: ;
#line 682
  return (-22);
  }
  ldv_35300: ;
#line 685
  return (0);
}
}
#line 696 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_g_jpegcomp(struct file *file , void *fh , struct v4l2_jpegcompression *parms ) 
{ 
  struct camera_data *cam ;
  void *tmp ;

  {
#line 698
  tmp = video_drvdata(file);
#line 698
  cam = (struct camera_data *)tmp;
#line 700
  memset((void *)parms, 0, 140UL);
#line 702
  parms->quality = 80;
#line 704
  parms->jpeg_markers = 48U;
#line 705
  if ((unsigned int )cam->params.compression.inhibit_htables == 0U) {
#line 706
    parms->jpeg_markers = parms->jpeg_markers | 8U;
  } else {

  }
#line 709
  parms->APPn = cam->APPn;
#line 710
  parms->APP_len = cam->APP_len;
#line 711
  if (cam->APP_len > 0) {
#line 712
    memcpy((void *)(& parms->APP_data), (void const   *)(& cam->APP_data), (size_t )cam->APP_len);
#line 713
    parms->jpeg_markers = parms->jpeg_markers | 128U;
  } else {

  }
#line 716
  parms->COM_len = cam->COM_len;
#line 717
  if (cam->COM_len > 0) {
#line 718
    memcpy((void *)(& parms->COM_data), (void const   *)(& cam->COM_data), (size_t )cam->COM_len);
#line 719
    parms->jpeg_markers = parms->jpeg_markers | 64U;
  } else {

  }
#line 725
  return (0);
}
}
#line 737 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_s_jpegcomp(struct file *file , void *fh , struct v4l2_jpegcompression  const  *parms ) 
{ 
  struct camera_data *cam ;
  void *tmp ;

  {
#line 740
  tmp = video_drvdata(file);
#line 740
  cam = (struct camera_data *)tmp;
#line 745
  cam->params.compression.inhibit_htables = ((unsigned int )parms->jpeg_markers & 8U) == 0U;
#line 748
  if ((int )parms->APP_len != 0) {
#line 749
    if ((((int )parms->APP_len > 0 && (unsigned int )parms->APP_len <= 60U) && (int )parms->APPn >= 0) && (int )parms->APPn <= 15) {
#line 752
      cam->APPn = parms->APPn;
#line 753
      cam->APP_len = parms->APP_len;
#line 754
      memcpy((void *)(& cam->APP_data), (void const   *)(& parms->APP_data), (size_t )parms->APP_len);
    } else {
#line 756
      printk("\016cpia2: Bad APPn Params n=%d len=%d\n", parms->APPn, parms->APP_len);
#line 758
      return (-22);
    }
  } else {
#line 761
    cam->APP_len = 0;
  }
#line 764
  if ((int )parms->COM_len != 0) {
#line 765
    if ((int )parms->COM_len > 0 && (unsigned int )parms->COM_len <= 60U) {
#line 767
      cam->COM_len = parms->COM_len;
#line 768
      memcpy((void *)(& cam->COM_data), (void const   *)(& parms->COM_data), (size_t )parms->COM_len);
    } else {
#line 770
      printk("\016cpia2: Bad COM_len=%d\n", parms->COM_len);
#line 771
      return (-22);
    }
  } else {

  }
#line 775
  return (0);
}
}
#line 787 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_reqbufs(struct file *file , void *fh , struct v4l2_requestbuffers *req ) 
{ 
  struct camera_data *cam ;
  void *tmp ;

  {
#line 789
  tmp = video_drvdata(file);
#line 789
  cam = (struct camera_data *)tmp;
#line 791
  if (req->type != 1U || req->memory != 1U) {
#line 793
    return (-22);
  } else {

  }
#line 796
  req->count = (__u32 )cam->num_frames;
#line 797
  memset((void *)(& req->reserved), 0, 8UL);
#line 799
  return (0);
}
}
#line 810 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_querybuf(struct file *file , void *fh , struct v4l2_buffer *buf ) 
{ 
  struct camera_data *cam ;
  void *tmp ;

  {
#line 812
  tmp = video_drvdata(file);
#line 812
  cam = (struct camera_data *)tmp;
#line 814
  if (buf->type != 1U || buf->index > (__u32 )cam->num_frames) {
#line 816
    return (-22);
  } else {

  }
#line 818
  buf->m.offset = (__u32 )((long )(cam->buffers + (unsigned long )buf->index)->data) - (__u32 )((long )cam->frame_buffer);
#line 819
  buf->length = cam->frame_size;
#line 821
  buf->memory = 1U;
#line 823
  if ((unsigned int )cam->mmapped != 0U) {
#line 824
    buf->flags = 1U;
  } else {
#line 826
    buf->flags = 0U;
  }
#line 828
  buf->flags = buf->flags | 8192U;
#line 830
  switch ((unsigned int )(cam->buffers + (unsigned long )buf->index)->status) {
  case 0U: ;
  case 3U: ;
  case 1U: 
#line 834
  buf->bytesused = 0U;
#line 835
  buf->flags = 2U;
#line 836
  goto ldv_35338;
  case 2U: 
#line 838
  buf->bytesused = (__u32 )(cam->buffers + (unsigned long )buf->index)->length;
#line 839
  buf->timestamp = (cam->buffers + (unsigned long )buf->index)->timestamp;
#line 840
  buf->sequence = (__u32 )(cam->buffers + (unsigned long )buf->index)->seq;
#line 841
  buf->flags = 4U;
#line 842
  goto ldv_35338;
  }
  ldv_35338: ;
#line 849
  return (0);
}
}
#line 860 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_qbuf(struct file *file , void *fh , struct v4l2_buffer *buf ) 
{ 
  struct camera_data *cam ;
  void *tmp ;

  {
#line 862
  tmp = video_drvdata(file);
#line 862
  cam = (struct camera_data *)tmp;
#line 864
  if ((buf->type != 1U || buf->memory != 1U) || buf->index > (__u32 )cam->num_frames) {
#line 867
    return (-22);
  } else {

  }
#line 871
  if ((unsigned int )(cam->buffers + (unsigned long )buf->index)->status == 2U) {
#line 872
    (cam->buffers + (unsigned long )buf->index)->status = 0;
  } else {

  }
#line 874
  return (0);
}
}
#line 885 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int find_earliest_filled_buffer(struct camera_data *cam ) 
{ 
  int i ;
  int found ;
  struct timeval *tv1 ;
  struct timeval *tv2 ;

  {
#line 888
  found = -1;
#line 889
  i = 0;
#line 889
  goto ldv_35354;
  ldv_35353: ;
#line 890
  if ((unsigned int )(cam->buffers + (unsigned long )i)->status == 2U) {
#line 891
    if (found < 0) {
#line 892
      found = i;
    } else {
#line 896
      tv1 = & (cam->buffers + (unsigned long )i)->timestamp;
#line 897
      tv2 = & (cam->buffers + (unsigned long )found)->timestamp;
#line 898
      if (tv1->tv_sec < tv2->tv_sec || (tv1->tv_sec == tv2->tv_sec && tv1->tv_usec < tv2->tv_usec)) {
#line 901
        found = i;
      } else {

      }
    }
  } else {

  }
#line 889
  i = i + 1;
  ldv_35354: ;
#line 889
  if (cam->num_frames > i) {
#line 891
    goto ldv_35353;
  } else {

  }

#line 905
  return (found);
}
}
#line 916 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_dqbuf(struct file *file , void *fh , struct v4l2_buffer *buf ) 
{ 
  struct camera_data *cam ;
  void *tmp ;
  int frame ;
  struct framebuf *cb ;
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct task_struct *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 918
  tmp = video_drvdata(file);
#line 918
  cam = (struct camera_data *)tmp;
#line 921
  if (buf->type != 1U || buf->memory != 1U) {
#line 923
    return (-22);
  } else {

  }
#line 925
  frame = find_earliest_filled_buffer(cam);
#line 927
  if (frame < 0 && (file->f_flags & 2048U) != 0U) {
#line 928
    return (-11);
  } else {

  }
#line 930
  if (frame < 0) {
#line 932
    cb = cam->curbuff;
#line 933
    ldv_mutex_unlock_24(& cam->v4l2_lock);
#line 934
    __ret = 0;
#line 934
    __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c",
                  936, 0);
#line 934
    tmp___2 = video_is_registered(& cam->vdev);
#line 934
    if (tmp___2 != 0) {
#line 934
      cb = cam->curbuff;
#line 934
      if ((unsigned int )cb->status != 2U) {
#line 934
        __ret___0 = 0L;
#line 934
        INIT_LIST_HEAD(& __wait.task_list);
#line 934
        __wait.flags = 0U;
        ldv_35370: 
#line 934
        tmp___0 = prepare_to_wait_event(& cam->wq_stream, & __wait, 1);
#line 934
        __int = tmp___0;
#line 934
        tmp___1 = video_is_registered(& cam->vdev);
#line 934
        if (tmp___1 == 0) {
#line 934
          goto ldv_35369;
        } else {
#line 934
          cb = cam->curbuff;
#line 934
          if ((unsigned int )cb->status == 2U) {
#line 934
            goto ldv_35369;
          } else {

          }
        }
#line 934
        if (__int != 0L) {
#line 934
          __ret___0 = __int;
#line 934
          goto ldv_35369;
        } else {

        }
#line 934
        schedule();
#line 934
        goto ldv_35370;
        ldv_35369: 
#line 934
        finish_wait(& cam->wq_stream, & __wait);
#line 934
        __ret = (int )__ret___0;
      } else {

      }
    } else {

    }
#line 937
    ldv_mutex_lock_25(& cam->v4l2_lock);
#line 938
    tmp___3 = get_current();
#line 938
    tmp___4 = signal_pending(tmp___3);
#line 938
    if (tmp___4 != 0) {
#line 939
      return (-512);
    } else {

    }
#line 940
    tmp___5 = video_is_registered(& cam->vdev);
#line 940
    if (tmp___5 == 0) {
#line 941
      return (-25);
    } else {

    }
#line 942
    frame = cb->num;
  } else {

  }
#line 946
  buf->index = (__u32 )frame;
#line 947
  buf->bytesused = (__u32 )(cam->buffers + (unsigned long )buf->index)->length;
#line 948
  buf->flags = 8197U;
#line 950
  buf->field = 1U;
#line 951
  buf->timestamp = (cam->buffers + (unsigned long )buf->index)->timestamp;
#line 952
  buf->sequence = (__u32 )(cam->buffers + (unsigned long )buf->index)->seq;
#line 953
  buf->m.offset = (__u32 )((long )(cam->buffers + (unsigned long )buf->index)->data) - (__u32 )((long )cam->frame_buffer);
#line 954
  buf->length = cam->frame_size;
#line 955
  buf->reserved2 = 0U;
#line 956
  buf->reserved = 0U;
#line 957
  memset((void *)(& buf->timecode), 0, 16UL);
#line 962
  return (0);
}
}
#line 965 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_streamon(struct file *file , void *fh , enum v4l2_buf_type type ) 
{ 
  struct camera_data *cam ;
  void *tmp ;
  int ret ;

  {
#line 967
  tmp = video_drvdata(file);
#line 967
  cam = (struct camera_data *)tmp;
#line 968
  ret = -22;
#line 971
  if ((unsigned int )cam->mmapped == 0U || (unsigned int )type != 1U) {
#line 972
    return (-22);
  } else {

  }
#line 974
  if (cam->streaming == 0) {
#line 975
    ret = cpia2_usb_stream_start(cam, (unsigned int )cam->params.camera_state.stream_mode);
#line 977
    if (ret == 0) {
#line 978
      v4l2_ctrl_grab(cam->usb_alt, 1);
    } else {

    }
  } else {

  }
#line 980
  return (ret);
}
}
#line 983 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_streamoff(struct file *file , void *fh , enum v4l2_buf_type type ) 
{ 
  struct camera_data *cam ;
  void *tmp ;
  int ret ;

  {
#line 985
  tmp = video_drvdata(file);
#line 985
  cam = (struct camera_data *)tmp;
#line 986
  ret = -22;
#line 989
  if ((unsigned int )cam->mmapped == 0U || (unsigned int )type != 1U) {
#line 990
    return (-22);
  } else {

  }
#line 992
  if (cam->streaming != 0) {
#line 993
    ret = cpia2_usb_stream_stop(cam);
#line 994
    if (ret == 0) {
#line 995
      v4l2_ctrl_grab(cam->usb_alt, 0);
    } else {

    }
  } else {

  }
#line 997
  return (ret);
}
}
#line 1005 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_mmap(struct file *file , struct vm_area_struct *area ) 
{ 
  struct camera_data *cam ;
  void *tmp ;
  int retval ;
  int tmp___0 ;

  {
#line 1007
  tmp = video_drvdata(file);
#line 1007
  cam = (struct camera_data *)tmp;
#line 1010
  tmp___0 = ldv_mutex_lock_interruptible_26(& cam->v4l2_lock);
#line 1010
  if (tmp___0 != 0) {
#line 1011
    return (-512);
  } else {

  }
#line 1012
  retval = cpia2_remap_buffer(cam, area);
#line 1014
  if (retval == 0) {
#line 1015
    cam->stream_fh = (struct v4l2_fh *)file->private_data;
  } else {

  }
#line 1016
  ldv_mutex_unlock_27(& cam->v4l2_lock);
#line 1017
  return (retval);
}
}
#line 1026 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static void reset_camera_struct_v4l(struct camera_data *cam ) 
{ 


  {
#line 1028
  cam->width = (u32 )cam->params.roi.width;
#line 1029
  cam->height = (u32 )cam->params.roi.height;
#line 1031
  cam->frame_size = (u32 )buffer_size;
#line 1032
  cam->num_frames = num_buffers;
#line 1035
  cam->params.flicker_control.flicker_mode_req = (u8 )flicker_mode;
#line 1038
  cam->params.camera_state.stream_mode = (u8 )alternate;
#line 1040
  cam->pixelformat = 1195724874U;
#line 1041
  return;
}
}
#line 1043 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static struct v4l2_ioctl_ops  const  cpia2_ioctl_ops  = 
#line 1043
     {& cpia2_querycap, & cpia2_enum_fmt_vid_cap, 0, 0, 0, 0, 0, & cpia2_g_fmt_vid_cap,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & cpia2_s_fmt_vid_cap, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, & cpia2_try_fmt_vid_cap, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & cpia2_reqbufs, & cpia2_querybuf,
    & cpia2_qbuf, 0, & cpia2_dqbuf, 0, 0, 0, 0, 0, & cpia2_streamon, & cpia2_streamoff,
    0, 0, 0, & cpia2_enum_input, & cpia2_g_input, & cpia2_s_input, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & cpia2_cropcap, 0, 0, 0, 0, & cpia2_g_jpegcomp,
    & cpia2_s_jpegcomp, 0, 0, 0, 0, 0, & cpia2_g_parm, & cpia2_s_parm, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, & cpia2_enum_framesizes, & cpia2_enum_frameintervals, 0,
    0, 0, 0, 0, 0, 0, & v4l2_ctrl_subscribe_event, & v4l2_event_unsubscribe, 0};
#line 1072 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static struct v4l2_file_operations  const  cpia2_fops  = 
#line 1072
     {& __this_module, & cpia2_v4l_read, 0, & cpia2_v4l_poll, & video_ioctl2, 0, 0,
    & cpia2_mmap, & cpia2_open, & cpia2_close};
#line 1082 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static struct video_device cpia2_template  = 
#line 1082
     {{{0, 0}, 0, 0U, 0, 0U, 0U, 0UL, 0U, (unsigned short)0, (unsigned short)0, (unsigned short)0,
     (unsigned short)0, 0, 0, 0, 0, 0, 0, {{0U, 0U}}}, & cpia2_fops, {0, 0, {0, {0,
                                                                                 0},
                                                                             0, 0,
                                                                             0, 0,
                                                                             {{0}},
                                                                             {{{0L},
                                                                               {0,
                                                                                0},
                                                                               0,
                                                                               {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}},
                                                                              {{0,
                                                                                0},
                                                                               0UL,
                                                                               0,
                                                                               0UL,
                                                                               0U,
                                                                               0,
                                                                               0,
                                                                               0,
                                                                               {(char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0},
                                                                               {0,
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                0,
                                                                                0UL}},
                                                                              0, 0},
                                                                             (unsigned char)0,
                                                                             (unsigned char)0,
                                                                             (unsigned char)0,
                                                                             (unsigned char)0,
                                                                             (unsigned char)0},
                                                                      0, 0, {{0},
                                                                             {{{{{0}},
                                                                                0U,
                                                                                0U,
                                                                                0,
                                                                                {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}}}},
                                                                             {0, 0},
                                                                             0, 0,
                                                                             {0, {0,
                                                                                  0},
                                                                              0, 0,
                                                                              0UL}},
                                                                      0, 0, 0, 0,
                                                                      {{0}, (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (_Bool)0, (_Bool)0,
                                                                       (_Bool)0, (_Bool)0,
                                                                       (_Bool)0, (_Bool)0,
                                                                       (_Bool)0, {{{{{0}},
                                                                                    0U,
                                                                                    0U,
                                                                                    0,
                                                                                    {0,
                                                                                     {0,
                                                                                      0},
                                                                                     0,
                                                                                     0,
                                                                                     0UL}}}},
                                                                       {0, 0}, {0U,
                                                                                {{{{{{0}},
                                                                                    0U,
                                                                                    0U,
                                                                                    0,
                                                                                    {0,
                                                                                     {0,
                                                                                      0},
                                                                                     0,
                                                                                     0,
                                                                                     0UL}}}},
                                                                                 {0,
                                                                                  0}}},
                                                                       0, (_Bool)0,
                                                                       (_Bool)0, {{0,
                                                                                   0},
                                                                                  0UL,
                                                                                  0,
                                                                                  0UL,
                                                                                  0U,
                                                                                  0,
                                                                                  0,
                                                                                  0,
                                                                                  {(char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0},
                                                                                  {0,
                                                                                   {0,
                                                                                    0},
                                                                                   0,
                                                                                   0,
                                                                                   0UL}},
                                                                       0UL, {{0L},
                                                                             {0, 0},
                                                                             0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
                                                                       {{{{{{0}},
                                                                           0U, 0U,
                                                                           0, {0,
                                                                               {0,
                                                                                0},
                                                                               0,
                                                                               0,
                                                                               0UL}}}},
                                                                        {0, 0}}, 0,
                                                                       {0}, {0}, (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       (unsigned char)0,
                                                                       0, 0, 0, 0,
                                                                       0UL, 0UL, 0UL,
                                                                       0UL, 0, 0,
                                                                       0}, 0, 0, 0,
                                                                      0, 0ULL, 0UL,
                                                                      0, {0, 0}, 0,
                                                                      0, {0, 0}, 0,
                                                                      0, 0U, 0U, {{{{{0}},
                                                                                    0U,
                                                                                    0U,
                                                                                    0,
                                                                                    {0,
                                                                                     {0,
                                                                                      0},
                                                                                     0,
                                                                                     0,
                                                                                     0UL}}}},
                                                                      {0, 0}, {0,
                                                                               {0,
                                                                                0},
                                                                               {{0}}},
                                                                      0, 0, 0, 0,
                                                                      (_Bool)0, (_Bool)0},
    0, 0, 0, 0, 0, 0, {'C', 'P', 'i', 'A', '2', ' ', 'C', 'a', 'm', 'e', 'r', 'a',
                       '\000'}, 0, 0, 0, (unsigned short)0, 0UL, 0, {{{{{0}}, 0U,
                                                                       0U, 0, {0,
                                                                               {0,
                                                                                0},
                                                                               0,
                                                                               0,
                                                                               0UL}}}},
    {0, 0}, 0, 0ULL, & video_device_release_empty, & cpia2_ioctl_ops, {0UL, 0UL, 0UL},
    {0UL, 0UL, 0UL}, 0};
#line 1090 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
void cpia2_camera_release(struct v4l2_device *v4l2_dev ) 
{ 
  struct camera_data *cam ;
  struct v4l2_device  const  *__mptr ;

  {
#line 1093
  __mptr = (struct v4l2_device  const  *)v4l2_dev;
#line 1093
  cam = (struct camera_data *)__mptr;
#line 1095
  v4l2_ctrl_handler_free(& cam->hdl);
#line 1096
  v4l2_device_unregister(& cam->v4l2_dev);
#line 1097
  kfree((void const   *)cam);
#line 1098
  return;
}
}
#line 1100 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static struct v4l2_ctrl_ops  const  cpia2_ctrl_ops  =    {0, 0, & cpia2_s_ctrl};
#line 1109 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
int cpia2_register_camera(struct camera_data *cam ) 
{ 
  struct v4l2_ctrl_handler *hdl ;
  struct v4l2_ctrl_config cpia2_usb_alt ;
  int ret ;
  struct lock_class_key _key ;
  int tmp ;

  {
#line 1111
  hdl = & cam->hdl;
#line 1112
  cpia2_usb_alt.ops = & cpia2_ctrl_ops;
#line 1112
  cpia2_usb_alt.type_ops = 0;
#line 1112
  cpia2_usb_alt.id = 10025216U;
#line 1112
  cpia2_usb_alt.name = "USB Alternate";
#line 1112
  cpia2_usb_alt.type = 1;
#line 1112
  cpia2_usb_alt.min = 2LL;
#line 1112
  cpia2_usb_alt.max = 7LL;
#line 1112
  cpia2_usb_alt.step = 1ULL;
#line 1112
  cpia2_usb_alt.def = 0LL;
#line 1112
  cpia2_usb_alt.dims[0] = 0U;
#line 1112
  cpia2_usb_alt.dims[1] = 0U;
#line 1112
  cpia2_usb_alt.dims[2] = 0U;
#line 1112
  cpia2_usb_alt.dims[3] = 0U;
#line 1112
  cpia2_usb_alt.elem_size = 0U;
#line 1112
  cpia2_usb_alt.flags = 0U;
#line 1112
  cpia2_usb_alt.menu_skip_mask = 0ULL;
#line 1112
  cpia2_usb_alt.qmenu = 0;
#line 1112
  cpia2_usb_alt.qmenu_int = 0;
#line 1112
  cpia2_usb_alt.is_private = (unsigned char)0;
#line 1123
  v4l2_ctrl_handler_init_class(hdl, 12U, & _key, "cpia2_v4l:1123:(hdl)->_lock");
#line 1124
  v4l2_ctrl_new_std(hdl, & cpia2_ctrl_ops, 9963776U, cam->params.pnp_id.device_type == 1U,
                    255LL, 1ULL, 70LL);
#line 1128
  v4l2_ctrl_new_std(hdl, & cpia2_ctrl_ops, 9963777U, 0LL, 255LL, 1ULL, 147LL);
#line 1130
  v4l2_ctrl_new_std(hdl, & cpia2_ctrl_ops, 9963778U, 0LL, 255LL, 1ULL, 127LL);
#line 1132
  v4l2_ctrl_new_std(hdl, & cpia2_ctrl_ops, 9963796U, 0LL, 1LL, 1ULL, 0LL);
#line 1134
  v4l2_ctrl_new_std(hdl, & cpia2_ctrl_ops, 10291460U, 0LL, 262144LL, 0ULL, 262144LL);
#line 1138
  v4l2_ctrl_new_std(hdl, & cpia2_ctrl_ops, 10291459U, 1LL, 100LL, 1ULL, 100LL);
#line 1141
  cpia2_usb_alt.def = (s64 )alternate;
#line 1142
  cam->usb_alt = v4l2_ctrl_new_custom(hdl, (struct v4l2_ctrl_config  const  *)(& cpia2_usb_alt),
                                      (void *)0);
#line 1144
  if (cam->params.pnp_id.device_type != 1U) {
#line 1145
    v4l2_ctrl_new_std(hdl, & cpia2_ctrl_ops, 9963797U, 0LL, 1LL, 1ULL, 0LL);
  } else {

  }
#line 1148
  if (cam->params.pnp_id.device_type == 1U) {
#line 1149
    v4l2_ctrl_new_std_menu(hdl, & cpia2_ctrl_ops, 9963800U, 2, 0ULL, 0);
  } else {

  }
#line 1153
  if ((unsigned int )cam->params.pnp_id.product == 337U) {
#line 1154
    cam->__annonCompField90.top_light = v4l2_ctrl_new_std(hdl, & cpia2_ctrl_ops, 9963813U,
                                                          0LL, 1LL, 1ULL, 0LL);
#line 1156
    cam->__annonCompField90.bottom_light = v4l2_ctrl_new_std(hdl, & cpia2_ctrl_ops,
                                                             9963814U, 0LL, 1LL, 1ULL,
                                                             0LL);
#line 1158
    v4l2_ctrl_cluster(2U, & cam->__annonCompField90.top_light);
  } else {

  }
#line 1161
  if (hdl->error != 0) {
#line 1162
    ret = hdl->error;
#line 1163
    v4l2_ctrl_handler_free(hdl);
#line 1164
    return (ret);
  } else {

  }
#line 1167
  cam->vdev = cpia2_template;
#line 1168
  video_set_drvdata(& cam->vdev, (void *)cam);
#line 1169
  cam->vdev.lock = & cam->v4l2_lock;
#line 1170
  cam->vdev.ctrl_handler = hdl;
#line 1171
  cam->vdev.v4l2_dev = & cam->v4l2_dev;
#line 1173
  reset_camera_struct_v4l(cam);
#line 1176
  tmp = video_register_device(& cam->vdev, 0, video_nr);
#line 1176
  if (tmp < 0) {
#line 1177
    printk("\vcpia2: video_register_device failed\n");
#line 1178
    return (-19);
  } else {

  }
#line 1181
  return (0);
}
}
#line 1189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
void cpia2_unregister_camera(struct camera_data *cam ) 
{ 


  {
#line 1191
  video_unregister_device(& cam->vdev);
#line 1192
  return;
}
}
#line 1200 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static void check_parameters(void) 
{ 


  {
#line 1202
  if ((unsigned int )buffer_size <= 4095U) {
#line 1203
    buffer_size = 4096;
#line 1204
    printk("\016cpia2: buffer_size too small, setting to %d\n", buffer_size);
  } else
#line 1205
  if (buffer_size > 1048576) {
#line 1207
    buffer_size = 1048576;
#line 1208
    printk("\016cpia2: buffer_size ridiculously large, setting to %d\n", buffer_size);
  } else {
#line 1211
    buffer_size = (int )((unsigned int )buffer_size + 4095U);
#line 1212
    buffer_size = buffer_size & -4096;
  }
#line 1215
  if (num_buffers <= 0) {
#line 1216
    num_buffers = 1;
#line 1217
    printk("\016cpia2: num_buffers too small, setting to %d\n", num_buffers);
  } else
#line 1218
  if (num_buffers > 32) {
#line 1219
    num_buffers = 32;
#line 1220
    printk("\016cpia2: num_buffers too large, setting to %d\n", num_buffers);
  } else {

  }
#line 1223
  if (alternate <= 1 || alternate > 7) {
#line 1224
    alternate = 7;
#line 1225
    printk("\016cpia2: alternate specified is invalid, using %d\n", alternate);
  } else {

  }
#line 1228
  if ((flicker_mode != 0 && flicker_mode != 50) && flicker_mode != 60) {
#line 1229
    flicker_mode = 0;
#line 1230
    printk("\016cpia2: Flicker mode specified is invalid, using %d\n", flicker_mode);
  } else {

  }
#line 1232
  return;
}
}
#line 1246 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static int cpia2_init(void) 
{ 


  {
#line 1248
  printk("\016cpia2: %s v%s\n", (char *)"V4L-Driver for Vision CPiA2 based cameras",
         (char *)"3.0.1");
#line 1250
  check_parameters();
#line 1251
  cpia2_usb_init();
#line 1252
  return (0);
}
}
#line 1261 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.c"
static void cpia2_exit(void) 
{ 


  {
#line 1263
  cpia2_usb_cleanup();
#line 1264
  schedule_timeout(500L);
#line 1265
  return;
}
}
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
int ldv_retval_0  ;
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
int ldv_retval_4  ;
#line 113
extern void ldv_initialize(void) ;
#line 114
void ldv_check_final_state(void) ;
#line 115
extern int ldv_probe_3(void) ;
#line 119 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_initialize_v4l2_file_operations_4(void) 
{ 
  void *tmp ;

  {
#line 120
  tmp = __VERIFIER_nondet_pointer();
#line 120
  cpia2_fops_group0 = (struct file *)tmp;
#line 121
  return;
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_initialize_v4l2_ioctl_ops_5(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 124
  tmp = ldv_init_zalloc(32UL);
#line 124
  cpia2_ioctl_ops_group2 = (struct v4l2_event_subscription  const  *)tmp;
#line 125
  tmp___0 = ldv_init_zalloc(208UL);
#line 125
  cpia2_ioctl_ops_group0 = (struct v4l2_format *)tmp___0;
#line 126
  tmp___1 = ldv_init_zalloc(176UL);
#line 126
  cpia2_ioctl_ops_group4 = (struct v4l2_fh *)tmp___1;
#line 127
  tmp___2 = __VERIFIER_nondet_pointer();
#line 127
  cpia2_ioctl_ops_group3 = (struct file *)tmp___2;
#line 128
  tmp___3 = ldv_init_zalloc(88UL);
#line 128
  cpia2_ioctl_ops_group5 = (struct v4l2_buffer *)tmp___3;
#line 129
  tmp___4 = ldv_init_zalloc(204UL);
#line 129
  cpia2_ioctl_ops_group1 = (struct v4l2_streamparm *)tmp___4;
#line 130
  return;
}
}
#line 138
void ldv_main_exported_1(void) ;
#line 142 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
int main(void) 
{ 
  unsigned int ldvarg1 ;
  size_t ldvarg4 ;
  loff_t *ldvarg3 ;
  void *tmp ;
  unsigned long ldvarg0 ;
  char *ldvarg5 ;
  void *tmp___0 ;
  struct poll_table_struct *ldvarg2 ;
  void *tmp___1 ;
  struct vm_area_struct *ldvarg6 ;
  void *tmp___2 ;
  struct video_device *ldvarg9 ;
  void *tmp___3 ;
  struct v4l2_ctrl *ldvarg10 ;
  void *tmp___4 ;
  void *ldvarg18 ;
  void *tmp___5 ;
  enum v4l2_buf_type ldvarg11 ;
  void *ldvarg32 ;
  void *tmp___6 ;
  struct v4l2_frmivalenum *ldvarg23 ;
  void *tmp___7 ;
  struct v4l2_requestbuffers *ldvarg43 ;
  void *tmp___8 ;
  void *ldvarg42 ;
  void *tmp___9 ;
  void *ldvarg12 ;
  void *tmp___10 ;
  void *ldvarg37 ;
  void *tmp___11 ;
  void *ldvarg29 ;
  void *tmp___12 ;
  void *ldvarg44 ;
  void *tmp___13 ;
  void *ldvarg24 ;
  void *tmp___14 ;
  void *ldvarg35 ;
  void *tmp___15 ;
  enum v4l2_buf_type ldvarg38 ;
  struct v4l2_cropcap *ldvarg33 ;
  void *tmp___16 ;
  struct v4l2_input *ldvarg16 ;
  void *tmp___17 ;
  void *ldvarg14 ;
  void *tmp___18 ;
  void *ldvarg34 ;
  void *tmp___19 ;
  void *ldvarg28 ;
  void *tmp___20 ;
  void *ldvarg39 ;
  void *tmp___21 ;
  void *ldvarg20 ;
  void *tmp___22 ;
  void *ldvarg31 ;
  void *tmp___23 ;
  void *ldvarg41 ;
  void *tmp___24 ;
  unsigned int ldvarg13 ;
  struct v4l2_fmtdesc *ldvarg36 ;
  void *tmp___25 ;
  void *ldvarg40 ;
  void *tmp___26 ;
  void *ldvarg26 ;
  void *tmp___27 ;
  struct v4l2_frmsizeenum *ldvarg27 ;
  void *tmp___28 ;
  void *ldvarg15 ;
  void *tmp___29 ;
  unsigned int *ldvarg30 ;
  void *tmp___30 ;
  struct v4l2_jpegcompression *ldvarg21 ;
  void *tmp___31 ;
  struct v4l2_capability *ldvarg25 ;
  void *tmp___32 ;
  void *ldvarg17 ;
  void *tmp___33 ;
  void *ldvarg22 ;
  void *tmp___34 ;
  struct v4l2_jpegcompression *ldvarg19 ;
  void *tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;

  {
#line 147
  tmp = ldv_init_zalloc(8UL);
#line 147
  ldvarg3 = (loff_t *)tmp;
#line 149
  tmp___0 = ldv_init_zalloc(1UL);
#line 149
  ldvarg5 = (char *)tmp___0;
#line 150
  tmp___1 = ldv_init_zalloc(16UL);
#line 150
  ldvarg2 = (struct poll_table_struct *)tmp___1;
#line 151
  tmp___2 = ldv_init_zalloc(184UL);
#line 151
  ldvarg6 = (struct vm_area_struct *)tmp___2;
#line 152
  tmp___3 = ldv_init_zalloc(1832UL);
#line 152
  ldvarg9 = (struct video_device *)tmp___3;
#line 153
  tmp___4 = ldv_init_zalloc(208UL);
#line 153
  ldvarg10 = (struct v4l2_ctrl *)tmp___4;
#line 154
  tmp___5 = ldv_init_zalloc(1UL);
#line 154
  ldvarg18 = tmp___5;
#line 156
  tmp___6 = ldv_init_zalloc(1UL);
#line 156
  ldvarg32 = tmp___6;
#line 157
  tmp___7 = ldv_init_zalloc(52UL);
#line 157
  ldvarg23 = (struct v4l2_frmivalenum *)tmp___7;
#line 158
  tmp___8 = ldv_init_zalloc(20UL);
#line 158
  ldvarg43 = (struct v4l2_requestbuffers *)tmp___8;
#line 159
  tmp___9 = ldv_init_zalloc(1UL);
#line 159
  ldvarg42 = tmp___9;
#line 160
  tmp___10 = ldv_init_zalloc(1UL);
#line 160
  ldvarg12 = tmp___10;
#line 161
  tmp___11 = ldv_init_zalloc(1UL);
#line 161
  ldvarg37 = tmp___11;
#line 162
  tmp___12 = ldv_init_zalloc(1UL);
#line 162
  ldvarg29 = tmp___12;
#line 163
  tmp___13 = ldv_init_zalloc(1UL);
#line 163
  ldvarg44 = tmp___13;
#line 164
  tmp___14 = ldv_init_zalloc(1UL);
#line 164
  ldvarg24 = tmp___14;
#line 165
  tmp___15 = ldv_init_zalloc(1UL);
#line 165
  ldvarg35 = tmp___15;
#line 167
  tmp___16 = ldv_init_zalloc(44UL);
#line 167
  ldvarg33 = (struct v4l2_cropcap *)tmp___16;
#line 168
  tmp___17 = ldv_init_zalloc(80UL);
#line 168
  ldvarg16 = (struct v4l2_input *)tmp___17;
#line 169
  tmp___18 = ldv_init_zalloc(1UL);
#line 169
  ldvarg14 = tmp___18;
#line 170
  tmp___19 = ldv_init_zalloc(1UL);
#line 170
  ldvarg34 = tmp___19;
#line 171
  tmp___20 = ldv_init_zalloc(1UL);
#line 171
  ldvarg28 = tmp___20;
#line 172
  tmp___21 = ldv_init_zalloc(1UL);
#line 172
  ldvarg39 = tmp___21;
#line 173
  tmp___22 = ldv_init_zalloc(1UL);
#line 173
  ldvarg20 = tmp___22;
#line 174
  tmp___23 = ldv_init_zalloc(1UL);
#line 174
  ldvarg31 = tmp___23;
#line 175
  tmp___24 = ldv_init_zalloc(1UL);
#line 175
  ldvarg41 = tmp___24;
#line 177
  tmp___25 = ldv_init_zalloc(64UL);
#line 177
  ldvarg36 = (struct v4l2_fmtdesc *)tmp___25;
#line 178
  tmp___26 = ldv_init_zalloc(1UL);
#line 178
  ldvarg40 = tmp___26;
#line 179
  tmp___27 = ldv_init_zalloc(1UL);
#line 179
  ldvarg26 = tmp___27;
#line 180
  tmp___28 = ldv_init_zalloc(44UL);
#line 180
  ldvarg27 = (struct v4l2_frmsizeenum *)tmp___28;
#line 181
  tmp___29 = ldv_init_zalloc(1UL);
#line 181
  ldvarg15 = tmp___29;
#line 182
  tmp___30 = ldv_init_zalloc(4UL);
#line 182
  ldvarg30 = (unsigned int *)tmp___30;
#line 183
  tmp___31 = ldv_init_zalloc(140UL);
#line 183
  ldvarg21 = (struct v4l2_jpegcompression *)tmp___31;
#line 184
  tmp___32 = ldv_init_zalloc(104UL);
#line 184
  ldvarg25 = (struct v4l2_capability *)tmp___32;
#line 185
  tmp___33 = ldv_init_zalloc(1UL);
#line 185
  ldvarg17 = tmp___33;
#line 186
  tmp___34 = ldv_init_zalloc(1UL);
#line 186
  ldvarg22 = tmp___34;
#line 187
  tmp___35 = ldv_init_zalloc(140UL);
#line 187
  ldvarg19 = (struct v4l2_jpegcompression *)tmp___35;
#line 143
  ldv_initialize();
#line 145
  ldv_memset((void *)(& ldvarg1), 0, 4UL);
#line 146
  ldv_memset((void *)(& ldvarg4), 0, 8UL);
#line 148
  ldv_memset((void *)(& ldvarg0), 0, 8UL);
#line 155
  ldv_memset((void *)(& ldvarg11), 0, 4UL);
#line 166
  ldv_memset((void *)(& ldvarg38), 0, 4UL);
#line 176
  ldv_memset((void *)(& ldvarg13), 0, 4UL);
#line 189
  ldv_state_variable_4 = 0;
#line 190
  ldv_state_variable_1 = 0;
#line 191
  ref_cnt = 0;
#line 192
  ldv_state_variable_0 = 1;
#line 193
  ldv_state_variable_3 = 0;
#line 194
  ldv_state_variable_2 = 0;
#line 195
  ldv_state_variable_5 = 0;
  ldv_35563: 
#line 197
  tmp___36 = __VERIFIER_nondet_int();
#line 197
  switch (tmp___36) {
  case 0: ;
#line 201
  if (ldv_state_variable_4 != 0) {
#line 202
    tmp___37 = __VERIFIER_nondet_int();
#line 202
    switch (tmp___37) {
    case 0: ;
#line 205
    if (ldv_state_variable_4 == 1) {
#line 207
      ldv_retval_0 = cpia2_open(cpia2_fops_group0);
#line 209
      if (ldv_retval_0 == 0) {
#line 210
        ldv_state_variable_4 = 2;
#line 211
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
#line 215
    goto ldv_35512;
    case 1: ;
#line 218
    if (ldv_state_variable_4 == 1) {
#line 220
      cpia2_mmap(cpia2_fops_group0, ldvarg6);
#line 222
      ldv_state_variable_4 = 1;
    } else {

    }
#line 225
    if (ldv_state_variable_4 == 2) {
#line 227
      cpia2_mmap(cpia2_fops_group0, ldvarg6);
#line 229
      ldv_state_variable_4 = 2;
    } else {

    }
#line 232
    goto ldv_35512;
    case 2: ;
#line 235
    if (ldv_state_variable_4 == 2) {
#line 237
      cpia2_close(cpia2_fops_group0);
#line 239
      ldv_state_variable_4 = 1;
#line 240
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 243
    goto ldv_35512;
    case 3: ;
#line 246
    if (ldv_state_variable_4 == 2) {
#line 248
      cpia2_v4l_read(cpia2_fops_group0, ldvarg5, ldvarg4, ldvarg3);
#line 250
      ldv_state_variable_4 = 2;
    } else {

    }
#line 253
    goto ldv_35512;
    case 4: ;
#line 256
    if (ldv_state_variable_4 == 1) {
#line 258
      cpia2_v4l_poll(cpia2_fops_group0, ldvarg2);
#line 260
      ldv_state_variable_4 = 1;
    } else {

    }
#line 263
    if (ldv_state_variable_4 == 2) {
#line 265
      cpia2_v4l_poll(cpia2_fops_group0, ldvarg2);
#line 267
      ldv_state_variable_4 = 2;
    } else {

    }
#line 270
    goto ldv_35512;
    case 5: ;
#line 273
    if (ldv_state_variable_4 == 1) {
#line 275
      video_ioctl2(cpia2_fops_group0, ldvarg1, ldvarg0);
#line 277
      ldv_state_variable_4 = 1;
    } else {

    }
#line 280
    if (ldv_state_variable_4 == 2) {
#line 282
      video_ioctl2(cpia2_fops_group0, ldvarg1, ldvarg0);
#line 284
      ldv_state_variable_4 = 2;
    } else {

    }
#line 287
    goto ldv_35512;
    default: 
#line 288
    ldv_stop();
    }
    ldv_35512: ;
  } else {

  }
#line 292
  goto ldv_35519;
  case 1: ;
#line 296
  if (ldv_state_variable_1 != 0) {
#line 297
    ldv_main_exported_1();
  } else {

  }
#line 300
  goto ldv_35519;
  case 2: ;
#line 304
  if (ldv_state_variable_0 != 0) {
#line 305
    tmp___38 = __VERIFIER_nondet_int();
#line 305
    switch (tmp___38) {
    case 0: ;
#line 308
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
#line 310
      cpia2_exit();
#line 311
      ldv_state_variable_0 = 2;
#line 312
      goto ldv_final;
    } else {

    }
#line 315
    goto ldv_35524;
    case 1: ;
#line 318
    if (ldv_state_variable_0 == 1) {
#line 320
      ldv_retval_4 = cpia2_init();
#line 322
      if (ldv_retval_4 == 0) {
#line 323
        ldv_state_variable_0 = 3;
#line 324
        ldv_state_variable_5 = 1;
#line 325
        ldv_initialize_v4l2_ioctl_ops_5();
#line 326
        ldv_state_variable_2 = 1;
#line 327
        ldv_state_variable_3 = 1;
#line 328
        ldv_state_variable_4 = 1;
#line 329
        ldv_initialize_v4l2_file_operations_4();
      } else {

      }
#line 331
      if (ldv_retval_4 != 0) {
#line 332
        ldv_state_variable_0 = 2;
#line 333
        goto ldv_final;
      } else {

      }
    } else {

    }
#line 337
    goto ldv_35524;
    default: 
#line 338
    ldv_stop();
    }
    ldv_35524: ;
  } else {

  }
#line 342
  goto ldv_35519;
  case 3: ;
#line 346
  if (ldv_state_variable_3 != 0) {
#line 347
    tmp___39 = __VERIFIER_nondet_int();
#line 347
    switch (tmp___39) {
    case 0: ;
#line 350
    if (ldv_state_variable_3 == 2) {
#line 352
      video_device_release_empty(ldvarg9);
#line 354
      ldv_state_variable_3 = 1;
#line 355
      ref_cnt = ref_cnt - 1;
    } else {

    }
#line 358
    goto ldv_35529;
    case 1: ;
#line 361
    if (ldv_state_variable_3 == 1) {
#line 363
      ldv_probe_3();
#line 365
      ldv_state_variable_3 = 2;
#line 366
      ref_cnt = ref_cnt + 1;
    } else {

    }
#line 369
    goto ldv_35529;
    default: 
#line 370
    ldv_stop();
    }
    ldv_35529: ;
  } else {

  }
#line 374
  goto ldv_35519;
  case 4: ;
#line 378
  if (ldv_state_variable_2 != 0) {
#line 379
    tmp___40 = __VERIFIER_nondet_int();
#line 379
    switch (tmp___40) {
    case 0: ;
#line 382
    if (ldv_state_variable_2 == 1) {
#line 384
      cpia2_s_ctrl(ldvarg10);
#line 386
      ldv_state_variable_2 = 1;
    } else {

    }
#line 389
    goto ldv_35534;
    default: 
#line 390
    ldv_stop();
    }
    ldv_35534: ;
  } else {

  }
#line 394
  goto ldv_35519;
  case 5: ;
#line 398
  if (ldv_state_variable_5 != 0) {
#line 399
    tmp___41 = __VERIFIER_nondet_int();
#line 399
    switch (tmp___41) {
    case 0: ;
#line 402
    if (ldv_state_variable_5 == 1) {
#line 404
      cpia2_reqbufs(cpia2_ioctl_ops_group3, ldvarg44, ldvarg43);
#line 406
      ldv_state_variable_5 = 1;
    } else {

    }
#line 409
    goto ldv_35538;
    case 1: ;
#line 412
    if (ldv_state_variable_5 == 1) {
#line 414
      v4l2_event_unsubscribe(cpia2_ioctl_ops_group4, cpia2_ioctl_ops_group2);
#line 416
      ldv_state_variable_5 = 1;
    } else {

    }
#line 419
    goto ldv_35538;
    case 2: ;
#line 422
    if (ldv_state_variable_5 == 1) {
#line 424
      cpia2_try_fmt_vid_cap(cpia2_ioctl_ops_group3, ldvarg42, cpia2_ioctl_ops_group0);
#line 426
      ldv_state_variable_5 = 1;
    } else {

    }
#line 429
    goto ldv_35538;
    case 3: ;
#line 432
    if (ldv_state_variable_5 == 1) {
#line 434
      cpia2_querybuf(cpia2_ioctl_ops_group3, ldvarg41, cpia2_ioctl_ops_group5);
#line 436
      ldv_state_variable_5 = 1;
    } else {

    }
#line 439
    goto ldv_35538;
    case 4: ;
#line 442
    if (ldv_state_variable_5 == 1) {
#line 444
      cpia2_dqbuf(cpia2_ioctl_ops_group3, ldvarg40, cpia2_ioctl_ops_group5);
#line 446
      ldv_state_variable_5 = 1;
    } else {

    }
#line 449
    goto ldv_35538;
    case 5: ;
#line 452
    if (ldv_state_variable_5 == 1) {
#line 454
      cpia2_streamoff(cpia2_ioctl_ops_group3, ldvarg39, ldvarg38);
#line 456
      ldv_state_variable_5 = 1;
    } else {

    }
#line 459
    goto ldv_35538;
    case 6: ;
#line 462
    if (ldv_state_variable_5 == 1) {
#line 464
      cpia2_enum_fmt_vid_cap(cpia2_ioctl_ops_group3, ldvarg37, ldvarg36);
#line 466
      ldv_state_variable_5 = 1;
    } else {

    }
#line 469
    goto ldv_35538;
    case 7: ;
#line 472
    if (ldv_state_variable_5 == 1) {
#line 474
      cpia2_s_fmt_vid_cap(cpia2_ioctl_ops_group3, ldvarg35, cpia2_ioctl_ops_group0);
#line 476
      ldv_state_variable_5 = 1;
    } else {

    }
#line 479
    goto ldv_35538;
    case 8: ;
#line 482
    if (ldv_state_variable_5 == 1) {
#line 484
      cpia2_cropcap(cpia2_ioctl_ops_group3, ldvarg34, ldvarg33);
#line 486
      ldv_state_variable_5 = 1;
    } else {

    }
#line 489
    goto ldv_35538;
    case 9: ;
#line 492
    if (ldv_state_variable_5 == 1) {
#line 494
      cpia2_g_fmt_vid_cap(cpia2_ioctl_ops_group3, ldvarg32, cpia2_ioctl_ops_group0);
#line 496
      ldv_state_variable_5 = 1;
    } else {

    }
#line 499
    goto ldv_35538;
    case 10: ;
#line 502
    if (ldv_state_variable_5 == 1) {
#line 504
      cpia2_g_input(cpia2_ioctl_ops_group3, ldvarg31, ldvarg30);
#line 506
      ldv_state_variable_5 = 1;
    } else {

    }
#line 509
    goto ldv_35538;
    case 11: ;
#line 512
    if (ldv_state_variable_5 == 1) {
#line 514
      cpia2_qbuf(cpia2_ioctl_ops_group3, ldvarg29, cpia2_ioctl_ops_group5);
#line 516
      ldv_state_variable_5 = 1;
    } else {

    }
#line 519
    goto ldv_35538;
    case 12: ;
#line 522
    if (ldv_state_variable_5 == 1) {
#line 524
      cpia2_enum_framesizes(cpia2_ioctl_ops_group3, ldvarg28, ldvarg27);
#line 526
      ldv_state_variable_5 = 1;
    } else {

    }
#line 529
    goto ldv_35538;
    case 13: ;
#line 532
    if (ldv_state_variable_5 == 1) {
#line 534
      cpia2_querycap(cpia2_ioctl_ops_group3, ldvarg26, ldvarg25);
#line 536
      ldv_state_variable_5 = 1;
    } else {

    }
#line 539
    goto ldv_35538;
    case 14: ;
#line 542
    if (ldv_state_variable_5 == 1) {
#line 544
      cpia2_enum_frameintervals(cpia2_ioctl_ops_group3, ldvarg24, ldvarg23);
#line 546
      ldv_state_variable_5 = 1;
    } else {

    }
#line 549
    goto ldv_35538;
    case 15: ;
#line 552
    if (ldv_state_variable_5 == 1) {
#line 554
      cpia2_s_jpegcomp(cpia2_ioctl_ops_group3, ldvarg22, (struct v4l2_jpegcompression  const  *)ldvarg21);
#line 556
      ldv_state_variable_5 = 1;
    } else {

    }
#line 559
    goto ldv_35538;
    case 16: ;
#line 562
    if (ldv_state_variable_5 == 1) {
#line 564
      cpia2_g_jpegcomp(cpia2_ioctl_ops_group3, ldvarg20, ldvarg19);
#line 566
      ldv_state_variable_5 = 1;
    } else {

    }
#line 569
    goto ldv_35538;
    case 17: ;
#line 572
    if (ldv_state_variable_5 == 1) {
#line 574
      cpia2_g_parm(cpia2_ioctl_ops_group3, ldvarg18, cpia2_ioctl_ops_group1);
#line 576
      ldv_state_variable_5 = 1;
    } else {

    }
#line 579
    goto ldv_35538;
    case 18: ;
#line 582
    if (ldv_state_variable_5 == 1) {
#line 584
      cpia2_enum_input(cpia2_ioctl_ops_group3, ldvarg17, ldvarg16);
#line 586
      ldv_state_variable_5 = 1;
    } else {

    }
#line 589
    goto ldv_35538;
    case 19: ;
#line 592
    if (ldv_state_variable_5 == 1) {
#line 594
      v4l2_ctrl_subscribe_event(cpia2_ioctl_ops_group4, cpia2_ioctl_ops_group2);
#line 596
      ldv_state_variable_5 = 1;
    } else {

    }
#line 599
    goto ldv_35538;
    case 20: ;
#line 602
    if (ldv_state_variable_5 == 1) {
#line 604
      cpia2_s_parm(cpia2_ioctl_ops_group3, ldvarg15, cpia2_ioctl_ops_group1);
#line 606
      ldv_state_variable_5 = 1;
    } else {

    }
#line 609
    goto ldv_35538;
    case 21: ;
#line 612
    if (ldv_state_variable_5 == 1) {
#line 614
      cpia2_s_input(cpia2_ioctl_ops_group3, ldvarg14, ldvarg13);
#line 616
      ldv_state_variable_5 = 1;
    } else {

    }
#line 619
    goto ldv_35538;
    case 22: ;
#line 622
    if (ldv_state_variable_5 == 1) {
#line 624
      cpia2_streamon(cpia2_ioctl_ops_group3, ldvarg12, ldvarg11);
#line 626
      ldv_state_variable_5 = 1;
    } else {

    }
#line 629
    goto ldv_35538;
    default: 
#line 630
    ldv_stop();
    }
    ldv_35538: ;
  } else {

  }
#line 634
  goto ldv_35519;
  default: 
#line 635
  ldv_stop();
  }
  ldv_35519: ;
#line 637
  goto ldv_35563;
  ldv_final: 
#line 639
  ldv_check_final_state();
#line 640
  return 0;
}
}
#line 667 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_lock_5(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 670
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 672
  mutex_lock(ldv_func_arg1);
#line 673
  return;
}
}
#line 675 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_unlock_6(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 678
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 680
  mutex_unlock(ldv_func_arg1);
#line 681
  return;
}
}
#line 683 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_unlock_7(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 686
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 688
  mutex_unlock(ldv_func_arg1);
#line 689
  return;
}
}
#line 691 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_lock_8(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 694
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 696
  mutex_lock(ldv_func_arg1);
#line 697
  return;
}
}
#line 699 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_lock_9(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 702
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 704
  mutex_lock(ldv_func_arg1);
#line 705
  return;
}
}
#line 707 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
int ldv_mutex_trylock_10(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 711
  tmp = mutex_trylock(ldv_func_arg1);
#line 711
  ldv_func_res = tmp;
#line 713
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 713
  return (tmp___0);
#line 715
  return (ldv_func_res);
}
}
#line 718 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_unlock_11(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 721
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 723
  mutex_unlock(ldv_func_arg1);
#line 724
  return;
}
}
#line 726 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_lock_12(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 729
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 731
  mutex_lock(ldv_func_arg1);
#line 732
  return;
}
}
#line 734 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_unlock_13(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 737
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 739
  mutex_unlock(ldv_func_arg1);
#line 740
  return;
}
}
#line 742 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
int ldv_mutex_lock_interruptible_14(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 746
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 746
  ldv_func_res = tmp;
#line 748
  tmp___0 = ldv_mutex_lock_interruptible_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 748
  return (tmp___0);
#line 750
  return (ldv_func_res);
}
}
#line 753 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_unlock_15(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 756
  ldv_mutex_unlock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 758
  mutex_unlock(ldv_func_arg1);
#line 759
  return;
}
}
#line 761 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_lock_16(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 764
  ldv_mutex_lock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 766
  mutex_lock(ldv_func_arg1);
#line 767
  return;
}
}
#line 769 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_unlock_17(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 772
  ldv_mutex_unlock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 774
  mutex_unlock(ldv_func_arg1);
#line 775
  return;
}
}
#line 777 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
int ldv_mutex_lock_interruptible_18(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 781
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 781
  ldv_func_res = tmp;
#line 783
  tmp___0 = ldv_mutex_lock_interruptible_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 783
  return (tmp___0);
#line 785
  return (ldv_func_res);
}
}
#line 788 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_unlock_19(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 791
  ldv_mutex_unlock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 793
  mutex_unlock(ldv_func_arg1);
#line 794
  return;
}
}
#line 796 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_lock_20(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 799
  ldv_mutex_lock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 801
  mutex_lock(ldv_func_arg1);
#line 802
  return;
}
}
#line 804 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_unlock_21(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 807
  ldv_mutex_unlock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 809
  mutex_unlock(ldv_func_arg1);
#line 810
  return;
}
}
#line 812 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_unlock_22(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 815
  ldv_mutex_unlock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 817
  mutex_unlock(ldv_func_arg1);
#line 818
  return;
}
}
#line 820 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_lock_23(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 823
  ldv_mutex_lock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 825
  mutex_lock(ldv_func_arg1);
#line 826
  return;
}
}
#line 828 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_unlock_24(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 831
  ldv_mutex_unlock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 833
  mutex_unlock(ldv_func_arg1);
#line 834
  return;
}
}
#line 836 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_lock_25(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 839
  ldv_mutex_lock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 841
  mutex_lock(ldv_func_arg1);
#line 842
  return;
}
}
#line 844 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
int ldv_mutex_lock_interruptible_26(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 848
  tmp = mutex_lock_interruptible(ldv_func_arg1);
#line 848
  ldv_func_res = tmp;
#line 850
  tmp___0 = ldv_mutex_lock_interruptible_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 850
  return (tmp___0);
#line 852
  return (ldv_func_res);
}
}
#line 855 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_v4l.o.c.prepared"
void ldv_mutex_unlock_27(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 858
  ldv_mutex_unlock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 860
  mutex_unlock(ldv_func_arg1);
#line 861
  return;
}
}
#line 187 "include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 189
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 176 "include/linux/mutex.h"
int ldv_mutex_trylock_58(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_56(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_59(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_60(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_63(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_65(struct mutex *ldv_func_arg1 ) ;
#line 201
void ldv_mutex_unlock_67(struct mutex *ldv_func_arg1 ) ;
#line 205
void ldv_mutex_unlock_69(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_mutex_lock_55(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_57(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_61(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_62(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_64(struct mutex *ldv_func_arg1 ) ;
#line 41
void ldv_mutex_lock_66(struct mutex *ldv_func_arg1 ) ;
#line 45
void ldv_mutex_lock_68(struct mutex *ldv_func_arg1 ) ;
#line 105 "include/linux/wait.h"
__inline static int waitqueue_active(wait_queue_head_t *q ) 
{ 
  int tmp ;

  {
#line 107
  tmp = list_empty((struct list_head  const  *)(& q->task_list));
#line 107
  return (tmp == 0);
}
}
#line 149
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 289 "include/linux/slab.h"
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 418 "include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
#line 435
  tmp___2 = __kmalloc(size, flags);
#line 435
  return (tmp___2);
}
}
#line 106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_usb_driver_1(void) ;
#line 1090 "include/linux/device.h"
extern void _dev_info(struct device  const  * , char const   *  , ...) ;
#line 189 "include/linux/usb.h"
__inline static void *usb_get_intfdata(struct usb_interface *intf ) 
{ 
  void *tmp ;

  {
#line 191
  tmp = dev_get_drvdata((struct device  const  *)(& intf->dev));
#line 191
  return (tmp);
}
}
#line 194 "include/linux/usb.h"
__inline static void usb_set_intfdata(struct usb_interface *intf , void *data ) 
{ 


  {
#line 196
  dev_set_drvdata(& intf->dev, data);
#line 197
  return;
}
}
#line 616 "include/linux/usb.h"
__inline static struct usb_device *interface_to_usbdev(struct usb_interface *intf ) 
{ 
  struct device  const  *__mptr ;

  {
#line 618
  __mptr = (struct device  const  *)intf->dev.parent;
#line 618
  return ((struct usb_device *)__mptr + 0xffffffffffffff70UL);
}
}
#line 762
extern void usb_driver_release_interface(struct usb_driver * , struct usb_interface * ) ;
#line 1169
extern int usb_register_driver(struct usb_driver * , struct module * , char const   * ) ;
#line 1173
int ldv_usb_register_driver_70(struct usb_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                               char const   *ldv_func_arg3 ) ;
#line 1180
extern void usb_deregister(struct usb_driver * ) ;
#line 1183
void ldv_usb_deregister_71(struct usb_driver *arg ) ;
#line 1602
extern struct urb *usb_alloc_urb(int  , gfp_t  ) ;
#line 1603
extern void usb_free_urb(struct urb * ) ;
#line 1606
extern int usb_submit_urb(struct urb * , gfp_t  ) ;
#line 1608
extern void usb_kill_urb(struct urb * ) ;
#line 1677
extern int usb_control_msg(struct usb_device * , unsigned int  , __u8  , __u8  , __u16  ,
                           __u16  , void * , __u16  , int  ) ;
#line 1697
extern int usb_set_interface(struct usb_device * , int  , int  ) ;
#line 1805 "include/linux/usb.h"
__inline static unsigned int __create_pipe(struct usb_device *dev , unsigned int endpoint ) 
{ 


  {
#line 1808
  return ((unsigned int )(dev->devnum << 8) | (endpoint << 15));
}
}
#line 190 "include/media/v4l2-common.h"
extern void v4l2_get_timestamp(struct timeval * ) ;
#line 72 "include/media/v4l2-device.h"
extern int v4l2_device_put(struct v4l2_device * ) ;
#line 101
extern void v4l2_device_disconnect(struct v4l2_device * ) ;
#line 398 "include/media/v4l2-ctrls.h"
extern int v4l2_ctrl_handler_setup(struct v4l2_ctrl_handler * ) ;
#line 441 "/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/media/usb/cpia2/cpia2.h"
int cpia2_send_command(struct camera_data *cam , struct cpia2_command *cmd ) ;
#line 442
int cpia2_do_command(struct camera_data *cam , unsigned int command , unsigned char direction ,
                     unsigned char param ) ;
#line 445
struct camera_data *cpia2_init_camera_struct(struct usb_interface *intf ) ;
#line 446
int cpia2_init_camera(struct camera_data *cam ) ;
#line 462
int cpia2_usb_transfer_cmd(struct camera_data *cam , void *registers , u8 request ,
                           u8 start , u8 count , u8 direction ) ;
#line 466
int cpia2_usb_stream_pause(struct camera_data *cam ) ;
#line 467
int cpia2_usb_stream_resume(struct camera_data *cam ) ;
#line 468
int cpia2_usb_change_streaming_alternate(struct camera_data *cam , unsigned int alt ) ;
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
static int frame_sizes[8U]  = 
#line 38 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
  {      0,      0,      128,      384, 
        640,      768,      896,      1023};
#line 52
static void process_frame(struct camera_data *cam ) ;
#line 53
static void cpia2_usb_complete(struct urb *urb ) ;
#line 54
static int cpia2_usb_probe(struct usb_interface *intf , struct usb_device_id  const  *id ) ;
#line 56
static void cpia2_usb_disconnect(struct usb_interface *intf ) ;
#line 57
static int cpia2_usb_suspend(struct usb_interface *intf , pm_message_t message ) ;
#line 58
static int cpia2_usb_resume(struct usb_interface *intf ) ;
#line 60
static void free_sbufs(struct camera_data *cam ) ;
#line 61
static void add_APPn(struct camera_data *cam ) ;
#line 62
static void add_COM(struct camera_data *cam ) ;
#line 63
static int submit_urbs(struct camera_data *cam ) ;
#line 64
static int set_alternate(struct camera_data *cam , unsigned int alt ) ;
#line 65
static int configure_transfer_mode(struct camera_data *cam , unsigned int alt ) ;
#line 67 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
static struct usb_device_id cpia2_id_table[4U]  = {      {3U, 1363U, 256U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      0UL}, 
        {3U, 1363U, 320U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      0UL}, 
        {3U, 1363U, 337U, (unsigned short)0, (unsigned short)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      0UL}};
#line 73 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
struct usb_device_id  const  __mod_usb__cpia2_id_table_device_table[4U]  ;
#line 75 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
static struct usb_driver cpia2_driver  = 
#line 75
     {"cpia2", & cpia2_usb_probe, & cpia2_usb_disconnect, 0, & cpia2_usb_suspend, & cpia2_usb_resume,
    & cpia2_usb_resume, 0, 0, (struct usb_device_id  const  *)(& cpia2_id_table),
    {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}, {{0, 0, 0, 0, (_Bool)0,
                                                                0, 0, 0, 0, 0, 0,
                                                                0, 0, 0, 0, 0}, 0},
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0};
#line 91 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
static void process_frame(struct camera_data *cam ) 
{ 
  int frame_count ;
  unsigned char *inbuff ;

  {
#line 95
  inbuff = (cam->workbuff)->data;
#line 100
  if ((cam->workbuff)->length > (cam->workbuff)->max_length) {
#line 101
    (cam->workbuff)->max_length = (cam->workbuff)->length;
  } else {

  }
#line 103
  if ((unsigned int )*inbuff == 255U && (unsigned int )*(inbuff + 1UL) == 216U) {
#line 104
    frame_count = frame_count + 1;
  } else {
#line 106
    (cam->workbuff)->status = 3;
#line 108
    return;
  }
#line 114
  if (cam->first_image_seen == 0) {
#line 117
    cam->first_image_seen = 1;
#line 118
    (cam->workbuff)->status = 0;
#line 119
    return;
  } else {

  }
#line 121
  if ((cam->workbuff)->length > 3) {
#line 122
    if ((unsigned int )cam->mmapped != 0U && (cam->workbuff)->length < (cam->workbuff)->max_length) {
#line 125
      memset((void *)(cam->workbuff)->data + (unsigned long )(cam->workbuff)->length,
               0, (size_t )((cam->workbuff)->max_length - (cam->workbuff)->length));
    } else {

    }
#line 129
    (cam->workbuff)->max_length = (cam->workbuff)->length;
#line 130
    (cam->workbuff)->status = 2;
#line 132
    if ((unsigned int )cam->mmapped == 0U && cam->num_frames > 2) {
#line 149
      (cam->curbuff)->status = 0;
    } else {

    }
#line 151
    cam->curbuff = cam->workbuff;
#line 152
    cam->workbuff = (cam->workbuff)->next;
#line 155
    return;
  } else {

  }
#line 160
  (cam->workbuff)->status = 3;
#line 161
  return;
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
static void add_APPn(struct camera_data *cam ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 172
  if (cam->APP_len > 0) {
#line 173
    tmp = (cam->workbuff)->length;
#line 173
    (cam->workbuff)->length = (cam->workbuff)->length + 1;
#line 173
    *((cam->workbuff)->data + (unsigned long )tmp) = 255U;
#line 174
    tmp___0 = (cam->workbuff)->length;
#line 174
    (cam->workbuff)->length = (cam->workbuff)->length + 1;
#line 174
    *((cam->workbuff)->data + (unsigned long )tmp___0) = (unsigned int )((u8 )cam->APPn) + 224U;
#line 175
    tmp___1 = (cam->workbuff)->length;
#line 175
    (cam->workbuff)->length = (cam->workbuff)->length + 1;
#line 175
    *((cam->workbuff)->data + (unsigned long )tmp___1) = 0U;
#line 176
    tmp___2 = (cam->workbuff)->length;
#line 176
    (cam->workbuff)->length = (cam->workbuff)->length + 1;
#line 176
    *((cam->workbuff)->data + (unsigned long )tmp___2) = (unsigned int )((u8 )cam->APP_len) + 2U;
#line 177
    memcpy((void *)(cam->workbuff)->data + (unsigned long )(cam->workbuff)->length,
             (void const   *)(& cam->APP_data), (size_t )cam->APP_len);
#line 179
    (cam->workbuff)->length = (cam->workbuff)->length + cam->APP_len;
  } else {

  }
#line 181
  return;
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
static void add_COM(struct camera_data *cam ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 191
  if (cam->COM_len > 0) {
#line 192
    tmp = (cam->workbuff)->length;
#line 192
    (cam->workbuff)->length = (cam->workbuff)->length + 1;
#line 192
    *((cam->workbuff)->data + (unsigned long )tmp) = 255U;
#line 193
    tmp___0 = (cam->workbuff)->length;
#line 193
    (cam->workbuff)->length = (cam->workbuff)->length + 1;
#line 193
    *((cam->workbuff)->data + (unsigned long )tmp___0) = 254U;
#line 194
    tmp___1 = (cam->workbuff)->length;
#line 194
    (cam->workbuff)->length = (cam->workbuff)->length + 1;
#line 194
    *((cam->workbuff)->data + (unsigned long )tmp___1) = 0U;
#line 195
    tmp___2 = (cam->workbuff)->length;
#line 195
    (cam->workbuff)->length = (cam->workbuff)->length + 1;
#line 195
    *((cam->workbuff)->data + (unsigned long )tmp___2) = (unsigned int )((u8 )cam->COM_len) + 2U;
#line 196
    memcpy((void *)(cam->workbuff)->data + (unsigned long )(cam->workbuff)->length,
             (void const   *)(& cam->COM_data), (size_t )cam->COM_len);
#line 198
    (cam->workbuff)->length = (cam->workbuff)->length + cam->COM_len;
  } else {

  }
#line 200
  return;
}
}
#line 208 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
static void cpia2_usb_complete(struct urb *urb ) 
{ 
  int i ;
  unsigned char *cdata ;
  bool frame_ready ;
  struct camera_data *cam ;
  int tmp ;
  int tmp___0 ;
  u16 checksum ;
  u16 iso_checksum ;
  int j ;
  int n ;
  int st ;
  struct framebuf *ptr ;
  int data_offset ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
#line 212
  frame_ready = 0;
#line 213
  cam = (struct camera_data *)urb->context;
#line 215
  if (urb->status != 0) {
#line 223
    return;
  } else {

  }
#line 226
  if (cam->streaming == 0) {
#line 227
    tmp = video_is_registered(& cam->vdev);
#line 227
    printk("\016cpia2: Will now stop the streaming: streaming = %d, present=%d\n",
           cam->streaming, tmp);
#line 229
    return;
  } else {
#line 226
    tmp___0 = video_is_registered(& cam->vdev);
#line 226
    if (tmp___0 == 0) {
#line 227
      tmp = video_is_registered(& cam->vdev);
#line 227
      printk("\016cpia2: Will now stop the streaming: streaming = %d, present=%d\n",
             cam->streaming, tmp);
#line 229
      return;
    } else {

    }
  }
#line 236
  i = 0;
#line 236
  goto ldv_34499;
  ldv_34498: 
#line 239
  n = (int )urb->iso_frame_desc[i].actual_length;
#line 240
  st = urb->iso_frame_desc[i].status;
#line 242
  if ((unsigned int )(cam->workbuff)->status == 2U) {
#line 246
    ptr = (cam->workbuff)->next;
#line 246
    goto ldv_34491;
    ldv_34490: ;
#line 250
    if ((unsigned int )ptr->status == 0U) {
#line 251
      ptr->status = 1;
#line 252
      ptr->length = 0;
#line 253
      goto ldv_34489;
    } else {

    }
#line 248
    ptr = ptr->next;
    ldv_34491: ;
#line 246
    if ((unsigned long )cam->workbuff != (unsigned long )ptr) {
#line 249
      goto ldv_34490;
    } else {

    }
    ldv_34489: ;
#line 256
    if ((unsigned long )cam->workbuff == (unsigned long )ptr) {
#line 257
      goto ldv_34492;
    } else {

    }
#line 259
    cam->workbuff = ptr;
  } else {

  }
#line 262
  if ((unsigned int )(cam->workbuff)->status == 0U || (unsigned int )(cam->workbuff)->status == 3U) {
#line 264
    (cam->workbuff)->status = 1;
#line 265
    (cam->workbuff)->length = 0;
  } else {

  }
#line 269
  cdata = (unsigned char *)urb->transfer_buffer + (unsigned long )urb->iso_frame_desc[i].offset;
#line 271
  if (st != 0) {
#line 272
    printk("\016cpia2: cpia2 data error: [%d] len=%d, status = %d\n", i, n, st);
#line 275
    (cam->workbuff)->status = 3;
#line 276
    goto ldv_34493;
  } else {

  }
#line 279
  if (n <= 2) {
#line 280
    goto ldv_34493;
  } else {

  }
#line 282
  checksum = 0U;
#line 283
  j = 0;
#line 283
  goto ldv_34495;
  ldv_34494: 
#line 284
  checksum = (int )((u16 )*(cdata + (unsigned long )j)) + (int )checksum;
#line 283
  j = j + 1;
  ldv_34495: ;
#line 283
  if (n + -2 > j) {
#line 285
    goto ldv_34494;
  } else {

  }
#line 285
  iso_checksum = (unsigned int )((u16 )*(cdata + (unsigned long )j)) + (unsigned int )((u16 )*(cdata + ((unsigned long )j + 1UL))) * 256U;
#line 286
  if ((int )checksum != (int )iso_checksum) {
#line 287
    printk("\016cpia2: checksum mismatch: [%d] len=%d, calculated = %x, checksum = %x\n",
           i, n, (int )checksum, (int )iso_checksum);
#line 290
    (cam->workbuff)->status = 3;
#line 291
    goto ldv_34493;
  } else {

  }
#line 294
  n = n + -2;
#line 296
  if ((unsigned int )(cam->workbuff)->status != 1U) {
#line 297
    if (((unsigned int )*cdata == 255U && (unsigned int )*(cdata + 1UL) == 216U) || (((unsigned int )*cdata == 216U && (unsigned int )*(cdata + 1UL) == 255U) && (unsigned int )*(cdata + 2UL) != 0U)) {
#line 302
      cam->frame_count = cam->frame_count + 1UL;
    } else {

    }
#line 306
    goto ldv_34493;
  } else {

  }
#line 309
  if (cam->frame_size < (u32 )((cam->workbuff)->length + n)) {
#line 310
    printk("\vcpia2: buffer overflow! length: %d, n: %d\n", (cam->workbuff)->length,
           n);
#line 312
    (cam->workbuff)->status = 3;
#line 313
    if ((cam->workbuff)->length > (cam->workbuff)->max_length) {
#line 314
      (cam->workbuff)->max_length = (cam->workbuff)->length;
    } else {

    }
#line 316
    goto ldv_34493;
  } else {

  }
#line 319
  if ((cam->workbuff)->length == 0) {
#line 321
    if ((unsigned int )*cdata == 216U && (unsigned int )*(cdata + 1UL) == 255U) {
#line 322
      data_offset = 1;
    } else
#line 323
    if (((unsigned int )*cdata == 255U && (unsigned int )*(cdata + 1UL) == 216U) && (unsigned int )*(cdata + 2UL) == 255U) {
#line 325
      data_offset = 2;
    } else {
#line 328
      goto ldv_34493;
    }
#line 331
    v4l2_get_timestamp(& (cam->workbuff)->timestamp);
#line 332
    tmp___1 = cam->frame_count;
#line 332
    cam->frame_count = cam->frame_count + 1UL;
#line 332
    (cam->workbuff)->seq = tmp___1;
#line 333
    *((cam->workbuff)->data) = 255U;
#line 334
    *((cam->workbuff)->data + 1UL) = 216U;
#line 335
    (cam->workbuff)->length = 2;
#line 336
    add_APPn(cam);
#line 337
    add_COM(cam);
#line 338
    memcpy((void *)(cam->workbuff)->data + (unsigned long )(cam->workbuff)->length,
             (void const   *)cdata + (unsigned long )data_offset, (size_t )(n - data_offset));
#line 340
    (cam->workbuff)->length = (cam->workbuff)->length + (n - data_offset);
  } else
#line 341
  if ((cam->workbuff)->length > 0) {
#line 342
    memcpy((void *)(cam->workbuff)->data + (unsigned long )(cam->workbuff)->length,
             (void const   *)cdata, (size_t )n);
#line 344
    (cam->workbuff)->length = (cam->workbuff)->length + n;
  } else {

  }
#line 347
  if ((((cam->workbuff)->length > 2 && (unsigned int )*((cam->workbuff)->data + ((unsigned long )(cam->workbuff)->length + 0xfffffffffffffffdUL)) == 255U) && (unsigned int )*((cam->workbuff)->data + ((unsigned long )(cam->workbuff)->length + 0xfffffffffffffffeUL)) == 217U) && (unsigned int )*((cam->workbuff)->data + ((unsigned long )(cam->workbuff)->length + 0xffffffffffffffffUL)) == 255U) {
#line 351
    frame_ready = 1;
#line 352
    *((cam->workbuff)->data + ((unsigned long )(cam->workbuff)->length + 0xffffffffffffffffUL)) = 0U;
#line 353
    (cam->workbuff)->length = (cam->workbuff)->length + -1;
  } else
#line 354
  if (((cam->workbuff)->length > 1 && (unsigned int )*((cam->workbuff)->data + ((unsigned long )(cam->workbuff)->length + 0xfffffffffffffffeUL)) == 255U) && (unsigned int )*((cam->workbuff)->data + ((unsigned long )(cam->workbuff)->length + 0xffffffffffffffffUL)) == 217U) {
#line 357
    frame_ready = 1;
  } else {

  }
#line 360
  if ((int )frame_ready) {
#line 362
    process_frame(cam);
#line 364
    frame_ready = 0;
#line 366
    tmp___2 = waitqueue_active(& cam->wq_stream);
#line 366
    if (tmp___2 != 0) {
#line 367
      __wake_up(& cam->wq_stream, 1U, 1, (void *)0);
    } else {

    }
  } else {

  }
  ldv_34493: 
#line 236
  i = i + 1;
  ldv_34499: ;
#line 236
  if (urb->number_of_packets > i) {
#line 238
    goto ldv_34498;
  } else {

  }
  ldv_34492: ;
#line 371
  if (cam->streaming != 0) {
#line 373
    urb->dev = cam->dev;
#line 374
    i = usb_submit_urb(urb, 32U);
#line 374
    if (i != 0) {
#line 375
      printk("\vcpia2: %s: usb_submit_urb ret %d!\n", "cpia2_usb_complete", i);
    } else {

    }
  } else {

  }
#line 377
  return;
}
}
#line 384 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
static int configure_transfer_mode(struct camera_data *cam , unsigned int alt ) 
{ 
  unsigned char iso_regs[8U][4U] ;
  struct cpia2_command cmd ;
  unsigned char reg ;
  int tmp ;

  {
#line 386
  iso_regs[0][0] = 0U;
#line 386
  iso_regs[0][1] = 0U;
#line 386
  iso_regs[0][2] = 0U;
#line 386
  iso_regs[0][3] = 0U;
#line 386
  iso_regs[1][0] = 0U;
#line 386
  iso_regs[1][1] = 0U;
#line 386
  iso_regs[1][2] = 0U;
#line 386
  iso_regs[1][3] = 0U;
#line 386
  iso_regs[2][0] = 185U;
#line 386
  iso_regs[2][1] = 0U;
#line 386
  iso_regs[2][2] = 0U;
#line 386
  iso_regs[2][3] = 126U;
#line 386
  iso_regs[3][0] = 185U;
#line 386
  iso_regs[3][1] = 0U;
#line 386
  iso_regs[3][2] = 1U;
#line 386
  iso_regs[3][3] = 126U;
#line 386
  iso_regs[4][0] = 185U;
#line 386
  iso_regs[4][1] = 0U;
#line 386
  iso_regs[4][2] = 2U;
#line 386
  iso_regs[4][3] = 126U;
#line 386
  iso_regs[5][0] = 185U;
#line 386
  iso_regs[5][1] = 0U;
#line 386
  iso_regs[5][2] = 2U;
#line 386
  iso_regs[5][3] = 254U;
#line 386
  iso_regs[6][0] = 185U;
#line 386
  iso_regs[6][1] = 0U;
#line 386
  iso_regs[6][2] = 3U;
#line 386
  iso_regs[6][3] = 126U;
#line 386
  iso_regs[7][0] = 185U;
#line 386
  iso_regs[7][1] = 0U;
#line 386
  iso_regs[7][2] = 3U;
#line 386
  iso_regs[7][3] = 253U;
#line 399
  tmp = video_is_registered(& cam->vdev);
#line 399
  if (tmp == 0) {
#line 400
    return (-19);
  } else {

  }
#line 405
  cmd.direction = 1U;
#line 406
  cmd.buffer.block_data[0] = iso_regs[alt][0];
#line 407
  cmd.buffer.block_data[1] = iso_regs[alt][1];
#line 408
  cmd.buffer.block_data[2] = iso_regs[alt][2];
#line 409
  cmd.buffer.block_data[3] = iso_regs[alt][3];
#line 410
  cmd.req_mode = 1U;
#line 411
  cmd.start = 176U;
#line 412
  cmd.reg_count = 4U;
#line 413
  cpia2_send_command(cam, & cmd);
#line 419
  cmd.direction = 0U;
#line 420
  cmd.req_mode = 1U;
#line 421
  cmd.start = 169U;
#line 422
  cmd.reg_count = 1U;
#line 423
  cpia2_send_command(cam, & cmd);
#line 424
  reg = cmd.buffer.block_data[0];
#line 427
  reg = (unsigned int )reg & 248U;
#line 431
  if (alt == 1U) {
#line 433
    reg = (unsigned int )reg | 2U;
#line 434
    cam->xfer_mode = 1;
  } else
#line 435
  if (alt > 1U) {
#line 437
    reg = (unsigned int )reg | 1U;
#line 438
    cam->xfer_mode = 0;
  } else {

  }
#line 441
  cmd.buffer.block_data[0] = reg;
#line 442
  cmd.direction = 1U;
#line 443
  cmd.start = 169U;
#line 444
  cmd.reg_count = 1U;
#line 445
  cmd.req_mode = 1U;
#line 446
  cpia2_send_command(cam, & cmd);
#line 448
  return (0);
}
}
#line 456 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
int cpia2_usb_change_streaming_alternate(struct camera_data *cam , unsigned int alt ) 
{ 
  int ret ;

  {
#line 459
  ret = 0;
#line 461
  if (alt <= 1U || alt > 7U) {
#line 462
    return (-22);
  } else {

  }
#line 464
  if ((unsigned int )cam->params.camera_state.stream_mode == alt) {
#line 465
    return (0);
  } else {

  }
#line 467
  cpia2_usb_stream_pause(cam);
#line 469
  configure_transfer_mode(cam, alt);
#line 471
  cam->params.camera_state.stream_mode = (u8 )alt;
#line 474
  cpia2_reset_camera(cam);
#line 476
  cpia2_usb_stream_resume(cam);
#line 478
  return (ret);
}
}
#line 486 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
static int set_alternate(struct camera_data *cam , unsigned int alt ) 
{ 
  int ret ;

  {
#line 488
  ret = 0;
#line 490
  if (cam->cur_alt == alt) {
#line 491
    return (0);
  } else {

  }
#line 493
  if (cam->cur_alt != 0U) {
#line 495
    ret = usb_set_interface(cam->dev, (int )cam->iface, 0);
#line 496
    if (ret != 0) {
#line 497
      return (ret);
    } else {

    }
  } else {

  }
#line 499
  if (alt != 0U) {
#line 501
    ret = usb_set_interface(cam->dev, (int )cam->iface, (int )alt);
#line 502
    if (ret != 0) {
#line 503
      return (ret);
    } else {

    }
  } else {

  }
#line 506
  cam->old_alt = cam->cur_alt;
#line 507
  cam->cur_alt = alt;
#line 509
  return (ret);
}
}
#line 520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
static void free_sbufs(struct camera_data *cam ) 
{ 
  int i ;

  {
#line 524
  i = 0;
#line 524
  goto ldv_34523;
  ldv_34522: ;
#line 525
  if ((unsigned long )cam->sbuf[i].urb != (unsigned long )((struct urb *)0)) {
#line 526
    usb_kill_urb(cam->sbuf[i].urb);
#line 527
    usb_free_urb(cam->sbuf[i].urb);
#line 528
    cam->sbuf[i].urb = (struct urb *)0;
  } else {

  }
#line 530
  if ((unsigned long )cam->sbuf[i].data != (unsigned long )((char *)0)) {
#line 531
    kfree((void const   *)cam->sbuf[i].data);
#line 532
    cam->sbuf[i].data = (char *)0;
  } else {

  }
#line 524
  i = i + 1;
  ldv_34523: ;
#line 524
  if (i <= 1) {
#line 526
    goto ldv_34522;
  } else {

  }

#line 531
  return;
}
}
#line 545 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
static int write_packet(struct usb_device *udev , u8 request , u8 *registers , u16 start ,
                        size_t size ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 548
  if ((unsigned long )registers == (unsigned long )((u8 *)0U) || size == 0UL) {
#line 549
    return (-22);
  } else {

  }
#line 551
  tmp = __create_pipe(udev, 0U);
#line 551
  tmp___0 = usb_control_msg(udev, tmp | 2147483648U, (int )request, 64, (int )start,
                            0, (void *)registers, (int )((__u16 )size), 250);
#line 551
  return (tmp___0);
}
}
#line 567 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
static int read_packet(struct usb_device *udev , u8 request , u8 *registers , u16 start ,
                       size_t size ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 570
  if ((unsigned long )registers == (unsigned long )((u8 *)0U) || size == 0UL) {
#line 571
    return (-22);
  } else {

  }
#line 573
  tmp = __create_pipe(udev, 0U);
#line 573
  tmp___0 = usb_control_msg(udev, tmp | 2147483776U, (int )request, 192, (int )start,
                            0, (void *)registers, (int )((__u16 )size), 250);
#line 573
  return (tmp___0);
}
}
#line 589 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
int cpia2_usb_transfer_cmd(struct camera_data *cam , void *registers , u8 request ,
                           u8 start , u8 count , u8 direction ) 
{ 
  int err ;
  struct usb_device *udev ;

  {
#line 593
  err = 0;
#line 594
  udev = cam->dev;
#line 596
  if ((unsigned long )udev == (unsigned long )((struct usb_device *)0)) {
#line 597
    printk("\vcpia2: %s: Internal driver error: udev is NULL\n", "cpia2_usb_transfer_cmd");
#line 598
    return (-22);
  } else {

  }
#line 601
  if ((unsigned long )registers == (unsigned long )((void *)0)) {
#line 602
    printk("\vcpia2: %s: Internal driver error: register array is NULL\n", "cpia2_usb_transfer_cmd");
#line 603
    return (-22);
  } else {

  }
#line 606
  if ((unsigned int )direction == 0U) {
#line 607
    err = read_packet(udev, (int )request, (u8 *)registers, (int )start, (size_t )count);
#line 608
    if (err > 0) {
#line 609
      err = 0;
    } else {

    }
  } else
#line 610
  if ((unsigned int )direction == 1U) {
#line 611
    err = write_packet(udev, (int )request, (u8 *)registers, (int )start, (size_t )count);
#line 612
    if (err < 0) {
#line 613
      printk("\016cpia2: Control message failed, err val = %d\n", err);
#line 614
      printk("\016cpia2: Message: request = 0x%0X, start = 0x%0X\n", (int )request,
             (int )start);
#line 616
      printk("\016cpia2: Message: count = %d, register[0] = 0x%0X\n", (int )count,
             (int )*((unsigned char *)registers));
    } else {
#line 619
      err = 0;
    }
  } else {
#line 621
    printk("\016cpia2: Unexpected first byte of direction: %d\n", (int )direction);
#line 623
    return (-22);
  }
#line 626
  if (err != 0) {
#line 627
    printk("\016cpia2: Unexpected error: %d\n", err);
  } else {

  }
#line 628
  return (err);
}
}
#line 637 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
static int submit_urbs(struct camera_data *cam ) 
{ 
  struct urb *urb ;
  int fx ;
  int err ;
  int i ;
  int j ;
  void *tmp ;
  unsigned int tmp___0 ;

  {
#line 642
  i = 0;
#line 642
  goto ldv_34563;
  ldv_34562: ;
#line 643
  if ((unsigned long )cam->sbuf[i].data != (unsigned long )((char *)0)) {
#line 644
    goto ldv_34558;
  } else {

  }
#line 645
  tmp = kmalloc((size_t )(frame_sizes[cam->cur_alt] * 10), 208U);
#line 645
  cam->sbuf[i].data = (char *)tmp;
#line 647
  if ((unsigned long )cam->sbuf[i].data == (unsigned long )((char *)0)) {
#line 648
    goto ldv_34560;
    ldv_34559: 
#line 649
    kfree((void const   *)cam->sbuf[i].data);
#line 650
    cam->sbuf[i].data = (char *)0;
    ldv_34560: 
#line 648
    i = i - 1;
#line 648
    if (i >= 0) {
#line 650
      goto ldv_34559;
    } else {

    }

#line 652
    return (-12);
  } else {

  }
  ldv_34558: 
#line 642
  i = i + 1;
  ldv_34563: ;
#line 642
  if (i <= 1) {
#line 644
    goto ldv_34562;
  } else {

  }
#line 659
  i = 0;
#line 659
  goto ldv_34574;
  ldv_34573: ;
#line 660
  if ((unsigned long )cam->sbuf[i].urb != (unsigned long )((struct urb *)0)) {
#line 661
    goto ldv_34565;
  } else {

  }
#line 663
  urb = usb_alloc_urb(10, 208U);
#line 664
  if ((unsigned long )urb == (unsigned long )((struct urb *)0)) {
#line 665
    printk("\vcpia2: %s: usb_alloc_urb error!\n", "submit_urbs");
#line 666
    j = 0;
#line 666
    goto ldv_34568;
    ldv_34567: 
#line 667
    usb_free_urb(cam->sbuf[j].urb);
#line 666
    j = j + 1;
    ldv_34568: ;
#line 666
    if (j < i) {
#line 668
      goto ldv_34567;
    } else {

    }

#line 668
    return (-12);
  } else {

  }
#line 671
  cam->sbuf[i].urb = urb;
#line 672
  urb->dev = cam->dev;
#line 673
  urb->context = (void *)cam;
#line 674
  tmp___0 = __create_pipe(cam->dev, 1U);
#line 674
  urb->pipe = tmp___0 | 128U;
#line 675
  urb->transfer_flags = 2U;
#line 676
  urb->transfer_buffer = (void *)cam->sbuf[i].data;
#line 677
  urb->complete = & cpia2_usb_complete;
#line 678
  urb->number_of_packets = 10;
#line 679
  urb->interval = 1;
#line 680
  urb->transfer_buffer_length = (u32 )(frame_sizes[cam->cur_alt] * 10);
#line 683
  fx = 0;
#line 683
  goto ldv_34571;
  ldv_34570: 
#line 684
  urb->iso_frame_desc[fx].offset = (unsigned int )(frame_sizes[cam->cur_alt] * fx);
#line 686
  urb->iso_frame_desc[fx].length = (unsigned int )frame_sizes[cam->cur_alt];
#line 683
  fx = fx + 1;
  ldv_34571: ;
#line 683
  if (fx <= 9) {
#line 685
    goto ldv_34570;
  } else {

  }

  ldv_34565: 
#line 659
  i = i + 1;
  ldv_34574: ;
#line 659
  if (i <= 1) {
#line 661
    goto ldv_34573;
  } else {

  }
#line 692
  i = 0;
#line 692
  goto ldv_34577;
  ldv_34576: 
#line 693
  err = usb_submit_urb(cam->sbuf[i].urb, 208U);
#line 694
  if (err != 0) {
#line 695
    printk("\vcpia2: usb_submit_urb[%d]() = %d\n", i, err);
#line 696
    return (err);
  } else {

  }
#line 692
  i = i + 1;
  ldv_34577: ;
#line 692
  if (i <= 1) {
#line 694
    goto ldv_34576;
  } else {

  }

#line 700
  return (0);
}
}
#line 708 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
int cpia2_usb_stream_start(struct camera_data *cam , unsigned int alternate___0 ) 
{ 
  int ret ;
  int old_alt ;
  int i ;
  int ret2 ;

  {
#line 713
  if (cam->streaming != 0) {
#line 714
    return (0);
  } else {

  }
#line 716
  if ((unsigned int )cam->flush != 0U) {
#line 719
    i = 0;
#line 719
    goto ldv_34587;
    ldv_34586: 
#line 720
    (cam->buffers + (unsigned long )i)->status = 0;
#line 721
    (cam->buffers + (unsigned long )i)->length = 0;
#line 719
    i = i + 1;
    ldv_34587: ;
#line 719
    if (cam->num_frames > i) {
#line 721
      goto ldv_34586;
    } else {

    }
#line 723
    cam->curbuff = cam->buffers;
#line 724
    cam->workbuff = (cam->curbuff)->next;
#line 725
    cam->flush = 0U;
  } else {

  }
#line 728
  old_alt = (int )cam->params.camera_state.stream_mode;
#line 729
  cam->params.camera_state.stream_mode = 0U;
#line 730
  ret = cpia2_usb_change_streaming_alternate(cam, alternate___0);
#line 731
  if (ret < 0) {
#line 733
    printk("\vcpia2: cpia2_usb_change_streaming_alternate() = %d!\n", ret);
#line 734
    cam->params.camera_state.stream_mode = (u8 )old_alt;
#line 735
    ret2 = set_alternate(cam, 0U);
#line 736
    if (ret2 < 0) {
#line 737
      printk("\vcpia2: cpia2_usb_change_streaming_alternate(%d) =%d has already failed. Then tried to call set_alternate(USBIF_CMDONLY) = %d.\n",
             alternate___0, ret, ret2);
    } else {

    }
  } else {
#line 743
    cam->frame_count = 0UL;
#line 744
    cam->streaming = 1;
#line 745
    ret = cpia2_usb_stream_resume(cam);
  }
#line 747
  return (ret);
}
}
#line 755 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
int cpia2_usb_stream_pause(struct camera_data *cam ) 
{ 
  int ret ;

  {
#line 757
  ret = 0;
#line 758
  if (cam->streaming != 0) {
#line 759
    free_sbufs(cam);
#line 760
    ret = set_alternate(cam, 0U);
  } else {

  }
#line 762
  return (ret);
}
}
#line 770 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
int cpia2_usb_stream_resume(struct camera_data *cam ) 
{ 
  int ret ;

  {
#line 772
  ret = 0;
#line 773
  if (cam->streaming != 0) {
#line 774
    cam->first_image_seen = 0;
#line 775
    ret = set_alternate(cam, (unsigned int )cam->params.camera_state.stream_mode);
#line 776
    if (ret == 0) {
#line 779
      cpia2_do_command(cam, 52U, 1, (int )cam->params.vp_params.user_effects);
#line 781
      ret = submit_urbs(cam);
    } else {

    }
  } else {

  }
#line 784
  return (ret);
}
}
#line 792 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
int cpia2_usb_stream_stop(struct camera_data *cam ) 
{ 
  int ret ;

  {
#line 796
  ret = cpia2_usb_stream_pause(cam);
#line 797
  cam->streaming = 0;
#line 798
  configure_transfer_mode(cam, 0U);
#line 799
  return (ret);
}
}
#line 808 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
static int cpia2_usb_probe(struct usb_interface *intf , struct usb_device_id  const  *id ) 
{ 
  struct usb_device *udev ;
  struct usb_device *tmp ;
  struct usb_interface_descriptor *interface ;
  struct camera_data *cam ;
  int ret ;

  {
#line 811
  tmp = interface_to_usbdev(intf);
#line 811
  udev = tmp;
#line 817
  if ((unsigned int )udev->descriptor.bNumConfigurations != 1U) {
#line 818
    return (-19);
  } else {

  }
#line 819
  interface = & (intf->cur_altsetting)->desc;
#line 822
  printk("\016cpia2: CPiA2 USB camera found\n");
#line 824
  cam = cpia2_init_camera_struct(intf);
#line 825
  if ((unsigned long )cam == (unsigned long )((struct camera_data *)0)) {
#line 826
    return (-12);
  } else {

  }
#line 828
  cam->dev = udev;
#line 829
  cam->iface = interface->bInterfaceNumber;
#line 831
  ret = set_alternate(cam, 0U);
#line 832
  if (ret < 0) {
#line 833
    printk("\vcpia2: %s: usb_set_interface error (ret = %d)\n", "cpia2_usb_probe",
           ret);
#line 834
    kfree((void const   *)cam);
#line 835
    return (ret);
  } else {

  }
#line 839
  ret = cpia2_init_camera(cam);
#line 839
  if (ret < 0) {
#line 840
    printk("\vcpia2: %s: failed to initialize cpia2 camera (ret = %d)\n", "cpia2_usb_probe",
           ret);
#line 841
    kfree((void const   *)cam);
#line 842
    return (ret);
  } else {

  }
#line 844
  printk("\016cpia2:   CPiA Version: %d.%02d (%d.%d)\n", (int )cam->params.version.firmware_revision_hi,
         (int )cam->params.version.firmware_revision_lo, (int )cam->params.version.asic_id,
         (int )cam->params.version.asic_rev);
#line 849
  printk("\016cpia2:   CPiA PnP-ID: %04x:%04x:%04x\n", (int )cam->params.pnp_id.vendor,
         (int )cam->params.pnp_id.product, (int )cam->params.pnp_id.device_revision);
#line 853
  printk("\016cpia2:   SensorID: %d.(version %d)\n", (int )cam->params.version.sensor_flags,
         (int )cam->params.version.sensor_rev);
#line 857
  usb_set_intfdata(intf, (void *)cam);
#line 859
  ret = cpia2_register_camera(cam);
#line 860
  if (ret < 0) {
#line 861
    printk("\vcpia2: %s: Failed to register cpia2 camera (ret = %d)\n", "cpia2_usb_probe",
           ret);
#line 862
    kfree((void const   *)cam);
#line 863
    return (ret);
  } else {

  }
#line 866
  return (0);
}
}
#line 874 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
static void cpia2_usb_disconnect(struct usb_interface *intf ) 
{ 
  struct camera_data *cam ;
  void *tmp ;
  int tmp___0 ;

  {
#line 876
  tmp = usb_get_intfdata(intf);
#line 876
  cam = (struct camera_data *)tmp;
#line 877
  usb_set_intfdata(intf, (void *)0);
#line 880
  cpia2_usb_stream_stop(cam);
#line 882
  ldv_mutex_lock_64(& cam->v4l2_lock);
#line 884
  cpia2_unregister_camera(cam);
#line 885
  v4l2_device_disconnect(& cam->v4l2_dev);
#line 886
  ldv_mutex_unlock_65(& cam->v4l2_lock);
#line 887
  v4l2_device_put(& cam->v4l2_dev);
#line 889
  if ((unsigned long )cam->buffers != (unsigned long )((struct framebuf *)0)) {
#line 891
    (cam->curbuff)->status = 2;
#line 892
    (cam->curbuff)->length = 0;
#line 893
    tmp___0 = waitqueue_active(& cam->wq_stream);
#line 893
    if (tmp___0 != 0) {
#line 894
      __wake_up(& cam->wq_stream, 1U, 1, (void *)0);
    } else {

    }
  } else {

  }
#line 898
  usb_driver_release_interface(& cpia2_driver, intf);
#line 900
  printk("\016cpia2: CPiA2 camera disconnected.\n");
#line 901
  return;
}
}
#line 903 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
static int cpia2_usb_suspend(struct usb_interface *intf , pm_message_t message ) 
{ 
  struct camera_data *cam ;
  void *tmp ;

  {
#line 905
  tmp = usb_get_intfdata(intf);
#line 905
  cam = (struct camera_data *)tmp;
#line 907
  ldv_mutex_lock_66(& cam->v4l2_lock);
#line 908
  if (cam->streaming != 0) {
#line 909
    cpia2_usb_stream_stop(cam);
#line 910
    cam->streaming = 1;
  } else {

  }
#line 912
  ldv_mutex_unlock_67(& cam->v4l2_lock);
#line 914
  _dev_info((struct device  const  *)(& intf->dev), "going into suspend..\n");
#line 915
  return (0);
}
}
#line 919 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
static int cpia2_usb_resume(struct usb_interface *intf ) 
{ 
  struct camera_data *cam ;
  void *tmp ;

  {
#line 921
  tmp = usb_get_intfdata(intf);
#line 921
  cam = (struct camera_data *)tmp;
#line 923
  ldv_mutex_lock_68(& cam->v4l2_lock);
#line 924
  v4l2_ctrl_handler_setup(& cam->hdl);
#line 925
  if (cam->streaming != 0) {
#line 926
    cam->streaming = 0;
#line 927
    cpia2_usb_stream_start(cam, (unsigned int )cam->params.camera_state.stream_mode);
  } else {

  }
#line 930
  ldv_mutex_unlock_69(& cam->v4l2_lock);
#line 932
  _dev_info((struct device  const  *)(& intf->dev), "coming out of suspend..\n");
#line 933
  return (0);
}
}
#line 941 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
int cpia2_usb_init(void) 
{ 
  int tmp ;

  {
#line 943
  tmp = ldv_usb_register_driver_70(& cpia2_driver, & __this_module, "cpia2");
#line 943
  return (tmp);
}
}
#line 951 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.c"
void cpia2_usb_cleanup(void) 
{ 


  {
#line 953
  schedule_timeout(500L);
#line 954
  ldv_usb_deregister_71(& cpia2_driver);
#line 955
  return;
}
}
#line 110 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
int ldv_retval_1  ;
#line 111 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
int ldv_retval_3  ;
#line 112 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
int ldv_retval_2  ;
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_usb_driver_1(void) 
{ 
  void *tmp ;

  {
#line 116
  tmp = ldv_init_zalloc(1560UL);
#line 116
  cpia2_driver_group1 = (struct usb_interface *)tmp;
#line 117
  return;
}
}
#line 120 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_main_exported_1(void) 
{ 
  pm_message_t ldvarg7 ;
  struct usb_device_id *ldvarg8 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 122
  tmp = ldv_init_zalloc(32UL);
#line 122
  ldvarg8 = (struct usb_device_id *)tmp;
#line 121
  ldv_memset((void *)(& ldvarg7), 0, 4UL);
#line 124
  tmp___0 = __VERIFIER_nondet_int();
#line 124
  switch (tmp___0) {
  case 0: ;
#line 127
  if (ldv_state_variable_1 == 1) {
#line 129
    ldv_retval_3 = cpia2_usb_probe(cpia2_driver_group1, (struct usb_device_id  const  *)ldvarg8);
#line 130
    if (ldv_retval_3 == 0) {
#line 131
      ldv_state_variable_1 = 2;
#line 132
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
#line 136
  goto ldv_34642;
  case 1: ;
#line 139
  if (ldv_state_variable_1 == 2) {
#line 141
    cpia2_usb_suspend(cpia2_driver_group1, ldvarg7);
#line 142
    ldv_state_variable_1 = 3;
  } else {

  }
#line 145
  goto ldv_34642;
  case 2: ;
#line 148
  if (ldv_state_variable_1 == 3) {
#line 150
    ldv_retval_2 = cpia2_usb_resume(cpia2_driver_group1);
#line 151
    if (ldv_retval_2 == 0) {
#line 152
      ldv_state_variable_1 = 2;
    } else {

    }
  } else {

  }
#line 156
  goto ldv_34642;
  case 3: ;
#line 159
  if (ldv_state_variable_1 == 3) {
#line 161
    ldv_retval_1 = cpia2_usb_resume(cpia2_driver_group1);
#line 162
    if (ldv_retval_1 == 0) {
#line 163
      ldv_state_variable_1 = 2;
    } else {

    }
  } else {

  }
#line 167
  goto ldv_34642;
  case 4: ;
#line 170
  if (ldv_state_variable_1 == 3 && usb_counter == 0) {
#line 172
    cpia2_usb_disconnect(cpia2_driver_group1);
#line 173
    ldv_state_variable_1 = 1;
#line 174
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 177
  if (ldv_state_variable_1 == 2 && usb_counter == 0) {
#line 179
    cpia2_usb_disconnect(cpia2_driver_group1);
#line 180
    ldv_state_variable_1 = 1;
#line 181
    ref_cnt = ref_cnt - 1;
  } else {

  }
#line 184
  goto ldv_34642;
  default: 
#line 185
  ldv_stop();
  }
  ldv_34642: ;
#line 189
  return;
}
}
#line 214 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_mutex_lock_55(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 217
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 219
  mutex_lock(ldv_func_arg1);
#line 220
  return;
}
}
#line 222 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_mutex_unlock_56(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 225
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 227
  mutex_unlock(ldv_func_arg1);
#line 228
  return;
}
}
#line 230 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_mutex_lock_57(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 233
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 235
  mutex_lock(ldv_func_arg1);
#line 236
  return;
}
}
#line 238 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
int ldv_mutex_trylock_58(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 242
  tmp = mutex_trylock(ldv_func_arg1);
#line 242
  ldv_func_res = tmp;
#line 244
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 244
  return (tmp___0);
#line 246
  return (ldv_func_res);
}
}
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_mutex_unlock_59(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 252
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 254
  mutex_unlock(ldv_func_arg1);
#line 255
  return;
}
}
#line 257 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_mutex_unlock_60(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 260
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 262
  mutex_unlock(ldv_func_arg1);
#line 263
  return;
}
}
#line 265 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_mutex_lock_61(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 268
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 270
  mutex_lock(ldv_func_arg1);
#line 271
  return;
}
}
#line 273 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_mutex_lock_62(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 276
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 278
  mutex_lock(ldv_func_arg1);
#line 279
  return;
}
}
#line 281 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_mutex_unlock_63(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 284
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 286
  mutex_unlock(ldv_func_arg1);
#line 287
  return;
}
}
#line 289 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_mutex_lock_64(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 292
  ldv_mutex_lock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 294
  mutex_lock(ldv_func_arg1);
#line 295
  return;
}
}
#line 297 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_mutex_unlock_65(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 300
  ldv_mutex_unlock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 302
  mutex_unlock(ldv_func_arg1);
#line 303
  return;
}
}
#line 305 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_mutex_lock_66(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 308
  ldv_mutex_lock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 310
  mutex_lock(ldv_func_arg1);
#line 311
  return;
}
}
#line 313 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_mutex_unlock_67(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 316
  ldv_mutex_unlock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 318
  mutex_unlock(ldv_func_arg1);
#line 319
  return;
}
}
#line 321 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_mutex_lock_68(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 324
  ldv_mutex_lock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 326
  mutex_lock(ldv_func_arg1);
#line 327
  return;
}
}
#line 329 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_mutex_unlock_69(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 332
  ldv_mutex_unlock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 334
  mutex_unlock(ldv_func_arg1);
#line 335
  return;
}
}
#line 337 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
int ldv_usb_register_driver_70(struct usb_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                               char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
#line 341
  tmp = usb_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 341
  ldv_func_res = tmp;
#line 343
  ldv_state_variable_1 = 1;
#line 344
  usb_counter = 0;
#line 345
  ldv_usb_driver_1();
#line 348
  return (ldv_func_res);
}
}
#line 351 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_usb.o.c.prepared"
void ldv_usb_deregister_71(struct usb_driver *arg ) 
{ 


  {
#line 354
  usb_deregister(arg);
#line 356
  ldv_state_variable_1 = 0;
#line 357
  return;
}
}
#line 1 "<compiler builtins>"
#line 1
__inline static long ldv__builtin_expect(long exp , long c ) ;
#line 72 "./arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 110 "./arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 248 "include/linux/kernel.h"
extern void __might_fault(char const   * , int  ) ;
#line 23 "./arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 119 "include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 176
int ldv_mutex_trylock_96(struct mutex *ldv_func_arg1 ) ;
#line 181
void ldv_mutex_unlock_94(struct mutex *ldv_func_arg1 ) ;
#line 185
void ldv_mutex_unlock_97(struct mutex *ldv_func_arg1 ) ;
#line 189
void ldv_mutex_unlock_98(struct mutex *ldv_func_arg1 ) ;
#line 193
void ldv_mutex_unlock_101(struct mutex *ldv_func_arg1 ) ;
#line 197
void ldv_mutex_unlock_102(struct mutex *ldv_func_arg1 ) ;
#line 21 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.o.c.prepared"
void ldv_mutex_lock_93(struct mutex *ldv_func_arg1 ) ;
#line 25
void ldv_mutex_lock_95(struct mutex *ldv_func_arg1 ) ;
#line 29
void ldv_mutex_lock_99(struct mutex *ldv_func_arg1 ) ;
#line 33
void ldv_mutex_lock_100(struct mutex *ldv_func_arg1 ) ;
#line 37
void ldv_mutex_lock_103(struct mutex *ldv_func_arg1 ) ;
#line 72 "include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 292 "include/linux/jiffies.h"
extern unsigned long __msecs_to_jiffies(unsigned int const    ) ;
#line 354 "include/linux/jiffies.h"
__inline static unsigned long msecs_to_jiffies(unsigned int const   m ) 
{ 
  unsigned long tmp___0 ;

  {
#line 361
  tmp___0 = __msecs_to_jiffies(m);
#line 361
  return (tmp___0);
}
}
#line 422 "include/linux/sched.h"
extern long schedule_timeout_interruptible(long  ) ;
#line 581 "include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 583
  tmp = kmalloc(size, flags | 32768U);
#line 583
  return (tmp);
}
}
#line 652 "./arch/x86/include/asm/uaccess.h"
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 677
extern void __copy_to_user_overflow(void) ;
#line 728 "./arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 730
  tmp = __builtin_object_size(from, 0);
#line 730
  sz = (int )tmp;
#line 732
  __might_fault("./arch/x86/include/asm/uaccess.h", 732);
#line 735
  tmp___0 = ldv__builtin_expect((long )(sz < 0 || (unsigned long )sz >= n), 1L);
#line 735
  if (tmp___0 != 0L) {
#line 736
    n = _copy_to_user(to, from, (unsigned int )n);
  } else {
#line 740
    __copy_to_user_overflow();
  }
#line 742
  return (n);
}
}
#line 42 "include/linux/poll.h"
__inline static void poll_wait(struct file *filp , wait_queue_head_t *wait_address ,
                               poll_table *p ) 
{ 


  {
#line 44
  if (((unsigned long )p != (unsigned long )((poll_table *)0) && (unsigned long )p->_qproc != (unsigned long )((void (*)(struct file * ,
                                                                                                                         wait_queue_head_t * ,
                                                                                                                         struct poll_table_struct * ))0)) && (unsigned long )wait_address != (unsigned long )((wait_queue_head_t *)0)) {
#line 45
    (*(p->_qproc))(filp, wait_address, p);
  } else {

  }
#line 46
  return;
}
}
#line 64 "include/linux/poll.h"
__inline static unsigned long poll_requested_events(poll_table const   *p ) 
{ 


  {
#line 66
  return ((unsigned long )p != (unsigned long )((poll_table const   *)0) ? (unsigned long )p->_key : 0xffffffffffffffffUL);
}
}
#line 223 "include/linux/page-flags.h"
__inline static void SetPageReserved(struct page *page ) 
{ 


  {
#line 223
  set_bit(10L, (unsigned long volatile   *)(& page->flags));
#line 224
  return;
}
}
#line 223 "include/linux/page-flags.h"
__inline static void ClearPageReserved(struct page *page ) 
{ 


  {
#line 223
  clear_bit(10L, (unsigned long volatile   *)(& page->flags));
#line 224
  return;
}
}
#line 375 "include/linux/mm.h"
extern struct page *vmalloc_to_page(void const   * ) ;
#line 924 "include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 926
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 2012
extern int remap_pfn_range(struct vm_area_struct * , unsigned long  , unsigned long  ,
                           unsigned long  , pgprot_t  ) ;
#line 77 "include/media/v4l2-device.h"
extern int v4l2_device_register(struct device * , struct v4l2_device * ) ;
#line 806 "include/media/v4l2-ctrls.h"
extern unsigned int v4l2_ctrl_poll(struct file * , struct poll_table_struct * ) ;
#line 75 "include/linux/vmalloc.h"
extern void *vmalloc_32(unsigned long  ) ;
#line 83
extern void vfree(void const   * ) ;
#line 42 "include/linux/firmware.h"
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
#line 51
extern void release_firmware(struct firmware  const  * ) ;
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
static int apply_vp_patch(struct camera_data *cam ) ;
#line 64
static int set_default_user_mode(struct camera_data *cam ) ;
#line 65
static int set_vw_size(struct camera_data *cam , int size ) ;
#line 66
static int configure_sensor(struct camera_data *cam , int req_width , int req_height ) ;
#line 68
static int config_sensor_410(struct camera_data *cam , int req_width , int req_height ) ;
#line 70
static int config_sensor_500(struct camera_data *cam , int req_width , int req_height ) ;
#line 72
static int set_all_properties(struct camera_data *cam ) ;
#line 73
static void wake_system(struct camera_data *cam ) ;
#line 74
static void set_lowlight_boost(struct camera_data *cam ) ;
#line 75
static void reset_camera_struct(struct camera_data *cam ) ;
#line 76
static int cpia2_set_high_power(struct camera_data *cam ) ;
#line 82 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
__inline static unsigned long kvirt_to_pa(unsigned long adr ) 
{ 
  unsigned long kva ;
  unsigned long ret ;
  struct page *tmp ;
  void *tmp___0 ;

  {
#line 86
  tmp = vmalloc_to_page((void const   *)adr);
#line 86
  tmp___0 = lowmem_page_address((struct page  const  *)tmp);
#line 86
  kva = (unsigned long )tmp___0;
#line 87
  kva = (adr & 4095UL) | kva;
#line 88
  ret = __phys_addr(kva);
#line 89
  return (ret);
}
}
#line 92 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
static void *rvmalloc(unsigned long size ) 
{ 
  void *mem ;
  unsigned long adr ;
  struct page *tmp ;

  {
#line 98
  size = (size + 4095UL) & 0xfffffffffffff000UL;
#line 100
  mem = vmalloc_32(size);
#line 101
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
#line 102
    return ((void *)0);
  } else {

  }
#line 104
  memset(mem, 0, size);
#line 105
  adr = (unsigned long )mem;
#line 107
  goto ldv_34629;
  ldv_34628: 
#line 108
  tmp = vmalloc_to_page((void const   *)adr);
#line 108
  SetPageReserved(tmp);
#line 109
  adr = adr + 4096UL;
#line 110
  size = size - 4096UL;
  ldv_34629: ;
#line 107
  if ((long )size > 0L) {
#line 109
    goto ldv_34628;
  } else {

  }

#line 112
  return (mem);
}
}
#line 115 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
static void rvfree(void *mem , unsigned long size ) 
{ 
  unsigned long adr ;
  struct page *tmp ;

  {
#line 119
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
#line 120
    return;
  } else {

  }
#line 122
  size = (size + 4095UL) & 0xfffffffffffff000UL;
#line 124
  adr = (unsigned long )mem;
#line 125
  goto ldv_34637;
  ldv_34636: 
#line 126
  tmp = vmalloc_to_page((void const   *)adr);
#line 126
  ClearPageReserved(tmp);
#line 127
  adr = adr + 4096UL;
#line 128
  size = size - 4096UL;
  ldv_34637: ;
#line 125
  if ((long )size > 0L) {
#line 127
    goto ldv_34636;
  } else {

  }
#line 130
  vfree((void const   *)mem);
#line 131
  return;
}
}
#line 140 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
int cpia2_do_command(struct camera_data *cam , unsigned int command , unsigned char direction ,
                     unsigned char param ) 
{ 
  int retval ;
  struct cpia2_command cmd ;
  unsigned int device ;

  {
#line 143
  retval = 0;
#line 145
  device = cam->params.pnp_id.device_type;
#line 147
  cmd.command = command;
#line 148
  cmd.reg_count = 2U;
#line 149
  cmd.direction = direction;
#line 154
  switch (command) {
  case 1U: 
#line 156
  cmd.req_mode = 0U;
#line 158
  cmd.start = 0U;
#line 159
  goto ldv_34649;
  case 2U: 
#line 161
  cmd.req_mode = 0U;
#line 163
  cmd.reg_count = 8U;
#line 164
  cmd.start = 48U;
#line 165
  goto ldv_34649;
  case 3U: 
#line 167
  cmd.req_mode = 1U;
#line 168
  cmd.start = 128U;
#line 169
  goto ldv_34649;
  case 4U: 
#line 171
  cmd.req_mode = 2U;
#line 172
  cmd.start = 5U;
#line 173
  goto ldv_34649;
  case 5U: 
#line 175
  cmd.req_mode = 2U;
#line 176
  cmd.start = 0U;
#line 177
  goto ldv_34649;
  case 7U: 
#line 179
  cmd.buffer.block_data[0] = param;
  case 6U: 
#line 181
  cmd.req_mode = 2U;
#line 182
  cmd.reg_count = 1U;
#line 183
  if (device == 1U) {
#line 184
    cmd.start = 22U;
  } else {
#line 186
    cmd.start = 32U;
  }
#line 187
  goto ldv_34649;
  case 9U: 
#line 189
  cmd.buffer.block_data[0] = param;
  case 8U: 
#line 191
  cmd.req_mode = 2U;
#line 192
  cmd.reg_count = 1U;
#line 193
  cmd.start = 38U;
#line 194
  goto ldv_34649;
  case 11U: 
#line 196
  cmd.buffer.block_data[0] = param;
  case 10U: 
#line 198
  cmd.req_mode = 2U;
#line 199
  cmd.reg_count = 1U;
#line 200
  if (device == 1U) {
#line 201
    cmd.start = 39U;
  } else {
#line 203
    cmd.start = 61U;
  }
#line 204
  goto ldv_34649;
  case 15U: 
#line 206
  cmd.buffer.block_data[0] = param;
  case 14U: 
#line 208
  cmd.req_mode = 2U;
#line 209
  cmd.reg_count = 1U;
#line 210
  cmd.start = 9U;
#line 211
  goto ldv_34649;
  case 13U: 
#line 213
  cmd.buffer.block_data[0] = param;
  case 12U: 
#line 215
  cmd.req_mode = 2U;
#line 216
  cmd.reg_count = 1U;
#line 217
  cmd.start = 8U;
#line 218
  goto ldv_34649;
  case 19U: 
#line 220
  cmd.buffer.block_data[0] = param;
  case 18U: 
#line 222
  cmd.req_mode = 1U;
#line 223
  cmd.reg_count = 1U;
#line 224
  cmd.start = 145U;
#line 225
  goto ldv_34649;
  case 17U: 
#line 227
  cmd.buffer.block_data[0] = param;
  case 16U: 
#line 229
  cmd.req_mode = 1U;
#line 230
  cmd.reg_count = 1U;
#line 231
  cmd.start = 144U;
#line 232
  goto ldv_34649;
  case 20U: 
#line 234
  cmd.req_mode = 0U;
#line 236
  cmd.start = 4U;
#line 237
  cmd.reg_count = 1U;
#line 238
  cmd.buffer.block_data[0] = param;
#line 239
  goto ldv_34649;
  case 22U: 
#line 241
  cmd.buffer.block_data[0] = param;
  case 21U: 
#line 243
  cmd.req_mode = 2U;
#line 244
  cmd.reg_count = 1U;
#line 245
  cmd.start = 27U;
#line 246
  goto ldv_34649;
  case 23U: 
#line 248
  cmd.req_mode = 5U;
#line 249
  cmd.reg_count = 2U;
#line 250
  cmd.start = 0U;
#line 251
  cmd.buffer.registers[0].index = 160U;
#line 252
  cmd.buffer.registers[0].value = 64U;
#line 254
  cmd.buffer.registers[1].index = 160U;
#line 255
  cmd.buffer.registers[1].value = 96U;
#line 259
  goto ldv_34649;
  case 24U: 
#line 261
  cmd.req_mode = 4U;
#line 263
  cmd.reg_count = 2U;
#line 264
  cmd.buffer.registers[0].index = 2U;
#line 266
  cmd.buffer.registers[1].index = 2U;
#line 268
  cmd.buffer.registers[0].value = 128U;
#line 269
  cmd.buffer.registers[1].value = 1U;
#line 271
  goto ldv_34649;
  case 25U: 
#line 273
  cmd.req_mode = 0U;
#line 275
  cmd.reg_count = 1U;
#line 276
  cmd.start = 2U;
#line 277
  cmd.buffer.block_data[0] = 0U;
#line 278
  goto ldv_34649;
  case 26U: 
#line 280
  cmd.req_mode = 0U;
#line 282
  cmd.reg_count = 1U;
#line 283
  cmd.start = 2U;
#line 284
  cmd.buffer.block_data[0] = 128U;
#line 285
  goto ldv_34649;
  case 27U: 
#line 287
  cmd.buffer.block_data[0] = param;
  case 28U: 
#line 289
  cmd.req_mode = 2U;
#line 290
  cmd.reg_count = 1U;
#line 291
  if (device == 1U) {
#line 292
    cmd.start = 16U;
  } else {
#line 294
    cmd.start = 19U;
  }
#line 295
  goto ldv_34649;
  case 29U: 
#line 297
  cmd.req_mode = 2U;
#line 298
  cmd.reg_count = 1U;
#line 299
  if (device == 1U) {
#line 300
    cmd.start = 17U;
  } else {
#line 302
    cmd.start = 20U;
  }
#line 303
  cmd.buffer.block_data[0] = param;
#line 304
  goto ldv_34649;
  case 32U: 
#line 306
  cmd.buffer.block_data[0] = param;
  case 31U: 
#line 308
  cmd.req_mode = 1U;
#line 309
  cmd.reg_count = 1U;
#line 310
  cmd.start = 131U;
#line 311
  goto ldv_34649;
  case 34U: 
#line 313
  cmd.buffer.block_data[0] = param;
  case 33U: 
#line 315
  cmd.req_mode = 1U;
#line 316
  cmd.reg_count = 1U;
#line 317
  cmd.start = 130U;
#line 318
  goto ldv_34649;
  case 37U: 
#line 320
  cmd.req_mode = 2U;
#line 321
  cmd.reg_count = 1U;
#line 322
  cmd.start = 2U;
#line 323
  goto ldv_34649;
  case 36U: 
#line 325
  cmd.buffer.block_data[0] = param;
  case 35U: 
#line 327
  cmd.req_mode = 0U;
#line 329
  cmd.reg_count = 1U;
#line 330
  cmd.start = 2U;
#line 331
  goto ldv_34649;
  case 39U: 
#line 333
  cmd.buffer.block_data[0] = param;
  case 38U: 
#line 335
  cmd.req_mode = 2U;
#line 336
  cmd.reg_count = 1U;
#line 337
  cmd.start = 3U;
#line 338
  goto ldv_34649;
  case 41U: 
#line 340
  cmd.buffer.block_data[0] = param;
  case 40U: 
#line 342
  cmd.req_mode = 2U;
#line 343
  cmd.reg_count = 1U;
#line 344
  cmd.start = 21U;
#line 345
  goto ldv_34649;
  case 43U: 
#line 347
  cmd.buffer.block_data[0] = param;
  case 42U: 
#line 349
  cmd.req_mode = 2U;
#line 350
  cmd.reg_count = 1U;
#line 351
  cmd.start = 7U;
#line 352
  goto ldv_34649;
  case 44U: 
#line 354
  cmd.buffer.block_data[0] = param;
#line 355
  cmd.req_mode = 0U;
#line 357
  cmd.reg_count = 1U;
#line 358
  cmd.start = 8U;
#line 359
  goto ldv_34649;
  case 45U: 
#line 361
  cmd.buffer.block_data[0] = param;
#line 362
  cmd.req_mode = 2U;
#line 363
  cmd.reg_count = 1U;
#line 364
  cmd.start = 118U;
#line 365
  goto ldv_34649;
  case 47U: 
#line 367
  cmd.buffer.block_data[0] = param;
  case 46U: 
#line 369
  cmd.req_mode = 1U;
#line 370
  cmd.reg_count = 1U;
#line 371
  cmd.start = 192U;
#line 372
  goto ldv_34649;
  case 48U: 
#line 374
  cmd.req_mode = 5U;
#line 375
  cmd.reg_count = 1U;
#line 376
  cmd.buffer.registers[0].index = 217U;
#line 377
  cmd.buffer.registers[0].value = param;
#line 378
  goto ldv_34649;
  case 49U: 
#line 380
  cmd.req_mode = 5U;
#line 381
  cmd.reg_count = 4U;
#line 382
  cmd.buffer.registers[0].index = 214U;
#line 383
  cmd.buffer.registers[0].value = 1U;
#line 385
  cmd.buffer.registers[1].index = 216U;
#line 386
  cmd.buffer.registers[1].value = 20U;
#line 387
  cmd.buffer.registers[2].index = 215U;
#line 388
  cmd.buffer.registers[2].value = 2U;
#line 389
  cmd.buffer.registers[3].index = 214U;
#line 390
  cmd.buffer.registers[3].value = 5U;
#line 391
  goto ldv_34649;
  case 50U: 
#line 393
  cmd.req_mode = 2U;
#line 394
  cmd.reg_count = 1U;
#line 395
  cmd.start = 96U;
#line 396
  cmd.buffer.block_data[0] = param;
#line 397
  goto ldv_34649;
  case 52U: 
#line 401
  cmd.buffer.block_data[0] = param;
  case 51U: 
#line 403
  cmd.req_mode = 2U;
#line 404
  cmd.reg_count = 1U;
#line 405
  if (device == 1U) {
#line 406
    cmd.start = 18U;
  } else {
#line 408
    cmd.start = 21U;
  }
#line 409
  goto ldv_34649;
  default: 
#line 411
  printk("\016cpia2: DoCommand received invalid command\n");
#line 412
  return (-22);
  }
  ldv_34649: 
#line 415
  retval = cpia2_send_command(cam, & cmd);
#line 416
  if (retval != 0) {
#line 417
    return (retval);
  } else {

  }
#line 423
  switch (command) {
  case 1U: 
#line 425
  cam->params.version.firmware_revision_hi = cmd.buffer.block_data[0];
#line 427
  cam->params.version.firmware_revision_lo = cmd.buffer.block_data[1];
#line 429
  goto ldv_34702;
  case 2U: 
#line 431
  cam->params.pnp_id.vendor = (u16 )((int )((short )((int )cmd.buffer.block_data[0] << 8)) | (int )((short )cmd.buffer.block_data[1]));
#line 433
  cam->params.pnp_id.product = (u16 )((int )((short )((int )cmd.buffer.block_data[2] << 8)) | (int )((short )cmd.buffer.block_data[3]));
#line 435
  cam->params.pnp_id.device_revision = (u16 )((int )((short )((int )cmd.buffer.block_data[4] << 8)) | (int )((short )cmd.buffer.block_data[5]));
#line 438
  if ((unsigned int )cam->params.pnp_id.vendor == 1363U) {
#line 439
    if ((unsigned int )cam->params.pnp_id.product == 256U) {
#line 440
      cam->params.pnp_id.device_type = 1U;
    } else
#line 441
    if ((unsigned int )cam->params.pnp_id.product == 320U || (unsigned int )cam->params.pnp_id.product == 337U) {
#line 443
      cam->params.pnp_id.device_type = 2U;
    } else {

    }
  } else {

  }
#line 446
  goto ldv_34702;
  case 3U: 
#line 448
  cam->params.version.asic_id = cmd.buffer.block_data[0];
#line 449
  cam->params.version.asic_rev = cmd.buffer.block_data[1];
#line 450
  goto ldv_34702;
  case 4U: 
#line 452
  cam->params.version.sensor_flags = cmd.buffer.block_data[0];
#line 453
  cam->params.version.sensor_rev = cmd.buffer.block_data[1];
#line 454
  goto ldv_34702;
  case 5U: 
#line 456
  cam->params.version.vp_device_hi = cmd.buffer.block_data[0];
#line 457
  cam->params.version.vp_device_lo = cmd.buffer.block_data[1];
#line 458
  goto ldv_34702;
  case 14U: 
#line 460
  cam->params.vp_params.gpio_data = cmd.buffer.block_data[0];
#line 461
  goto ldv_34702;
  case 12U: 
#line 463
  cam->params.vp_params.gpio_direction = cmd.buffer.block_data[0];
#line 464
  goto ldv_34702;
  case 16U: 
#line 466
  cam->params.vc_params.vc_mp_direction = cmd.buffer.block_data[0];
#line 467
  goto ldv_34702;
  case 18U: 
#line 469
  cam->params.vc_params.vc_mp_data = cmd.buffer.block_data[0];
#line 470
  goto ldv_34702;
  case 21U: 
#line 472
  cam->params.flicker_control.cam_register = cmd.buffer.block_data[0];
#line 474
  goto ldv_34702;
  case 31U: 
#line 476
  cam->params.vc_params.wakeup = cmd.buffer.block_data[0];
#line 477
  goto ldv_34702;
  case 33U: 
#line 479
  cam->params.vc_params.pw_control = cmd.buffer.block_data[0];
#line 480
  goto ldv_34702;
  case 35U: 
#line 482
  cam->params.camera_state.system_ctrl = cmd.buffer.block_data[0];
#line 483
  goto ldv_34702;
  case 37U: 
#line 485
  cam->params.vp_params.system_state = cmd.buffer.block_data[0];
#line 486
  goto ldv_34702;
  case 38U: 
#line 488
  cam->params.vp_params.system_ctrl = cmd.buffer.block_data[0];
#line 489
  goto ldv_34702;
  case 40U: 
#line 491
  cam->params.vp_params.exposure_modes = cmd.buffer.block_data[0];
#line 492
  goto ldv_34702;
  case 42U: 
#line 494
  cam->params.vp_params.device_config = cmd.buffer.block_data[0];
#line 495
  goto ldv_34702;
  case 46U: 
#line 497
  cam->params.vc_params.vc_control = cmd.buffer.block_data[0];
#line 498
  goto ldv_34702;
  case 28U: 
#line 500
  cam->params.vp_params.video_mode = cmd.buffer.block_data[0];
#line 501
  goto ldv_34702;
  case 51U: 
#line 503
  cam->params.vp_params.user_effects = cmd.buffer.block_data[0];
#line 504
  goto ldv_34702;
  default: ;
#line 506
  goto ldv_34702;
  }
  ldv_34702: ;
#line 508
  return (retval);
}
}
#line 520 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
int cpia2_send_command(struct camera_data *cam , struct cpia2_command *cmd ) 
{ 
  u8 count ;
  u8 start ;
  u8 *buffer ;
  int retval ;

  {
#line 527
  switch ((int )cmd->req_mode & 12) {
  case 4: 
#line 529
  count = (unsigned int )cmd->reg_count * 2U;
#line 530
  start = 0U;
#line 531
  buffer = (u8 *)(& cmd->buffer);
#line 535
  goto ldv_34732;
  case 0: 
#line 537
  count = cmd->reg_count;
#line 538
  start = cmd->start;
#line 539
  buffer = (u8 *)(& cmd->buffer.block_data);
#line 543
  goto ldv_34732;
  case 8: 
#line 545
  count = (unsigned int )cmd->reg_count * 4U;
#line 546
  start = 0U;
#line 547
  buffer = (u8 *)(& cmd->buffer);
#line 551
  goto ldv_34732;
  case 12: 
#line 553
  count = cmd->reg_count;
#line 554
  start = cmd->start;
#line 555
  buffer = (u8 *)(& cmd->buffer.block_data);
#line 559
  goto ldv_34732;
  default: 
#line 561
  printk("\016cpia2: %s: invalid request mode\n", "cpia2_send_command");
#line 562
  return (-22);
  }
  ldv_34732: 
#line 565
  retval = cpia2_usb_transfer_cmd(cam, (void *)buffer, (int )cmd->req_mode, (int )start,
                                  (int )count, (int )cmd->direction);
#line 584
  return (retval);
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
static void cpia2_get_version_info(struct camera_data *cam ) 
{ 


  {
#line 597
  cpia2_do_command(cam, 1U, 0, 0);
#line 598
  cpia2_do_command(cam, 2U, 0, 0);
#line 599
  cpia2_do_command(cam, 3U, 0, 0);
#line 600
  cpia2_do_command(cam, 4U, 0, 0);
#line 601
  cpia2_do_command(cam, 5U, 0, 0);
#line 602
  return;
}
}
#line 610 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
int cpia2_reset_camera(struct camera_data *cam ) 
{ 
  u8 tmp_reg ;
  int retval ;
  int target_kb ;
  int i ;
  struct cpia2_command cmd ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 613
  retval = 0;
#line 621
  retval = configure_sensor(cam, cam->params.roi.width, cam->params.roi.height);
#line 624
  if (retval < 0) {
#line 625
    printk("\vcpia2: Couldn\'t configure sensor, error=%d\n", retval);
#line 626
    return (retval);
  } else {

  }
#line 630
  cmd.req_mode = 5U;
#line 631
  cmd.direction = 1U;
#line 632
  cmd.reg_count = 2U;
#line 633
  cmd.buffer.registers[0].index = 160U;
#line 634
  cmd.buffer.registers[0].value = 64U;
#line 636
  cmd.buffer.registers[1].index = 160U;
#line 637
  cmd.buffer.registers[1].value = 96U;
#line 641
  cpia2_send_command(cam, & cmd);
#line 643
  cpia2_set_high_power(cam);
#line 645
  if (cam->params.pnp_id.device_type == 1U) {
#line 647
    cmd.req_mode = 4U;
#line 648
    cmd.buffer.registers[0].index = 4U;
#line 649
    cmd.buffer.registers[0].value = 1U;
#line 651
    cmd.reg_count = 1U;
#line 652
    cpia2_send_command(cam, & cmd);
  } else {

  }
#line 655
  tmp = msecs_to_jiffies(100U);
#line 655
  schedule_timeout_interruptible((long )tmp);
#line 657
  if (cam->params.pnp_id.device_type == 1U) {
#line 658
    retval = apply_vp_patch(cam);
  } else {

  }
#line 661
  tmp___0 = msecs_to_jiffies(100U);
#line 661
  schedule_timeout_interruptible((long )tmp___0);
#line 666
  if (cam->params.pnp_id.device_type == 2U) {
#line 667
    cmd.req_mode = 6U;
#line 670
    cmd.buffer.registers[0].index = 58U;
#line 671
    cmd.buffer.registers[0].value = 0U;
#line 673
    cmd.buffer.registers[1].index = 59U;
#line 674
    cmd.buffer.registers[1].value = 146U;
#line 677
    cmd.buffer.registers[2].index = 60U;
#line 678
    cmd.buffer.registers[2].value = 255U;
#line 681
    cmd.buffer.registers[3].index = 61U;
#line 682
    cmd.buffer.registers[3].value = 255U;
#line 685
    cmd.buffer.registers[4].index = 34U;
#line 686
    cmd.buffer.registers[4].value = 128U;
#line 690
    cmd.buffer.registers[5].index = 10U;
#line 691
    cmd.buffer.registers[5].value = 1U;
#line 692
    cmd.buffer.registers[6].index = 11U;
#line 693
    cmd.buffer.registers[6].value = 227U;
#line 694
    cmd.buffer.registers[7].index = 12U;
#line 695
    cmd.buffer.registers[7].value = 2U;
#line 696
    cmd.buffer.registers[8].index = 12U;
#line 697
    cmd.buffer.registers[8].value = 252U;
#line 699
    cmd.direction = 1U;
#line 700
    cmd.reg_count = 9U;
#line 702
    cpia2_send_command(cam, & cmd);
  } else {

  }
#line 707
  set_default_user_mode(cam);
#line 710
  tmp___1 = msecs_to_jiffies(100U);
#line 710
  schedule_timeout_interruptible((long )tmp___1);
#line 712
  set_all_properties(cam);
#line 714
  cpia2_do_command(cam, 28U, 0, 0);
#line 724
  cpia2_do_command(cam, 38U, 0, 0);
#line 725
  tmp_reg = cam->params.vp_params.system_ctrl;
#line 726
  cmd.buffer.registers[0].value = (unsigned int )tmp_reg & 253U;
#line 729
  cpia2_do_command(cam, 42U, 0, 0);
#line 730
  cmd.buffer.registers[1].value = (u8 )((unsigned int )cam->params.vp_params.device_config | 1U);
#line 732
  cmd.buffer.registers[0].index = 3U;
#line 733
  cmd.buffer.registers[1].index = 7U;
#line 734
  cmd.req_mode = 6U;
#line 735
  cmd.reg_count = 2U;
#line 736
  cmd.direction = 1U;
#line 737
  cmd.start = 0U;
#line 738
  cpia2_send_command(cam, & cmd);
#line 741
  cpia2_do_command(cam, 44U, 1, 32);
#line 747
  cpia2_do_command(cam, 45U, 1, 16);
#line 752
  if (cam->params.pnp_id.device_type == 1U) {
#line 753
    cpia2_do_command(cam, 44U, 1, 136);
  } else {
#line 758
    cpia2_do_command(cam, 44U, 1, 138);
  }
#line 764
  if (cam->params.pnp_id.device_type == 2U) {
#line 765
    cpia2_do_command(cam, 41U, 1, 16);
  } else {

  }
#line 771
  cpia2_do_command(cam, 42U, 0, 0);
#line 772
  cmd.buffer.registers[0].value = (unsigned int )cam->params.vp_params.device_config & 254U;
#line 775
  cpia2_do_command(cam, 38U, 0, 0);
#line 776
  cmd.buffer.registers[1].value = (u8 )((unsigned int )cam->params.vp_params.system_ctrl | 2U);
#line 779
  cmd.buffer.registers[0].index = 7U;
#line 780
  cmd.buffer.registers[1].index = 3U;
#line 781
  cmd.req_mode = 6U;
#line 782
  cmd.reg_count = 2U;
#line 783
  cmd.direction = 1U;
#line 785
  cpia2_send_command(cam, & cmd);
#line 788
  cpia2_do_command(cam, 46U, 0, 0);
#line 789
  if ((unsigned int )cam->params.compression.inhibit_htables != 0U) {
#line 790
    tmp_reg = (u8 )((unsigned int )cam->params.vc_params.vc_control | 16U);
  } else {
#line 793
    tmp_reg = (unsigned int )cam->params.vc_params.vc_control & 239U;
  }
#line 796
  cpia2_do_command(cam, 47U, 1, (int )tmp_reg);
#line 802
  target_kb = (int )(((((cam->width * cam->height) * 2U) / 16384U) * (u32 )cam->params.vc_params.quality) / 100U);
#line 804
  if (target_kb <= 0) {
#line 805
    target_kb = 1;
  } else {

  }
#line 806
  cpia2_do_command(cam, 48U, 1, (int )((unsigned char )target_kb));
#line 813
  i = 0;
#line 813
  goto ldv_34750;
  ldv_34749: 
#line 814
  cpia2_do_command(cam, 33U, 0, 0);
#line 813
  i = i + 1;
  ldv_34750: ;
#line 813
  if (i <= 49) {
#line 815
    goto ldv_34749;
  } else {

  }
#line 818
  tmp_reg = cam->params.vc_params.pw_control;
#line 819
  tmp_reg = (unsigned int )tmp_reg & 239U;
#line 821
  cpia2_do_command(cam, 34U, 1, (int )tmp_reg);
#line 823
  tmp_reg = (u8 )((unsigned int )tmp_reg | 16U);
#line 824
  cpia2_do_command(cam, 34U, 1, (int )tmp_reg);
#line 826
  cpia2_do_command(cam, 49U, 1, 0);
#line 828
  cpia2_do_command(cam, 28U, 0, 0);
#line 832
  return (retval);
}
}
#line 840 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
static int cpia2_set_high_power(struct camera_data *cam ) 
{ 
  int i ;

  {
#line 843
  i = 0;
#line 843
  goto ldv_34758;
  ldv_34757: 
#line 845
  cpia2_do_command(cam, 35U, 0, 0);
#line 848
  if (((int )cam->params.camera_state.system_ctrl & 16) != 0) {
#line 850
    cpia2_do_command(cam, 26U, 1, 0);
  } else {

  }
#line 854
  cpia2_do_command(cam, 36U, 1, 1);
#line 858
  cpia2_do_command(cam, 37U, 0, 0);
#line 860
  if ((int )cam->params.vp_params.system_state & 1) {
#line 862
    goto ldv_34756;
  } else
#line 863
  if (i == 50) {
#line 864
    cam->params.camera_state.power_mode = 0U;
#line 865
    printk("\vcpia2: Camera did not wake up\n");
#line 866
    return (-5);
  } else {

  }
#line 843
  i = i + 1;
  ldv_34758: ;
#line 843
  if (i <= 50) {
#line 845
    goto ldv_34757;
  } else {

  }
  ldv_34756: 
#line 871
  cam->params.camera_state.power_mode = 1U;
#line 872
  return (0);
}
}
#line 880 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
int cpia2_set_low_power(struct camera_data *cam ) 
{ 


  {
#line 882
  cam->params.camera_state.power_mode = 0U;
#line 883
  cpia2_do_command(cam, 36U, 1, 0);
#line 884
  return (0);
}
}
#line 892 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
static int cpia2_send_onebyte_command(struct camera_data *cam , struct cpia2_command *cmd ,
                                      u8 start , u8 datum ) 
{ 
  int tmp ;

  {
#line 896
  cmd->buffer.block_data[0] = datum;
#line 897
  cmd->start = start;
#line 898
  cmd->reg_count = 1U;
#line 899
  tmp = cpia2_send_command(cam, cmd);
#line 899
  return (tmp);
}
}
#line 902 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
static int apply_vp_patch(struct camera_data *cam ) 
{ 
  struct firmware  const  *fw ;
  char fw_name[22U] ;
  int i ;
  int ret ;
  struct cpia2_command cmd ;
  int __min1 ;
  int __min2 ;

  {
#line 905
  fw_name[0] = 'c';
#line 905
  fw_name[1] = 'p';
#line 905
  fw_name[2] = 'i';
#line 905
  fw_name[3] = 'a';
#line 905
  fw_name[4] = '2';
#line 905
  fw_name[5] = '/';
#line 905
  fw_name[6] = 's';
#line 905
  fw_name[7] = 't';
#line 905
  fw_name[8] = 'v';
#line 905
  fw_name[9] = '0';
#line 905
  fw_name[10] = '6';
#line 905
  fw_name[11] = '7';
#line 905
  fw_name[12] = '2';
#line 905
  fw_name[13] = '_';
#line 905
  fw_name[14] = 'v';
#line 905
  fw_name[15] = 'p';
#line 905
  fw_name[16] = '4';
#line 905
  fw_name[17] = '.';
#line 905
  fw_name[18] = 'b';
#line 905
  fw_name[19] = 'i';
#line 905
  fw_name[20] = 'n';
#line 905
  fw_name[21] = '\000';
#line 909
  ret = request_firmware(& fw, (char const   *)(& fw_name), & (cam->dev)->dev);
#line 910
  if (ret != 0) {
#line 911
    printk("\vcpia2: failed to load VP patch \"%s\"\n", (char const   *)(& fw_name));
#line 913
    return (ret);
  } else {

  }
#line 916
  cmd.req_mode = 14U;
#line 917
  cmd.direction = 1U;
#line 920
  cpia2_send_onebyte_command(cam, & cmd, 10, (int )*(fw->data));
#line 921
  cpia2_send_onebyte_command(cam, & cmd, 11, (int )*(fw->data + 1UL));
#line 924
  i = 2;
#line 924
  goto ldv_34780;
  ldv_34779: 
#line 925
  cmd.start = 12U;
#line 926
  __min1 = 64;
#line 926
  __min2 = (int )((unsigned int )fw->size - (unsigned int )i);
#line 926
  cmd.reg_count = (u8 )(__min1 < __min2 ? __min1 : __min2);
#line 927
  memcpy((void *)(& cmd.buffer.block_data), (void const   *)fw->data + (unsigned long )i,
           (size_t )cmd.reg_count);
#line 928
  cpia2_send_command(cam, & cmd);
#line 924
  i = i + 64;
  ldv_34780: ;
#line 924
  if ((unsigned long )i < (unsigned long )fw->size) {
#line 926
    goto ldv_34779;
  } else {

  }
#line 932
  cpia2_send_onebyte_command(cam, & cmd, 10, (int )*(fw->data));
#line 933
  cpia2_send_onebyte_command(cam, & cmd, 11, (int )*(fw->data + 1UL));
#line 936
  cpia2_send_onebyte_command(cam, & cmd, 13, 1);
#line 938
  release_firmware(fw);
#line 939
  return (0);
}
}
#line 947 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
static int set_default_user_mode(struct camera_data *cam ) 
{ 
  unsigned char user_mode___0 ;
  unsigned char frame_rate ;
  int width ;
  int height ;

  {
#line 951
  width = cam->params.roi.width;
#line 952
  height = cam->params.roi.height;
#line 954
  switch ((int )cam->params.version.sensor_flags) {
  case 1: ;
  case 2: ;
  case 4: ;
  case 8: ;
#line 959
  if (width > 176 || height > 144) {
#line 961
    user_mode___0 = 1U;
  } else {
#line 963
    user_mode___0 = 2U;
  }
#line 965
  frame_rate = 32U;
#line 966
  goto ldv_34793;
  case 16: ;
#line 968
  if (width > 352 || height > 288) {
#line 970
    user_mode___0 = 32U;
  } else {
#line 972
    user_mode___0 = 8U;
  }
#line 974
  if (cam->params.pnp_id.device_type == 1U) {
#line 975
    frame_rate = 8U;
  } else {
#line 977
    frame_rate = 32U;
  }
#line 978
  goto ldv_34793;
  default: 
#line 980
  printk("\016cpia2: %s: Invalid sensor flag value 0x%0X\n", "set_default_user_mode",
         (int )cam->params.version.sensor_flags);
#line 982
  return (-22);
  }
  ldv_34793: 
#line 987
  cpia2_do_command(cam, 27U, 1, (int )user_mode___0);
#line 989
  if ((unsigned int )cam->params.vp_params.frame_rate != 0U && (int )cam->params.vp_params.frame_rate < (int )frame_rate) {
#line 991
    frame_rate = cam->params.vp_params.frame_rate;
  } else {

  }
#line 993
  cpia2_set_fps(cam, (int )frame_rate);
#line 1002
  return (0);
}
}
#line 1012 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
int cpia2_match_video_size(int width , int height ) 
{ 


  {
#line 1014
  if (width > 639 && height > 479) {
#line 1015
    return (0);
  } else {

  }
#line 1017
  if (width > 351 && height > 287) {
#line 1018
    return (1);
  } else {

  }
#line 1020
  if (width > 319 && height > 239) {
#line 1021
    return (2);
  } else {

  }
#line 1023
  if (width > 287 && height > 215) {
#line 1024
    return (4);
  } else {

  }
#line 1026
  if (width > 255 && height > 191) {
#line 1027
    return (5);
  } else {

  }
#line 1029
  if (width > 223 && height > 167) {
#line 1030
    return (6);
  } else {

  }
#line 1032
  if (width > 191 && height > 143) {
#line 1033
    return (7);
  } else {

  }
#line 1035
  if (width > 175 && height > 143) {
#line 1036
    return (3);
  } else {

  }
#line 1038
  return (-1);
}
}
#line 1046 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
static int set_vw_size(struct camera_data *cam , int size ) 
{ 
  int retval ;

  {
#line 1048
  retval = 0;
#line 1050
  cam->params.vp_params.video_size = (u8 )size;
#line 1052
  switch (size) {
  case 0: 
#line 1055
  cam->params.roi.width = 640;
#line 1056
  cam->params.roi.height = 480;
#line 1057
  cam->width = 640U;
#line 1058
  cam->height = 480U;
#line 1059
  goto ldv_34807;
  case 1: 
#line 1062
  cam->params.roi.width = 352;
#line 1063
  cam->params.roi.height = 288;
#line 1064
  cam->width = 352U;
#line 1065
  cam->height = 288U;
#line 1066
  goto ldv_34807;
  case 2: 
#line 1069
  cam->params.roi.width = 320;
#line 1070
  cam->params.roi.height = 240;
#line 1071
  cam->width = 320U;
#line 1072
  cam->height = 240U;
#line 1073
  goto ldv_34807;
  case 4: 
#line 1075
  cam->params.roi.width = 288;
#line 1076
  cam->params.roi.height = 216;
#line 1077
  cam->width = 288U;
#line 1078
  cam->height = 216U;
#line 1079
  goto ldv_34807;
  case 5: 
#line 1081
  cam->width = 256U;
#line 1082
  cam->height = 192U;
#line 1083
  cam->params.roi.width = 256;
#line 1084
  cam->params.roi.height = 192;
#line 1085
  goto ldv_34807;
  case 6: 
#line 1087
  cam->width = 224U;
#line 1088
  cam->height = 168U;
#line 1089
  cam->params.roi.width = 224;
#line 1090
  cam->params.roi.height = 168;
#line 1091
  goto ldv_34807;
  case 7: 
#line 1093
  cam->width = 192U;
#line 1094
  cam->height = 144U;
#line 1095
  cam->params.roi.width = 192;
#line 1096
  cam->params.roi.height = 144;
#line 1097
  goto ldv_34807;
  case 3: 
#line 1100
  cam->params.roi.width = 176;
#line 1101
  cam->params.roi.height = 144;
#line 1102
  cam->width = 176U;
#line 1103
  cam->height = 144U;
#line 1104
  goto ldv_34807;
  default: 
#line 1106
  retval = -22;
  }
  ldv_34807: ;
#line 1108
  return (retval);
}
}
#line 1116 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
static int configure_sensor(struct camera_data *cam , int req_width , int req_height ) 
{ 
  int retval ;

  {
#line 1121
  switch ((int )cam->params.version.sensor_flags) {
  case 1: ;
  case 2: ;
  case 4: ;
  case 8: 
#line 1126
  retval = config_sensor_410(cam, req_width, req_height);
#line 1127
  goto ldv_34826;
  case 16: 
#line 1129
  retval = config_sensor_500(cam, req_width, req_height);
#line 1130
  goto ldv_34826;
  default: ;
#line 1132
  return (-22);
  }
  ldv_34826: ;
#line 1135
  return (retval);
}
}
#line 1143 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
static int config_sensor_410(struct camera_data *cam , int req_width , int req_height ) 
{ 
  struct cpia2_command cmd ;
  int i ;
  int image_size ;
  int image_type ;
  int width ;
  int height ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;

  {
#line 1147
  i = 0;
#line 1150
  width = req_width;
#line 1151
  height = req_height;
#line 1156
  if (width > 352) {
#line 1157
    width = 352;
  } else {

  }
#line 1158
  if (height > 288) {
#line 1159
    height = 288;
  } else {

  }
#line 1161
  image_size = cpia2_match_video_size(width, height);
#line 1165
  if (image_size >= 0) {
#line 1166
    set_vw_size(cam, image_size);
#line 1167
    width = cam->params.roi.width;
#line 1168
    height = cam->params.roi.height;
#line 1172
    if (width <= 176 && height <= 144) {
#line 1174
      image_type = 3;
    } else
#line 1176
    if (width <= 320 && height <= 240) {
#line 1178
      image_type = 2;
    } else {
#line 1182
      image_type = 1;
    }
  } else {
#line 1185
    printk("\vcpia2: ConfigSensor410 failed\n");
#line 1186
    return (-22);
  }
#line 1189
  cmd.req_mode = 5U;
#line 1190
  cmd.direction = 1U;
#line 1193
  cmd.buffer.registers[i].index = 195U;
#line 1194
  if (image_type == 1) {
#line 1195
    tmp = i;
#line 1195
    i = i + 1;
#line 1195
    cmd.buffer.registers[tmp].value = 9U;
  } else {
#line 1199
    tmp___0 = i;
#line 1199
    i = i + 1;
#line 1199
    cmd.buffer.registers[tmp___0].value = 1U;
  }
#line 1204
  cmd.buffer.registers[i].index = 196U;
#line 1205
  if (image_type == 3) {
#line 1206
    if (cam->params.pnp_id.device_type == 1U) {
#line 1207
      tmp___1 = i;
#line 1207
      i = i + 1;
#line 1207
      cmd.buffer.registers[tmp___1].value = 14U;
    } else {
#line 1214
      tmp___2 = i;
#line 1214
      i = i + 1;
#line 1214
      cmd.buffer.registers[tmp___2].value = 10U;
    }
  } else
#line 1219
  if (cam->params.pnp_id.device_type == 1U) {
#line 1220
    tmp___3 = i;
#line 1220
    i = i + 1;
#line 1220
    cmd.buffer.registers[tmp___3].value = 4U;
  } else {
#line 1225
    tmp___4 = i;
#line 1225
    i = i + 1;
#line 1225
    cmd.buffer.registers[tmp___4].value = 24U;
  }
#line 1234
  cmd.buffer.registers[i].index = 197U;
#line 1235
  if (image_type == 3) {
#line 1236
    tmp___5 = i;
#line 1236
    i = i + 1;
#line 1236
    cmd.buffer.registers[tmp___5].value = 44U;
  } else {
#line 1239
    tmp___6 = i;
#line 1239
    i = i + 1;
#line 1239
    cmd.buffer.registers[tmp___6].value = 88U;
  }
#line 1243
  cmd.buffer.registers[i].index = 198U;
#line 1244
  if (image_type == 3) {
#line 1245
    tmp___7 = i;
#line 1245
    i = i + 1;
#line 1245
    cmd.buffer.registers[tmp___7].value = 0U;
  } else {
#line 1247
    tmp___8 = i;
#line 1247
    i = i + 1;
#line 1247
    cmd.buffer.registers[tmp___8].value = 1U;
  }
#line 1249
  cmd.buffer.registers[i].index = 199U;
#line 1250
  if (image_type == 3) {
#line 1251
    tmp___9 = i;
#line 1251
    i = i + 1;
#line 1251
    cmd.buffer.registers[tmp___9].value = 208U;
  } else {
#line 1253
    tmp___10 = i;
#line 1253
    i = i + 1;
#line 1253
    cmd.buffer.registers[tmp___10].value = 160U;
  }
#line 1255
  cmd.buffer.registers[i].index = 200U;
#line 1256
  if (image_type == 3) {
#line 1257
    tmp___11 = i;
#line 1257
    i = i + 1;
#line 1257
    cmd.buffer.registers[tmp___11].value = 0U;
  } else {
#line 1259
    tmp___12 = i;
#line 1259
    i = i + 1;
#line 1259
    cmd.buffer.registers[tmp___12].value = 1U;
  }
#line 1261
  cmd.buffer.registers[i].index = 201U;
#line 1262
  if (image_type == 3) {
#line 1263
    tmp___13 = i;
#line 1263
    i = i + 1;
#line 1263
    cmd.buffer.registers[tmp___13].value = 160U;
  } else {
#line 1265
    tmp___14 = i;
#line 1265
    i = i + 1;
#line 1265
    cmd.buffer.registers[tmp___14].value = 64U;
  }
#line 1268
  cmd.buffer.registers[i].index = 202U;
#line 1269
  tmp___15 = i;
#line 1269
  i = i + 1;
#line 1269
  cmd.buffer.registers[tmp___15].value = (u8 )(cam->params.roi.width / 4);
#line 1271
  cmd.buffer.registers[i].index = 203U;
#line 1272
  tmp___16 = i;
#line 1272
  i = i + 1;
#line 1272
  cmd.buffer.registers[tmp___16].value = (u8 )(cam->params.roi.height / 4);
#line 1275
  cmd.buffer.registers[i].index = 204U;
#line 1276
  if (image_type == 3) {
#line 1277
    tmp___17 = i;
#line 1277
    i = i + 1;
#line 1277
    cmd.buffer.registers[tmp___17].value = (unsigned char )((44 - width / 4) / 2);
  } else {
#line 1280
    tmp___18 = i;
#line 1280
    i = i + 1;
#line 1280
    cmd.buffer.registers[tmp___18].value = (unsigned char )((88 - width / 4) / 2);
  }
#line 1283
  cmd.buffer.registers[i].index = 205U;
#line 1284
  if (image_type == 3) {
#line 1285
    tmp___19 = i;
#line 1285
    i = i + 1;
#line 1285
    cmd.buffer.registers[tmp___19].value = (unsigned char )((36 - height / 4) / 2);
  } else {
#line 1288
    tmp___20 = i;
#line 1288
    i = i + 1;
#line 1288
    cmd.buffer.registers[tmp___20].value = (unsigned char )((72 - height / 4) / 2);
  }
#line 1292
  cmd.buffer.registers[i].index = 206U;
#line 1293
  tmp___21 = i;
#line 1293
  i = i + 1;
#line 1293
  cmd.buffer.registers[tmp___21].value = 0U;
#line 1295
  cmd.buffer.registers[i].index = 207U;
#line 1296
  tmp___22 = i;
#line 1296
  i = i + 1;
#line 1296
  cmd.buffer.registers[tmp___22].value = 0U;
#line 1298
  cmd.buffer.registers[i].index = 208U;
#line 1299
  tmp___23 = i;
#line 1299
  i = i + 1;
#line 1299
  cmd.buffer.registers[tmp___23].value = 31U;
#line 1301
  cmd.buffer.registers[i].index = 209U;
#line 1302
  tmp___24 = i;
#line 1302
  i = i + 1;
#line 1302
  cmd.buffer.registers[tmp___24].value = 31U;
#line 1304
  cmd.buffer.registers[i].index = 210U;
#line 1305
  tmp___25 = i;
#line 1305
  i = i + 1;
#line 1305
  cmd.buffer.registers[tmp___25].value = 0U;
#line 1307
  cmd.buffer.registers[i].index = 211U;
#line 1308
  tmp___26 = i;
#line 1308
  i = i + 1;
#line 1308
  cmd.buffer.registers[tmp___26].value = 0U;
#line 1310
  cmd.buffer.registers[i].index = 212U;
#line 1311
  tmp___27 = i;
#line 1311
  i = i + 1;
#line 1311
  cmd.buffer.registers[tmp___27].value = 129U;
#line 1313
  cmd.buffer.registers[i].index = 213U;
#line 1314
  tmp___28 = i;
#line 1314
  i = i + 1;
#line 1314
  cmd.buffer.registers[tmp___28].value = 129U;
#line 1316
  cmd.reg_count = (u8 )i;
#line 1318
  cpia2_send_command(cam, & cmd);
#line 1320
  return (i);
}
}
#line 1329 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
static int config_sensor_500(struct camera_data *cam , int req_width , int req_height ) 
{ 
  struct cpia2_command cmd ;
  int i ;
  int image_size ;
  int image_type ;
  int width ;
  int height ;
  unsigned int device ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 1333
  i = 0;
#line 1334
  image_size = 1;
#line 1335
  image_type = 0;
#line 1336
  width = req_width;
#line 1337
  height = req_height;
#line 1338
  device = cam->params.pnp_id.device_type;
#line 1340
  image_size = cpia2_match_video_size(width, height);
#line 1342
  if (width > 352 || height > 288) {
#line 1343
    image_type = 0;
  } else
#line 1344
  if (width > 320 || height > 240) {
#line 1345
    image_type = 1;
  } else
#line 1346
  if (width > 176 || height > 144) {
#line 1347
    image_type = 2;
  } else {
#line 1349
    image_type = 3;
  }
#line 1351
  if (image_size >= 0) {
#line 1352
    set_vw_size(cam, image_size);
#line 1353
    width = cam->params.roi.width;
#line 1354
    height = cam->params.roi.height;
  } else {
#line 1356
    printk("\vcpia2: ConfigSensor500 failed\n");
#line 1357
    return (-22);
  }
#line 1363
  cmd.req_mode = 5U;
#line 1364
  cmd.direction = 1U;
#line 1365
  i = 0;
#line 1368
  cmd.buffer.registers[i].index = 195U;
#line 1369
  cmd.buffer.registers[i].value = 1U;
#line 1370
  if (image_type == 3) {
#line 1371
    cmd.buffer.registers[i].value = (u8 )((unsigned int )cmd.buffer.registers[i].value | 4U);
  } else {

  }
#line 1372
  i = i + 1;
#line 1375
  cmd.buffer.registers[i].index = 196U;
#line 1376
  if (device == 1U) {
#line 1377
    if (image_type == 0) {
#line 1378
      cmd.buffer.registers[i].value = 1U;
    } else {
#line 1381
      cmd.buffer.registers[i].value = 11U;
    }
  } else
#line 1385
  if (image_type == 0) {
#line 1386
    cmd.buffer.registers[i].value = 0U;
  } else {
#line 1389
    cmd.buffer.registers[i].value = 18U;
  }
#line 1393
  i = i + 1;
#line 1398
  cmd.buffer.registers[i].index = 197U;
#line 1399
  if (image_type == 0) {
#line 1400
    cmd.buffer.registers[i].value = 160U;
  } else {
#line 1403
    cmd.buffer.registers[i].value = 80U;
  }
#line 1405
  i = i + 1;
#line 1409
  cmd.buffer.registers[i].index = 198U;
#line 1410
  if (image_type == 0) {
#line 1411
    tmp = i;
#line 1411
    i = i + 1;
#line 1411
    cmd.buffer.registers[tmp].value = 2U;
  } else {
#line 1413
    tmp___0 = i;
#line 1413
    i = i + 1;
#line 1413
    cmd.buffer.registers[tmp___0].value = 1U;
  }
#line 1415
  cmd.buffer.registers[i].index = 199U;
#line 1416
  if (image_type == 0) {
#line 1417
    tmp___1 = i;
#line 1417
    i = i + 1;
#line 1417
    cmd.buffer.registers[tmp___1].value = 250U;
  } else
#line 1418
  if (image_type == 2) {
#line 1419
    tmp___2 = i;
#line 1419
    i = i + 1;
#line 1419
    cmd.buffer.registers[tmp___2].value = 125U;
  } else {
#line 1421
    tmp___3 = i;
#line 1421
    i = i + 1;
#line 1421
    cmd.buffer.registers[tmp___3].value = 160U;
  }
#line 1423
  cmd.buffer.registers[i].index = 200U;
#line 1424
  if (image_type == 0) {
#line 1425
    tmp___4 = i;
#line 1425
    i = i + 1;
#line 1425
    cmd.buffer.registers[tmp___4].value = 2U;
  } else {
#line 1427
    tmp___5 = i;
#line 1427
    i = i + 1;
#line 1427
    cmd.buffer.registers[tmp___5].value = 1U;
  }
#line 1429
  cmd.buffer.registers[i].index = 201U;
#line 1430
  if (image_type == 0) {
#line 1431
    tmp___6 = i;
#line 1431
    i = i + 1;
#line 1431
    cmd.buffer.registers[tmp___6].value = 12U;
  } else
#line 1432
  if (image_type == 2) {
#line 1433
    tmp___7 = i;
#line 1433
    i = i + 1;
#line 1433
    cmd.buffer.registers[tmp___7].value = 64U;
  } else {
#line 1435
    tmp___8 = i;
#line 1435
    i = i + 1;
#line 1435
    cmd.buffer.registers[tmp___8].value = 6U;
  }
#line 1438
  cmd.buffer.registers[i].index = 202U;
#line 1439
  if (image_type == 3) {
#line 1440
    tmp___9 = i;
#line 1440
    i = i + 1;
#line 1440
    cmd.buffer.registers[tmp___9].value = 88U;
  } else {
#line 1442
    tmp___10 = i;
#line 1442
    i = i + 1;
#line 1442
    cmd.buffer.registers[tmp___10].value = (u8 )(width / 4);
  }
#line 1444
  cmd.buffer.registers[i].index = 203U;
#line 1445
  if (image_type == 3) {
#line 1446
    tmp___11 = i;
#line 1446
    i = i + 1;
#line 1446
    cmd.buffer.registers[tmp___11].value = 72U;
  } else {
#line 1448
    tmp___12 = i;
#line 1448
    i = i + 1;
#line 1448
    cmd.buffer.registers[tmp___12].value = (u8 )(height / 4);
  }
#line 1451
  cmd.buffer.registers[i].index = 204U;
#line 1452
  if (image_type == 0) {
#line 1453
    tmp___13 = i;
#line 1453
    i = i + 1;
#line 1453
    cmd.buffer.registers[tmp___13].value = (unsigned char )((160 - width / 4) / 2);
  } else
#line 1455
  if (image_type == 2) {
#line 1456
    tmp___14 = i;
#line 1456
    i = i + 1;
#line 1456
    cmd.buffer.registers[tmp___14].value = (unsigned char )((80 - width / 4) / 2);
  } else
#line 1458
  if (image_type == 1) {
#line 1459
    tmp___15 = i;
#line 1459
    i = i + 1;
#line 1459
    cmd.buffer.registers[tmp___15].value = (unsigned char )((88 - width / 4) / 2);
  } else {
#line 1462
    tmp___16 = i;
#line 1462
    i = i + 1;
#line 1462
    cmd.buffer.registers[tmp___16].value = (unsigned char )((44 - width / 4) / 2);
  }
#line 1465
  cmd.buffer.registers[i].index = 205U;
#line 1466
  if (image_type == 0) {
#line 1467
    tmp___17 = i;
#line 1467
    i = i + 1;
#line 1467
    cmd.buffer.registers[tmp___17].value = (unsigned char )((120 - height / 4) / 2);
  } else
#line 1469
  if (image_type == 2) {
#line 1470
    tmp___18 = i;
#line 1470
    i = i + 1;
#line 1470
    cmd.buffer.registers[tmp___18].value = (unsigned char )((60 - height / 4) / 2);
  } else
#line 1472
  if (image_type == 1) {
#line 1473
    tmp___19 = i;
#line 1473
    i = i + 1;
#line 1473
    cmd.buffer.registers[tmp___19].value = (unsigned char )((72 - height / 4) / 2);
  } else {
#line 1476
    tmp___20 = i;
#line 1476
    i = i + 1;
#line 1476
    cmd.buffer.registers[tmp___20].value = (unsigned char )((36 - height / 4) / 2);
  }
#line 1480
  cmd.buffer.registers[i].index = 206U;
#line 1481
  if (image_type == 1 || image_type == 3) {
#line 1482
    tmp___21 = i;
#line 1482
    i = i + 1;
#line 1482
    cmd.buffer.registers[tmp___21].value = 36U;
  } else {
#line 1484
    tmp___22 = i;
#line 1484
    i = i + 1;
#line 1484
    cmd.buffer.registers[tmp___22].value = 0U;
  }
#line 1486
  cmd.buffer.registers[i].index = 207U;
#line 1487
  if (image_type == 1 || image_type == 3) {
#line 1488
    tmp___23 = i;
#line 1488
    i = i + 1;
#line 1488
    cmd.buffer.registers[tmp___23].value = 32U;
  } else {
#line 1490
    tmp___24 = i;
#line 1490
    i = i + 1;
#line 1490
    cmd.buffer.registers[tmp___24].value = 0U;
  }
#line 1492
  cmd.buffer.registers[i].index = 208U;
#line 1493
  if (image_type == 1 || image_type == 3) {
#line 1494
    tmp___25 = i;
#line 1494
    i = i + 1;
#line 1494
    cmd.buffer.registers[tmp___25].value = 26U;
  } else {
#line 1496
    tmp___26 = i;
#line 1496
    i = i + 1;
#line 1496
    cmd.buffer.registers[tmp___26].value = 31U;
  }
#line 1498
  cmd.buffer.registers[i].index = 209U;
#line 1499
  if (image_type == 1 || image_type == 3) {
#line 1500
    tmp___27 = i;
#line 1500
    i = i + 1;
#line 1500
    cmd.buffer.registers[tmp___27].value = 21U;
  } else {
#line 1502
    tmp___28 = i;
#line 1502
    i = i + 1;
#line 1502
    cmd.buffer.registers[tmp___28].value = 31U;
  }
#line 1504
  cmd.buffer.registers[i].index = 210U;
#line 1505
  tmp___29 = i;
#line 1505
  i = i + 1;
#line 1505
  cmd.buffer.registers[tmp___29].value = 0U;
#line 1507
  cmd.buffer.registers[i].index = 211U;
#line 1508
  tmp___30 = i;
#line 1508
  i = i + 1;
#line 1508
  cmd.buffer.registers[tmp___30].value = 0U;
#line 1510
  cmd.buffer.registers[i].index = 212U;
#line 1511
  if (image_type == 1 || image_type == 3) {
#line 1512
    tmp___31 = i;
#line 1512
    i = i + 1;
#line 1512
    cmd.buffer.registers[tmp___31].value = 43U;
  } else {
#line 1514
    tmp___32 = i;
#line 1514
    i = i + 1;
#line 1514
    cmd.buffer.registers[tmp___32].value = 129U;
  }
#line 1516
  cmd.buffer.registers[i].index = 213U;
#line 1517
  if (image_type == 1 || image_type == 3) {
#line 1518
    tmp___33 = i;
#line 1518
    i = i + 1;
#line 1518
    cmd.buffer.registers[tmp___33].value = 19U;
  } else {
#line 1520
    tmp___34 = i;
#line 1520
    i = i + 1;
#line 1520
    cmd.buffer.registers[tmp___34].value = 129U;
  }
#line 1522
  cmd.reg_count = (u8 )i;
#line 1524
  cpia2_send_command(cam, & cmd);
#line 1526
  return (i);
}
}
#line 1536 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
static int set_all_properties(struct camera_data *cam ) 
{ 


  {
#line 1543
  cpia2_usb_change_streaming_alternate(cam, (unsigned int )cam->params.camera_state.stream_mode);
#line 1546
  cpia2_do_command(cam, 17U, 1, (int )cam->params.vp_params.gpio_direction);
#line 1549
  cpia2_do_command(cam, 19U, 1, (int )cam->params.vp_params.gpio_data);
#line 1552
  v4l2_ctrl_handler_setup(& cam->hdl);
#line 1554
  wake_system(cam);
#line 1556
  set_lowlight_boost(cam);
#line 1558
  return (0);
}
}
#line 1566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
void cpia2_save_camera_state(struct camera_data *cam ) 
{ 


  {
#line 1568
  cpia2_do_command(cam, 51U, 0, 0);
#line 1569
  cpia2_do_command(cam, 16U, 0, 0);
#line 1571
  cpia2_do_command(cam, 18U, 0, 0);
#line 1572
  return;
}
}
#line 1581 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
int cpia2_set_flicker_mode(struct camera_data *cam , int mode ) 
{ 
  unsigned char cam_reg ;
  int err ;

  {
#line 1584
  err = 0;
#line 1586
  if (cam->params.pnp_id.device_type != 1U) {
#line 1587
    return (-22);
  } else {

  }
#line 1590
  err = cpia2_do_command(cam, 21U, 0, 0);
#line 1590
  if (err != 0) {
#line 1592
    return (err);
  } else {

  }
#line 1593
  cam_reg = cam->params.flicker_control.cam_register;
#line 1595
  switch (mode) {
  case 0: 
#line 1597
  cam_reg = (unsigned int )cam_reg | 32U;
#line 1598
  cam_reg = (unsigned int )cam_reg & 127U;
#line 1599
  goto ldv_34865;
  case 60: 
#line 1601
  cam_reg = (unsigned int )cam_reg & 223U;
#line 1602
  cam_reg = (unsigned int )cam_reg & 127U;
#line 1603
  goto ldv_34865;
  case 50: 
#line 1605
  cam_reg = (unsigned int )cam_reg & 223U;
#line 1606
  cam_reg = (unsigned int )cam_reg | 128U;
#line 1607
  goto ldv_34865;
  default: ;
#line 1609
  return (-22);
  }
  ldv_34865: 
#line 1612
  err = cpia2_do_command(cam, 22U, 1, (int )cam_reg);
#line 1612
  if (err != 0) {
#line 1614
    return (err);
  } else {

  }
#line 1617
  err = cpia2_do_command(cam, 40U, 0, 0);
#line 1617
  if (err != 0) {
#line 1619
    return (err);
  } else {

  }
#line 1620
  cam_reg = cam->params.vp_params.exposure_modes;
#line 1622
  if (mode == 0) {
#line 1623
    cam_reg = (unsigned int )cam_reg | 32U;
  } else {
#line 1625
    cam_reg = (unsigned int )cam_reg & 223U;
  }
#line 1628
  err = cpia2_do_command(cam, 41U, 1, (int )cam_reg);
#line 1628
  if (err != 0) {
#line 1630
    return (err);
  } else {

  }
#line 1632
  err = cpia2_do_command(cam, 50U, 1, 1);
#line 1632
  if (err != 0) {
#line 1634
    return (err);
  } else {

  }
#line 1636
  switch (mode) {
  case 0: ;
  case 60: ;
  case 50: 
#line 1640
  cam->params.flicker_control.flicker_mode_req = (u8 )mode;
#line 1641
  goto ldv_34872;
  default: 
#line 1643
  err = -22;
  }
  ldv_34872: ;
#line 1646
  return (err);
}
}
#line 1654 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
void cpia2_set_property_flip(struct camera_data *cam , int prop_val ) 
{ 
  unsigned char cam_reg ;

  {
#line 1658
  cpia2_do_command(cam, 51U, 0, 0);
#line 1659
  cam_reg = cam->params.vp_params.user_effects;
#line 1661
  if (prop_val != 0) {
#line 1663
    cam_reg = (unsigned int )cam_reg | 64U;
  } else {
#line 1667
    cam_reg = (unsigned int )cam_reg & 191U;
  }
#line 1669
  cam->params.vp_params.user_effects = cam_reg;
#line 1670
  cpia2_do_command(cam, 52U, 1, (int )cam_reg);
#line 1671
  return;
}
}
#line 1679 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
void cpia2_set_property_mirror(struct camera_data *cam , int prop_val ) 
{ 
  unsigned char cam_reg ;

  {
#line 1683
  cpia2_do_command(cam, 51U, 0, 0);
#line 1684
  cam_reg = cam->params.vp_params.user_effects;
#line 1686
  if (prop_val != 0) {
#line 1688
    cam_reg = (unsigned int )cam_reg | 4U;
  } else {
#line 1692
    cam_reg = (unsigned int )cam_reg & 251U;
  }
#line 1694
  cam->params.vp_params.user_effects = cam_reg;
#line 1695
  cpia2_do_command(cam, 52U, 1, (int )cam_reg);
#line 1696
  return;
}
}
#line 1704 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
int cpia2_set_gpio(struct camera_data *cam , unsigned char setting ) 
{ 
  int ret ;

  {
#line 1713
  ret = cpia2_do_command(cam, 17U, 1, 255);
#line 1717
  if (ret < 0) {
#line 1718
    return (ret);
  } else {

  }
#line 1719
  cam->params.vp_params.gpio_direction = 255U;
#line 1721
  ret = cpia2_do_command(cam, 19U, 1, (int )setting);
#line 1725
  if (ret < 0) {
#line 1726
    return (ret);
  } else {

  }
#line 1727
  cam->params.vp_params.gpio_data = setting;
#line 1729
  return (0);
}
}
#line 1737 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
int cpia2_set_fps(struct camera_data *cam , int framerate ) 
{ 
  int retval ;

  {
#line 1741
  switch (framerate) {
  case 32: ;
  case 16: ;
#line 1744
  if (cam->params.pnp_id.device_type == 1U && (unsigned int )cam->params.version.sensor_flags == 16U) {
#line 1747
    return (-22);
  } else {

  }
  case 8: ;
  case 4: ;
  case 2: ;
  case 1: ;
#line 1754
  goto ldv_34900;
  default: ;
#line 1756
  return (-22);
  }
  ldv_34900: ;
#line 1759
  if (cam->params.pnp_id.device_type == 1U && framerate == 8) {
#line 1761
    framerate = 0;
  } else {

  }
#line 1763
  retval = cpia2_do_command(cam, 29U, 1, (int )((unsigned char )framerate));
#line 1768
  if (retval == 0) {
#line 1769
    cam->params.vp_params.frame_rate = (u8 )framerate;
  } else {

  }
#line 1771
  return (retval);
}
}
#line 1779 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
void cpia2_set_brightness(struct camera_data *cam , unsigned char value ) 
{ 


  {
#line 1785
  if (cam->params.pnp_id.device_type == 1U && (unsigned int )value == 0U) {
#line 1786
    value = (unsigned char )((int )value + 1);
  } else {

  }
#line 1788
  cpia2_do_command(cam, 7U, 1, (int )value);
#line 1789
  return;
}
}
#line 1796 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
void cpia2_set_contrast(struct camera_data *cam , unsigned char value ) 
{ 


  {
#line 1799
  cpia2_do_command(cam, 9U, 1, (int )value);
#line 1800
  return;
}
}
#line 1807 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
void cpia2_set_saturation(struct camera_data *cam , unsigned char value ) 
{ 


  {
#line 1810
  cpia2_do_command(cam, 11U, 1, (int )value);
#line 1811
  return;
}
}
#line 1818 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
static void wake_system(struct camera_data *cam ) 
{ 


  {
#line 1820
  cpia2_do_command(cam, 32U, 1, 0);
#line 1821
  return;
}
}
#line 1829 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
static void set_lowlight_boost(struct camera_data *cam ) 
{ 
  struct cpia2_command cmd ;

  {
#line 1833
  if (cam->params.pnp_id.device_type != 1U || (unsigned int )cam->params.version.sensor_flags != 16U) {
#line 1835
    return;
  } else {

  }
#line 1837
  cmd.direction = 1U;
#line 1838
  cmd.req_mode = 2U;
#line 1839
  cmd.reg_count = 3U;
#line 1840
  cmd.start = 10U;
#line 1842
  cmd.buffer.block_data[0] = 0U;
#line 1843
  cmd.buffer.block_data[1] = 89U;
#line 1844
  cmd.buffer.block_data[2] = 0U;
#line 1846
  cpia2_send_command(cam, & cmd);
#line 1848
  if ((unsigned int )cam->params.vp_params.lowlight_boost != 0U) {
#line 1849
    cmd.buffer.block_data[0] = 2U;
  } else {
#line 1851
    cmd.buffer.block_data[0] = 6U;
  }
#line 1853
  cmd.start = 12U;
#line 1854
  cmd.reg_count = 1U;
#line 1855
  cpia2_send_command(cam, & cmd);
#line 1858
  cpia2_do_command(cam, 50U, 1, 1);
#line 1859
  return;
}
}
#line 1867 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
void cpia2_set_format(struct camera_data *cam ) 
{ 


  {
#line 1869
  cam->flush = 1U;
#line 1871
  cpia2_usb_stream_pause(cam);
#line 1874
  cpia2_set_low_power(cam);
#line 1875
  cpia2_reset_camera(cam);
#line 1876
  cam->flush = 0U;
#line 1878
  cpia2_dbg_dump_registers(cam);
#line 1880
  cpia2_usb_stream_resume(cam);
#line 1881
  return;
}
}
#line 1888 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
void cpia2_dbg_dump_registers(struct camera_data *cam ) 
{ 


  {
#line 1890
  return;
}
}
#line 2106 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
static void reset_camera_struct(struct camera_data *cam ) 
{ 


  {
#line 2111
  cam->params.vp_params.lowlight_boost = 0U;
#line 2114
  cam->params.flicker_control.flicker_mode_req = 0U;
#line 2117
  cam->params.compression.jpeg_options = 5U;
#line 2118
  cam->params.compression.creep_period = 2U;
#line 2119
  cam->params.compression.user_squeeze = 20U;
#line 2120
  cam->params.compression.inhibit_htables = 0U;
#line 2123
  cam->params.vp_params.gpio_direction = 0U;
#line 2124
  cam->params.vp_params.gpio_data = 0U;
#line 2127
  cam->params.vc_params.quality = 100U;
#line 2132
  if (cam->params.pnp_id.device_type == 1U) {
#line 2133
    if ((unsigned int )cam->params.version.sensor_flags == 16U) {
#line 2134
      cam->params.vp_params.frame_rate = 8U;
    } else {
#line 2136
      cam->params.vp_params.frame_rate = 32U;
    }
  } else {
#line 2138
    cam->params.vp_params.frame_rate = 32U;
  }
#line 2145
  if ((unsigned int )cam->params.version.sensor_flags == 16U) {
#line 2146
    cam->sensor_type = 1;
#line 2147
    cam->video_size = 0;
#line 2148
    cam->params.roi.width = 640;
#line 2149
    cam->params.roi.height = 480;
  } else {
#line 2151
    cam->sensor_type = 0;
#line 2152
    cam->video_size = 1;
#line 2153
    cam->params.roi.width = 352;
#line 2154
    cam->params.roi.height = 288;
  }
#line 2157
  cam->width = (u32 )cam->params.roi.width;
#line 2158
  cam->height = (u32 )cam->params.roi.height;
#line 2159
  return;
}
}
#line 2167 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
struct camera_data *cpia2_init_camera_struct(struct usb_interface *intf ) 
{ 
  struct camera_data *cam ;
  void *tmp ;
  int tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
#line 2171
  tmp = kzalloc(2912UL, 208U);
#line 2171
  cam = (struct camera_data *)tmp;
#line 2173
  if ((unsigned long )cam == (unsigned long )((struct camera_data *)0)) {
#line 2174
    printk("\vcpia2: couldn\'t kmalloc cpia2 struct\n");
#line 2175
    return ((struct camera_data *)0);
  } else {

  }
#line 2178
  cam->v4l2_dev.release = & cpia2_camera_release;
#line 2179
  tmp___0 = v4l2_device_register(& intf->dev, & cam->v4l2_dev);
#line 2179
  if (tmp___0 < 0) {
#line 2180
    printk("\v%s: couldn\'t register v4l2_device\n", (char *)(& cam->v4l2_dev.name));
#line 2181
    kfree((void const   *)cam);
#line 2182
    return ((struct camera_data *)0);
  } else {

  }
#line 2185
  __mutex_init(& cam->v4l2_lock, "&cam->v4l2_lock", & __key);
#line 2186
  __init_waitqueue_head(& cam->wq_stream, "&cam->wq_stream", & __key___0);
#line 2188
  return (cam);
}
}
#line 2197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
int cpia2_init_camera(struct camera_data *cam ) 
{ 


  {
#line 2201
  cam->mmapped = 0U;
#line 2204
  cpia2_set_high_power(cam);
#line 2205
  cpia2_get_version_info(cam);
#line 2206
  if ((unsigned int )cam->params.version.asic_id != 103U) {
#line 2207
    printk("\vcpia2: Device IO error (asicID has incorrect value of 0x%X\n", (int )cam->params.version.asic_id);
#line 2209
    return (-19);
  } else {

  }
#line 2213
  cpia2_do_command(cam, 17U, 1, 0);
#line 2215
  cpia2_do_command(cam, 19U, 1, 0);
#line 2219
  reset_camera_struct(cam);
#line 2221
  cpia2_set_low_power(cam);
#line 2225
  return (0);
}
}
#line 2233 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
int cpia2_allocate_buffers(struct camera_data *cam ) 
{ 
  int i ;
  u32 size ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 2237
  if ((unsigned long )cam->buffers == (unsigned long )((struct framebuf *)0)) {
#line 2238
    size = (u32 )((unsigned long )cam->num_frames) * 56U;
#line 2239
    tmp = kmalloc((size_t )size, 208U);
#line 2239
    cam->buffers = (struct framebuf *)tmp;
#line 2240
    if ((unsigned long )cam->buffers == (unsigned long )((struct framebuf *)0)) {
#line 2241
      printk("\vcpia2: couldn\'t kmalloc frame buffer structures\n");
#line 2242
      return (-12);
    } else {

    }
  } else {

  }
#line 2246
  if ((unsigned long )cam->frame_buffer == (unsigned long )((u8 *)0U)) {
#line 2247
    tmp___0 = rvmalloc((unsigned long )(cam->frame_size * (u32 )cam->num_frames));
#line 2247
    cam->frame_buffer = (u8 *)tmp___0;
#line 2248
    if ((unsigned long )cam->frame_buffer == (unsigned long )((u8 *)0U)) {
#line 2249
      printk("\vcpia2: couldn\'t vmalloc frame buffer data area\n");
#line 2250
      kfree((void const   *)cam->buffers);
#line 2251
      cam->buffers = (struct framebuf *)0;
#line 2252
      return (-12);
    } else {

    }
  } else {

  }
#line 2256
  i = 0;
#line 2256
  goto ldv_34945;
  ldv_34944: 
#line 2257
  (cam->buffers + (unsigned long )i)->next = cam->buffers + ((unsigned long )i + 1UL);
#line 2258
  (cam->buffers + (unsigned long )i)->data = cam->frame_buffer + (unsigned long )(cam->frame_size * (u32 )i);
#line 2259
  (cam->buffers + (unsigned long )i)->status = 0;
#line 2260
  (cam->buffers + (unsigned long )i)->length = 0;
#line 2261
  (cam->buffers + (unsigned long )i)->max_length = 0;
#line 2262
  (cam->buffers + (unsigned long )i)->num = i;
#line 2256
  i = i + 1;
  ldv_34945: ;
#line 2256
  if (cam->num_frames + -1 > i) {
#line 2258
    goto ldv_34944;
  } else {

  }
#line 2264
  (cam->buffers + (unsigned long )i)->next = cam->buffers;
#line 2265
  (cam->buffers + (unsigned long )i)->data = cam->frame_buffer + (unsigned long )(cam->frame_size * (u32 )i);
#line 2266
  (cam->buffers + (unsigned long )i)->status = 0;
#line 2267
  (cam->buffers + (unsigned long )i)->length = 0;
#line 2268
  (cam->buffers + (unsigned long )i)->max_length = 0;
#line 2269
  (cam->buffers + (unsigned long )i)->num = i;
#line 2270
  cam->curbuff = cam->buffers;
#line 2271
  cam->workbuff = (cam->curbuff)->next;
#line 2274
  return (0);
}
}
#line 2282 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
void cpia2_free_buffers(struct camera_data *cam ) 
{ 


  {
#line 2284
  if ((unsigned long )cam->buffers != (unsigned long )((struct framebuf *)0)) {
#line 2285
    kfree((void const   *)cam->buffers);
#line 2286
    cam->buffers = (struct framebuf *)0;
  } else {

  }
#line 2288
  if ((unsigned long )cam->frame_buffer != (unsigned long )((u8 *)0U)) {
#line 2289
    rvfree((void *)cam->frame_buffer, (unsigned long )(cam->frame_size * (u32 )cam->num_frames));
#line 2290
    cam->frame_buffer = (u8 *)0U;
  } else {

  }
#line 2292
  return;
}
}
#line 2299 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
long cpia2_read(struct camera_data *cam , char *buf , unsigned long count , int noblock ) 
{ 
  struct framebuf *frame ;
  int __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct task_struct *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;

  {
#line 2304
  if (count == 0UL) {
#line 2305
    return (0L);
  } else {

  }
#line 2307
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 2308
    printk("\vcpia2: %s: buffer NULL\n", "cpia2_read");
#line 2309
    return (-22L);
  } else {

  }
#line 2312
  if ((unsigned long )cam == (unsigned long )((struct camera_data *)0)) {
#line 2313
    printk("\vcpia2: %s: Internal error, camera_data NULL!\n", "cpia2_read");
#line 2314
    return (-22L);
  } else {

  }
#line 2317
  if (cam->streaming == 0) {
#line 2319
    cpia2_usb_stream_start(cam, (unsigned int )cam->params.camera_state.stream_mode);
  } else {

  }
#line 2324
  frame = cam->curbuff;
#line 2325
  if (noblock != 0 && (unsigned int )frame->status != 2U) {
#line 2326
    return (-11L);
  } else {

  }
#line 2329
  if ((unsigned int )frame->status != 2U) {
#line 2330
    ldv_mutex_unlock_102(& cam->v4l2_lock);
#line 2331
    __ret = 0;
#line 2331
    __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c",
                  2333, 0);
#line 2331
    tmp___1 = video_is_registered(& cam->vdev);
#line 2331
    if (tmp___1 != 0) {
#line 2331
      frame = cam->curbuff;
#line 2331
      if ((unsigned int )frame->status != 2U) {
#line 2331
        __ret___0 = 0L;
#line 2331
        INIT_LIST_HEAD(& __wait.task_list);
#line 2331
        __wait.flags = 0U;
        ldv_34964: 
#line 2331
        tmp = prepare_to_wait_event(& cam->wq_stream, & __wait, 1);
#line 2331
        __int = tmp;
#line 2331
        tmp___0 = video_is_registered(& cam->vdev);
#line 2331
        if (tmp___0 == 0) {
#line 2331
          goto ldv_34963;
        } else {
#line 2331
          frame = cam->curbuff;
#line 2331
          if ((unsigned int )frame->status == 2U) {
#line 2331
            goto ldv_34963;
          } else {

          }
        }
#line 2331
        if (__int != 0L) {
#line 2331
          __ret___0 = __int;
#line 2331
          goto ldv_34963;
        } else {

        }
#line 2331
        schedule();
#line 2331
        goto ldv_34964;
        ldv_34963: 
#line 2331
        finish_wait(& cam->wq_stream, & __wait);
#line 2331
        __ret = (int )__ret___0;
      } else {

      }
    } else {

    }
#line 2334
    ldv_mutex_lock_103(& cam->v4l2_lock);
#line 2335
    tmp___2 = get_current();
#line 2335
    tmp___3 = signal_pending(tmp___2);
#line 2335
    if (tmp___3 != 0) {
#line 2336
      return (-512L);
    } else {

    }
#line 2337
    tmp___4 = video_is_registered(& cam->vdev);
#line 2337
    if (tmp___4 == 0) {
#line 2338
      return (0L);
    } else {

    }
  } else {

  }
#line 2342
  if ((unsigned long )frame->length > count) {
#line 2343
    return (-14L);
  } else {

  }
#line 2344
  tmp___5 = copy_to_user((void *)buf, (void const   *)frame->data, (unsigned long )frame->length);
#line 2344
  if (tmp___5 != 0UL) {
#line 2345
    return (-14L);
  } else {

  }
#line 2347
  count = (unsigned long )frame->length;
#line 2349
  frame->status = 0;
#line 2351
  return ((long )count);
}
}
#line 2359 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
unsigned int cpia2_poll(struct camera_data *cam , struct file *filp , poll_table *wait ) 
{ 
  unsigned int status ;
  unsigned int tmp ;
  unsigned long tmp___0 ;

  {
#line 2362
  tmp = v4l2_ctrl_poll(filp, wait);
#line 2362
  status = tmp;
#line 2364
  tmp___0 = poll_requested_events((poll_table const   *)wait);
#line 2364
  if ((tmp___0 & 65UL) != 0UL && cam->streaming == 0) {
#line 2367
    cpia2_usb_stream_start(cam, (unsigned int )cam->params.camera_state.stream_mode);
  } else {

  }
#line 2371
  poll_wait(filp, & cam->wq_stream, wait);
#line 2373
  if ((unsigned int )(cam->curbuff)->status == 2U) {
#line 2374
    status = status | 65U;
  } else {

  }
#line 2376
  return (status);
}
}
#line 2384 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.c"
int cpia2_remap_buffer(struct camera_data *cam , struct vm_area_struct *vma ) 
{ 
  char const   *adr ;
  unsigned long size ;
  unsigned long start_offset ;
  unsigned long start ;
  unsigned long page ;
  unsigned long pos ;
  int tmp ;
  pgprot_t __constr_expr_0 ;
  int tmp___0 ;

  {
#line 2386
  adr = (char const   *)vma->vm_start;
#line 2387
  size = vma->vm_end - vma->vm_start;
#line 2388
  start_offset = vma->vm_pgoff << 12;
#line 2389
  start = (unsigned long )adr;
#line 2394
  tmp = video_is_registered(& cam->vdev);
#line 2394
  if (tmp == 0) {
#line 2395
    return (-19);
  } else {

  }
#line 2397
  if (((unsigned long )(cam->frame_size * (u32 )cam->num_frames) < size || start_offset % (unsigned long )cam->frame_size != 0UL) || start_offset + size > (unsigned long )(cam->frame_size * (u32 )cam->num_frames)) {
#line 2400
    return (-22);
  } else {

  }
#line 2402
  pos = (unsigned long )cam->frame_buffer + start_offset;
#line 2403
  goto ldv_34985;
  ldv_34984: 
#line 2404
  page = kvirt_to_pa(pos);
#line 2405
  __constr_expr_0.pgprot = 0x8000000000000027UL;
#line 2405
  tmp___0 = remap_pfn_range(vma, start, page >> 12, 4096UL, __constr_expr_0);
#line 2405
  if (tmp___0 != 0) {
#line 2406
    return (-11);
  } else {

  }
#line 2407
  start = start + 4096UL;
#line 2408
  pos = pos + 4096UL;
#line 2409
  if (size > 4096UL) {
#line 2410
    size = size - 4096UL;
  } else {
#line 2412
    size = 0UL;
  }
  ldv_34985: ;
#line 2403
  if (size != 0UL) {
#line 2405
    goto ldv_34984;
  } else {

  }
#line 2415
  cam->mmapped = 1U;
#line 2416
  return (0);
}
}
#line 134 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.o.c.prepared"
void ldv_mutex_lock_93(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 137
  ldv_mutex_lock_lock(ldv_func_arg1);
#line 139
  mutex_lock(ldv_func_arg1);
#line 140
  return;
}
}
#line 142 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.o.c.prepared"
void ldv_mutex_unlock_94(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 145
  ldv_mutex_unlock_lock(ldv_func_arg1);
#line 147
  mutex_unlock(ldv_func_arg1);
#line 148
  return;
}
}
#line 150 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.o.c.prepared"
void ldv_mutex_lock_95(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 153
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
#line 155
  mutex_lock(ldv_func_arg1);
#line 156
  return;
}
}
#line 158 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.o.c.prepared"
int ldv_mutex_trylock_96(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
#line 162
  tmp = mutex_trylock(ldv_func_arg1);
#line 162
  ldv_func_res = tmp;
#line 164
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
#line 164
  return (tmp___0);
#line 166
  return (ldv_func_res);
}
}
#line 169 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.o.c.prepared"
void ldv_mutex_unlock_97(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 172
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
#line 174
  mutex_unlock(ldv_func_arg1);
#line 175
  return;
}
}
#line 177 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.o.c.prepared"
void ldv_mutex_unlock_98(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 180
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
#line 182
  mutex_unlock(ldv_func_arg1);
#line 183
  return;
}
}
#line 185 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.o.c.prepared"
void ldv_mutex_lock_99(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 188
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
#line 190
  mutex_lock(ldv_func_arg1);
#line 191
  return;
}
}
#line 193 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.o.c.prepared"
void ldv_mutex_lock_100(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 196
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 198
  mutex_lock(ldv_func_arg1);
#line 199
  return;
}
}
#line 201 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.o.c.prepared"
void ldv_mutex_unlock_101(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 204
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
#line 206
  mutex_unlock(ldv_func_arg1);
#line 207
  return;
}
}
#line 209 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.o.c.prepared"
void ldv_mutex_unlock_102(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 212
  ldv_mutex_unlock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 214
  mutex_unlock(ldv_func_arg1);
#line 215
  return;
}
}
#line 217 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/dscv/ri/32_7a/drivers/media/usb/cpia2/cpia2_core.o.c.prepared"
void ldv_mutex_lock_103(struct mutex *ldv_func_arg1 ) 
{ 


  {
#line 220
  ldv_mutex_lock_v4l2_lock_of_camera_data(ldv_func_arg1);
#line 222
  mutex_lock(ldv_func_arg1);
#line 223
  return;
}
}
#line 12 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
#line 14
  __VERIFIER_error();
}
}
#line 32 "/home/ldvuser/ldv/inst/kernel-rules/verifier/rcv.h"
__inline static int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
#line 34
  tmp = ldv_undef_int();
#line 34
  ret = tmp;
#line 36
  if (ret >= 0) {
#line 36
    ldv_stop();
  } else {

  }
#line 38
  return (ret);
}
}
#line 7 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err(void const   *ptr ) 
{ 


  {
#line 10
  return ((unsigned long )ptr > 2012UL);
}
}
#line 14 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 17
  return ((void *)(2012L - error));
}
}
#line 21 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 24
  return ((long )(2012UL - (unsigned long )ptr));
}
}
#line 28 "/home/ldvuser/ldv/inst/kernel-rules/kernel-model/ERR.inc"
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 31
    tmp___0 = 1;
  } else {
#line 31
    tmp = ldv_is_err(ptr);
#line 31
    if ((int )tmp) {
#line 31
      tmp___0 = 1;
    } else {
#line 31
      tmp___0 = 0;
    }
  }
#line 31
  return ((bool )tmp___0);
}
}
#line 8 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_i_mutex_of_inode  =    1;
#line 11 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 16
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 16
    ldv_error();
  } else {

  }
#line 19
  nondetermined = ldv_undef_int();
#line 22
  if (nondetermined != 0) {
#line 25
    ldv_mutex_i_mutex_of_inode = 2;
#line 27
    return (0);
  } else {
#line 32
    return (-4);
  }
}
}
#line 37 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 42
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 42
    ldv_error();
  } else {

  }
#line 45
  nondetermined = ldv_undef_int();
#line 48
  if (nondetermined != 0) {
#line 51
    ldv_mutex_i_mutex_of_inode = 2;
#line 53
    return (0);
  } else {
#line 58
    return (-4);
  }
}
}
#line 63 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
#line 66
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 66
    ldv_error();
  } else {

  }
#line 68
  ldv_mutex_i_mutex_of_inode = 2;
#line 69
  return;
}
}
#line 72 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 77
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 77
    ldv_error();
  } else {

  }
#line 80
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 83
  if (is_mutex_held_by_another_thread != 0) {
#line 86
    return (0);
  } else {
#line 91
    ldv_mutex_i_mutex_of_inode = 2;
#line 93
    return (1);
  }
}
}
#line 98 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_i_mutex_of_inode(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 103
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 103
    ldv_error();
  } else {

  }
#line 106
  atomic_value_after_dec = ldv_undef_int();
#line 109
  if (atomic_value_after_dec == 0) {
#line 112
    ldv_mutex_i_mutex_of_inode = 2;
#line 114
    return (1);
  } else {

  }
#line 118
  return (0);
}
}
#line 123 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 127
  if (ldv_mutex_i_mutex_of_inode == 1) {
#line 130
    nondetermined = ldv_undef_int();
#line 133
    if (nondetermined != 0) {
#line 136
      return (0);
    } else {
#line 141
      return (1);
    }
  } else {
#line 147
    return (1);
  }
}
}
#line 152 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
#line 155
  if (ldv_mutex_i_mutex_of_inode != 2) {
#line 155
    ldv_error();
  } else {

  }
#line 157
  ldv_mutex_i_mutex_of_inode = 1;
#line 158
  return;
}
}
#line 163 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_i_mutex_of_inode(void) 
{ 


  {
#line 166
  ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
#line 167
  return;
}
}
#line 170 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_i_mutex_of_inode(void) 
{ 
  int tmp ;

  {
#line 172
  tmp = ldv_mutex_trylock_i_mutex_of_inode((struct mutex *)0);
#line 172
  return (tmp);
}
}
#line 176 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_i_mutex_of_inode(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 178
  tmp___0 = ldv_undef_int();
#line 178
  if (tmp___0 != 0) {
#line 180
    ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
#line 182
    return (0);
  } else {
#line 185
    tmp = ldv_undef_int_negative();
#line 185
    return (tmp);
  }
}
}
#line 189 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_i_mutex_of_inode(void) 
{ 


  {
#line 191
  ldv_mutex_unlock_i_mutex_of_inode((struct mutex *)0);
#line 192
  return;
}
}
#line 194 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock  =    1;
#line 197 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 202
  if (ldv_mutex_lock != 1) {
#line 202
    ldv_error();
  } else {

  }
#line 205
  nondetermined = ldv_undef_int();
#line 208
  if (nondetermined != 0) {
#line 211
    ldv_mutex_lock = 2;
#line 213
    return (0);
  } else {
#line 218
    return (-4);
  }
}
}
#line 223 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 228
  if (ldv_mutex_lock != 1) {
#line 228
    ldv_error();
  } else {

  }
#line 231
  nondetermined = ldv_undef_int();
#line 234
  if (nondetermined != 0) {
#line 237
    ldv_mutex_lock = 2;
#line 239
    return (0);
  } else {
#line 244
    return (-4);
  }
}
}
#line 249 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
#line 252
  if (ldv_mutex_lock != 1) {
#line 252
    ldv_error();
  } else {

  }
#line 254
  ldv_mutex_lock = 2;
#line 255
  return;
}
}
#line 258 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 263
  if (ldv_mutex_lock != 1) {
#line 263
    ldv_error();
  } else {

  }
#line 266
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 269
  if (is_mutex_held_by_another_thread != 0) {
#line 272
    return (0);
  } else {
#line 277
    ldv_mutex_lock = 2;
#line 279
    return (1);
  }
}
}
#line 284 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 289
  if (ldv_mutex_lock != 1) {
#line 289
    ldv_error();
  } else {

  }
#line 292
  atomic_value_after_dec = ldv_undef_int();
#line 295
  if (atomic_value_after_dec == 0) {
#line 298
    ldv_mutex_lock = 2;
#line 300
    return (1);
  } else {

  }
#line 304
  return (0);
}
}
#line 309 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 313
  if (ldv_mutex_lock == 1) {
#line 316
    nondetermined = ldv_undef_int();
#line 319
    if (nondetermined != 0) {
#line 322
      return (0);
    } else {
#line 327
      return (1);
    }
  } else {
#line 333
    return (1);
  }
}
}
#line 338 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
#line 341
  if (ldv_mutex_lock != 2) {
#line 341
    ldv_error();
  } else {

  }
#line 343
  ldv_mutex_lock = 1;
#line 344
  return;
}
}
#line 349 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_lock(void) 
{ 


  {
#line 352
  ldv_mutex_lock_lock((struct mutex *)0);
#line 353
  return;
}
}
#line 356 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_lock(void) 
{ 
  int tmp ;

  {
#line 358
  tmp = ldv_mutex_trylock_lock((struct mutex *)0);
#line 358
  return (tmp);
}
}
#line 362 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_lock(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 364
  tmp___0 = ldv_undef_int();
#line 364
  if (tmp___0 != 0) {
#line 366
    ldv_mutex_lock_lock((struct mutex *)0);
#line 368
    return (0);
  } else {
#line 371
    tmp = ldv_undef_int_negative();
#line 371
    return (tmp);
  }
}
}
#line 375 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_lock(void) 
{ 


  {
#line 377
  ldv_mutex_unlock_lock((struct mutex *)0);
#line 378
  return;
}
}
#line 380 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_lock_of_v4l2_ctrl_handler  =    1;
#line 383 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 388
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 1) {
#line 388
    ldv_error();
  } else {

  }
#line 391
  nondetermined = ldv_undef_int();
#line 394
  if (nondetermined != 0) {
#line 397
    ldv_mutex_lock_of_v4l2_ctrl_handler = 2;
#line 399
    return (0);
  } else {
#line 404
    return (-4);
  }
}
}
#line 409 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 414
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 1) {
#line 414
    ldv_error();
  } else {

  }
#line 417
  nondetermined = ldv_undef_int();
#line 420
  if (nondetermined != 0) {
#line 423
    ldv_mutex_lock_of_v4l2_ctrl_handler = 2;
#line 425
    return (0);
  } else {
#line 430
    return (-4);
  }
}
}
#line 435 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 


  {
#line 438
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 1) {
#line 438
    ldv_error();
  } else {

  }
#line 440
  ldv_mutex_lock_of_v4l2_ctrl_handler = 2;
#line 441
  return;
}
}
#line 444 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 449
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 1) {
#line 449
    ldv_error();
  } else {

  }
#line 452
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 455
  if (is_mutex_held_by_another_thread != 0) {
#line 458
    return (0);
  } else {
#line 463
    ldv_mutex_lock_of_v4l2_ctrl_handler = 2;
#line 465
    return (1);
  }
}
}
#line 470 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_lock_of_v4l2_ctrl_handler(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 475
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 1) {
#line 475
    ldv_error();
  } else {

  }
#line 478
  atomic_value_after_dec = ldv_undef_int();
#line 481
  if (atomic_value_after_dec == 0) {
#line 484
    ldv_mutex_lock_of_v4l2_ctrl_handler = 2;
#line 486
    return (1);
  } else {

  }
#line 490
  return (0);
}
}
#line 495 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 499
  if (ldv_mutex_lock_of_v4l2_ctrl_handler == 1) {
#line 502
    nondetermined = ldv_undef_int();
#line 505
    if (nondetermined != 0) {
#line 508
      return (0);
    } else {
#line 513
      return (1);
    }
  } else {
#line 519
    return (1);
  }
}
}
#line 524 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 


  {
#line 527
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 2) {
#line 527
    ldv_error();
  } else {

  }
#line 529
  ldv_mutex_lock_of_v4l2_ctrl_handler = 1;
#line 530
  return;
}
}
#line 535 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_lock_of_v4l2_ctrl_handler(void) 
{ 


  {
#line 538
  ldv_mutex_lock_lock_of_v4l2_ctrl_handler((struct mutex *)0);
#line 539
  return;
}
}
#line 542 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_lock_of_v4l2_ctrl_handler(void) 
{ 
  int tmp ;

  {
#line 544
  tmp = ldv_mutex_trylock_lock_of_v4l2_ctrl_handler((struct mutex *)0);
#line 544
  return (tmp);
}
}
#line 548 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_lock_of_v4l2_ctrl_handler(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 550
  tmp___0 = ldv_undef_int();
#line 550
  if (tmp___0 != 0) {
#line 552
    ldv_mutex_lock_lock_of_v4l2_ctrl_handler((struct mutex *)0);
#line 554
    return (0);
  } else {
#line 557
    tmp = ldv_undef_int_negative();
#line 557
    return (tmp);
  }
}
}
#line 561 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_lock_of_v4l2_ctrl_handler(void) 
{ 


  {
#line 563
  ldv_mutex_unlock_lock_of_v4l2_ctrl_handler((struct mutex *)0);
#line 564
  return;
}
}
#line 566 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_mutex_of_device  =    1;
#line 569 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 574
  if (ldv_mutex_mutex_of_device != 1) {
#line 574
    ldv_error();
  } else {

  }
#line 577
  nondetermined = ldv_undef_int();
#line 580
  if (nondetermined != 0) {
#line 583
    ldv_mutex_mutex_of_device = 2;
#line 585
    return (0);
  } else {
#line 590
    return (-4);
  }
}
}
#line 595 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 600
  if (ldv_mutex_mutex_of_device != 1) {
#line 600
    ldv_error();
  } else {

  }
#line 603
  nondetermined = ldv_undef_int();
#line 606
  if (nondetermined != 0) {
#line 609
    ldv_mutex_mutex_of_device = 2;
#line 611
    return (0);
  } else {
#line 616
    return (-4);
  }
}
}
#line 621 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 624
  if (ldv_mutex_mutex_of_device != 1) {
#line 624
    ldv_error();
  } else {

  }
#line 626
  ldv_mutex_mutex_of_device = 2;
#line 627
  return;
}
}
#line 630 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 635
  if (ldv_mutex_mutex_of_device != 1) {
#line 635
    ldv_error();
  } else {

  }
#line 638
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 641
  if (is_mutex_held_by_another_thread != 0) {
#line 644
    return (0);
  } else {
#line 649
    ldv_mutex_mutex_of_device = 2;
#line 651
    return (1);
  }
}
}
#line 656 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 661
  if (ldv_mutex_mutex_of_device != 1) {
#line 661
    ldv_error();
  } else {

  }
#line 664
  atomic_value_after_dec = ldv_undef_int();
#line 667
  if (atomic_value_after_dec == 0) {
#line 670
    ldv_mutex_mutex_of_device = 2;
#line 672
    return (1);
  } else {

  }
#line 676
  return (0);
}
}
#line 681 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 685
  if (ldv_mutex_mutex_of_device == 1) {
#line 688
    nondetermined = ldv_undef_int();
#line 691
    if (nondetermined != 0) {
#line 694
      return (0);
    } else {
#line 699
      return (1);
    }
  } else {
#line 705
    return (1);
  }
}
}
#line 710 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 


  {
#line 713
  if (ldv_mutex_mutex_of_device != 2) {
#line 713
    ldv_error();
  } else {

  }
#line 715
  ldv_mutex_mutex_of_device = 1;
#line 716
  return;
}
}
#line 721 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_mutex_of_device(void) 
{ 


  {
#line 724
  ldv_mutex_lock_mutex_of_device((struct mutex *)0);
#line 725
  return;
}
}
#line 728 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_mutex_of_device(void) 
{ 
  int tmp ;

  {
#line 730
  tmp = ldv_mutex_trylock_mutex_of_device((struct mutex *)0);
#line 730
  return (tmp);
}
}
#line 734 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_mutex_of_device(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 736
  tmp___0 = ldv_undef_int();
#line 736
  if (tmp___0 != 0) {
#line 738
    ldv_mutex_lock_mutex_of_device((struct mutex *)0);
#line 740
    return (0);
  } else {
#line 743
    tmp = ldv_undef_int_negative();
#line 743
    return (tmp);
  }
}
}
#line 747 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_mutex_of_device(void) 
{ 


  {
#line 749
  ldv_mutex_unlock_mutex_of_device((struct mutex *)0);
#line 750
  return;
}
}
#line 752 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
static int ldv_mutex_v4l2_lock_of_camera_data  =    1;
#line 755 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_interruptible_v4l2_lock_of_camera_data(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 760
  if (ldv_mutex_v4l2_lock_of_camera_data != 1) {
#line 760
    ldv_error();
  } else {

  }
#line 763
  nondetermined = ldv_undef_int();
#line 766
  if (nondetermined != 0) {
#line 769
    ldv_mutex_v4l2_lock_of_camera_data = 2;
#line 771
    return (0);
  } else {
#line 776
    return (-4);
  }
}
}
#line 781 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_lock_killable_v4l2_lock_of_camera_data(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 786
  if (ldv_mutex_v4l2_lock_of_camera_data != 1) {
#line 786
    ldv_error();
  } else {

  }
#line 789
  nondetermined = ldv_undef_int();
#line 792
  if (nondetermined != 0) {
#line 795
    ldv_mutex_v4l2_lock_of_camera_data = 2;
#line 797
    return (0);
  } else {
#line 802
    return (-4);
  }
}
}
#line 807 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_lock_v4l2_lock_of_camera_data(struct mutex *lock ) 
{ 


  {
#line 810
  if (ldv_mutex_v4l2_lock_of_camera_data != 1) {
#line 810
    ldv_error();
  } else {

  }
#line 812
  ldv_mutex_v4l2_lock_of_camera_data = 2;
#line 813
  return;
}
}
#line 816 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_trylock_v4l2_lock_of_camera_data(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
#line 821
  if (ldv_mutex_v4l2_lock_of_camera_data != 1) {
#line 821
    ldv_error();
  } else {

  }
#line 824
  is_mutex_held_by_another_thread = ldv_undef_int();
#line 827
  if (is_mutex_held_by_another_thread != 0) {
#line 830
    return (0);
  } else {
#line 835
    ldv_mutex_v4l2_lock_of_camera_data = 2;
#line 837
    return (1);
  }
}
}
#line 842 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_atomic_dec_and_mutex_lock_v4l2_lock_of_camera_data(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
#line 847
  if (ldv_mutex_v4l2_lock_of_camera_data != 1) {
#line 847
    ldv_error();
  } else {

  }
#line 850
  atomic_value_after_dec = ldv_undef_int();
#line 853
  if (atomic_value_after_dec == 0) {
#line 856
    ldv_mutex_v4l2_lock_of_camera_data = 2;
#line 858
    return (1);
  } else {

  }
#line 862
  return (0);
}
}
#line 867 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_mutex_is_locked_v4l2_lock_of_camera_data(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
#line 871
  if (ldv_mutex_v4l2_lock_of_camera_data == 1) {
#line 874
    nondetermined = ldv_undef_int();
#line 877
    if (nondetermined != 0) {
#line 880
      return (0);
    } else {
#line 885
      return (1);
    }
  } else {
#line 891
    return (1);
  }
}
}
#line 896 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_mutex_unlock_v4l2_lock_of_camera_data(struct mutex *lock ) 
{ 


  {
#line 899
  if (ldv_mutex_v4l2_lock_of_camera_data != 2) {
#line 899
    ldv_error();
  } else {

  }
#line 901
  ldv_mutex_v4l2_lock_of_camera_data = 1;
#line 902
  return;
}
}
#line 907 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_lock_device_v4l2_lock_of_camera_data(void) 
{ 


  {
#line 910
  ldv_mutex_lock_v4l2_lock_of_camera_data((struct mutex *)0);
#line 911
  return;
}
}
#line 914 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_trylock_device_v4l2_lock_of_camera_data(void) 
{ 
  int tmp ;

  {
#line 916
  tmp = ldv_mutex_trylock_v4l2_lock_of_camera_data((struct mutex *)0);
#line 916
  return (tmp);
}
}
#line 920 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
int ldv_usb_lock_device_for_reset_v4l2_lock_of_camera_data(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 922
  tmp___0 = ldv_undef_int();
#line 922
  if (tmp___0 != 0) {
#line 924
    ldv_mutex_lock_v4l2_lock_of_camera_data((struct mutex *)0);
#line 926
    return (0);
  } else {
#line 929
    tmp = ldv_undef_int_negative();
#line 929
    return (tmp);
  }
}
}
#line 933 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_usb_unlock_device_v4l2_lock_of_camera_data(void) 
{ 


  {
#line 935
  ldv_mutex_unlock_v4l2_lock_of_camera_data((struct mutex *)0);
#line 936
  return;
}
}
#line 940 "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/3779/dscv_tempdir/rule-instrumentor/32_7a/common-model/ldv_common_model.c"
void ldv_check_final_state(void) 
{ 


  {
#line 943
  if (ldv_mutex_i_mutex_of_inode != 1) {
#line 943
    ldv_error();
  } else {

  }
#line 945
  if (ldv_mutex_lock != 1) {
#line 945
    ldv_error();
  } else {

  }
#line 947
  if (ldv_mutex_lock_of_v4l2_ctrl_handler != 1) {
#line 947
    ldv_error();
  } else {

  }
#line 949
  if (ldv_mutex_mutex_of_device != 1) {
#line 949
    ldv_error();
  } else {

  }
#line 951
  if (ldv_mutex_v4l2_lock_of_camera_data != 1) {
#line 951
    ldv_error();
  } else {

  }
#line 955
  return;
}
}
