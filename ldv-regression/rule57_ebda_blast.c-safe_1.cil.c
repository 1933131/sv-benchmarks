/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

#line 11 "files/rule57_ebda_blast.c"
struct hotplug_slot;
#line 11
struct hotplug_slot;
#line 13 "files/rule57_ebda_blast.c"
struct bus_info {

};
#line 16 "files/rule57_ebda_blast.c"
struct slot {
   int a ;
   int b ;
   struct hotplug_slot *hotplug_slot ;
   struct bus_info *bus_on ;
};
#line 23 "files/rule57_ebda_blast.c"
struct hotplug_slot {
   struct slot *private ;
   int b ;
};
#line 2 "./assert.h"
void __blast_assert(void) 
{ 

  {
  ERROR: 
  goto ERROR;
}
}
#line 5 "files/rule57_ebda_blast.c"
int VERDICT_SAFE  ;
#line 33 "files/rule57_ebda_blast.c"
struct slot *tmp_slot  ;
#line 34 "files/rule57_ebda_blast.c"
int used_tmp_slot  =    0;
#line 35 "files/rule57_ebda_blast.c"
int freed_tmp_slot  =    1;
#line 37
extern void *kzalloc(int  , int  ) ;
#line 39 "files/rule57_ebda_blast.c"
void kfree(void *p ) 
{ void *__cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 40
  __cil_tmp2 = (void *)0;
#line 40
  __cil_tmp3 = (unsigned long )__cil_tmp2;
#line 40
  __cil_tmp4 = (unsigned long )p;
#line 40
  if (__cil_tmp4 != __cil_tmp3) {
    {
#line 40
    __cil_tmp5 = (unsigned long )tmp_slot;
#line 40
    __cil_tmp6 = (unsigned long )p;
#line 40
    if (__cil_tmp6 == __cil_tmp5) {
#line 41
      freed_tmp_slot = 1;
    } else {

    }
    }
  } else {

  }
  }
#line 42
  return;
}
}
#line 44
extern struct bus_info *ibmphp_find_same_bus_num() ;
#line 46
extern int fillslotinfo(struct hotplug_slot * ) ;
#line 47
extern int ibmphp_init_devno(struct slot ** ) ;
#line 49 "files/rule57_ebda_blast.c"
int ebda_rsrc_controller(void) 
{ struct hotplug_slot *hp_slot_ptr ;
  struct bus_info *bus_info_ptr1 ;
  int rc ;
  void *tmp ;
  void *tmp___0 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  struct slot **__cil_tmp17 ;
  struct slot *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
  {
#line 55
  __cil_tmp6 = (int )16UL;
#line 55
  tmp = kzalloc(__cil_tmp6, 1);
#line 55
  hp_slot_ptr = (struct hotplug_slot *)tmp;
  }
#line 56
  if (! hp_slot_ptr) {
#line 57
    rc = -2;
    goto error_no_slot;
  } else {

  }
  {
#line 60
  __cil_tmp7 = (unsigned long )hp_slot_ptr;
#line 60
  __cil_tmp8 = __cil_tmp7 + 8;
#line 60
  *((int *)__cil_tmp8) = 5;
#line 62
  __cil_tmp9 = (int )24UL;
#line 62
  tmp___0 = kzalloc(__cil_tmp9, 1);
#line 62
  tmp_slot = (struct slot *)tmp___0;
  }
#line 64
  if (! tmp_slot) {
#line 65
    rc = -2;
    goto error_no_slot;
  } else {

  }
  {
#line 69
  used_tmp_slot = 0;
#line 70
  freed_tmp_slot = 0;
#line 72
  *((int *)tmp_slot) = 2;
#line 73
  __cil_tmp10 = (unsigned long )tmp_slot;
#line 73
  __cil_tmp11 = __cil_tmp10 + 4;
#line 73
  *((int *)__cil_tmp11) = 3;
#line 75
  bus_info_ptr1 = ibmphp_find_same_bus_num();
  }
#line 76
  if (! bus_info_ptr1) {
    {
#line 77
    rc = -3;
#line 80
    __cil_tmp12 = (void *)tmp_slot;
#line 80
    kfree(__cil_tmp12);
#line 81
    freed_tmp_slot = 1;
    }
    goto error;
  } else {

  }
  {
#line 85
  __cil_tmp13 = (unsigned long )tmp_slot;
#line 85
  __cil_tmp14 = __cil_tmp13 + 16;
#line 85
  *((struct bus_info **)__cil_tmp14) = bus_info_ptr1;
#line 86
  bus_info_ptr1 = (struct bus_info *)0;
#line 88
  __cil_tmp15 = (unsigned long )tmp_slot;
#line 88
  __cil_tmp16 = __cil_tmp15 + 8;
#line 88
  *((struct hotplug_slot **)__cil_tmp16) = hp_slot_ptr;
#line 90
  *((struct slot **)hp_slot_ptr) = tmp_slot;
#line 91
  used_tmp_slot = 1;
#line 93
  rc = fillslotinfo(hp_slot_ptr);
  }
#line 94
  if (rc) {
    goto error;
  } else {

  }
  {
#line 97
  __cil_tmp17 = (struct slot **)hp_slot_ptr;
#line 97
  rc = ibmphp_init_devno(__cil_tmp17);
  }
#line 98
  if (rc) {
    goto error;
  } else {

  }
#line 101
  return (0);
  error: 
  {
#line 104
  __cil_tmp18 = *((struct slot **)hp_slot_ptr);
#line 104
  __cil_tmp19 = (void *)__cil_tmp18;
#line 104
  kfree(__cil_tmp19);
  }
  error_no_slot: 
#line 109
  return (rc);
}
}
#line 112 "files/rule57_ebda_blast.c"
void main(void) 
{ 

  {
  {
#line 113
  ebda_rsrc_controller();
  }
#line 114
  if (! used_tmp_slot) {
#line 115
    if (freed_tmp_slot) {

    } else {
      {
#line 115
      __blast_assert();
      }
    }
  } else {

  }
#line 116
  return;
}
}
